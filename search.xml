<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《星际拓荒》(Outer Wilds)</title>
      <link href="/2024/04/20/read/you-xi/2024-03/xing-ji-tuo-huang-outer-wilds/"/>
      <url>/2024/04/20/read/you-xi/2024-03/xing-ji-tuo-huang-outer-wilds/</url>
      
        <content type="html"><![CDATA[<p>优点：星际探索；未知恐惧；星球生态有趣<br>缺点：不能手动存档，试错成本高</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《去月球》</title>
      <link href="/2024/04/20/read/you-xi/2024-03/qu-yue-qiu/"/>
      <url>/2024/04/20/read/you-xi/2024-03/qu-yue-qiu/</url>
      
        <content type="html"><![CDATA[<p>迫于狗屎般的操作和几乎没有的提示*，玩不下去了<br>03-13</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>str.</title>
      <link href="/2024/04/20/study/python/str./"/>
      <url>/2024/04/20/study/python/str./</url>
      
        <content type="html"><![CDATA[<h5 id="str-startswith-prefix-start-end"><a href="#str-startswith-prefix-start-end" class="headerlink" title="str.startswith(prefix[, start[, end]])"></a><code>str.startswith(prefix[, start[, end]])</code></h5><pre class="line-numbers language-none"><code class="language-none">text &#x3D; &quot;Hello, world!&quot;# 检查字符串是否以特定前缀开始result &#x3D; text.startswith(&quot;Hello&quot;)print(result)  # 输出 True# 可以指定起始和结束位置result &#x3D; text.startswith(&quot;world&quot;, 7)print(result)  # 输出 True，从索引 7 开始检查  # 检查多个前缀result &#x3D; text.startswith((&quot;Hello&quot;, &quot;Hi&quot;, &quot;Hey&quot;))print(result)  # 输出 True，因为 &quot;Hello&quot; 在字符串开头  # 检查多个前缀，指定起始和结束位置result &#x3D; text.startswith((&quot;world&quot;, &quot;universe&quot;), 7, 12)print(result)  # 输出 True，因为 &quot;world&quot; 在索引 7 到 11 的范围内<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于检查字符串是否以指定的前缀开始。它返回一个布尔值，如果字符串以指定的前缀开头，则返回 True，否则返回 False。</li><li><code>prefix</code>：要检查的前缀，可以是一个字符串或一个元组（tuple）包含多个前缀。</li><li><code>start</code>（可选）：开始搜索的起始位置，默认为 0，即整个字符串。</li><li><code>end</code>（可选）：结束搜索的位置，默认为字符串的末尾。</li></ul><h5 id="str-endswith-suffix-start-end"><a href="#str-endswith-suffix-start-end" class="headerlink" title="str.endswith(suffix[, start[, end]])"></a><code>str.endswith(suffix[, start[, end]])</code></h5><pre class="line-numbers language-none"><code class="language-none">text &#x3D; &quot;Hello, world!&quot;# 检查字符串是否以特定后缀结束result &#x3D; text.endswith(&quot;world!&quot;)print(result)  # 输出 True# 可以指定起始和结束位置result &#x3D; text.endswith(&quot;Hello&quot;, 0, 5)print(result)  # 输出 True，从索引 0 到 4 的范围内检查# 检查多个后缀result &#x3D; text.endswith((&quot;world!&quot;, &quot;universe!&quot;))print(result)  # 输出 True，因为 &quot;world!&quot; 在字符串末尾# 检查多个后缀，指定起始和结束位置result &#x3D; text.endswith((&quot;Hello&quot;, &quot;Hi&quot;, &quot;Hey&quot;), 0, 5)print(result)  # 输出 True，因为 &quot;Hello&quot; 在索引 0 到 4 的范围内<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于检查字符串是否以指定的后缀结束。它返回一个布尔值，如果字符串以指定的后缀结束，则返回 True，否则返回 False。</li><li><code>suffix</code>：要检查的后缀，可以是一个字符串或一个元组（tuple）包含多个后缀。</li><li><code>start</code>（可选）：开始搜索的起始位置，默认为 0，即整个字符串。</li><li><code>end</code>（可选）：结束搜索的位置，默认为字符串的末尾。</li></ul><h5 id="str-find-substring-start-end"><a href="#str-find-substring-start-end" class="headerlink" title="str.find(substring, start, end)"></a><code>str.find(substring, start, end)</code></h5><pre class="line-numbers language-none"><code class="language-none">sentence &#x3D; &quot;This is a sample sentence.&quot;index &#x3D; sentence.find(&quot;is&quot;)  # 在整个字符串中查找 &quot;is&quot;print(index)  # 输出 2，因为 &quot;is&quot; 在位置 2 开始index &#x3D; sentence.find(&quot;is&quot;, 3)  # 从位置 3 开始查找 &quot;is&quot;print(index)  # 输出 5，因为第二个 &quot;is&quot; 在位置 5 开始index &#x3D; sentence.find(&quot;notfound&quot;)  # 查找不存在的子字符串print(index)  # 输出 -1，因为 &quot;notfound&quot; 未在字符串中找到<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于在给定的字符串中查找子字符串 <code>substring</code> 的第一个匹配，并返回匹配的索引位置。如果未找到匹配的子字符串，则返回 -1。</li><li><code>substring</code>：要查找的子字符串。</li><li><code>start</code>（可选）：搜索的起始位置，默认为 0，表示从字符串的开头开始搜索。</li><li><code>end</code>（可选）：搜索的结束位置，默认为字符串的末尾，表示在整个字符串中搜索。</li></ul><h5 id="str-split-separator-maxsplit"><a href="#str-split-separator-maxsplit" class="headerlink" title="str.split(separator, maxsplit)"></a><code>str.split(separator, maxsplit)</code></h5><pre class="line-numbers language-none"><code class="language-none">text &#x3D; &quot;apple,banana,grape,kiwi&quot;    # 使用逗号作为分隔符，默认情况下分割所有出现的逗号  fruits &#x3D; text.split(&quot;,&quot;)  print(fruits)  # 输出: [&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;kiwi&#39;]    # 使用空格作为分隔符  sentence &#x3D; &quot;This is a sample sentence.&quot;  words &#x3D; sentence.split(&quot; &quot;)  print(words)  # 输出: [&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;sample&#39;, &#39;sentence.&#39;]    # 使用最大分割次数，将字符串分割为2部分  parts &#x3D; sentence.split(&quot; &quot;, 2)  print(parts)  # 输出: [&#39;This&#39;, &#39;is&#39;, &#39;a sample sentence.&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于将一个字符串分割成子字符串列表，根据指定的分隔符 <code>separator</code> 进行分割。它返回一个包含分割后的子字符串的列表。</li><li><code>separator</code>：分隔符，用于指定在哪里分割字符串。可以是一个字符或字符串。如果省略此参数，则默认使用空格作为分隔符。</li><li><code>maxsplit</code>（可选）：指定最大的分割次数。如果提供了此参数，字符串将被分割为最多 <code>maxsplit+1</code> 个部分。如果省略此参数或将其设置为 -1，则将字符串分割为尽可能多的部分。</li></ul><h5 id="str-strip-characters"><a href="#str-strip-characters" class="headerlink" title="str.strip(characters)"></a><code>str.strip(characters)</code></h5><pre class="line-numbers language-none"><code class="language-none">text &#x3D; &quot;   Hello, World!   &quot;# 使用默认的空白字符删除开头和结尾的空格stripped_text &#x3D; text.strip()print(stripped_text)  # 输出: &quot;Hello, World!&quot;# 删除开头和结尾的逗号和空格custom_stripped_text &#x3D; text.strip(&quot; ,&quot;)print(custom_stripped_text)  # 输出: &quot;Hello, World!&quot;# 删除开头和结尾的空白字符和感叹号exclamation_stripped_text &#x3D; text.strip(&quot; !&quot;)print(exclamation_stripped_text)  # 输出: &quot;Hello, World&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于删除字符串的开头和结尾处包含在 <code>characters</code> 参数中的字符（或字符集合）。它返回一个新的字符串，不影响原始字符串。</li></ul><h5 id="str-replace-old-new-count"><a href="#str-replace-old-new-count" class="headerlink" title="&#96;str.replace(old, new[, count])"></a>&#96;str.replace(old, new[, count])</h5><pre class="line-numbers language-none"><code class="language-none">original_string &#x3D; &quot;Hello, World! Hello, Universe!&quot;new_string &#x3D; original_string.replace(&quot;Hello&quot;, &quot;Hi&quot;)print(new_string)  # 输出： &quot;Hi, World! Hi, Universe!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>用于将字符串中指定的子字符串（或模式）替换为另一个子字符串。</li><li><code>old</code>：要被替换的子字符串或模式。</li><li><code>new</code>：要替换为的新子字符串。</li><li><code>count</code>：可选参数，指定要替换的最大次数。如果省略这个参数，所有匹配的子字符串都会被替换。</li></ul><h5 id="string-maketrans-x-y-z"><a href="#string-maketrans-x-y-z" class="headerlink" title="string.maketrans(x[, y[, z]])"></a><code>string.maketrans(x[, y[, z]])</code></h5><pre class="line-numbers language-none"><code class="language-none"># 创建一个字符映射转换表，将字母a替换为字母b，删除字母c  translation_table &#x3D; str.maketrans(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)    # 原始字符串  original_string &#x3D; &quot;abcdeabc&quot;    # 使用转换表执行字符替换和删除操作  result_string &#x3D; original_string.translate(translation_table)    print(result_string)  # 输出： &quot;bbdebb&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于创建一个字符映射转换表。这个转换表通常与 <code>str.translate()</code> 方法一起使用，用于在字符串中执行字符替换或删除操作。</li><li><code>x</code>：一个字符串，包含你想要替换的字符。</li><li><code>y</code>：一个字符串，包含要替换成的字符。它必须与 <code>x</code> 中的字符一一对应。</li><li><code>z</code>：一个字符串，包含你想要从原始字符串中删除的字符。</li></ul><h5 id="str-translate-table-deletechars"><a href="#str-translate-table-deletechars" class="headerlink" title="str.translate(table[, deletechars])"></a><code>str.translate(table[, deletechars])</code></h5><pre class="line-numbers language-none"><code class="language-none"># 创建一个字符映射转换表，将字母a替换为字母b，删除字母c  translation_table &#x3D; str.maketrans(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)    # 原始字符串  original_string &#x3D; &quot;abcdeabc&quot;    # 使用转换表执行字符替换和删除操作  result_string &#x3D; original_string.translate(translation_table)    print(result_string)  # 输出： &quot;bbdebb&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用于执行字符映射转换或删除操作。它通常与 <code>str.maketrans()</code> 方法一起使用，前者用于指定字符的映射转换规则，后者用于创建字符映射表。</li><li><code>table</code> 是创建的字符映射表。</li><li><code>deletechars</code>想要删除的字符。</li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>random</title>
      <link href="/2024/04/20/study/python/random/"/>
      <url>/2024/04/20/study/python/random/</url>
      
        <content type="html"><![CDATA[<h5 id="random-seed-x"><a href="#random-seed-x" class="headerlink" title="random.seed(x)"></a><code>random.seed(x)</code></h5><pre class="line-numbers language-none"><code class="language-none">import random# 设置种子random.seed(123)# 生成随机数序列print(random.randint(1, 10))# 再次设置种子random.seed(456)# 生成随机数序列print(random.randint(1, 10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置完种子<code>x</code>后，每次生成的随机数相同。</li></ul><h5 id="random-random"><a href="#random-random" class="headerlink" title="random.random()"></a><code>random.random()</code></h5><pre class="line-numbers language-none"><code class="language-none">import random    print(random.random())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>生成0-1的随机浮点数，每次结果不同。</li></ul><h5 id="random-randint-strat-stop"><a href="#random-randint-strat-stop" class="headerlink" title="random.randint(strat, stop)"></a><code>random.randint(strat, stop)</code></h5><pre class="line-numbers language-none"><code class="language-none">import random    print(random.randint(1, 10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>start</code>：生成随机整数的起始位置</li><li><code>stop</code>：生成随机整数的终止位置</li><li><code>start</code>与<code>stop</code>必须是整数</li></ul><h5 id="random-randrange-strat-stop-step"><a href="#random-randrange-strat-stop-step" class="headerlink" title="random.randrange(strat, stop[, step])"></a><code>random.randrange(strat, stop[, step])</code></h5><pre class="line-numbers language-none"><code class="language-none">import random    print(random.randrange(1, 10)) # 生成1 ~ 9  print(random.randrange(1, 10, 2)) # 生成1, 3, 5, 7, 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>start</code>：生成随机整数的起始位置</li><li><code>stop</code>：生成随机整数的终止位置（不包括）</li><li><code>step</code>：是随机整数之间的步长，<code>step</code>默认为 1 。</li><li><code>start</code>、<code>stop</code>与<code>step</code>必须是整数</li></ul><h5 id="random-uniform-start-stop"><a href="#random-uniform-start-stop" class="headerlink" title="random.uniform(start, stop)"></a><code>random.uniform(start, stop)</code></h5><pre class="line-numbers language-none"><code class="language-none">random.uniform(strat, stop)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>strat</code>：生成随机数的起始位置</li><li><code>stop</code>：生成随机数的终止位置</li></ul><h5 id="random-choice-seq"><a href="#random-choice-seq" class="headerlink" title="random.choice(seq)"></a><code>random.choice(seq)</code></h5><pre class="line-numbers language-none"><code class="language-none">random.choice(seq)random.choice(seq, k)random.sample(seq, k)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>random.choice(seq)</code>用于从序列中获取一个随机元素，并返回一个（列表，元组或字符串中的）随机项，其中参数 <code>seq</code> 是一个非空序列。</li><li><code>random.choice(seq, k)</code>&#x3D;<code>random.sample(seq, k)</code>，表示随机生成<code>k</code>个元素。</li></ul><h5 id="random-shuffle-seq"><a href="#random-shuffle-seq" class="headerlink" title="random.shuffle(seq)"></a><code>random.shuffle(seq)</code></h5><pre class="line-numbers language-none"><code class="language-none">import randommy_list &#x3D; [1, 2, 3, 4, 5]random.shuffle(my_list)print(my_list) # 输出可能是[2, 5, 3, 4, 1]也可能是别的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>函数是Python中的一个用于随机打乱列表顺序的函数。它接受一个可变序列作为参数，并在原地对该序列进行随机排序，即改变原始序列的顺序而不创建新的序列。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda 表达式</title>
      <link href="/2024/04/20/study/python/lambda-biao-da-shi/"/>
      <url>/2024/04/20/study/python/lambda-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Lambda 表达式是一种匿名函数，允许在代码中定义简单的函数或函数对象而无需为其分配一个名称。Lambda 表达式通常用于函数式编程，特别是在编程语言中支持函数作为一等公民（first-class citizens）的情况下，例如 Python、Java 等。</p></li><li><p>Lambda 表达式的一般语法通常包括以下元素：</p></li><li><p><code>lambda 参数列表: 表达式</code></p><pre class="line-numbers language-none"><code class="language-none"># 使用lambda表达式定义一个简单的加法函数add &#x3D; lambda x, y: x + y# 调用lambda函数result &#x3D; add(3, 5)print(result)  # 输出 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在一些编程语言中，包括Python，Lambda表达式可以包含条件判断语句（if语句）。这使得Lambda表达式更加灵活，可以根据条件来执行不同的操作。Lambda表达式的条件语法通常如下：</p></li><li><p><code>lambda 参数列表: 返回值1 if 条件 else 返回值2</code></p><pre class="line-numbers language-none"><code class="language-none"># 使用Lambda表达式带有if条件判断is_even &#x3D; lambda x: &quot;Even&quot; if x % 2 &#x3D;&#x3D; 0 else &quot;Odd&quot;print(is_even(4))  # 输出 &quot;Even&quot;print(is_even(7))  # 输出 &quot;Odd&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eval()函数</title>
      <link href="/2024/04/20/study/python/eval-han-shu/"/>
      <url>/2024/04/20/study/python/eval-han-shu/</url>
      
        <content type="html"><![CDATA[<ul><li><code>eval()</code> 是一个内置函数，用于在 Python 中执行包含有效 Python 表达式的字符串。它接受一个字符串作为参数，并将该字符串解释为 Python 代码，并返回其结果。这对于动态执行代码或执行用户输入的代码非常有用，但也需要小心使用，因为它可以导致安全问题和错误。</li><li><code>eval()</code> 函数的基本语法如下：<code>eval(expression, globals=None, locals=None)</code></li><li><code>expression</code> 是包含要执行的 Python 表达式的字符串。</li><li><code>globals</code>（可选参数）是一个字典，包含全局命名空间中的变量和值。</li><li><code>locals</code>（可选参数）是一个字典，包含局部命名空间中的变量和值。</li><li><code>eval()</code> 函数将 <code>expression</code> 参数中的字符串解释为 Python 表达式，并返回其计算结果。下面是一个简单的示例：<pre class="line-numbers language-none"><code class="language-none">x &#x3D; 10y &#x3D; 20expression &#x3D; &quot;x + y&quot;result &#x3D; eval(expression)print(result)  # 输出 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exec() 函数</title>
      <link href="/2024/04/20/study/python/exec-han-shu/"/>
      <url>/2024/04/20/study/python/exec-han-shu/</url>
      
        <content type="html"><![CDATA[<ul><li><code>exec()</code> 是一个用于执行包含 Python 代码的字符串的内置函数。与 <code>eval()</code> 不同，<code>exec()</code> 主要用于执行语句块或多行代码，而不是求值单个表达式。这使得它非常适合在运行时执行动态生成的 Python 代码块。</li><li><code>exec()</code> 函数的基本语法如下：<code>exec(object, globals=None, locals=None)</code></li><li><code>object</code> 是包含要执行的 Python 代码的字符串，可以是多行代码。</li><li><code>globals</code>（可选参数）是一个字典，包含全局命名空间中的变量和值。</li><li><code>locals</code>（可选参数）是一个字典，包含局部命名空间中的变量和值。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>collections 模块</title>
      <link href="/2024/04/20/study/python/collections-mo-kuai/"/>
      <url>/2024/04/20/study/python/collections-mo-kuai/</url>
      
        <content type="html"><![CDATA[<h5 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a><code>namedtuple</code></h5><ul><li>用于创建带有命名字段的元组（named tuple）。它的主要目的是为了让您创建更具可读性和可维护性的数据结构，类似于使用类定义的对象，但比普通元组更轻量。</li><li><code>namedtuple</code> 的基本语法如下：<pre class="line-numbers language-none"><code class="language-none">from collections import namedtupleMyTuple &#x3D; namedtuple(&#39;MyTuple&#39;, [&#39;field1&#39;, &#39;field2&#39;, ...])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><code>&#39;MyTuple&#39;</code> 是元组类型的名称，您可以自定义它。</li><li><code>[&#39;field1&#39;, &#39;field2&#39;, ...]</code> 是元组的字段名称列表。<pre class="line-numbers language-none"><code class="language-none">from collections import namedtuple# 创建一个名为 &#39;Person&#39; 的命名元组类型，有 &#39;name&#39; 和 &#39;age&#39; 两个字段Person &#x3D; namedtuple(&#39;Person&#39;, [&#39;name&#39;, &#39;age&#39;])# 创建一个 &#39;Person&#39; 的实例person1 &#x3D; Person(name&#x3D;&#39;Alice&#39;, age&#x3D;30)# 访问字段值print(person1.name)  # 输出: &#39;Alice&#39;print(person1.age)   # 输出: 30# 创建另一个实例person2 &#x3D; Person(name&#x3D;&#39;Bob&#39;, age&#x3D;25)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a><code>deque</code></h5><ul><li><p><code>deque</code>（发音为 “deck”）是 Python 中 <code>collections</code> 模块中的一种数据结构，它代表了一个双向队列（double-ended queue），可以高效地从队列的两端添加或删除元素。<code>deque</code> 提供了与列表（<code>list</code>）相似的功能，但在特定情况下，它的性能更好。</p></li><li><p>创建一个 <code>deque</code> 对象：</p><pre class="line-numbers language-none"><code class="language-none">my_deque &#x3D; deque()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>向队列的一端添加元素：</p><pre class="line-numbers language-none"><code class="language-none">my_deque.append(1)  # 从右端添加元素my_deque.appendleft(2)  # 从左端添加元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查看队列的内容和长度：</p><pre class="line-numbers language-none"><code class="language-none">print(my_deque)  # 打印队列的内容print(len(my_deque))  # 打印队列的长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在队列的两端执行其他操作：</p><pre class="line-numbers language-none"><code class="language-none">my_deque.extend([3, 4, 5])  # 从右端扩展队列my_deque.extendleft([0, -1, -2])  # 从左端扩展队列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>在队列中查找元素：</p><pre class="line-numbers language-none"><code class="language-none">index &#x3D; my_deque.index(3)  # 查找元素 3 的索引count &#x3D; my_deque.count(2)  # 计算元素 2 的出现次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a><code>Counter</code></h5><ul><li><code>Counter</code> 是 Python 中 <code>collections</code> 模块中的一个类，用于快速计数可迭代对象中元素的出现次数。<code>Counter</code> 返回一个字典，其中键是可迭代对象中的元素，而值是该元素在可迭代对象中出现的次数。<pre class="line-numbers language-none"><code class="language-none"># 创建一个计数对象my_list &#x3D; [1, 2, 3, 1, 2, 3, 4, 1, 2, 1]counter &#x3D; Counter(my_list)# 计算元素的出现次数count_1 &#x3D; counter[1]  # 元素 1 出现 4 次count_2 &#x3D; counter[2]  # 元素 2 出现 3 次count_3 &#x3D; counter[3]  # 元素 3 出现 2 次count_4 &#x3D; counter[4]  # 元素 4 出现 1 次# 查看计数对象的内容print(counter)  # 输出: Counter(&#123;1: 4, 2: 3, 3: 2, 4: 1&#125;)# 获取所有元素及其出现次数element_counts &#x3D; counter.items()# 输出: dict_items([(1, 4), (2, 3), (3, 2), (4, 1)])# 获取最常见的元素most_common &#x3D; counter.most_common(2)  # 获取出现次数最多的前两个元素# 输出: [(1, 4), (2, 3)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a><code>itertools</code></h5><ul><li><p><code>itertools</code> 是 Python 中的一个模块，提供了一组用于创建和操作迭代器的工具函数。这些函数能够帮助您在处理迭代对象（如列表、元组、集合等）时更灵活和高效地生成、过滤和组合元素。</p></li><li><p><code>count(start=0, step=1)</code>： 创建一个无限迭代器，从 <code>start</code> 开始，以 <code>step</code> 为步长生成整数。</p><pre class="line-numbers language-none"><code class="language-none">from itertools import countfor i in count(10, 2):    if i &gt; 20:        break    print(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>cycle(iterable)</code>： 无限迭代地重复 <code>iterable</code> 中的元素。</p><pre class="line-numbers language-none"><code class="language-none">from itertools import cyclemy_list &#x3D; [1, 2, 3]for num in cycle(my_list):    if num &gt; 5:        break    print(num)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>repeat(elem, n)</code>： 生成一个无限迭代器，不断重复 <code>elem</code> 元素 <code>n</code> 次。</p><pre class="line-numbers language-none"><code class="language-none">from itertools import repeatfor i in repeat(&#39;Hello&#39;, 3):    print(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>combinations(iterable, r)</code>：</strong> 返回 <code>iterable</code> 中长度为 <code>r</code> 的所有可能组合，不重复。</p><pre class="line-numbers language-none"><code class="language-none">from itertools import combinationsmy_list &#x3D; [1, 2, 3]combs &#x3D; list(combinations(my_list, 2))print(combs)  # 输出: [(1, 2), (1, 3), (2, 3)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>permutations(iterable, r)</code>：</strong> 返回 <code>iterable</code> 中长度为 <code>r</code> 的所有可能排列，不重复。</p><pre class="line-numbers language-none"><code class="language-none">from itertools import permutationsmy_list &#x3D; [1, 2, 3]perms &#x3D; list(permutations(my_list, 2))print(perms)  # 输出: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>filterfalse(predicate, iterable)</code>：</strong> 返回 <code>iterable</code> 中不满足 <code>predicate</code> 函数条件的元素。</p><pre class="line-numbers language-none"><code class="language-none">from itertools import filterfalsemy_list &#x3D; [1, 2, 3, 4, 5]filtered &#x3D; list(filterfalse(lambda x: x % 2 &#x3D;&#x3D; 0, my_list))print(filtered)  # 输出: [1, 3, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><ol start="7"><li><strong><code>chain(iterable1, iterable2, ...)</code>：</strong> 将多个可迭代对象连接成一个单一的迭代器。<pre class="line-numbers language-none"><code class="language-none">from itertools import chainlist1 &#x3D; [1, 2, 3]list2 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]combined &#x3D; list(chain(list1, list2))print(combined)  # 输出: [1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典</title>
      <link href="/2024/04/20/study/python/zi-dian/"/>
      <url>/2024/04/20/study/python/zi-dian/</url>
      
        <content type="html"><![CDATA[<h5 id="字典的创建"><a href="#字典的创建" class="headerlink" title="字典的创建"></a>字典的创建</h5><ul><li><p>使用大括号 <code>&#123;&#125;</code> 创建一个空字典：<br><code>my_dict = &#123;&#125;</code></p></li><li><p>使用键值对初始化字典：<br><code>my_dict = &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;</code></p></li><li><p>使用 <code>dict()</code> 构造函数创建字典：<br><code>my_dict = dict(name=&#39;Alice&#39;, age=25, city=&#39;Los Angeles&#39;) </code></p></li><li><p>从列表或元组中创建字典：</p><pre class="line-numbers language-none"><code class="language-none">key_value_pairs &#x3D; [(&#39;name&#39;, &#39;Bob&#39;), (&#39;age&#39;, 35), (&#39;city&#39;, &#39;Chicago&#39;)]my_dict &#x3D; dict(key_value_pairs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用字典推导式创建字典：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;key: value for key, value in [(&#39;name&#39;, &#39;Eve&#39;), (&#39;age&#39;, 28), (&#39;city&#39;, &#39;Houston&#39;)]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="增添元素"><a href="#增添元素" class="headerlink" title="增添元素"></a>增添元素</h5><ul><li><p>直接指定一个新的键值对：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;my_dict[&#39;email&#39;] &#x3D; &#39;john@example.com&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <code>update()</code> 方法添加多个键值对：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;my_dict.update(&#123;&#39;email&#39;: &#39;john@example.com&#39;, &#39;phone&#39;: &#39;555-555-5555&#39;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用字典推导式创建一个新的字典并添加元素：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;new_data &#x3D; &#123;&#39;email&#39;: &#39;john@example.com&#39;, &#39;phone&#39;: &#39;555-555-5555&#39;&#125;my_dict &#x3D; &#123;**my_dict, **new_data&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用 <code>setdefault()</code> 方法，如果键不存在则设置默认值：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30&#125;my_dict.setdefault(&#39;email&#39;, &#39;john@example.com&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <code>defaultdict</code> 来添加元素，如果键不存在会自动创建默认值：</p><pre class="line-numbers language-none"><code class="language-none">from collections import defaultdictmy_dict &#x3D; defaultdict(int)  # 默认值为整数my_dict[&#39;count&#39;] +&#x3D; 1  # 自动创建并增加计数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><ul><li><p>使用 <code>del</code> 语句删除指定键的键值对：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;del my_dict[&#39;age&#39;]  # 删除键为&#39;age&#39;的键值对<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <code>pop()</code> 方法删除指定键的键值对，并返回其值：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;age &#x3D; my_dict.pop(&#39;age&#39;)  # 删除并返回&#39;age&#39;的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <code>popitem()</code> 方法删除最后一个键值对，并返回一个元组：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;key, value &#x3D; my_dict.popitem()  # 删除并返回最后一个键值对<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <code>clear()</code> 方法清空整个字典：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;my_dict.clear()  # 清空字典，变成一个空字典<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用 <code>dict.pop()</code> 方法删除键，并提供默认值以防键不存在：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;city&#39;: &#39;New York&#39;&#125;age &#x3D; my_dict.pop(&#39;age&#39;, 0)  # 删除&#39;age&#39;，如果不存在则返回默认值0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><ul><li><p><strong>直接赋值：</strong> 您可以通过将新值分配给字典中的键来直接修改元素</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;# 直接赋值来修改 &#39;age&#39; 键的值my_dict[&#39;age&#39;] &#x3D; 31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>update() 方法：</strong> 使用 <code>update()</code> 方法可以更新一个或多个键值对。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;# 使用 update() 方法同时更新 &#39;age&#39; 和 &#39;city&#39;my_dict.update(&#123;&#39;age&#39;: 32, &#39;city&#39;: &#39;Los Angeles&#39;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>字典推导式：</strong> 您可以使用字典推导式来创建一个新字典，根据原始字典的键值对进行修改。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;    # 使用字典推导式修改字典中的值  my_dict &#x3D; &#123;key: &#39;Amy&#39; if key &#x3D;&#x3D; &#39;name&#39; else value for key, value in my_dict.items()&#125;  my_dict &#x3D; &#123;key: 31 if key &#x3D;&#x3D; &#39;age&#39; else value for key, value in my_dict.items()&#125;  my_dict &#x3D; &#123;key: &#39;Los Angeles&#39; if key &#x3D;&#x3D; &#39;city&#39; else value for key, value in my_dict.items()&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h5><ul><li><p><strong>使用键来获取值：</strong> 使用字典的键来检索相关的值。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;    name &#x3D; my_dict[&#39;name&#39;]  age &#x3D; my_dict[&#39;age&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用<code>get()</code>方法：</strong> 使用<code>get()</code>方法来获取键对应的值。这种方法可以在键不存在时提供一个默认值。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;    name &#x3D; my_dict.get(&#39;name&#39;)  age &#x3D; my_dict.get(&#39;age&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用<code>in</code>操作符检查键是否存在：</strong> 您可以使用<code>in</code>操作符来检查字典中是否包含某个键。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;    if &#39;age&#39; in my_dict:      age &#x3D; my_dict[&#39;age&#39;]  else:      age &#x3D; None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用<code>keys()</code>方法来获取所有键：</strong> 使用<code>keys()</code>方法获取字典中所有键的列表，然后可以遍历列表进行查询。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;    for key in my_dict.keys():      if key &#x3D;&#x3D; &#39;name&#39;:          name &#x3D; my_dict[key]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用<code>values()</code>方法来获取所有值：</strong> 使用<code>values()</code>方法获取字典中所有值的列表，然后可以遍历列表进行查询。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;    for value in my_dict.values():      if value &#x3D;&#x3D; &#39;John&#39;:          name &#x3D; value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="键与值相关的函数"><a href="#键与值相关的函数" class="headerlink" title="键与值相关的函数"></a>键与值相关的函数</h5><ul><li><p><strong><code>keys()</code> 方法：</strong> 返回一个包含字典所有键的视图（view），这个视图可以被用于迭代或转换为列表。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;keys &#x3D; my_dict.keys()  # 返回一个视图对象key_list &#x3D; list(my_dict.keys())  # 将视图转换为列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>values()</code> 方法：</strong> 返回一个包含字典所有值的视图，同样可以用于迭代或转换为列表。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;values &#x3D; my_dict.values()  # 返回一个视图对象value_list &#x3D; list(my_dict.values())  # 将视图转换为列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>items()</code> 方法：</strong> 返回一个包含字典所有键值对（元组形式）的视图。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;items &#x3D; my_dict.items()  # 返回一个视图对象item_list &#x3D; list(my_dict.items())  # 将视图转换为列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>get()</code> 方法：</strong> 用于获取指定键的值，如果键不存在，可以提供一个默认值作为参数。</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;name &#x3D; my_dict.get(&#39;name&#39;)  # name &#x3D; &#39;John&#39;email &#x3D; my_dict.get(&#39;email&#39;, &#39;N&#x2F;A&#39;)  # 如果&#39;email&#39;不存在，返回&#39;N&#x2F;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong><code>pop()</code> 方法：</strong> 用于删除指定键的键值对，并返回相应的值。\</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;age &#x3D; my_dict.pop(&#39;age&#39;)  # 删除&#39;age&#39;键值对，age &#x3D; 30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id="返回迭代器"><a href="#返回迭代器" class="headerlink" title="返回迭代器"></a>返回迭代器</h5><ul><li><p>返回一个迭代器遍历字典的键：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;key_iterator &#x3D; iter(my_dict.keys())  # 将键视图转换为迭代器for key in key_iterator:    print(key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>返回一个迭代器遍历字典的值：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;value_iterator &#x3D; iter(my_dict.values())  # 将值视图转换为迭代器for value in value_iterator:    print(value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>返回一个迭代器遍历字典的键值对：</p><pre class="line-numbers language-none"><code class="language-none">my_dict &#x3D; &#123;&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;&#125;item_iterator &#x3D; iter(my_dict.items())  # 将键值对视图转换为迭代器for key, value in item_iterator:    print(key, value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip()函数"></a><code>zip()</code>函数</h5><ul><li><code>zip()</code> 函数是Python内置函数之一，用于将多个可迭代对象（例如列表、元组等）组合成一个元组的序列，以便进行迭代或其他操作。<code>zip()</code> 函数的基本语法如下：</li><li><code>zip(iterable1, iterable2, ...)</code></li><li><code>iterable1</code>, <code>iterable2</code>, …：要合并的可迭代对象，可以是多个，用逗号分隔。<pre class="line-numbers language-none"><code class="language-none">names &#x3D; [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charlie&#39;]scores &#x3D; [95, 88, 75]# 使用 zip() 合并两个列表zipped_data &#x3D; zip(names, scores)# 遍历合并后的迭代器for name, score in zipped_data:    print(name, score)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2024/04/20/study/python/yi-chang/"/>
      <url>/2024/04/20/study/python/yi-chang/</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>异常类型：</strong> 异常在 Python 中有许多不同的类型，每种类型代表不同的错误或异常情况。例如，<code>ZeroDivisionError</code> 表示除以零错误，<code>ValueError</code> 表示值错误，<code>FileNotFoundError</code> 表示文件未找到等。您可以使用 <code>try</code> 和 <code>except</code> 块来捕获和处理特定类型的异常。</p></li><li><p><strong>try-except 块：</strong> 使用 <code>try</code> 和 <code>except</code> 关键字，您可以编写代码块来尝试执行可能引发异常的操作，并在异常发生时执行相应的异常处理代码。</p><pre class="line-numbers language-none"><code class="language-none">try:    # 尝试执行可能引发异常的操作    result &#x3D; 10 &#x2F; 0except ZeroDivisionError:    # 处理除以零异常    print(&quot;除以零错误发生了&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>多个 except 块：</strong> 您可以使用多个 <code>except</code> 块来处理不同类型的异常。</p><pre class="line-numbers language-none"><code class="language-none">try:    result &#x3D; int(&quot;abc&quot;)except ValueError:    print(&quot;值错误发生了&quot;)except ZeroDivisionError:    print(&quot;除以零错误发生了&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>通用 except 块：</strong> 您可以使用一个通用的 <code>except</code> 块来捕获任何未处理的异常。</p><pre class="line-numbers language-none"><code class="language-none">try:    result &#x3D; int(&quot;abc&quot;)except Exception as e:    print(f&quot;发生了异常：&#123;e&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>else 块：</strong> 可选的 <code>else</code> 块允许您在没有异常发生时执行特定的代码。</p><pre class="line-numbers language-none"><code class="language-none">try:    result &#x3D; int(&quot;42&quot;)except ValueError:    print(&quot;值错误发生了&quot;)else:    print(&quot;没有异常发生&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>finally 块：</strong> <code>finally</code> 块中的代码无论是否发生异常都会执行。通常，它用于执行一些清理工作，例如关闭文件或释放资源。</p><pre class="line-numbers language-none"><code class="language-none">try:    file &#x3D; open(&quot;example.txt&quot;, &quot;r&quot;)    data &#x3D; file.read()except FileNotFoundError:    print(&quot;文件未找到&quot;)finally:    file.close()  # 确保文件被关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>自定义异常：</strong> 您还可以创建自定义异常类，以便更好地描述特定应用程序的错误情况，并在代码中引发这些异常。</p><pre class="line-numbers language-none"><code class="language-none">class CustomError(Exception):    def __init__(self, message):        super().__init__(message)try:    raise CustomError(&quot;这是一个自定义异常&quot;)except CustomError as e:    print(f&quot;捕获到自定义异常：&#123;e&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列相关的函数</title>
      <link href="/2024/04/20/study/python/xu-lie-xiang-guan-de-han-shu/"/>
      <url>/2024/04/20/study/python/xu-lie-xiang-guan-de-han-shu/</url>
      
        <content type="html"><![CDATA[<h5 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter() 函数"></a>filter() 函数</h5><ul><li><code>filter()</code> 是一个内置函数，用于过滤可迭代对象（通常是列表）中的元素，根据给定的函数（或条件）来决定哪些元素应该包含在结果中。<code>filter()</code> 函数的基本语法如下：<code>filter(function, iterable)</code></li><li><code>function</code>：表示用于过滤的函数，可以是一个函数或可调用对象。这个函数将用于判断可迭代对象中的每个元素。</li><li><code>iterable</code>：是要过滤的可迭代对象，例如列表、元组等。<pre class="line-numbers language-none"><code class="language-none"># 定义一个过滤函数，用于判断元素是否为偶数def is_even(x):    return x % 2 &#x3D;&#x3D; 0numbers &#x3D; [1, 2, 3, 4, 5, 6, 7, 8]# 使用 filter 函数筛选出偶数even_numbers &#x3D; list(filter(is_even, numbers))print(even_numbers)  # 输出 [2, 4, 6, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="map-函数"><a href="#map-函数" class="headerlink" title="map() 函数"></a>map() 函数</h5><ul><li><code>map</code> 是一种常见的高阶函数，通常用于函数式编程语言中，也在许多编程语言中提供支持，包括Python、JavaScript、Java等。<code>map</code> 函数用于将一个函数应用于可迭代对象（如列表或数组）的每个元素，并返回一个新的包含函数应用结果的可迭代对象。</li><li><code>map</code> 函数的基本语法如下：<code>map(function, iterable)</code></li><li><code>function</code>：是要应用于每个元素的函数，它接受一个参数并返回一个结果。</li><li><code>iterable</code>：是要迭代的可迭代对象，例如列表、元组或数组。<pre class="line-numbers language-none"><code class="language-none"># 定义一个函数，将每个元素加倍def double(x):    return x * 2numbers &#x3D; [1, 2, 3, 4, 5]# 使用 map 函数将 double 函数应用于 numbers 中的每个元素doubled_numbers &#x3D; list(map(double, numbers))print(doubled_numbers)  # 输出 [2, 4, 6, 8, 10]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行函数</title>
      <link href="/2024/04/20/study/python/xing-han-shu/"/>
      <url>/2024/04/20/study/python/xing-han-shu/</url>
      
        <content type="html"><![CDATA[<ul><li><p>含函数又叫列表解析或列表推导式（List Comprehension）是一种在许多编程语言中用于创建新列表的紧凑和表达性高的方法。它允许您从现有的可迭代对象（通常是列表、元组或其他序列类型）中创建新列表，同时对元素进行转换、过滤或组合。</p></li><li><p>通常，列表解析的语法包括以下部分：<code>[expression for item in iterable if condition]</code></p><ol><li><code>expression</code>：定义了新列表中每个元素的计算方式。</li><li><code>item</code>：表示可迭代对象中的每个元素。</li><li><code>iterable</code>：是您要遍历的可迭代对象，如列表、元组等。</li><li><code>condition</code>（可选）：用于过滤元素的条件，只有满足条件的元素才会包含在新列表中。</li></ol></li><li><p><strong>创建新列表</strong>：</p><pre class="line-numbers language-none"><code class="language-none">numbers &#x3D; [1, 2, 3, 4, 5]squared_numbers &#x3D; [x**2 for x in numbers]# squared_numbers现在包含[1, 4, 9, 16, 25]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>带有条件的列表解析</strong>：</p><pre class="line-numbers language-none"><code class="language-none">numbers &#x3D; [1, 2, 3, 4, 5]even_numbers &#x3D; [x for x in numbers if x % 2 &#x3D;&#x3D; 0]# even_numbers现在包含[2, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>嵌套列表解析</strong>：</p><pre class="line-numbers language-none"><code class="language-none">matrix &#x3D; [[1, 2, 3], [4, 5, 6], [7, 8, 9]]flattened &#x3D; [num for row in matrix for num in row]# flattened现在包含[1, 2, 3, 4, 5, 6, 7, 8, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2024/04/20/study/python/han-shu/"/>
      <url>/2024/04/20/study/python/han-shu/</url>
      
        <content type="html"><![CDATA[<h5 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a><code>nonlocal</code></h5><ul><li>使用 <code>nonlocal</code> 关键字可以改变外部函数的变量，特别是在嵌套函数中。这是 <code>nonlocal</code> 的主要作用之一。</li><li><code>nonlocal</code> 是一个在 Python 中用于指示变量的作用域的关键字。它通常用在嵌套函数中，以允许你在内部函数中修改外部函数的局部变量，而不会创建一个新的同名局部变量。</li><li>在 Python 中，通常有三种作用域：<ol><li>局部作用域（Local scope）：定义在函数内部的变量只能在该函数内部访问。</li><li>嵌套作用域（Enclosing scope）：嵌套函数可以访问包含它们的外部函数的变量。</li><li>全局作用域（Global scope）：在模块级别定义的变量可以在模块中的任何地方访问。</li></ol></li><li>有时，当在嵌套函数中尝试修改一个外部函数的局部变量时，Python 会默认将这个变量解释为一个新的局部变量，而不是修改外部函数的变量。这就是使用 <code>nonlocal</code> 的情况。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数的高级应用</title>
      <link href="/2024/04/20/study/python/han-shu-de-gao-ji-ying-yong/"/>
      <url>/2024/04/20/study/python/han-shu-de-gao-ji-ying-yong/</url>
      
        <content type="html"><![CDATA[<h5 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h5><ul><li>函数闭包（Function Closure）是一个重要的编程概念，它涉及到函数和其所在作用域的相互关系。一个闭包是一个函数，它不仅包含自身的代码，还包含了在函数定义时可访问的外部作用域的变量。这意味着闭包函数可以访问其外部作用域中定义的变量，即使在外部作用域已经销毁或不再可见的情况下也可以如此。<pre class="line-numbers language-none"><code class="language-none">def outer_function(x):    def inner_function(y):        return x + y    return inner_functionclosure &#x3D; outer_function(10)  # 创建一个闭包result &#x3D; closure(5)  # 调用闭包函数print(result)  # 输出 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><ul><li>迭代器（Iterator）是一种用于遍历可迭代对象（Iterable）的对象或数据结构。可迭代对象是一种包含多个元素的数据结构，例如列表、元组、集合、字典等。迭代器允许按顺序逐个访问可迭代对象的元素，而不必提前加载整个数据集到内存中，这对于处理大型数据集和节省内存非常有用。</li><li>迭代器通常具有以下特征：<ol><li><code>__iter__</code> 方法：迭代器对象必须实现一个 <code>__iter__</code> 方法，该方法返回迭代器本身。这允许迭代器在迭代上下文中使用，例如 <code>for</code> 循环。</li><li><code>__next__</code> 方法：迭代器对象必须实现一个 <code>__next__</code> 方法，该方法返回可迭代对象的下一个元素。如果没有更多的元素可供迭代，<code>__next__</code> 方法应该引发 <code>StopIteration</code> 异常。</li><li>记录状态：迭代器通常会在内部维护一个状态，以跟踪当前迭代的位置，以便在每次调用 <code>__next__</code> 方法时返回下一个元素。<pre class="line-numbers language-none"><code class="language-none">my_list &#x3D; [1, 2, 3, 4, 5]my_iterator &#x3D; iter(my_list)  # 获取迭代器try:    while True:        element &#x3D; next(my_iterator)        print(element)except StopIteration:    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><ul><li><p>生成器（Generator）是Python中一种特殊类型的可迭代对象，用于按需生成数据而不一次性生成所有数据。生成器允许你定义一个函数，其中包含 <code>yield</code> 语句，该语句在每次调用生成器时生成一个值，并保留生成器的状态，以便在下一次调用时从上次离开的地方继续执行。</p></li><li><p><strong>生成器函数</strong>：生成器函数是一个包含 <code>yield</code> 语句的函数。当函数执行到 <code>yield</code> 时，它会生成一个值，并暂停函数的执行，将值返回给调用者。</p><pre class="line-numbers language-none"><code class="language-none">def simple_generator():    yield 1    yield 2    yield 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>生成器表达式</strong>：生成器表达式是一种类似于列表推导式的语法，但使用圆括号而不是方括号。它允许你创建简单的生成器，逐个生成值。</p><pre class="line-numbers language-none"><code class="language-none">generator &#x3D; (x * 2 for x in range(5))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>迭代生成器</strong>：生成器可以通过 <code>for</code> 循环进行迭代，或者你可以使用 <code>next()</code> 函数手动获取生成的值。</p><pre class="line-numbers language-none"><code class="language-none">gen &#x3D; simple_generator()for value in gen:    print(value)# 或者使用 next() 函数gen &#x3D; simple_generator()print(next(gen))  # 输出 1print(next(gen))  # 输出 2print(next(gen))  # 输出 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>生成器的状态</strong>：生成器会保持其内部状态，以便在每次生成值后可以从上次离开的地方继续执行。</p><pre class="line-numbers language-none"><code class="language-none">def counter():    i &#x3D; 0    while True:        yield i        i +&#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>断言的用法、with语句</title>
      <link href="/2024/04/20/study/python/duan-yan-de-yong-fa-with-yu-ju/"/>
      <url>/2024/04/20/study/python/duan-yan-de-yong-fa-with-yu-ju/</url>
      
        <content type="html"><![CDATA[<h5 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h5><ul><li>断言（Assertion）是一种在程序中嵌入的检查机制，用于检查特定条件是否为真。它用于确保在程序执行过程中的某个点，某个条件得到满足，否则会引发异常。断言通常用于调试和测试代码，以确保程序的正确性。</li><li>在Python中，断言通过 <code>assert</code> 语句来实现。<code>assert</code> 语句接受一个条件表达式作为参数，如果该条件为假（False），则引发 <code>AssertionError</code> 异常。如果条件为真（True），则程序会继续正常执行。</li><li>断言的基本语法如下：<code>assert condition, message</code></li><li><code>condition</code> 是一个要检查的条件表达式，如果为假，将引发异常。</li><li><code>message</code> 是一个可选的消息，用于在引发异常时提供额外的描述信息。<pre class="line-numbers language-none"><code class="language-none"># 示例1: 简单的断言x &#x3D; 10assert x &gt; 5, &quot;x 应该大于 5&quot;  # 条件为真，不会引发异常# 示例2: 检查列表不为空my_list &#x3D; []assert len(my_list) &gt; 0, &quot;列表应该不为空&quot;  # 条件为假，引发异常# 示例3: 使用断言来验证函数的前提条件def divide(a, b):    assert b !&#x3D; 0, &quot;除数不能为零&quot;    return a &#x2F; bresult &#x3D; divide(10, 2)  # 不会引发异常result &#x3D; divide(10, 0)  # 引发异常：&quot;除数不能为零&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a><code>with</code>语句</h5><ul><li><p><code>with</code> 语句是 Python 中用于管理资源的一种结构，主要用于确保在进入和离开代码块时资源得到正确的分配和释放。最常见的用例是处理文件、网络连接、数据库连接以及其他需要明确打开和关闭的资源。</p></li><li><p><code>with</code> 语句的一般语法如下：</p><pre class="line-numbers language-none"><code class="language-none">with expression as variable:    # 代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>expression</code> 是一个表示需要管理的资源的表达式，它返回一个支持上下文管理协议的对象，通常是具有 <code>__enter__()</code> 和 <code>__exit__()</code> 方法的对象。</p></li><li><p><code>variable</code> 是一个变量名，用于引用表达式返回的对象。</p></li><li><p><code>with</code> 语句在进入代码块之前调用 <code>expression</code> 返回对象的 <code>__enter__()</code> 方法，在离开代码块时调用 <code>__exit__()</code> 方法。这样可以确保资源在使用后被正确释放，即使发生异常也可以处理。</p></li><li><p><strong>文件处理</strong>：</p><pre class="line-numbers language-none"><code class="language-none">with open(&#39;example.txt&#39;, &#39;r&#39;) as file:    data &#x3D; file.read()# 在离开代码块后，文件会自动关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>数据库连接</strong>（使用 <code>sqlite3</code> 作为示例）：</p><pre class="line-numbers language-none"><code class="language-none">import sqlite3with sqlite3.connect(&#39;my_database.db&#39;) as connection:    cursor &#x3D; connection.cursor()    cursor.execute(&#39;SELECT * FROM my_table&#39;)# 在离开代码块后，数据库连接会自动关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>网络连接</strong>（使用 <code>socket</code> 作为示例）：</p><pre class="line-numbers language-none"><code class="language-none">import socketwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:    s.connect((&#39;example.com&#39;, 80))    s.sendall(b&#39;GET &#x2F; HTTP&#x2F;1.1\r\n\r\n&#39;)    data &#x3D; s.recv(1024)# 在离开代码块后，网络连接会自动关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql server卸载</title>
      <link href="/2024/04/20/study/ying-yong-de-an-zhuang-yu-xie-zai/sqlserver/sql-server-xie-zai/"/>
      <url>/2024/04/20/study/ying-yong-de-an-zhuang-yu-xie-zai/sqlserver/sql-server-xie-zai/</url>
      
        <content type="html"><![CDATA[<p>停止所有与Sql Server有关的服务。<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/install_and_uninstall202404191453199.png"></p><p>在控制面板中，删除所有与Sql Server有关的程序。 其中卸载Microsoft SQLServer 2014(64)位时，与安装程序步骤一致。</p><p>删除HKEY_CURRENT_USER\SOFTWARE\Microsoft\Microsoft SQL Server<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/install_and_uninstall202404191951038.png"></p><p>删除HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft下所有关于Microsoft SQL Server的子项<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/install_and_uninstall202404191954888.png"></p><p>进入C盘里的Program Files文件夹，如果是64位的，同时还要查看Program Files（86）文件夹。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 卸载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle卸载</title>
      <link href="/2024/04/20/study/ying-yong-de-an-zhuang-yu-xie-zai/oracle11g/oracle-xie-zai/"/>
      <url>/2024/04/20/study/ying-yong-de-an-zhuang-yu-xie-zai/oracle11g/oracle-xie-zai/</url>
      
        <content type="html"><![CDATA[<p>进入“服务”<br>三种方法<br>搜索框直接搜索<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011537266.png"><br>对此电脑点管理<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011539492.png"><br>打开任务管理器，最右边的是服务<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011556881.png"></p><p>找到所有oracle开头的服务<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011558102.png"><br>停止所有oracle的服务<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011559079.png"></p><p>在菜单中找到并点击universal uninstaller<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011610178.png"><br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011611029.png"></p><p>点击卸载产品<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011612569.png"><br>选择卸载的产品，点击删除<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011616588.png"></p><p>进入图中所示目录<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011617434.png"><br>双击运行该程序<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011619362.png"></p><p>出现如下图所示窗口，并输入提示词：LISTENER，回车等待<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011622350.png"><br>输入框内的提示词：ORCL，回车等待，<mark style="background: #FF5582A6;">别按其他任何按键，不要着急！</mark><br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011625620.png"><br>出现指定此数据库，直接回车<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011649225.png"><br>直接回车<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011651620.png"><br>如果提示目录不存在，则输入提示框内提示词，输入到diag即可，然后回车<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011652162.png"><br>输入FS，然后回车<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011654348.png"><br>直接回车<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011654768.png">直接回车<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011655436.png">直接回车<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011655829.png"><br>输入y，然后回车<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011656548.png"><br><mark style="background: #FF5582A6;">等待操作完成<br></mark></p><p>win+r开大运行界面，输入regedit进入注册表编辑器<br>删除HKEY_LOCAL_MACHINE\ SYSTEM\CurrentControlSet\Services\ 路径下的所有Oracle开始的服务名称，我已经删除了几个<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011707974.png"><br>删除HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application注册表的所有Oracle开头的所有服务<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011708310.png"><br>删除HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE 注册表<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011709002.png"><br>查看环境变量中是否存在Oracle相关的设置，若有直接删除，然后点击确定返回<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011711329.png"></p><p>删除app目录下的所有文件<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011712840.png"><br>删除C盘下C:\Program Files或者C:\Program Files(x86)目录下的Oracle目录<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011716501.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 卸载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g安装</title>
      <link href="/2024/04/20/study/ying-yong-de-an-zhuang-yu-xie-zai/oracle11g/oracle-11g-an-zhuang/"/>
      <url>/2024/04/20/study/ying-yong-de-an-zhuang-yu-xie-zai/oracle11g/oracle-11g-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>点击是<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011728788.png"><br>下一步<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011729367.png"><br>是<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011732607.png"><br>默认，下一步<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011731478.png"><br>默认，下一步<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011733799.png"><br>不要装载C盘，口令可以设置简单一些，下一步<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011734323.png"><br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011734601.png"><br>完成<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011735896.png"><br>等待安装<br><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network202404011736909.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本章引言</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/ben-zhang-yin-yan/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/ben-zhang-yin-yan/</url>
      
        <content type="html"><![CDATA[<ul><li>所谓方法学是指组织软件生产过程的一系列方法、技术和 规范，是软件开发者长年成功和失败经验的理论性总结。 研究方法学的目的是，使后人分享前人的成功，避开前人 的失败，把注意力集中在尚未开拓领域的创造性劳动上。 但没有放之四海而皆准的方法学，任何方法学都有其局限 性，软件开发人员大可不必拘泥于某种特定的方法学。</li><li>本章主要包括面向对象的基本概念、面向对象的方法学、 面向对象软件工程、面向对象建模工具、统一建模语言 UML 及统一软件开发过程RUP 的介绍</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3 统一建模语言UML</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/9.3-tong-yi-jian-mo-yu-yan-uml/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/9.3-tong-yi-jian-mo-yu-yan-uml/</url>
      
        <content type="html"><![CDATA[<ul><li>UML 的发展<ol><li>发展历史![[Pasted image 20230627115315.png]]</li><li>UML1.0支持的图形![[Pasted image 20230627115345.png]]</li></ol></li><li>UML 的定义及主要内容<ol><li>UML 是一种标准的可视化（即图形化）建模语言，它由元模型和图组成。元模型给出图的定义，是UML的语义， 图是 UML 的语法。<ul><li>UML 语法；<ol><li>在一个四层抽象级别的建模框架中定义<ul><li>元元模型层：表示要定义的所有事务；</li><li>元模型层：包括面向对象和面向组件的概念；</li><li>模型层：由 UML 模型组成，包括面向对象和面向组件的概念；</li><li>用户模型层：由例子组成，每个概念都是模型层的一个实例。</li></ul></li></ol></li><li>UML 的表示方法；<ol><li>视图：整个系统描述的投影，说明系统的一个侧面；</li><li>图：表示一个视图的内容；</li><li>模型元素：用相应的试图元素及图形符号表示；</li><li>公共机制：可为图附加额外的信息</li></ol></li><li>UML 的构成；<ol><li>![[Pasted image 20230627141922.png]]</li></ol></li></ul></li></ol></li><li>UML 的特点和用途<ol><li>UML 的主要特点<ul><li>统一的标准；</li><li>面向对像</li><li>可视化，表示能力强大</li><li>独立于过程</li><li>易于掌握应用</li></ul></li><li>使用 UML 进行软件系统的分析与设计，能够加速软件开发的进程，提高代码的质量，支持变动的业务需求。</li><li>UML 适用于各种大小规模的软件系统项目，能促进软件复用，方便地集成已有的系统软件资源。</li><li>UML 是一种标准的表示方法，为不同领域的人提供了一种统一的交流方法。</li><li>UML 采用面向对象的图形方式来描述任何类型的系统，因此，UML 具有广泛的应用领域。</li><li>UML 的应用覆盖了从需求分析阶段到软件测试阶段的各阶段。</li></ol></li><li>UML 的模型视图简介<ol><li>UML 用模型来描述系统的结构以及静态特征结构以及动态特征行为，从不同的角度为系统建模，形成不同的视图。UML 中提供了静态图和动态图，共计13种，以及5种视图：<ul><li>静态图：类图、对象图、用例图、构建图、部署图、包图、组合机构图；</li><li>动态图：状态图、顺序图、通信图、活动图、计时图、交互概览图；</li><li>视图：用例视图、逻辑视图、进程试图、实现视图、部署视图；</li></ul></li><li>![[Pasted image 20230627142433.png]]</li><li>![[Pasted image 20230627142456.png]]</li></ol></li><li>UML 常用软件开发工具<ol><li>Rational Rose<ul><li>Rose家族的一些主要功能：<ol><li>对面向对象模型的支持；</li><li>对螺旋上升式开发过程的支持；</li><li>对双向工程的支持；</li><li>对团队开发的支持；</li><li>对工具的支持</li></ol></li></ul></li><li>Visio 简介<ul><li>Microsoft Visio 是一种绘图软件，它可以帮助商务与专业技术人员将思想、信息与系统进行可视化和交流——从工艺流程与组织结构到网络拓扑与应用开发，从而协助项目的计划与实施。</li><li>特别是 Visio 2002 以后的版本支持 UML 语言，可用作面向对象的可视化建模工具，支持正向工程，将 UML 图表转换，产生程序的代码框架结构。同时支持逆向工程，通过逆向工程将代码转换为 UML 静态结构图表。</li></ul></li><li>目前有很多支持 UML 的工具，例如Rational Rose2003、Together 6.1、ArgoUMLv0.14其中Rose用于分析和设计面向对象软件系统的工具，目前有较高的市场占有率。</li><li>Visio Professional 2003是一个功能很强的绘图工具， 支持UML规范说明中定义的图，因而也可应用于 UML 语言的系统建模中。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.4 统一软件开发过程RUP概述</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/9.4-tong-yi-ruan-jian-kai-fa-guo-cheng-rup-gai-shu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/9.4-tong-yi-ruan-jian-kai-fa-guo-cheng-rup-gai-shu/</url>
      
        <content type="html"><![CDATA[<ul><li><mark style="background: #FF5582A6;">软件开发过程</mark>是一个将用户的需求转化为软件系统所需要的活动的集合，按业务建模的术语，软件开发过程是一个业务流程。</li><li>RUP（Rational Unified Process）是一个面向对象软件工程的通用业务流程。 它描述一系列相关的软件工程过程，具有相同的过程框架。</li><li>RUP 为在开发组织中分配任务和职责提供了一种<mark style="background: #FF5582A6;">规范方法</mark>。其<mark style="background: #FF5582A6;">目标</mark>是确保在可预计的时间安排和预算内开发出满足最终用户需求的高品质的软件。它汇集现代软件开发中多方面的最佳经验，为适应各种项目及组织的需要提供了灵活的形式。</li><li>RUP 的历史<ol><li>![[Pasted image 20230627143840.png]]</li></ol></li><li>RUP 的特色<ol><li>迭代和增量方法<ul><li>是把整个项目开发分为多个迭代过程，在每次迭代中，只考虑系统的一部分需求，进行分析、设计、实现、测试、部署等过程，它是在已完成部分的基础上进行的，每次增加一些新的功能实现，依次进行，直至最后项目完成。</li></ul></li><li>以软件体系结构为中心<ul><li>软件体系结构是软件设计过程中的一个层次，体系结构层次 的设计问题包括系统的总体组织和全局控制、通讯协议、同步、 数据存取、给设计元素分配特定功能、设计元素的组织、物理 分布、系统的伸缩性和性能等，因此在设计时需要在各种可能 的选择之间权衡，使系统总体上达到设计目标。</li></ul></li></ol></li><li>RUP 软件开发的生存周期<ol><li>![[Pasted image 20230627144252.png]]</li><li>图中横轴代表时间，显示了过程的生命周期，体现了过程的动态结构。通过周期、阶段、迭代和里程碑来表示。纵轴代表核心工作流，工作流将活动自然地进行逻辑分组，体现了过程的静态结构。</li><li>RUP 把软件开发生命周期划分为多个循环（Cycle），每个 Cycle 生成产品的一个新的版本，每个 Cycle 依次由 4 个连续的阶段（Phase）组成，依次为：<ul><li>初始阶段（Inception）：定义最终产品视图和业务模型，并确定系统范围；</li><li>细化阶段（Elaboration）：设计及确定系统的体系结构，制定工作计划及资源要求；</li><li>构造阶段（Construction）：构造产品并继续演进需求、体系机构、计划、直至产品提交；</li><li>交付阶段（Transition）：把产品提交给用户使用。</li><li>每个阶段完成确定的任务，这 4 个阶段体现了 RUP 软件开发过程的动态结构。</li></ul></li><li>每一个阶段都有一个或多个连续的迭代（Iteration）组成，迭代是针对不同用例的细化和实现。</li><li>在每个阶段结束前有一个里程碑（Milestone）评估该阶段的工作。</li><li>迭代开发方法是一种渐增过程，RUP 的每个阶段可以进一步被分解为多个迭代过程，迭代过程是导致可执行产品版本（内部或外部）的完整开发循环，是最终产品的一个子集，从一个迭代过程到另一个迭代过程递增式增长形成最终的系统。</li><li>同传统的瀑布模型软件开发方法相比，迭代方法降低了软件过程的早期风险，易于实现变更控制，可以提高软件重用性，保障软件产品的整体质量。</li><li>RUP 软件开发过程中的 9 个核心工作流，表示 RUP 软件开发过程的静态结构：<ul><li>业务建模（Business Modeling）</li><li>需求（Requirements）</li><li>分析与设计（Analysis &amp; Design）</li><li>实现（Implementation）</li><li>测试（Test）</li><li>部署（Deployment）</li><li>项目管理（Project Management）</li><li>配置与变更管理（Configuration &amp; Change Management）</li><li>环境（Environment）</li></ul></li></ol></li><li>RUP 过程的建模<ol><li>RUP 的可视化建模，可以将一个软件系统构架的结构和行为以可视化模型表示，便于开发组中的成员清晰地、无二意地相互交流设计思想和方案。</li><li>RUP 建模的四个阶段：<ul><li>初始阶段：确定系统中的角色和用例；</li><li>细化阶段：对每个用例进行细化；</li><li>构造阶段：创建组件和组件框图；</li><li>交付阶段：将完成的软件产品交给用户。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1 面向对象方法概述</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/9.1-mian-xiang-dui-xiang-fang-fa-gai-shu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/9.1-mian-xiang-dui-xiang-fang-fa-gai-shu/</url>
      
        <content type="html"><![CDATA[<ul><li>面向对象（Object Oriented，OO）方法学的出发点和基本原则是尽可能模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类解决问题的方法与过程。</li><li>面向对象的方法学可以用下式来表述： OO &#x3D; Objects + Classes + Inheritance + Communication with message</li><li>面向对象方法学的发展<ol><li>在软件工程领域，面向对象的发展历史大致可以划分为 3 个阶段：<ul><li>初期阶段（20 世纪60 年代开始）：由挪威计算中心和奥斯陆大学共同研制 Simula 语言；发展阶段（20 世纪80 年代中期到90 年代）：以面向对象程序设计语言 C++ 为代表；</li><li>成熟阶段（20 世纪90 年代以后）：OOP -&gt; OOA -&gt; OOD-&gt; 面向对象方法（Booch，Coad&#x2F;Yourdon， OMT ，OOSE, RDD）-&gt;UML；</li></ul></li></ol></li><li>面向对象方法学的优点和不足<ol><li>面向对象方法学的主要优点：<ul><li>与人类习惯的思维方式一致；</li><li>软件稳定性好；</li><li>可重用性好；</li><li>较易；</li><li>可维护性好，易于测试开发大型软件产品。</li></ul></li><li>面向对象方法学的不足之处：<ul><li>相对面向过程而言比较麻烦，需要写更多的代码；</li><li>占用空间比较多，程序效率比较低，如多态等特性会降低性能；</li><li>创建对象实例的过程往往是非常耗时的工作，因此一些认为“万事皆对象”的语言对于一些简单类型的操作性能比较低；</li><li>对系统动态特征表述不充分（主要是整体动态特征），且反映系统整体功能特征的能力较差。如需要一定的软件支持环境，只能在现有业务基础上进行分类整理，不能从科学管理角度进行理顺和优化，初学者不易接受、难学；</li><li>面向对象方法学 4 大特性（抽象、封装、继承和多态）在一定程度上避免了不合理的操作，并能有效地阻止错误的扩散，减轻了维护工作量，但是也加大了测试的难度，给软件测试带来不便。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2 面向对象的软件工程</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/9.2-mian-xiang-dui-xiang-de-ruan-jian-gong-cheng/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/9-mian-xiang-dui-xiang-fang-fa-xue/9.2-mian-xiang-dui-xiang-de-ruan-jian-gong-cheng/</url>
      
        <content type="html"><![CDATA[<ul><li>面向对象的软件工程是面向对象方法在软件工程领域的全面应用， 从软件工程过程的角度讲，包括了<mark style="background: #FF5582A6;">管理</mark>、<mark style="background: #FF5582A6;">过程</mark>和<mark style="background: #FF5582A6;">技术</mark> 3 个方面。<br>  ![[Pasted image 20230627103531.png]]</li><li>从生存周期角度讲，包括  OOA，OOD，OOP，OOT，OOSM。</li><li>面向对象基本概念<ol><li>对象<ul><li>对象是对问题域中客观存在的事物的抽象，是一组属性和在这些属性上的操作的封装体。</li><li>对象包括两大要素：属性（用来描述对象的静态特征）和操作（用来描述对象的动态特征）。</li></ul></li><li>类<ul><li>类是具有相同属性和操作的一组相似对象（实体）的集合。同类的对象具有相同的属性和方法。</li><li>UML 中类图的描述通常表示为长方形，其中，长方形又分 3 个部分，分别用来表示类的名字、属性（静态）和操作（动态）。</li><li>例如， “小汽车”类的 UML 类图描述可以参见图9.3。<br>  ![[Pasted image 20230627111037.png]]</li></ul></li><li>消息<ul><li>消息是面向对象系统中对象之间交互的途径，是向另外一个对象发出的服务请求，请求对象参与某一处理或回答某一要求的信息，是对象之间建立的一种通信机制；</li><li>通常一个消息的关键要素包括消息的发送者、消息的接收者、消息所要求的具体服务及其参数、消息的应答等；</li><li>例如，若有已定义的类 Circle，定义 MyCircle 是 Circle 类的一个对象，则语句 MyCircle.Show（GREEN）用来表示该对象向系统发送一个要以绿颜色显示自己的消息，其中 MyCircle 是发送消息的对象名字，Show 是消息名， GREEN 是消息的参数。</li></ul></li><li><mark style="background: #FF5582A6;">封装</mark><ul><li>封装指把对象的属性和操作结合成一个独立的系统单位，并尽可能隐藏对象的内部细节；</li><li>封装的作用有 3 个方面：<ol><li>一是使对象形成接口和实现；</li><li>二是封装的信息隐藏将所声明的功能（行为）与内部实现 （细节）分离；</li><li>三是封装可以保护对象，避免用户误用。</li></ol></li></ul></li></ol></li><li>对象、类及类之间关系的分析<ol><li>类与对象的关系<ul><li><blockquote><p>类给出了属于该类的全部对象的抽象定义，而对象则是符合这种定义的一个实体。因此，对象又称为是类的一个“实例( Instance) ”，类又称为是对象的“模板（Template)；</p></blockquote></li><li>类是静态的，类的语义和类之间的关系在程序执行之前已经定义，但对象是动态的，在程序执行过程中可以动态地创建和删除对象；</li><li>类代表一类抽象的概念或事物，对象是在客观世界中实际存在的类的实例。</li></ul></li><li>类与类之间的关系<ul><li>继承（Inheritance）<ol><li>继承是子类自动地共享父类中定义的数据和方法的机制；</li><li>反过来，从子类抽取共同通用的特征形成父类的过程也叫做泛化（Generalization）;</li><li>继承可以表示类与类、接口与接口之间的继承关系，或类与接口之间的实现关系；</li><li>具有继承关系的类之间，既具有共享特性又具有差别或新增部分，并且类之间具有层次结构；</li><li>继承具有传递性。</li></ol></li><li>多态性（Polymorphi）<ol><li>指子类对象可以像父类对象那样使用，它们可以共享一个操作名，然而却有不同的实现方法，换句话说，指在父类中定义的属性或操作被子类继承后可以具有不同的数据类型或表现出不同的行为。</li><li>多态性的实现有两种形式：<ul><li><mark style="background: #FF5582A6;">编译时的多态性</mark></li><li><mark style="background: #FF5582A6;">运行时的多态性</mark></li><li>![[Pasted image 20230627112304.png]]</li></ul></li></ol></li><li>关联（Association）<ol><li>关联体现的是两个类之间语义级别的一种强依赖关系，一般是长期性的，而且双方的关系一般是平等的；</li><li>关联可以是单向的、双向的；</li><li>表现在代码层面，被关联类 B 以类的属性形式出现在关联类 A 中，也可能是关联类 A 引用了一个类型为被关联类 B 的全局变量。</li></ol></li><li>依赖（Dependancy）<ol><li>依赖就是一个类 A 使用到了另一个类 B ，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类 B 的变化会影响到类 A ；</li><li>表现在代码层面，假如类 A 的某个方法中使用了类 B ，那么就说类 A 依赖于类 B ，它们是依赖关系。类 B 在类 A 中都是以局部变量的形式存在的；</li><li>在 UML 类图设计中，依赖关系用由类 A 指向类 B 的带箭头虚线表示，虚线箭头表示依赖，箭头指向被依赖的类，参见图9.10。<ul><li>![[Pasted image 20230627113214.png]]</li></ul></li><li>关于关联关系和依赖关系有一个简单的判断原则：某个类以成员变量的形式出现在另一个类中，二者是<mark style="background: #FF5582A6;">关联关系</mark>；某个类以局部变量的形式出现在另一个类中，二者是<mark style="background: #FF5582A6;">依赖关系</mark>。</li></ol></li><li>实现（ Realization ）<ol><li>实现是用来规定接口和实现接口的类之间的关系，接口是操作的集合，而这些操作就用于规定类或者构件的一种服务；</li><li>实现是类和接口之间最常见的一种关系，一个类实现接口（可以是多个）的功能；</li><li>在 UML 中，类与接口之间的实现关系用带空心三角形的虚线来表示，参见图9.11。<ul><li>![[Pasted image 20230627113504.png]]</li></ul></li></ol></li><li>聚集（Aggregation）与组合（Composition）<ol><li>表示组成关系的整体和部分类之间的关联又可以细分为<mark style="background: #FF5582A6;">聚集</mark>和<mark style="background: #FF5582A6;">组合</mark>。需求描述中的“包含” 、“组成” 、“分成……部分”等词常常意味着存在组成关系；</li><li>整体拥有各部分，部分与整体不是相同的生存期，如整体不存在了，部分还存在，称为<mark style="background: #FF5582A6;">聚集</mark>；</li><li>部分与整体具有同样的生存期，如整体不存在了，部分也会随之消失，称为<mark style="background: #FF5582A6;">组合</mark></li><li>关联和聚合（聚集和组合）的区别如下：<ul><li>关联和聚合在代码层面的表现是一致的，只能从语义级别来区分。关联的两个对象之间一般是平等的，如你是我的朋友，聚集则一般不是平等的，表示一个对象是另一个对象的组成部分。</li><li>关联是一种结构化的关系，指一种对象和另一种对象有联系。</li></ul></li></ol></li><li>类与类之间的关系（小结）<ol><li>继承与实现体现的是一种类与类或类与接口之间的纵向关系</li><li>其他 4 种（组合、聚集、关联、依赖）表示的是类与类或者类与接口之间的引用、横向关系，是比较难区分的，因这几种关系都是语义级别的，所以从代码层面并不能完全区分各种关系，四者之间的强弱关系依次为：组合&gt;聚集&gt;关联&gt;依赖。</li></ol></li></ul></li></ol></li><li>典型的面向对象开发方法<ol><li>自20 世纪80 年代后期以来，相继出现了多种面向对 象开发方法，每种方法都有自己的一套系统分析过程 和方法，都有一组可描述过程演进的图形标识，以及 能使得软件工程师以一致的方式建立模型的符号体系</li><li>本节选择其中几种典型的OO 方法进行简介和比较</li><li>Booch 方法</li><li>Coad&#x2F;Yourdon方法（简称 Coad 方法或 OOAD 方法） </li><li>OMT&#x2F;Rumbaugh 方法</li><li>OOSE 方法</li><li>Wirfs-Brock 方法</li><li>统一建模语言 UML（Unified Modeling Language）1995 年10 月，Grady Booch 和Jim Rumbaugh 联合推出了 Unified Method 0.8 版本，该方法力图实现OMT 方法和 Booch 方法的统一。同年秋天，Ivar Jacobson 加入了Booch 和Rumbaugh 所在的Rational 软件公司，于是OOSE 方法也 加入了统一的过程中。1997 年9月1 日产生了UML 1.1，并被 提交到了OMG（Object Management Group 对象管理组织） ，同年11 月被OMG 采纳。随着OMG 将UML 定为标准建模语 言，面向对象领域的方法学大战也宣告结束，各种方法的提出 者也开始转向UML 方面的研究</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.5 软件再工程</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.5-ruan-jian-zai-gong-cheng/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.5-ruan-jian-zai-gong-cheng/</url>
      
        <content type="html"><![CDATA[<ul><li>软件再工程旨在对现存的大量软件系统进行挖掘、整理以得到有用的软件组件，或对已有软件组件进行维护以延长其生存期。</li><li>软件再工程的基础是系统理解，包括对运行系统、源代码、设计、分析和文档等的全面理解，但在很多情况下，由于各类文档的丢失，只能对源代码进行理解，即程序理解。</li><li>软件再工程和逆向工程是目前预防性维护采用的主要技术，是走向自动维护的必经之路。</li><li>再工程与逆向工程的概念<ol><li>软件再工程：是一类软件工程活动，它能够使我们：<ul><li>增进对软件的理解；</li><li>准备或直接提高软件的可维护性、复用性或演化性</li></ul></li><li>软件的逆向工程：是分析程序，力图在比源代码更高的抽象层次上建立程序表示的过程。<ul><li>![[Pasted image 20230627101740.png]]</li></ul></li></ol></li><li>为什么要实施软件再工程<ol><li>实施软件再工程所带来的好处 ：<ul><li>再工程可帮助软件机构降低软件演化的风险；</li><li>再工程可帮助软件机构补偿软件的投资；</li><li>再工程可使得软件易于进一步变更；</li><li>再工程有着广阔的市场。</li></ul></li></ol></li><li>软件再工程技术<br>  ![[Pasted image 20230627102336.png]]</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本章引言</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/ben-zhang-yin-yan/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/ben-zhang-yin-yan/</url>
      
        <content type="html"><![CDATA[<ul><li>软件系统开发完成交付用户使用后，就进入软件的运行维护阶段。软件维护阶段是软件生存周期中<mark style="background: #FF5582A6;">时间最长</mark>的一个阶段，所<mark style="background: #FF5582A6;">花费的精力和费用也是最多</mark>的一个阶段。</li><li>本章主要介绍软件维护的相关概念，包括定义、分类、特点、软件维护的过程、可维护性等，以及软件维护中存在的问题。最后简单介绍再工程和逆向工程的概念。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.4 软件维护中存在的问题</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.4-ruan-jian-wei-hu-zhong-cun-zai-de-wen-ti/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.4-ruan-jian-wei-hu-zhong-cun-zai-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<ul><li>软件维护困难的表现<ol><li>软件维护的困难主要表现在以下几个方面：<ul><li>读懂别人的程序是很困难的，而文档的不足更增加了这种难度；</li><li>文档的不一致性是软件维护困难的又一个因素， 解决方法就是要加强开发工作中文档的版本管理；</li><li>软件开发和软件维护在人员和时间上存在差异；</li><li>软件维护不是一件吸引人的工作。</li></ul></li></ol></li><li>软件维护的副作用<ol><li>维护的副作用是指由于修改软件而导致新的错误的出现或者新增加一些不希望发生的情况。一般维护产生的副作用主要有如下 3 种：<ul><li>修改<mark style="background: #FF5582A6;">代码</mark>的副作用<ol><li>删除或修改一个子程序、删除或修改一个标号、删除或修改一个标识符、改变程序代码的时序关系、改变占用存储的大小、改变逻辑运算符、修改文件的打开或关闭、改进程序的执行效率，以及把设计上的改变翻译成代码的改变、为边界条件的逻辑测试做出改变时，都容易引入错误。</li></ol></li><li>修改<mark style="background: #FF5582A6;">数据</mark>的副作用<ol><li>在重新定义局部的或全局的常量、重新定义记录或文件的格式、增大或减小一个数组或高层数据结构的大小、修改全局或公共数据、重新初始化控制标志或指针、重新排列输入&#x2F;输出或子程序的参数时，容易导致设计与数据不相容的错误。</li></ol></li><li>修改<mark style="background: #FF5582A6;">文档</mark>的副作用<ol><li>对交互输入的顺序或格式进行修改，如果没有正确地记入文档中，就可能引起重大的问题</li></ol></li></ul></li></ol></li><li>软件维护的代价<ol><li>影响维护工作量的因素主要有以下六种：<ul><li>系统的大小；</li><li>程序设计语言：语言的功能越强，生成程序的模块化和结构化程度越高，所需的指令数就越少，程序的可读性越好；</li><li>系统年龄：系统使用时间越长，所进行的修改就越多，而多次修改可能造成系统结构变得混乱；</li><li>数据库技术的应用：可以简单而有效地管理和存储用户程序中的数据，减少生成用户报表应用软件的维护工作量；</li><li>先进的软件开发技术 ：可减少大量的维护工作量；</li><li>其它一些因素，如应用的类型、数学模型、任务的难度、开关与标记、IF嵌套深度、索引或下标数等，对维护工作量也有影响。</li></ul></li><li>有形的软件维护成本是花费了多少钱，而其他非直接的成本有更大的影响。例如，无形的成本可以是：<ul><li>一些看起来是合理的修复或修改请求不能及时安排，使得客户不满意；</li><li>变更的结果把一些潜在的错误引入正在维护的软件，使得软件整体质量下降；</li><li>当必须把软件人员抽调到维护工作中去时，就使得软件开发工作受到干扰；<br> 维护工作量可以分成生产性活动（如分析和评价、设计修改和实现）和“轮转”活动（如力图理解代码在做什么、试图判明数据结构、接口特性、性能界限等）</li></ul></li><li>Belady 和Lehman 提出一个软件维护工作量的模型如下：M&#x3D;P+K * exp（C-D）其中，M 表示维护中消耗的总工作量；P 表示上面描述的生产性活动工作量；K 是一个经验常数；C 表示由非结构化维护（缺乏好的设计和文档）而引起的程序复杂性的度量；D 表示对维护软件熟悉程度的度量；</li><li>由上式可以发现，C 越大，D 越小，那么维护工作量就成指数的增加。</li><li>也就是说，如果使用了不好的软件开发方法（未按软件工程要求做），原来参加开发的人员或小组不能参加维护的话，则维护工作量（及成本）将按指数级增加。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.3 软件可维护</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.3-ruan-jian-ke-wei-hu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.3-ruan-jian-ke-wei-hu/</url>
      
        <content type="html"><![CDATA[<ul><li>软件可维护性的定义<ol><li>是指纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或压缩的容易程度。</li><li>是软件开发阶段各个时期的关键目标。</li><li>![[Pasted image 20230626201629.png]]</li><li>可理解性：维护人员通过阅读源代码和相关文档，理解软件的结构、接口、功能和内部过程的难易程度；</li><li>可测试性：指证实程序正确性的难易程度。程序越简单，证明其正确性就越容易，好的文档资料对诊断和测试至关重要</li><li>可修改性：指修改程序的难易程度。一个可修改的程序往往是可理解的、通用的、灵活的和简明的</li><li>可靠性：一个程序按照用户的要求和设计目标，在给定的一段时间内正确执行的概率。度量标准主要有平均失效时间间隔、平均修复时间和有效性；</li><li>可移植性：指程序从一个计算机环境移到另一计算机环境的适应能力，亦即程序在不同计算机环境下能够有效地运行的程度。</li><li>可使用性：从用户观点出发，把可使用性定义为程序方便、实用、及易于使用的程度。</li><li>效率：一个程序能执行预定功能而又不浪费机器资源的程度。这些机器资源包括内存容量、外存容量、通道容量和执行时间。</li></ol></li><li>软件可维护性的度量<ol><li>度量一个可维护的程序的七种特性时常用的方法就是<mark style="background: #FF5582A6;">质量检查表</mark>、<mark style="background: #FF5582A6;">质量测试</mark>和<mark style="background: #FF5582A6;">质量标准</mark>。</li><li><mark style="background: #FF5582A6;">质量检查表</mark>：用于测试程序中某些质量特性是否存在的一个问题清单。评价者针对检查表上的每个问题，依据自己的 定性判断，回答“是”或者“否” 。</li><li>质量测试和质量标准则用于定量分析和评价程序的质量。</li></ol></li><li>提高软件可维护性的方法<ol><li>需要从以下五个方面着手：<ul><li>建立明确的软件质量目标和优先级</li><li>使用提高软件质量的技术和工具</li><li>选择便于维护的程序设计语言</li><li>采取明确的、有效的质量保证审查措施</li><li>完善程序的文档</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.1 软件维护概述</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.1-ruan-jian-wei-hu-gai-shu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.1-ruan-jian-wei-hu-gai-shu/</url>
      
        <content type="html"><![CDATA[<ul><li>软件系统开发完成交付用户使用后，就进入软件的运行维护阶段。</li><li>软件维护的工作量大，而且随着软件数量的增多和使用寿命的延长，软件维护的工作量占整个软件开发运行过程总工作量的比例还在持续上升。</li><li>软件维护的定义<ol><li><mark style="background: #FF5582A6;">软件维护</mark>：指软件系统交付使用以后，为了改正软件运行错误，或者因满足新的需求而加入新功能的修改软件的过程。</li><li>软件维护与硬件维修不同，不是简单地将软件产品恢复到初始状态，而是需要给用户提供一个经过修改的软件新产品。软件维护活动需要改正现有错误 ，修改、改进现有软件以适应新环境。</li><li>软件维护不像软件开发一样从零做起，需要在现有软件结构中引入修改，并且要考虑代码结构所施加的约束，此外，软件维护所允许的时间通常只是很短的一段时间。</li></ol></li><li>软件维护的分类<ol><li>软件维护活动可以归结为以下四类：<ul><li><mark style="background: #FF5582A6;">改正性维护</mark><ol><li>在软件交付使用后，因开发时测试的不彻底、不完全，必然会有部分隐藏的错误遗留到运行阶段；</li><li>这些隐藏下来的错误在某些特定的使用环境下就会暴露出来；</li><li>为了识别和纠正软件错误、改正软件性能上的缺陷，而进行诊断和改正错误的过程就叫做改正性维护；</li><li>改正性维护的主要维护策略：<ul><li>开发过程中采用新技术；</li><li>利用应用软件包；</li><li>提高系统结构化程度；</li><li>进行周期性维护审查等；</li></ul></li></ol></li><li><mark style="background: #FF5582A6;">适应性维护</mark><ol><li>在使用过程中，外部环境（新的硬、软件配置），数据环境（数据库、数据格式、数据输入&#x2F;输出方式、数据存储介质）可能发生变化；</li><li>为使软件适应这种变化，而去修改软件的过程就叫做适应性维护；</li><li>适应性维护中的主要维护策略<ul><li>对可能变化的因素进行配置管理；</li><li>将因环境变化而必须修改的部分局部化，即局限于某些程序模块等。</li></ul></li></ol></li><li><mark style="background: #FF5582A6;">完善性维护</mark><ol><li>在软件的使用过程中，用户往往会对软件提出新的功能与性能要求；</li><li>为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性；</li><li>这种情况下进行的维护活动叫做完善性维护。</li><li>软件维护的分类：<ul><li>实践表明，在几种维护活动中，<mark style="background: #FF5582A6;">完善性维护所占的比重最大</mark>。即大部分维护工作是改变和加强软件，而不是纠错；</li><li>完善性维护不一定是救火式的紧急维修，而可以是有计划、有预谋的一种再开发活动；</li><li>完善性维护中的主要维护策略<ol><li>尽量采用功能强，使用方便的工具，采用原型化的开发方法等。</li></ol></li></ul></li></ol></li><li><mark style="background: #FF5582A6;">预防性维护</mark><ol><li>是为了改进未来的可维护性或可靠性，或为了给未来的改进奠定更好的基础而修改软件；</li><li>也可以定义为： “把今天的方法学用于昨天的系统以满足明天的需要” 。即该类维护工作需要采用先进的软件工程方法，对需要维护的软件或软件中的某一部分（重新）进行设计、编码和测试；</li><li>预防性维护中的主要维护策略<ul><li>采用提前实现，软件重用等技术。</li></ul></li></ol></li></ul></li><li>软件维护工作有以下特点：<ul><li>软件维护是软件生存周期中延续时间最长、工作量最大的一个阶段；</li><li>软件维护不仅工作量大、任务重，而且维护不当的话， 还会产生一些意想不到的副作用，甚至引起新的错误；</li><li>软件维护活动实际上是一个修改和简化了的软件开发活动；</li><li>尽管软件维护需要的工作量很大，但是长期以来，软件维护工作却一直未受到软件设计者们的足够重视。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.2 软件维护的过程</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.2-ruan-jian-wei-hu-de-guo-cheng/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/8-ruan-jian-wei-hu/8.2-ruan-jian-wei-hu-de-guo-cheng/</url>
      
        <content type="html"><![CDATA[<ul><li>软件维护是一件复杂而困难的事情，必须在相应的技术指导下，按照一定的步骤进行。</li><li>一般地，软件维护活动首先要建立一个维护组织，然后建立维护活动的登记、申请制度及对维护方案的审批制度， 规定复审的评价标准。</li><li>结构化维护与非结构化维护<ol><li><mark style="background: #FF5582A6;">结构化维护</mark>——指软件开发过程是按照软件工程 方法进行的，开发各阶段的文档齐全，软件的维 护过程，有一整套完整的方案、技术、审定过程 及文档。因此易于维护。</li><li><mark style="background: #FF5582A6;">非结构化维护</mark>——软件配置的惟一成分是程序代码, 缺乏必要的文档说明，文档缺少或者不一致，难 于确定数据结构、系统接口等特性，这样的维护 工作令人生畏，事倍功半。因此非结构化维护需 要付出很大代价。</li></ol></li><li>软件维护的特点<ol><li>![[Pasted image 20230626174254.png]]</li><li>维护组织 <ul><li>对于大型软件系统，建立一个专门的维护组织机构是必须的。较小的软件系统，也有必要委派一 个专人负责软件维护工作</li><li>在维护活动开始之前，必须明确维护活动的审批制度。每个维护要求都要通过维护管理员转交给系统管理员去评价。系统管理员对维护申请做出评价后，由主管部门决定是否进行软件修改。维护小组在接到通过审批的维护申请报告后，将维护任务下达给指定的维护人员，并监控维护活动的开展。</li><li>![[Pasted image 20230626195248.png]]</li></ul></li><li>维护工作的流程<ul><li>软件维护过程是：建立维护机构→编写软件维护申请报告→确定软件维护工作流程→整理软件维护文档→评价软件维护性能；</li><li>一个典型的维护机构包括：维护管理员、修改批准人员、系统管理员、配置管理员和维护人员。</li><li>维护申请报告将由维护管理员和系统管理员共同研究和处理，相应地做出软件变更报告（Software Change Report, SCR）。SCR 的内容包括：所需修改变动的性质；申请修改的优先级；为满足该维护申请报告所需的工作量（人员数 、时间数等）；预计修改后的结果等。</li><li>具体执行软件维护工作时，主要的步骤包括：<ol><li>确认维护类型</li><li>实施相应维护</li><li>维护评审</li></ol></li><li>整理软件维护文档</li><li>评价软件维护性能</li></ul></li><li>维护工作的组织管理<ul><li>软件维护工作的复杂性决定了软件维护不仅需要技术性工作，还需要大量的管理工作与之相配合，才能保证维护工作的质量和效率。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本章引言</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/ben-zhang-yin-yan/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/ben-zhang-yin-yan/</url>
      
        <content type="html"><![CDATA[<ul><li>在软件开发的一系列活动中，为了保证软件的可靠性，人们研究并使用了很多方法进行分析、设计及编码实现。但是由于软件产品本身是无形的、复杂的、知识密集的逻辑产品，其中难免有各种各样的错误，因此需要通过测试查找错误，保证软件的质量。<mark style="background: #FF5582A6;">软件测试是保证软件质量的关键，它是对需求分析、设计和编码的最终复审。</mark></li><li>软件测试<ol><li>保证软件质量的关键，它是对需求分析、设计和编码的最终复审。</li><li>检测和评价软件以确定其质量的过程和方法，即评价软件或程序的属性和能力，以确定它是否满足所需结果的过程与方法。</li></ol></li><li>软件测试的现状<ol><li>软件开发中出现错误或缺陷的机会越来越多，市场对软件质量重要性的认识逐渐增强。软件测试在软件项目实施过程中的重要性日益突出。</li></ol></li><li>软件测试的前景<ol><li>随着软件产业的发展，软件产品的质量控制与质量管理正逐渐成为软件企业生存与发展的核心。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.7 软件测试阶段终止的条件</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.7-ruan-jian-ce-shi-jie-duan-zhong-zhi-de-tiao-jian/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.7-ruan-jian-ce-shi-jie-duan-zhong-zhi-de-tiao-jian/</url>
      
        <content type="html"><![CDATA[<ul><li>以上所介绍的测试方法都不可能做到彻底测试，不可能彻底 发现程序的所有错误。既然如此，测试应该进行到什么程 度才能终止，因为测试过少，程序遗留错误较多，质量无 法保证；测试过多，软件开发成本会不必要的增加。</li><li>因此有必要制定测试终止的条件<ol><li>根据程序的可靠性制定测试的终止条件；</li><li>测试的覆盖率要达到一定的目标；</li><li>规定至少要查出的错误数量。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 调试</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.6-diao-shi/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.6-diao-shi/</url>
      
        <content type="html"><![CDATA[<ul><li>调试是在测试发现错误之后排除错误的过程。调试也称为纠错，是在测试发现错误之后<mark style="background: #FF5582A6;">确定错误的位置</mark>并<mark style="background: #FF5582A6;">加以排除</mark>的过程。</li><li>在进行调试工作之前，首先要发现存在着某种错误的迹象。随后的调试过程通常分为两步：<ol><li>确定问题的性质并且找到该错误在软件总所处的位置；</li><li>修正这一错误。</li></ol></li><li>测试和调试往往是紧密联系在一起的。</li><li>目前调试它在很大程度上仍然是一项技巧。软件工程师在评估测试结果时，往往仅面对着软件错误的症状，而软件错误的外部表现和它的内在原因之间可能并没有明显的联系。调试就是把症状和原因联系起来。</li><li>调试的目的和任务<ol><li>软件测试的目的是为找出软件中存在的错误，即通过测试来发现错误，而<mark style="background: #FF5582A6;">调试的目的</mark>是为了解决存在的错误，即对错误定位、分析并找出原因改正错误，因此调试也称为纠错。</li><li>软件调试是一项具有很强技巧性的工作，软件测试结束以后，测试人员在分析结果时，只能看到程序错误的外部表现，而错误的内部原因与错误的外部表现没有明显的关系， 要确定发生错误的内在原因和位置是一件很不容易的事情。</li><li>调试是一个通过外部表现找出原因的思维分析过程。调试工作同人的心理因素和技术因素都有关系，需要很强的脑力劳动和丰富的实践经验。调试相对测试来讲，缺乏系统的理论研究。</li></ol></li><li>常用调试技术<ol><li>简单的调试技术<ul><li>使计算机将存储器的全部内容，通过打印机打印出来。 然后通过逐个数据进行查找，从中寻找确定错误位置；</li><li>在程序特定部位插入打印语句，其方法的优点是显示程序的动态过程，比较容易检查源程序的有关信息；</li><li>使用自动调试工具来分析程序的动态行为，纠正错误。</li></ul></li><li>消去原因法<ul><li>通过思考，分析列出发生错误的所有可能原因，逐个排除，最后找出真正的原因。试探法、折半查找法、归纳法和演绎法都属于消去原因法。</li></ul></li><li><mark style="background: #FF5582A6;">归纳法</mark>：是从特殊到一般，即从个别现象推断出一般性结论的思维方法。人们从一些线索（错误迹象，征兆）入手，寻找分析它们之间的联系，导出错误原因的假设，然后再证明或否定这个假设。常常可以确定错误的位置并纠正。归纳法纠错流程如图：<br> ![[Pasted image 20230625214652.png]]</li><li><mark style="background: #FF5582A6;">演绎法</mark>：从一般到特殊，是一种从一般原理或前提出发，运用排除和推理过程做出结论。演绎法首先列出所有可能的原因和假设，然后排除一个又一个不可能的原因，直到最后剩下一个真正的原因为止。 演绎法纠错流程如图：<br> ![[Pasted image 20230625214727.png]]</li><li><mark style="background: #FF5582A6;">分析</mark>：归纳法和演绎法用得比较多。另外，对于小程序一般常用<mark style="background: #FF5582A6;">回溯法</mark>来纠错比较有效。这种方法从发现错误征兆的地方开始，人工地往回追溯源程序代码，直到找到错误的原因为止。但是，如果回溯的路径数目变得很大，回溯会变得比较困难，以致无法管理。</li></ol></li><li>软件测试和软件调试的区别<ol><li>软件调试：发现所编写软件中的错误，确定错误的位置并加以排除，使之能由计算机或相关软件正确理解与执行的方法与过程。</li><li>在进行调试工作以前，首先要发现存在着某种错误的迹象。随后的调试过程通常分为两步:<ul><li>确定问题的性质并且找到该错误在软件中所处的位置；</li><li>修正这一错误。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 软件测试用例的设计</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.4-ruan-jian-ce-shi-yong-li-de-she-ji/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.4-ruan-jian-ce-shi-yong-li-de-she-ji/</url>
      
        <content type="html"><![CDATA[<ul><li>测试用例的<mark style="background: #FF5582A6;">目的</mark>：<ol><li>确定一组最有可能发现某个错误或某类错误的测试数据。</li></ol></li><li>测试用例的不足：<ol><li>不可能测试程序的每条路径，也不能把所有数据都试一遍， 设计人员必须努力以最少量的测试用例来发现最大量的可能错误。</li></ol></li><li>测试用例的两种技术：<ol><li>黑盒技术：着重测试<mark style="background: #FF5582A6;">软件功能</mark>。</li><li>白盒技术：是以程序的<mark style="background: #FF5582A6;">内部逻辑结构</mark>为基础设计测试用例，被检测的对象是源程序。</li></ol></li><li>黑盒技术：着重测试软件<mark style="background: #FF5582A6;">功能</mark>，设计测试用例时，需要研究需求说明和总体设计说明中的有关程序功能或输入、输出之间的关系等信息，从而与测 试后的结果进行分析比较。<ol><li>测试人员将程序看成是一个“黑盒”，不深入代码细节的测试方法称为动态黑盒测试。</li><li>黑盒法是把测试对象看作一个黑盒，测试时完全不考虑程序的内部的逻辑结构与内部特性，只需根据<mark style="background: #FF5582A6;">需求规格说明书</mark>，测试程序的<mark style="background: #FF5582A6;">功能</mark>或程序的<mark style="background: #FF5582A6;">外部特性</mark>。<mark style="background: #FF5582A6;">即不关心程序内部是什么，只要检查程序是否符合它的“功能说明”</mark>。因此黑盒法又称为功能测试或数据驱动测试。</li><li>黑盒法特点：<ul><li>应用黑盒法时，手头只需有程序的功能说明书就够了。</li><li>使用白盒法设计测试用例时，只需要选择一个覆 盖标准，而使用黑盒法进行测试，则应该同时使用 多种黑盒测试方法，才能得到较好的测试效果。</li><li>黑盒测试着重测试软件功能。但黑盒测试并不能取代白盒测试，它是与白盒测试互补的测试方法，它很可能发现白盒测试不易发现的其他类型的错误；</li><li>黑盒测试力图发现下述类型的错误：<ol><li>功能不正确或遗漏了功能</li><li>界面错误</li><li>数据结构错误或外部数据库访问错误</li><li>性能错误</li><li>初始化和终止错误</li></ol></li></ul></li><li>设计黑盒测试方案时，应该考虑下述问题：<ul><li>怎样测试功能的有效性？</li><li>哪些类型的输入可构成好测试用例？</li><li>系统是否对特定的输入值特别敏感？</li><li>怎样划定数据类的边界？</li><li>系统能够承受什么样的数据率和数据量？</li><li>数据的特定组合将对系统运行产生什么影响？</li></ul></li><li>常用的黑盒测试方法有三种：<ul><li>等价分类法<ol><li>等价类划分：把程序的输入域划分成若干个数据类，然后从每一等价类中选择出<mark style="background: #FF5582A6;">少数有代表性的数据做为测试用例</mark>，据此导出测试用例。一个理想的测试用例能独自发现一类错误。</li><li>穷尽的黑盒测试（即用所有有效的和无效的输入数据来测试程序）通常是不现实的。因此，只能选取少量最有代表性的输入数据作为测试数据，以期用较小的代价暴露出较多的程序错误。</li><li>步骤：<mark style="background: #FF5582A6;">划分等价类</mark>（列出等价类表）和<mark style="background: #FF5582A6;">选取测试用例</mark>。<ul><li>第一步：划分等价类<ol><li>等价类是指某个输入域的子集合。在该子集合中，<mark style="background: #FF5582A6;">各个输入数据对于揭露程序中的错误都是等效的</mark>。测试某等价类的代表值就等价于对这一类其它值的测试。</li><li>等价类的划分有两种不同的情况：<ul><li><mark style="background: #FF5582A6;">有效等价类</mark>：是指对于程序的规格说明来说 ，是合理的，有意义的输入数据构成的集合。</li><li><mark style="background: #FF5582A6;">无效等价类</mark>：是指对于程序的规格说明来说 ，是不合理的，无意义的输入数据构成的集合 。</li></ul></li><li>在设计测试用例时，要同时考虑有效等价类和 无效等价类的设计。</li><li>划分等价类的原则：<ul><li>如果规定了输入值的范围，则可划分出一个有效的等价类 ( 输入值在此范围内 ) ，两个无效的等价类 ( 输入值小于最小值或大于最大值 ) ；<br>  如“数据值”是从 1 到 999 ，则<ol><li>有效等价类：大于 1 而小于等于 999 的数</li><li>无效等价类：小于 1 的数；大于 999 的数</li></ol></li><li>如果规定了输入数据的个数，则类似地也可 以划分出一个有效的等价类和两个无效的等价类；<br>  如每个学生可以选修 1 至 3 门课程，则<ol><li>有效等价类：选修 1—3 门课程；</li><li>无效等价类：没有选修课程；超过 3 门课程</li></ol></li><li>如果规定了输入数据必须遵循的规则，则可 以划分出一个有效的等价类 ( 符合规则 ) 和若干个 无效的等价类 ( 从各种不同角度违反规则 ) ；<br>  如职称的输入值可以是助教、讲师、副教授和教 授 4 种 ) ，则<ol><li>有效等价类 : 助教、讲师、副教授和教授 4 种 ;</li><li>无效等价类 : 上述 4 种职称之外的任意值。</li></ol></li></ul></li></ol></li><li>第二步：选择测试用例<ol><li>为每个等价类编号；</li><li>设计一个新的测试用例，使它能包括尽可能多的 尚未被包括的合理等价类；重复做这一步，直至这 些测试用例已包括所有的合理等价类；</li><li>设计一个新的测试用例，使它包括一个尚未被包 括的不合理等价类，重复做这一步，直至测试用例已 包括所有的不合理等价类。</li></ol></li></ul></li></ol></li><li>边值分析法<ol><li>边界值分析也是一种黑盒测试方法，是对等价类划 分方法的补充。</li><li>人们从长期的测试工作经验得知，大量的错误是发 生在输入或输出范围的边界上，而不是在输入范围 的内部。因此针对各种边界情况设计测试用例，可 以查出更多的错误。</li><li>比如，在做三角形计算时，要输入三角形的三个 边长： A 、 B 和 C 。 我们应注意到这三个数值 应当满足：A ＞ 0 、 B ＞ 0 、 C ＞ 0 、 A ＋ B ＞ C 、 A ＋ C ＞ B 、 B ＋ C ＞ A，才 能构成三角形。但如果把六个不等式中的任何一 个大于号“＞”错写成大于等于号“≥”，那就 不能构成三角形。问题恰出现在容易被疏忽的边 界附近。</li><li>使用边界值分析方法设计测试用例，首先应确定 边界情况。应当选取正好等于，刚刚大于，或刚 刚小于边界的值做为测试数据，而不是选取等价 类中的典型值或任意值做为测试数据。</li><li>运用边界值分析法，需要有一定的创造性， 以下几点供使用时参考：<ul><li>如果某个输入条件说明了值的范围，则可选择 一些恰好取到边界值的例子，另外，再编写一些代 表不合理输入数据的例子，它们的值恰好越过边界。<br>  例如：输入值的范围是 -1.0 至 1.0 ，则可选 - 1.0 、 1.0 、 -1.001 和 1.001 等例子。</li><li>如果一个输入条件指出了输入数据的个数，则 为最小个数、最大个数、比最小个数少 1 、比最 大个数多 1 、分别设计例子。<br>  例如：一个输入文件可以有 1 ～ 255 个记录， 则分别设计有 0 个、 1 个、 255 个和 256 个记录的输入文件。</li><li>如果程序的输入和输出是有序集合 ( 如顺序文 件、线性表等 ) ，则应特别注意集合的第一个或最 后一个元素</li><li>注意：等价分类法与边界值分析法的主要差别在于 后者是着重检查等价类边界上的情况。</li></ul></li></ol></li><li>错误推测法<ol><li>靠经验和直觉推测程序中可能存在的各种错 误，从而有针对性地编写检查这些错误的测试 用例。这就是错误推测法。</li><li>错误推测法的基本想法是：列举出程序中所有 可能有的错误和容易发生错误的特殊情况，根 据它们选择测试用例。</li><li>错误推测法的特点：没有确定的步骤，很大程度上 是凭经验进行的。例如输入数据为零或输出数据为 零是容易发生错误的情况，所以可选择输入值为零 的例子，以及使输出值为零的例子；又如输入表格 为“空”或输入表格只有一行是较易出错误的情况 ，所以可选择表示这些情况的例子。</li><li>错误推测法是一种简单易行的黑盒法，但由于 该方法有较大的随意性，主要依赖于测试者的经验， 因此通常作为一种辅助的黑盒测试方法。</li></ol></li></ul></li></ol></li><li>白盒技术：以<mark style="background: #FF5582A6;">程序的结构</mark>为依据，被测对象基本上是源程序，以程序的内部逻辑结构为基础设计测试用例。<ol><li>白盒法又称为逻辑覆盖法，是一种以程序（模块）内部的逻辑结构为基础来设计测试用例的方法，对程序所有逻辑路径进行测试。它主要用于<mark style="background: #FF5582A6;">单元测试</mark>。</li><li>白盒法的特点：<ul><li>需了解程序内部的结构；</li><li>测试用例是根据程序的内部逻辑来设计的；</li><li>如果想用白盒法发现程序中所有的错误，则至少必须使程序中每种可能的路径都执行一次；</li><li>应用白盒法时，需要有程序的<mark style="background: #FF5582A6;">功能说明书</mark>和<mark style="background: #FF5582A6;">程序清单</mark>。</li></ul></li><li>软件人员使用白盒测试方法，主要想对程序模块进行如下的检查：<ul><li>对程序模块的所有独立的执行路径至少测试一次；</li><li>对所有的逻辑判定，取“真”与取“假”的两种情况都至少测试一次；</li><li>在循环的边界和运行界限内执行循环体；</li><li>测试内部数据结构的有效性等。</li></ul></li><li>白盒的测试以程序的结构为依据，所以又称为结构测试。</li><li>早期的白盒的测试把注意力放在<mark style="background: #FF5582A6;">流程图的各个判定框</mark>上，使用不同的逻辑覆盖标准来表达对程序测试的详尽程度。</li><li>随着测试技术的发展，人们越来越重视测试对程序的<mark style="background: #FF5582A6;">执行路径</mark>的考察，并且用流图代替流程图来设计测试用例。</li><li>为了区分这两种白盒测试技术，把前者称为逻辑覆盖测试，后者称为路径测试。<ul><li>逻辑覆盖测试法<ol><li>逻辑覆盖测试法用流程图来设计测试，它考察的重点是图中的判定框（菱形框）。因为这些判定若不是与选择有关，就是与循环结构有关。是决定程序结构的关键成分。</li><li>按照对被测程序所作测试的有效程度，逻辑覆盖测试可由弱到强区分为 5 种覆盖标准，如下图所示：<ul><li>![[Pasted image 20230624155451.png]]<ol><li>语句覆盖<ul><li>语句覆盖选择足够的测试用例，运行被测程序，使得程序中<mark style="background: #FF5582A6;">每个语句</mark>至少都能被执行一次。 “语句覆盖”是一个<mark style="background: #FF5582A6;">比较弱的测试标准</mark>。</li><li>语句覆盖只关心判定表达式的值，而没有分别测试当判定表达式中每个条件取不同值的情况。显然当 条件有错误发现不了，因此，语句覆盖是很弱的逻辑覆盖。</li></ul></li><li>判定覆盖（分支覆盖）<ul><li>判定覆盖又叫分支覆盖，它的含义是，不仅<mark style="background: #FF5582A6;">每个语句</mark>必须至少执行一次，而且<mark style="background: #FF5582A6;">每个判定的每种可能</mark>的结果都应该至少执行 一次，也就是<mark style="background: #FF5582A6;">每个判定的每个分支</mark>都至少执行一次。</li><li>判定覆盖只关心整个判定表达式的值，而判定表达式中的各个条件可能的值并没有考虑到。</li></ul></li><li>条件覆盖<ul><li>条件覆盖的含义是，<mark style="background: #FF5582A6;">使判定表达式中的每个条件都取到各种可能的结果</mark>（真或假）。</li><li>条件覆盖通常比判定覆盖强，因为它使判定表达式中每个条件都取到了两个不同的结果，判定覆盖却只关心整个判定表达式的值。</li><li>有时候满足条件覆盖标准的测试用例，并不一定满 足判定覆盖标准，有些判定总是为真或为假。</li></ul></li><li>判定 &#x2F; 条件覆盖<ul><li>判定 &#x2F; 条件覆盖能同时满足<mark style="background: #FF5582A6;">判定覆盖</mark>和<mark style="background: #FF5582A6;">条件覆盖</mark>两种覆盖的标准。它的含义是，选取足够多的测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果</li><li>“ 判定／条件覆盖”似乎是比较合理的，但事实并非如此，因为大多数计算机不能用一条指令对多个条 件作出判定，而必须将源程序中对多个条件的判定分解成几个简单判定。</li><li>判定 &#x2F; 条件覆盖每一个条件的每种可能没有<mark style="background: #FF5582A6;">真正获得执行的机会</mark>。</li></ul></li><li>条件组合覆盖（路径覆盖）<ul><li>含义是选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。</li><li>条件组合覆盖所测试的情况最多，但是选择用例较多。相对难度也大些。</li><li>满足条件组合覆盖标准的测试数据 ，也一定满足判定覆盖、条件覆盖和判定 &#x2F; 条件覆盖标准。因此，条件组合覆盖是前述几种覆盖标准中最强的。但是，满足条件组合覆盖标准的测试数据并不一定能使程序中的每条路径都执行到。所以我们还需要用其他的测试方法 ( 如黑盒法 ) 作补充。</li></ul></li></ol></li></ul></li></ol></li></ul></li></ol></li><li>黑盒测试与白盒测试比较<ol><li>黑盒测试是从用户观点，按规格说明书要 求的输入数据与输出数据的对应关系设计测试 用例 , 是根据程序外部特征进行测试。</li><li>白盒测试是根据程序内部逻辑结构进行测试。</li><li>黑盒测试与白盒测试优缺点比较<br> ![[Pasted image 20230625161103.png]]</li><li>黑盒测试与白盒测试<ul><li>不论黑盒还是白盒测试都不能进行穷尽测试 , 所以软件测试不可能发现程序中存在的所有错误 , 因此需精心设计测试方案 , 力争尽可能少的次数 , 测出尽可能多的错误</li></ul></li><li>黑盒测试与白盒测试能发现的错误<br> ![[Pasted image 20230625161152.png]]</li><li>综合测试策略：<ul><li>白盒法和黑盒法各有长处和短处，每种方法 都可提供一组有用的测试用例，这组测试用例容易 发现某种类型的错误，但不易发现其他类型的错误 ，然而没有一种方法能提供一组“完整的”测试用 例。因此，实际软件测试方案设计是不同方法的综 合应用。</li><li>在任何情况下首选边界值分析的方法 ( 这个方法 应对输入和输出的边界值进行析 );</li><li>必要时用等价类划分方法补充测试用例 ;</li><li>必要时再用错误推测法附加测试用例</li><li>检查上述已经设计出的测试方案 , 若未能满足某 些覆盖标准 , 则利用逻辑覆盖补充足够的测试用例</li><li>一般要求语句覆盖程度到达 100%, 判定覆盖达到 90%.</li></ul></li></ol></li><li>循环测试<ol><li>除了选择结构外，循环也是程序的主要逻辑结构， 要覆盖含有循环结构的所有路径是不可能的，但可通过控制循环次数来测试。</li><li>在结构化的程序中通常有 3 种循环类型：简单循环、串接循环、嵌套循环。<ul><li>简单循环<ol><li>![[Pasted image 20230624181955.png]]</li><li>可采用下列测试集来测试简单循环：<ul><li>零次循环：从循环入口到出口</li><li>一次循环：检查循环初始值</li><li>m 次循环：检查在多次循环</li><li>最大次数循环、比最大次数多一 次、少一次的循环。</li></ul></li></ol></li><li>串接循环<ol><li>![[Pasted image 20230624182057.png]]</li><li>如果各个循环互相独立，则可以用与简单循环相同的方法进行测试。但如果几个循环不是互相独立的，则需要使用测试嵌套循环的办法来处理。</li></ol></li><li>嵌套循环<ol><li>![[Pasted image 20230624182051.png]]</li><li>对最内层循环做简单循环的全部测试。所有其它层的循环变量置为最小值；</li><li>逐步外推，对其外面一层循环进行测试。测试时保持所有外层循环的循环变量取最小值，所有其它嵌套内层循环的循环变量取“典型”值；</li><li>反复进行，直到所有各层循环测试完毕；</li><li>对全部各层循环同时取最小循环次数，或者同时 取最大循环次数。</li></ol></li></ul></li></ol></li><li>基本路径测试（了解）<ol><li>逻辑覆盖测试引导人们把注意力集中在程序的各个判定部分，抓住了程序测试的重点，但是另一方面，它却忽略了另一个对测试也有重要影响的方面——程序的执行路径。随着程序结构复杂性的增长和测试技术的发展，人们逐渐认识到这种忽略所带来的缺陷。于是路径测试方法便应运而生。</li><li>基本路径测试是在程序控制流程图的基础上，通过分析控制结构的环路复杂性，导出基本可执行路径集合，从而设计测试用例。设计出的测试用例保证这些路径至少通过一次。</li><li>覆盖<ul><li>点覆盖<ol><li>定义：如果连通图 G 的子图 G′ 是连通的，而且包含 G 的所有结点，则称 G′ 是 G 的点覆盖。</li><li>点覆盖是选取足够多的测试数据，使得程序执行路径至少经过流图的每个结点一次，由于流图的每个结点与一条或多条语句相对应，显然，点覆盖标准和语句覆盖标准是相同的。</li></ol></li><li>边覆盖<ol><li>定义：边覆盖的定义是：如果连通图 G 的子图 G″ 是连通的，而且包含 G 的所有边，则称 G″ 是 G 的边覆盖。 为了满足边覆盖的测试标准，要求选取足够多测试 数据，使得程序执行路径至少经过流图中每条边一次。通常边覆盖和判定覆盖是一致的。</li></ol></li><li>路径覆盖<ol><li>含义：路径覆盖的含义是，选取足够多测试数据，使程序的每条可能路径都至少执行一次 (如果程序图中有环，则要求每个环至少经过一次) 。</li></ol></li></ul></li><li>使用基本路径测试技术设计测试用例的步骤如下：<ul><li>根据详细设计结果或源程序画出相应的程序图（也称为流图）；</li><li>计算程序图 G 的环形复杂度 V(G) 。环形复 杂度定量度量程序的逻辑复杂性；</li><li>确定线性独立路径的基本集合；</li><li>导出测试用例；</li><li>准备测试用例，确保基本路径集中的每一 条路径的执行。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 软件测试过程</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.5-ruan-jian-ce-shi-guo-cheng/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.5-ruan-jian-ce-shi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<ul><li>在软件测试过程中需要 3 类信息：<ol><li>软件配置：指需求说明书、设计说明书和源程序等；</li><li>测试配置：指测试方案、测试用例和测试驱动程序等；</li><li>测试工具：指计算机辅助测试的有关工具。</li></ol></li><li>软件产品在交付使用之前一般要经过<mark style="background: #FF5582A6;">单元测试</mark>、<mark style="background: #FF5582A6;">集成测试</mark>、 <mark style="background: #FF5582A6;">确认测试</mark>和<mark style="background: #FF5582A6;">系统测试</mark> 4 个阶段的测试。<br>  ![[Pasted image 20230625205159.png]]</li><li>单元测试：<ol><li>对软件基本组成单元进行的测试；</li><li>所发现的是编码和详细设计中的错误；  </li><li>单元测试集中检测软件设计的<mark style="background: #FF5582A6;">最小单元</mark>——模块。<ul><li>模块应该是有明确的功能、性能定义、接口定义，而且可以清晰地与其他单位区分开。</li></ul></li><li>在编写出源程序代码并通过编译程序的语法检查后，用详细设计说明书作指南，对重要的<mark style="background: #FF5582A6;">执行通路</mark>进行测试，以便发现模块内部的错误。</li><li>可以应用<mark style="background: #FF5582A6;">人工测试</mark>和<mark style="background: #FF5582A6;">计算机测试</mark>两种测试方法来进行单元测试。</li><li>通常，单元测试主要使用<mark style="background: #FF5582A6;">白盒测试技术</mark>，而且多个模块可以并行地进行测试。</li><li>测试内容：<ul><li><mark style="background: #FF5582A6;">模块接口</mark>：I&#x2F;O 参数值的个数、类型 、次序、格式是否正确， I&#x2F;O 文件属性、操作是否正确等。<ol><li>首先应该对通过模块接口的数据流进行测试，如果数据不能正确地进出，所有其他测试都是不切实际的。</li><li>在对模块接口进行测试时主要检查下述几个方面：<ul><li>参数的数目、次序、属性或单位系统与变元是否一致 ；</li><li>是否修改了只作输入用的变元；</li><li>全局变量的定义和用法在各个模块中是否一致</li></ul></li></ol></li><li><mark style="background: #FF5582A6;">局部数据结构</mark>：数据说明是否正确、一 致，变量及其初值定义是否正确等。<ol><li>局部数据结构是模块常见的错误来源。常见的错误如下 :<ul><li>不正确或不一致的数据说明 ;</li><li>错误的初始化或没有赋处值 ;</li><li>变量名的<mark style="background: #FF5582A6;">拼写</mark>或<mark style="background: #FF5582A6;">缩写</mark>错误；</li><li>数据类型不相容；</li><li>上溢、下溢和地址异常</li></ul></li></ol></li><li><mark style="background: #FF5582A6;">重要的执行通路</mark>：重要路径通常是指完成模块功能的主要路径，一般是控制结构。<ol><li>由于通常不可能进行穷尽测试，因此，在进行单元测试时 , 关键是选择最有代表性、最可能发现错误的执行通路。</li><li>应该设计测试方案用来发现由于错误的计算、不正确的比 较或不适当的控制流而造成的错误。</li></ol></li><li><mark style="background: #FF5582A6;">出错处理通路</mark>：检查“错误处理程序”本身的错误。<ol><li>好的设计应该能预见出现错误的条件，并且设置适当的处 理错误的通路，以便在真的出现错误时执行相应的出错处理 通路或结束处理。</li><li>当评价出错处理通路时，应该着重测试下述一些可能发生 的错误：<ul><li>对错误的描述是难以理解的；</li><li>记下的错误与实际遇到的错误不同；</li><li>在对错误进行处理之前，错误条件已经引起系统干 预；</li><li>对错误的处理不正确；</li><li>描述错误的信息难以确定造成错误的位置。</li></ul></li></ol></li><li><mark style="background: #FF5582A6;">边界条件</mark>：边界条件常包括循环边界，最大最小值、控制流中等于、大于、小于的比较值等。<ol><li>边界测试是单元测试中<mark style="background: #FF5582A6;">最后且最重要的一步</mark>。</li><li>软件常常在它的边界上失效，例如，处理 n 元数组的第 n 个元素时，或做到 i 次循环中的第 i 次重复时，往往会发生错误。使用刚好小于、刚好等于和刚好大于最大值或最小值的数据结构、控制量和数据值的测试方案，非常可能发现软件中的错误。</li></ol></li></ul></li><li>测试方法：<ul><li>代码审查（静态分析）<ol><li>代码审查也称为人工测试，既可以由编写者自己来完成也可由审查小组来完成。后者对单元测试很有效，可以查出 30% ～ 70% 的逻辑设计错误和编码错误。审查小组最好由下述 4 人组成：<ul><li>组长</li><li>程序的设计者</li><li>程序的编写者</li><li>程序的测试者</li></ul></li></ol></li><li>计算机测试（动态测试）<ol><li>每一个被测试的单元 ( 模块 ) 并不是一个独立的程序， 模块自己不能单独执行 , 必须依靠其他模块来驱动。所以要为被测试的模块设计一些辅助性的模块，我们把他们称为<mark style="background: #FF5582A6;">驱动模块</mark>和 ( 或 ) <mark style="background: #FF5582A6;">存根模块</mark>。</li><li>驱动模块和存根模块需要编写程序，也就是说，使用计算机进行单元测试必须编写测试软件。<ul><li>驱动模块：是一个“<mark style="background: #FF5582A6;">主程序</mark>”，用来模拟测试模块的调用模块，它接收测试数据，把这些数据传送给被测试的模块，最后输出测试模块产生数据。</li><li>存根模块：作用是<mark style="background: #FF5582A6;">模拟被测试</mark>的<mark style="background: #FF5582A6;">模块的下属模块</mark>。因此也可以称为“<mark style="background: #FF5582A6;">虚拟子程序</mark>”。</li><li>![[Pasted image 20230625211223.png]]</li></ul></li></ol></li></ul></li></ol></li><li>集成测试：<ol><li>将已分别通过测试的单元按设计要求组合起来再进行测试</li><li>发现的是软件设计中的错误</li><li>也可能发现需求中的错误</li><li>集成测试：在装配的过程中对组装的模块进行测试 , 主要目标是<mark style="background: #FF5582A6;">发现与接口有关的问题</mark>。它包括<mark style="background: #FF5582A6;">子系统测试</mark>和<mark style="background: #FF5582A6;">系统测试</mark>两个过程。测试的技术有两种：<ul><li><mark style="background: #FF5582A6;">非渐增式测试技术</mark>：先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序；</li><li><mark style="background: #FF5582A6;">渐增式测试技术</mark>：把下一个要测试的模块同已经测试好的那些模块结合起来进行测试，测试完以后再把下一个应该测试的模块结合进来测试。这种每次增加一个模块的方法称为<mark style="background: #FF5582A6;">渐增式测试</mark>，这种方法实际上同时完成单元测试和集成测试。</li><li>两者的主要优缺点对比：<ol><li>非渐增式测试一下子把所有模块放在一起，把庞大的程序作为一个整体来测试，测试时会遇到许许多多的错误，而且改正错误相当困难；</li><li>渐增式测试把程序划分成小段来构造和测试，在这个过程中<mark style="background: #FF5582A6;">比较容易定位</mark>和<mark style="background: #FF5582A6;">改正错误</mark>；对接口可以进行更彻底的测试；可以使用系统化的测试方法。</li><li>因此，目前在进行集成测试时<mark style="background: #FF5582A6;">普遍采用渐增式测试方法</mark>。渐增方式有两种集成方法：<ul><li>自顶向下集成<ol><li>从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块一一结合起来，从而构成目标系统。在把附属于主控制模块的那些模块组装到程序结构中去时，有两种策略：<ul><li><mark style="background: #FF5582A6;">深度优先的策略</mark><ol><li>深度优先的结合方 法，先把软件结构的一条主 控制通路上的所有模块都结 合组装起来。然后再结合组 装中央或右侧的控制路径， 直到所有模块都被结合进去 为止。其中选择一条主控制 通路取决于应用的特点，并 且有很大任意性。</li><li>![[Pasted image 20230625212019.png]]</li></ol></li><li><mark style="background: #FF5582A6;">广度优先的策略</mark><ol><li>宽度优先的结合策略是沿软件结构水平地移动，把处于同一个控制层次上的所有模块组装起来。然后再组 装下一个控制层次中所有模块，如此进行下去，直到所有模块都被结合进软件结构为止。</li><li>![[Pasted image 20230625212114.png]]</li></ol></li></ul></li><li>自顶向下集成过程：<ul><li>第一步，用主控程序作为测试驱动模块，用存根程序代替所有<mark style="background: #FF5582A6;">下属</mark>于主控制模块的模块；</li><li>第二步，选择一种结合策略（深度优先或宽度优先），每次用一个实际模块代换一个存根程序；</li><li>第三步，每结合一个模块，就进行相应测试；</li><li>第四步，为了保证不引入新的错误，可以进行回归测试（全部或部分地重复以前做过的测试）；</li><li>从第二步开始不断地重复进行上述过程，直到构造起完整的软件结构为止。</li></ul></li></ol></li><li>自底向上集成<ol><li>从软件结构最低层的模块开始进行组装和测试。它不需要存根程序，但需要驱动程序。</li><li>自底向上的结合过程为：<ul><li>第一步，把低层模块组成模块族，以实现某个特定的软件子功能；</li><li>第二步，为每个族写一个驱动程序，作为测试控制，用来协调测试数据的输入和输出；</li><li>第三步，对由模块组成的子功能族进行测试；</li><li>第四步，去掉驱动程序，沿软件结构自下向上移动，把子功能族组合起来形成更大的子功能族；</li><li>上述第二步到第四步实质上构成了一个循环。</li><li>![[Pasted image 20230625212915.png]]</li></ul></li></ol></li><li>不同集成测试策略的比较<ol><li>自顶向下集成测试方法：<ul><li>优点：<ol><li><mark style="background: #FF5582A6;">不需要驱动程序</mark>；</li><li>能够在测试阶段的早期实现并验证系统的主要功能；</li><li>能在早期发现上层模块的接口错误。</li></ol></li><li>缺点：<ol><li>需要存根程序 , 可能遇到与此相联系的测试困难；</li><li>低层关键模块中的<mark style="background: #FF5582A6;">错误发现较晚</mark>；</li><li>在早期不能充分展开人力</li></ol></li><li>而自底向上测试方法的优缺点与上述自顶向下测试方法的优 缺点刚好相反。</li></ul></li><li>自底向上集成测试方法：<ul><li>优点：<ol><li>不需存根驱动；</li><li>测试用例的设计比自顶向下集成测试方法容易。</li></ol></li><li>缺点：<ol><li>需要程序驱动；</li><li>直到把最后一个模块结合进来之前，程序作为一 个整体始终不存在。</li></ol></li></ul></li><li>总结：<br>  - 在测试实际的软件系统时，应该根据软件的特点以及工程进度安排，选用适当的测试策略。一般说来，纯粹自顶向下或纯粹自底向上的策略可能都不实用，人们在实践中创造出许多<mark style="background: #FF5582A6;">混合策略</mark>：<ol><li>改进的自顶向下测试方法。基本上使用自顶向下的测试方法，但是在早期使用<mark style="background: #FF5582A6;">自底向上</mark>的方法测试软件中的少数关键模块。优点能在测试的早期发现关键模块中的错误；但是缺点也比自顶向下方法多一条，即测试关键模块时需要<mark style="background: #FF5582A6;">驱动程序</mark>；</li><li>混合法。自顶向下方法和自底向上方法相结合。对软件结构中较上层使用的自顶向下方法 , 对软件结构中<mark style="background: #FF5582A6;">较下层</mark>使用的<mark style="background: #FF5582A6;">自底向上方法</mark>。这种方法兼有两种方法的优点和缺点，当被测试的软件中关键模块比较多时，这种混合法可能是最好的折衷方法。</li></ol></li></ol></li></ul></li></ol></li></ul></li></ol></li><li>确认测试：<ol><li>检查所开发的软件是否满足需求规格说明书中所确定的功能和性能的需求</li><li>发现的是需求分析阶段的错误</li><li>确认测试（validation testing），又称为有效性测试或验收测试。<mark style="background: #FF5582A6;">目标</mark>是验证软件的<mark style="background: #FF5582A6;">有效性</mark>。</li><li>其任务是验证系统的功能、性能等特性是否符合需求规格说明；文档资料是否正确、完整；系统的可移植性、兼容性、错误的恢复能力和易维护性是否满足。</li><li>确认测试步骤<ul><li>![[Pasted image 20230625213718.png]]</li><li><mark style="background: #FF5582A6;">有效性测试</mark><ol><li>确认测试对已测试过的纯技术性的问题不再测试，对用户特别感兴趣的<mark style="background: #FF5582A6;">功能和性能</mark>需要增加测试。按照用户的实际使用过程，使用<mark style="background: #FF5582A6;">实际数据</mark>进行测试。确认测试是以<mark style="background: #FF5582A6;">用户</mark>为主进行的，用户参与设计测试方案，参与实地测试，参与评价测试结果。确认测试属于<mark style="background: #FF5582A6;">黑盒测试</mark>。</li><li>确认测试有下述两种可能的结果：<ul><li>功能和性能与用户要求一致，软件是可以接受的；</li><li>功能和性能与用户要求有差距。</li></ul></li></ol></li><li><mark style="background: #FF5582A6;">软件配置报告</mark><ol><li>复查软件配置是确认测试的一个重要内容。复查的目的是保证软件配置的所有成分都齐全，质量符合要求，文档与程序完全一致，具有完成软件维护所必须的细节， 而且已经编好目录。</li><li>除了按合同规定的内容和要求，由人工审查软件配置之外，在确认测试过程中还应该严格遵循用户指南及其他操作程序，以便检验这些使用手册的完整性和正确性。 必须仔细记录发现的遗漏或错误，并且适当地补充和改正。</li></ol></li></ul></li></ol></li><li>系统测试<ol><li>系统测试是将经过单元测试、集成测试、确认测试以后的软件，作为计算机系统中的一个组成部分，需要与系统中的硬件、外部设备、支持软件、数据及操作人员结合起来，在实际运行环境下对计算机系统进行一系列的严格有效的测试来发现软件的潜在问题，以保证各组成部分不仅单独的正常运行，而且在系统各部分统一协调下也能正常运行。</li><li><mark style="background: #FF5582A6;">系统测试不同于功能测试</mark>。功能测试主要是验证软件功能是否符合用户需求，并不考虑各种环境及非功能问题，如安全性、可靠性、性能等，而<mark style="background: #FF5582A6;">系统测试是在更大范围内进行的测试，着重对系统的性能、特性进行测试</mark>。</li></ol></li><li>Alpha 和 Beta 测试<ol><li>如果一个软件是为许多客户开发的，那么，让每个客户都进行正式的验收测试是不现实的。在这种情况下，使用 <mark style="background: #FF5582A6;">Alpha</mark> 测试和 <mark style="background: #FF5582A6;">Beta</mark> 测试。<ul><li>Alpha 测试是在<mark style="background: #FF5582A6;">受控的环境</mark>中进行的。它由用户在开发者的场所进行，并且在开发者对用户的“指导”下进行测试。开发者负责记录发现的错误和使用中遇到的问题。</li><li>Beta 测试是软件在开发者<mark style="background: #FF5582A6;">不能控制的环境</mark>中的“真实”应用。Beta 测试由软件的最终用户们在一个或多个客户场所进行。用户定期把在 Beta 测试过程中遇到的一切问题（真实的或想像的）记录下来，并且报告给开发者。开发者接收到在 Beta 测试期间报告的问题之后，对软件产品进行必要的修改，并准备向全体客户发布最终的软件产品。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 软件测试方法及分类</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.3-ruan-jian-ce-shi-fang-fa-ji-fen-lei/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.3-ruan-jian-ce-shi-fang-fa-ji-fen-lei/</url>
      
        <content type="html"><![CDATA[<ul><li>为了便于区分，一般把被测程序在机器上运行称为“动态测试”，不在机器上运行被测程序称为“静态分析”。广义地讲，它们都属于软件测试。因此，软件测试的方法一般分为<mark style="background: #FF5582A6;">动态测试</mark>和<mark style="background: #FF5582A6;">静态测试</mark>。</li><li>动态测试方法中又根据测试用例的设计方法不同，分为<mark style="background: #FF5582A6;">黑盒测试法</mark>和<mark style="background: #FF5582A6;">白盒测试法</mark>两类。</li><li>静态测试与动态测试<ol><li>静态测试<ul><li>定义：指被测程序不在机器上运行，对模块的源代码进行研读，查找错误或收集一些度量数据，采用人工检测和计算机辅助静态分析手段对程序进行检测，只进行特性分析。常用的方法有：<ol><li>人工测试；<ul><li>定义：指不依靠计算机而完全靠人工审查程序或评审软件。该方法偏重于编码风格、编码质量的检验，除了审查编码还要对各阶段的软件产品进行检验，可以有效地发现软件的逻辑设计和编码错误，发现计算机不容易发现的错误。</li><li>人工测试常用的方法包括：<ol><li>桌前检查（ Desk Checking ) 由程序员检查自己的程 序，对源代码进行分析、检验。</li><li>代码会审（ Code Reading Review ) 由程序员和测试员组成评审小组，按照“常见的错误清单”，进行会议讨论检查。</li><li>步行检查 ( Walkthroughs ) 与代码会审类似，也要进行 代码评审，但评审过程主要采取人工执行程序的方式，故也称为“走查”。步行检查是最常用的静态分析方法。</li></ol></li></ul></li><li>计算机辅助静态分析；<ul><li>定义：指利用静态分析工具对被测程序进行特性分析，从程序中提取一些信息，以便检查程序逻辑的各种缺陷和可疑的程序构造。如错误使用全局变量和局部变量，不匹配的参数，循环嵌套和分支嵌套使用不当，潜在的死循环和死语句等。静态分析中还可以用符号代替数值求得程序结果，以便对程序进行运算规律检验。</li></ul></li></ol></li></ul></li><li>动态测试<ul><li>定义：指借助输入样例（测试用例），通过运行程序发现错误。一般所讲的测试大多是指动态测试。</li><li>一般有两种方法：<ol><li>黑盒测试法；<ul><li>定义：也称功能测试或数据驱动测试。它不考虑程序内部结构和处理过程。把被测程序看成一个黑盒子，只在软件接口 处进行测试，依据需求规格说明书，<mark style="background: #FF5582A6;">检查程序是否满足功能要求</mark>。</li><li>如果已经知道了产品应该具有的功能，可以通过测试来检验是否每个功能都能正常使用；</li></ul></li><li>白盒测试法；<ul><li>定义：也称结构测试或逻辑驱动测试。测试人员需了解程序的内部结构和处理过程，以检查处理过程的细节为基础，要求对程序的结构特性做到一定程度的覆盖，对程序中的所有逻辑路径进行测试，并<mark style="background: #FF5582A6;">检验内部控制结构是否有错</mark>，确定实际的运行状态与预期的状态是否一致。</li><li>如果知道产品的内部工作过程，可以通过测试来检验产品内部结构及处理过程是否按照规格说明书的规定正常进行。</li></ul></li><li>黑盒测试和白盒测试都不可能进行穷尽测试。</li></ol></li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1 软件测试的目标</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.1-ruan-jian-ce-shi-de-mu-biao/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.1-ruan-jian-ce-shi-de-mu-biao/</url>
      
        <content type="html"><![CDATA[<ul><li>关于测试及其目标 G.Myers 曾给出了测试以下观点：<ol><li>测试是为了发现程序中的错误而执行程序的过程；</li><li>好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案；</li><li>成功的测试是发现了至今为止尚未发现的错误的测试。</li></ol></li><li>软件测试的<mark style="background: #FF5582A6;">目标</mark>：<ol><li>预防错误</li><li>发现错误</li></ol></li><li>一般只有符合下列 5 个规则才叫软件错误：<ol><li>软件未达到产品说明书标注的功能；</li><li>产品出现了产品说明书指明不会出现的错误；</li><li>软件功能超出产品说明书的范围；</li><li>软件未到达产品说明书虽未指出但应达到的目标；</li><li>软件测试员认为软件难以理解、不易使用、运行速度缓慢，或最终用户认为不好。</li></ol></li><li>测试阶段的<mark style="background: #FF5582A6;">基本任务</mark>是：根据软件开发各阶段的文档资料和程序内部结构，精心设计一组“高产”的<mark style="background: #FF5582A6;">测试用例</mark>，利用这些用例执行程序，找出软件中潜在的各种错误缺陷。</li><li>测试一般不可能发现程序中的所有错误。</li><li>测试只能证明程序中存在错误，但不能证明程序中不存在错误。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 软件测试的原则</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.2-ruan-jian-ce-shi-de-yuan-ze/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/7-ruan-jian-ce-shi/7.2-ruan-jian-ce-shi-de-yuan-ze/</url>
      
        <content type="html"><![CDATA[<ul><li>测试用例既要有<mark style="background: #FF5582A6;">输入数据</mark>，又要有对应的<mark style="background: #FF5582A6;">输出结果</mark>；</li><li>测试用例不仅要选用<mark style="background: #FF5582A6;">合理</mark>的输入数据，还应选择<mark style="background: #FF5582A6;">不合理</mark>的输入数据；</li><li>除了检查程序是否做了它<mark style="background: #FF5582A6;">应该做</mark>的工作，还应该检查程序是否做了它<mark style="background: #FF5582A6;">不应该做</mark>的工作；</li><li>应该远在<mark style="background: #FF5582A6;">测试开始之前</mark>就制定测试计划；</li><li>测试计划、测试用例、测试报告必须作为文档<mark style="background: #FF5582A6;">长期保存</mark>；</li><li>Pareto 原理说明，测试发现的错误中 80% 很可能是由程序中 20% 的模块造成的，即错误出现的“<mark style="background: #FF5582A6;">群集性</mark>”现象；</li><li>为了达到最佳的测试效果，程序员应该<mark style="background: #FF5582A6;">避免</mark>测试自己的程序。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本章引言</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/ben-zhang-yin-yan/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/ben-zhang-yin-yan/</url>
      
        <content type="html"><![CDATA[<ul><li>经过软件的总体设计和详细设计后，便得到了软件系统的结构和每个模块的详细过程描述，接着便进入了软件的制作阶段，或者叫编码阶段，也就是通常人们惯称的程序设计阶段。</li><li>程序设计语言的性能和编码风格在很大程序上影响着软件的质量和维护性能，即对程序的可靠性、可读性、可测试性和可维护性产生深远的影响，所以选择哪一种程序设计语言和怎样来编写代码是要认真考虑的。但是，本章并不具体讲述如何编写程序，而是在软件工程这个广泛的范围内介绍与编程语言和编写程序有关的一些问题。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本章小结</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/ben-zhang-xiao-jie/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/ben-zhang-xiao-jie/</url>
      
        <content type="html"><![CDATA[<ul><li>编码阶段是将详细设计的每个模块的算法转换为用程序设计语言编写的源程序。用程序设计语言编写源程序时，要根据实际项目的特点，既要考虑现实可能性，又要从技术角度、工程角度和心理角度评价和比较各种语言，选择一种合适的程序设计语言。</li><li>编码风格直接影响软件的质量，影响软件的可读性、可维护性和可移植性。因此，编码风格要求简明和清晰，不要追求所谓程序设计技巧，要注重程序结构清晰，层次结构分明，语言简单明了，各种标识符名字的命名要规范，程序和复杂 的数据要有注释。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.2 程序设计语言的选择</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/6.2-cheng-xu-she-ji-yu-yan-de-xuan-ze/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/6.2-cheng-xu-she-ji-yu-yan-de-xuan-ze/</url>
      
        <content type="html"><![CDATA[<ul><li>程序设计语言选择的理想标准主要有：<ol><li>为了使程序容易测试和维护以减少软件的总成本，所选用的高级语言应该有理想的模块化机制，以及可读性好的控制结构和数据结构;</li><li>为了便于调试和提高软件可靠性，语言特点应该使编译程序能够尽可能多地发现程序中的错误;</li><li>为了降低软件开发和维护的成本，选用的高级语言应该有良好的独立编译机制。</li></ol></li><li>程序设计语言选择的实用标准主要有：<ol><li>待开发软件的应用领域;</li><li>用户的要求;</li><li>软件的运行环境</li><li>软件开发人员的知识</li><li>软件的可移植性要求</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3 程序设计风格</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/6.3-cheng-xu-she-ji-feng-ge/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/6.3-cheng-xu-she-ji-feng-ge/</url>
      
        <content type="html"><![CDATA[<ul><li>源程序代码的逻辑简明、易读易懂是好程序的一个重要标准，应遵循：<ol><li>程序内部文档；<br> 程序内部文档包括标识符的选取、增加注解和好的程序布局。<ul><li>标识符的选取</li><li>程序的注释</li><li>程序的布局</li></ul></li><li>数据说明<br> <mark style="background: #FF5582A6;">数据说明应遵循一些简单的原则</mark>：<ul><li>数据说明的次序应该标准化</li><li>当一个说明语句说明多个变量时，最好按字典顺序排列</li><li>如果设计时使用了一个复杂的数据结构，则应加注解说明用程序设计语言实现这个数据结构的方法和特点</li></ul></li><li>语句构造<br> <mark style="background: #FF5582A6;">语句构造的原则</mark>：<ul><li>不要为了节省存储空间把多个语句写在一行</li><li>尽量避免复杂的条件测试，尤其是减少对“非”条件的测试</li><li>避免大量使用循环嵌套语句和条件嵌套语句；</li><li>利用圆括号使逻辑表达式或算术表达式的运算次序清晰直观；</li><li>变量说明不要遗漏，变量的类型、长度、存储及初始化要正确；</li><li>心理换位： “如果我不是编码人，我能看懂它吗”？</li></ul></li><li>输入输出<br> <mark style="background: #FF5582A6;">有关输入输出风格的规则</mark>：<ul><li>对所有输入数据都要进行校验</li><li>检查输入项重要组合的合法性</li><li>保持简单的输入格式</li><li>输入一批数据时，使用数据或文件结束标志，不要用计数来控制</li><li>人机交互式输入时，要详细说明可用的选择范围和边界值</li><li>当程序设计语言对输入&#x2F;输出格式有严格要求时，应保持输入格式与输入语句的要求一致</li><li>输出报表的设计要符合用户要求，输出数据尽量表格化、图形化；</li><li>给所有的输出数据加标志，并加以必要的注解</li></ul></li><li>效率<br> <mark style="background: #FF5582A6;">效率主要是指处理机工作时间和内存容量这两方面的利用率</mark>。<ul><li>关于程序效率问题应该记住下面 3 条原则：<ol><li>效率是属于性能的要求，因此应该在软件需求分析阶段确定效率方面的要求</li><li>良好的设计可以提高效率</li><li>提高程序的效率和好的编码风格要保持一致，不应该一味追求程序的效率而牺牲程序的清晰性和可读性</li></ol></li><li><mark style="background: #FF5582A6;">进一步讨论效率问题</mark>：<ol><li>代码效率 、存贮效率和输入输出的效率。</li></ol></li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.1 程序设计语言的分类</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/6.1-cheng-xu-she-ji-yu-yan-de-fen-lei/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/6-ruan-jian-bian-ma/6.1-cheng-xu-she-ji-yu-yan-de-fen-lei/</url>
      
        <content type="html"><![CDATA[<ul><li>从不同的分类角度，程序设计语言可得出不同的分类体系。从软件工程的角度，编程语言可分为基础语言、结构化语言和面向对象语言 3 大类。</li><li>基础语言<ol><li>基础语言是通用语言，它的特点是适用性强，应用面广，历史悠久。</li><li>FORTRAN，COBOL，BASIC和ALGOL都属于这类语言。</li></ol></li><li>结构化语言<ol><li>20世纪70年代以来，随着结构化程序设计思想的逐步发展，先后出现了一批常用的结构化语言。</li><li>作为基础语言的ALGOL语言是结构化语言的基础，它衍生出了Pascal、C、Ada等结构化语言。</li></ol></li><li>面向对象的语言<ol><li>C++语言</li><li>Java语言</li><li>C#语言</li></ol></li><li>从软件工程的角度，按”代“可以将编程语言划分为：<ol><li>1GL：面向机器的语言，代表是机器语言和汇编语言；</li><li>2GL：始于20世纪50年代至60年代，代表：FORTRAN、ALGOL、 COBOL、BASIC。</li><li>3GL：也称现代编程语言，代表Pascal、C、Ada、C++、 Smalltalk等；</li><li>4GL ：代表：VB、VC、JAVA。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本章引言</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/ben-zhang-yin-yan/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/ben-zhang-yin-yan/</url>
      
        <content type="html"><![CDATA[<ul><li>详细设计是软件设计的第二阶段；</li><li>上一章，总体设计阶段，已将系统划分为<mark style="background: #FF5582A6;">多个模块</mark>，并将它们按照一定的原则<mark style="background: #FF5582A6;">组装</mark>起来，同时确定了<mark style="background: #FF5582A6;">每个模块的功能</mark>及<mark style="background: #FF5582A6;">模块与模块之间的外部接口</mark>；、</li><li><mark style="background: #FF5582A6;">详细设计</mark>是对总体设计的细节进行完善，给出软件结构中每个模块的<mark style="background: #FF5582A6;">内部特征</mark>（数据结构、算法和接口）的描述。 从而在编码阶段可以把这个描述直接翻译成用某种程序设 计语言书写的程序；</li><li>本章将讲述详细设计的目的和任务、结构化程序设计、详 细设计工具以及人机界面设计方法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.5 详细设计说明书的主要内容</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.5-xiang-xi-she-ji-shuo-ming-shu-de-zhu-yao-nei-rong/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.5-xiang-xi-she-ji-shuo-ming-shu-de-zhu-yao-nei-rong/</url>
      
        <content type="html"><![CDATA[<ul><li>详细设计说明书主要包括以下内容：<ol><li>引言：编写目的、项目背景、定义、参考资料；</li><li>程序描述（所有模块给出以下说明）：功能、性能、输出和输入项目、算法、程序逻辑、接口、存储分配、限制条件、测试要点等。</li></ol></li><li>软件设计规约（软件设计说明书）<ol><li>什么是软件设计规约；<ul><li>软件设计规约对软件的组织或其组成部分的内部结构的描述，满足系统需求规约所指定的全部功能及性能要求。</li></ul></li><li>软件设计规约的组成。<ul><li>软件设计规约通常有<mark style="background: #FF5582A6;">概要设计规约</mark>和<mark style="background: #FF5582A6;">详细设计规约</mark>，分别为相应设计过程的输出文档。</li><li><mark style="background: #FF5582A6;">概要设计规约</mark>指明软件的组织结构，其主要内容包括：<ol><li>系统环境<ul><li>硬件、软件接口与人机界面</li><li>外部定义的数据库</li><li>与设计有关的限定条件</li></ul></li><li>设计描述<ul><li>数据流和主要数据结构</li><li>软件模块的结构</li><li>模块之间的接口</li></ul></li><li>对每个模块的描述<ul><li>处理过程外部行为</li><li>界面定义</li><li>数据结构</li><li>必要的注释</li></ul></li><li>文件结构和全局数据<ul><li>文件的逻辑结构、记录描述以及访问方式</li><li>交叉引用信息</li></ul></li></ol><ul><li>此外，还应包括有关软件测试方面的要求和说明。</li><li>软件概要设计是面向软件开发者的文档，主要作为<mark style="background: #FF5582A6;">软件项目管理人员</mark>、<mark style="background: #FF5582A6;">系统分析人员</mark>与<mark style="background: #FF5582A6;">设计人员</mark>之间交流的媒体。</li></ul></li><li><mark style="background: #FF5582A6;">详细设计规约</mark>是对软件各组成部分内部属性的描述，它是概要设计的细化。即在概要设计规约的基础上，增加以下内容：<ol><li>各处理过程的算法；</li><li>算法所涉及的全部数据结构的描述，特别地，对主要数据结构往往包括与算法实现有关的描述；</li></ol><ul><li>软件设计规约主要作为<mark style="background: #FF5582A6;">软件设计人员与程序员</mark>之间交流的媒体。</li></ul></li><li>设计规约格式<ol><li>引言<ul><li>编写目的<ol><li>说明编写本软件设计说明书的目的。</li></ol></li><li>背景说明<ol><li>给出待开发的软件产品的名称；</li><li>说明本项目的提出者、开发者及用户；</li><li>说明该软件产品将做什么，如有必要，说明不做什么。</li></ol></li><li>术语定义<ol><li>列出本文档中所用的专门术语的定义和外文首字母组词的原词组。</li></ol></li><li>参考资料<ol><li>列出本文档中所引用的全部资料，包括标题、文档编号、版本号出版日期及出版单位等,必要时注明资料来源。</li></ol></li></ul></li><li>总体设计<ul><li>需求规定<ol><li>说明对本软件的主要输入、输出、处理的功能及性能要求。</li></ol></li><li>运行环境<ol><li>简要说明对本软件运行的软件、硬件环境和支持环境的要求。</li></ol></li><li>处理流程<ol><li>说明本软件的处理流程，尽量使用图、文、表的形式。</li></ol></li><li>软件结构<ol><li>在DFD图的基础上，用模块结构图来说明各层模块的划分及其相互关系，划分原则上应细到程序级(即程序单元)，每个单元必须执行单独一个功能(即单元不能再分了)。</li></ol></li></ul></li><li>运行设计<ul><li>运行模块的组合<ol><li>说明对系统施加不同的外界运行控制时所引起的各种不同的运行模块的组合,说明每种运行所经历的内部模块和支持软件。</li></ol></li><li>运行控制<ol><li>说明各运行控制方式、方法和具体的操作步骤。</li></ol></li></ul></li><li>系统出错处理<ul><li>出错信息简要说明每种可能的出错或故障情况出现时，系统输出信息的格式和含义。</li><li>出错处理方法及补救措施<ol><li>说明故障出现后可采取的措施，包括：<ul><li>后备技术。当原始系统数据万一丢失时启用的副本的建立和启动的技术，如周期性的信息转储；</li><li>性能降级。使用另一个效率稍低的系统或方法(如手工操作、数据的人工记录等)，以求得到所需结果的某些部分；</li><li>恢复和再启动。用建立恢复点等技术，使软件再开始运行。</li></ul></li></ol></li></ul></li><li>模块设计说明<br> 以填写模块说明表的形式,对每个模块给出下述内容：<ol><li>模块的一般说明，包括名称、编号、设计者、所在文件、所在库、调用本模块的模块名和本模块调用的其他模块名；</li><li>功能概述；</li><li>处理描述，使用伪码描述本模块的算法、计算公式及步骤；</li><li>引用格式；</li><li>返回值；</li><li>内部接口，说明本软件内部各模块间的接口关系，包括；<ul><li>名称</li><li>意义</li><li>数据类型</li><li>有效范围；</li><li>I&#x2F;O标志</li></ul></li><li>外部接口，说明本软件同其他软件及硬件间的接口关系，包括：<ul><li>名称；</li><li>意义</li><li>数据类型；</li><li>有效范围；</li><li>I&#x2F;O标志；</li><li>格式，指输入或输出数据的语法规则和有关约定；</li><li>媒体。</li></ul></li><li>用户接口，说明将向用户提供的命令和命令的语法结构，以及软件的回答信息，包括：<ul><li>名称；</li><li>意义；</li><li>数据类型；</li><li>有效范围；</li><li>I&#x2F;O标志；</li><li>格式，指输入或输出数据的语法规则和有关约定；</li><li>媒体。</li></ul></li></ol></li></ol></li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本章小结</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/ben-zhang-xiao-jie/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/ben-zhang-xiao-jie/</url>
      
        <content type="html"><![CDATA[<ul><li>详细设计阶段的任务是确定如何实现所要求的目标系统，将 总体设计阶段得到的模块算法用详细设计工具：程序流程图 、N-S图、PAD图和PDL语言描述出来，即设计出程序的“ 蓝图” 。从而在下一编码阶段直接翻译成用某种程序设计语 言书写的程序。结构化程序设计技术是软件详细设计的基础 ，任何一个程序都可以用程序、选择、循环三种结构来设计 和实现，结构化程序设计具有可理解性和可维护性。</li><li>人机界面设计质量直接影响用户对软件产品的接受程度，因 此， 必须对人机界面设计给予足够重视。在人机界面的设 计过程中必须充分重视并认真处理好系统响应时间、用户帮 助实施、出错信息处理和命令交互四个设计问题。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.3 详细设计工具（描述方法）</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.3-xiang-xi-she-ji-gong-ju-miao-shu-fang-fa/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.3-xiang-xi-she-ji-gong-ju-miao-shu-fang-fa/</url>
      
        <content type="html"><![CDATA[<ul><li>前言<ol><li>描述每个模块执行过程的工具叫做详细设计工具，可以分为图形、表格和语言三类。<ul><li><mark style="background: #FF5582A6;">图形工具</mark>：包括传统的程序流程图、盒图和问题分析图（PAD）等；</li><li><mark style="background: #FF5582A6;">表格工具</mark>：包括判定表、判定树等；</li><li><mark style="background: #FF5582A6;">语言工具</mark>：过程设计语言（PDL）等</li></ul></li><li>不论是哪类工具，对它们的基本要求都是能提供对设计准 确，无歧义的描述，也就是应该能指明控制流程、处理功 能、数据组织以及其它方面的实现细节，从而在编码阶段 能把对设计的描述直接翻译成程序代码。</li></ol></li><li>程序流程图<ol><li>程序流程图又称为<mark style="background: #FF5582A6;">程序框图</mark>，它是一种最古老、应用最广泛、且最有争议的描述详细设计的工具。</li><li>它易学、表达算法直观。缺点是不够规范，特别是 使用箭头使质量受到很大影响，因此必须加以限制 ，使其成为规范的详细设计工具。</li><li>为了能够用程序流程图描述结构化的程序，一般地，限制只允许使用<mark style="background: #FF5582A6;">三种基本结构</mark>。</li><li>结构化程序设计的<mark style="background: #FF5582A6;">基本控制结构</mark>是:<ul><li>顺序型<br>  ![[Pasted image 20230623151801.png]]</li><li>选择型<br>  ![[Pasted image 20230623151901.png]]</li><li>先判断型循环<br>  ![[Pasted image 20230623151912.png]]</li><li>后判断型循环<br>  ![[Pasted image 20230623151922.png]]</li><li>多种情况选择型（CASE）<br>  ![[Pasted image 20230623151936.png]]</li></ul></li><li>程序流程图的<mark style="background: #FF5582A6;">优点</mark>：<ul><li>表达直观、结构清晰、易于理解、易于修改</li></ul></li><li>程序流程图的<mark style="background: #FF5582A6;">缺点</mark>：<ul><li>本质上不是逐步求精的好工具，它诱使程序员 过早考虑控制流程，而不去考虑程序的整体结构；</li><li>用箭头代表控制流，因此程序员不受任何约束 ，可以完全不顾结构程序设计的精神，随意转移控制，容易造成非结构化的程序结构；</li><li>不易表示数据结构和层次结构</li></ul></li></ol></li><li>盒图(N-S图)<ol><li>N-S图是为克服流程图在描述程序逻辑时的随意性等缺点，1973年， 由Nassi和Shneiderman提出来的，体现了结构化设计的精神。是目前过程设计中广泛使用 的一种图形。</li><li>N-S图仅含有5种基本成分，它们分别表示SP方法（结构化程序设计方法）的几种标准控制结构。</li><li>下图给出了结构化控制结构的盒图表示，也给出了调用子程序的盒图表示方法。<ul><li>顺序<br>  ![[Pasted image 20230623152644.png]]</li><li>IF-THEN-ELSE分支<br>  ![[Pasted image 20230623152655.png]]</li><li>CASE型多分支<br>  ![[Pasted image 20230623152703.png]]</li><li>循环<br>  ![[Pasted image 20230623152720.png]]</li><li>调用子程序<br>  ![[Pasted image 20230623152732.png]]</li></ul></li><li>在N-S图中，每个“处理步骤”是用一个盒子表示的，所谓“处理步骤”可以是语句或语句序列。需要时，盒子中还可以嵌套另一个盒子，嵌套深度一般没有限制，只要整张图在一页纸上能容纳得下，<mark style="background: #FF5582A6;">由于只能从上边进入盒子然后从下边走出</mark>，除此之外没有其他的入口和出口，所以，N-S图限制了随意的控制转移，保证了程序的良好结构。</li><li>用N-S图作为详细设计的描述手段时，常需用两个盒子：<mark style="background: #FF5582A6;">数据盒</mark>和<mark style="background: #FF5582A6;">模块盒</mark>，<mark style="background: #FF5582A6;">前者</mark>描述有关的数据，包括全程数据、局部数据和模块界面上的参数等，<mark style="background: #FF5582A6;">后者</mark>描述执行过程。</li><li>N-S图有下述特点：<ul><li><mark style="background: #FF5582A6;">功能域</mark>(一个特定控制结构的作用域)明确，可以从盒图上一眼就看出来。</li><li><mark style="background: #FF5582A6;">不可能任意转移控制</mark>。</li><li>很容易确定局部和全程数据的作用域</li><li>很容易表现<mark style="background: #FF5582A6;">嵌套关系</mark>，也可以表示模块的层次结构</li></ul></li><li>N-S图的优点：<ul><li>它强制设计人员按SP方法进行思考并描述他的设计方案，这就有效地保证了设计的质量，从而也保证了程序的质量;</li><li>N-S图形象直观，<mark style="background: #FF5582A6;">功能域明确</mark>，<mark style="background: #FF5582A6;">结构层次清晰</mark>。为编程、复查、选择测试用例、维护都带来了方便;</li><li>N-S图简单、易学易用，可用于软件教育和其他方面。</li></ul></li><li>N-S图的缺点：<ul><li>随着程序内嵌套的层数的增多时，内层方框越来越小，这样不仅会增加画图的难度，还会影响图形的清晰度。</li><li>手工修改也比较麻烦，这是有些人不用它的主要原因</li></ul></li><li>N-S图的嵌套定义形式<br> ![[JM5A%OAK~)WXML}X04LH0S1.png]]</li></ol></li><li>问题分析图（PAD图）<ol><li><p>PAD是问题分析图(problem analysis diagram)的英文缩写，由日立公司中央研究所在1973年研究开发的。</p></li><li><p>它使用<mark style="background: #FF5582A6;">二维树形结构图</mark>来描述程序的逻辑，将这种图翻译成程序代码比较容易。是一种十分有前途的表达方法。</p></li><li><p>PAD支持SP方法，它仅具有顺序、选择、循环三类基本成分，其中选择和循环又有几种形式</p></li><li><p>下图是PAD图的基本符号。</p><ul><li>顺序<br>  ![[Pasted image 20230623154842.png]]</li><li>选择<br>  ![[Pasted image 20230623154853.png]]</li><li>Case型多分支选择<br>  ![[Pasted image 20230623154859.png]]</li><li>当型循环<br>  ![[Pasted image 20230623154915.png]]</li><li>直到型循环<br>  ![[Pasted image 20230623154923.png]]</li><li>语句标号<br>  ![[Pasted image 20230623155014.png]]</li><li>定义<br>  ![[Pasted image 20230623155023.png]]</li><li>初始的PAD图<br>  ![[Pasted image 20230623155304.png]]</li><li>使用def符号细化处理框P2<br>  ![[Pasted image 20230623155316.png]]</li></ul></li><li><p>PAD图的主要优点：</p><ul><li>使用PAD符号设计的程序必然是结构化的程序。</li><li>PAD图所描绘的程序结构十分清晰，<mark style="background: #FF5582A6;">PAD图中竖线的总条数就是程序的层次数</mark>。</li><li>用PAD图表现程序逻辑,易读，易记，易懂</li><li>容易将PAD图转换成高级语言源程序，可用软件工具实现自动转换</li><li>既可以表示<mark style="background: #FF5582A6;">程序逻辑</mark>，也可以描绘<mark style="background: #FF5582A6;">数据结构</mark></li><li>支持自顶向下，逐步求精方法的使用。用“def” 符号逐步增加细节</li></ul></li></ol></li><li>过程设计语言（PDL）<ol><li>过程设计语言（PDL）也称为<mark style="background: #FF5582A6;">伪码</mark>，PDL是一种用于描述功能模块的<mark style="background: #FF5582A6;">算法设计</mark>和<mark style="background: #FF5582A6;">加工细节</mark>的语言。</li><li>PDL是一种“<mark style="background: #FF5582A6;">混杂式语言</mark>”，它采用某种语言（如英语或自然语言）的<mark style="background: #FF5582A6;">词汇</mark>，另一种语言（结构化程序设计语言)的<mark style="background: #FF5582A6;">全部语法</mark>。</li><li>伪码的语法规则分为“外语法”和“内语法”。</li><li>PDL语法是开放式的，其外层语法是确定的，而内层语法则故意不确定。</li><li><mark style="background: #FF5582A6;">外层语法描述控制结构和数据结构</mark>，它用类似于一般编程语言控制结构的关键字(如IF—THEN—ELSE、WHILE——DO、REPEAT——UNTIL等)表示，所以是确定的，</li><li><mark style="background: #FF5582A6;">内层语法</mark>可使用自然语言的词汇<mark style="background: #FF5582A6;">描述具体操作</mark>。</li><li>过程设计语言的表示：<br> ![[Pasted image 20230623160241.png]]</li><li>PDL<mark style="background: #FF5582A6;">特点</mark>：<ul><li>关键字的固定语法，它提供了结构化控制结构、 数据说明和模块化的特点。</li><li>自然语言的自由语法，它描述处理特点；</li><li>数据说明的手段。</li><li>模块定义和调用的技术，应该提供各种接口描述模式</li></ul></li><li>PDL<mark style="background: #FF5582A6;">优点</mark>：<ul><li>可以作为注释直接插在源程序中间。这样做能促 使维护人员在修改程序代码的同时也相应地修改PDL 注释，因此有助于保持文档和程序的一致性，提高了 文档的质量</li><li>可以使用普通的正文编辑程序或文字处理系统， 很方便地完成PDL的书写和编辑工作</li><li>同自然语言(英语)很接近，易于理解。</li><li>由于是语言形式，所以易于被计算机处理。</li><li>由于同程序是同结构的，从中自动产生程序亦较容易。</li></ul></li><li>PDL<mark style="background: #FF5582A6;">缺点</mark>：<ul><li>不如图形工具形象直观;</li><li>描述复杂的条件组合与动作间的对应关系时，不如判定表清晰简单。</li></ul></li><li>总之,支持SP方法的各种描述手段(结构化流程图、N-S图、PAD图、PDL等)各有优缺点,总的说来，PDL是比较令人满意的，所以在英语国家中最为流行。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.4 人机界面设计</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.4-ren-ji-jie-mian-she-ji/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.4-ren-ji-jie-mian-she-ji/</url>
      
        <content type="html"><![CDATA[<ul><li>前言<ol><li>没有“正确”或“错误”的人机界面，只有“好的” 或“不好的”人机界面；</li><li>人机界面设计是否成功将直接影响着软件系统的质量。</li></ol></li><li>人机界面设计问题<ol><li>在设计人机界面的过程中，需考虑下面4个问题：<ul><li>系统响应时间<ol><li>系统响应时间指从用户完成某个控制动作(例如， 按回车键或点击鼠标)，到软件给出预期的响应(输出信息或做动作)之间的这段时间</li><li>系统响应时间有两个重要属性：<mark style="background: #FF5582A6;">长度</mark>和<mark style="background: #FF5582A6;">易变性</mark>。如果系统响应时间过长，用户就会感到紧张和沮丧。但是，当用户工作速度是由人机界面决定的时候，系统响应时间过短也不好，这会迫使用户加快操作节奏，从而可能会犯错误。</li><li><mark style="background: #FF5582A6;">易变性</mark>指系统响应时间相对于平均响应时间的偏 差，这是系统响应时间的比较重要的属性。响应 时间易变性低有助于用户建立起稳定的工作节奏。 例如，稳定在1秒的响应时间比从0.1秒到2.5秒变 化的响应时间要好</li></ol></li><li>用户帮助设施<ol><li>常见的帮助设施:集成的和附加的两类：<ul><li>集成的帮助设施<ol><li>从一开始就设计在软件里面</li><li>可以缩短用户获得帮助的时间，增加界面的友好性</li></ol></li><li>附加的帮助设施<ol><li>在系统建成后再添加到软件中的</li><li>一般是一种查询能力有限的联机用户手册</li></ol></li></ul></li></ol></li><li>出错信息处理<br>  <mark style="background: #FF5582A6;">出错信息</mark>和<mark style="background: #FF5582A6;">警告信息</mark>，是出现问题时交互式系统 给出的“坏消息” 。出错信息设计得不好，将向 用户提供无用的甚至误导的信息，反而会加重用 户的挫折感。<br>   一般说来，交互式系统给出的出错信息或警 告信息，应该具有下述属性<ol><li>信息应该用用户可以理解的术语描述问题。</li><li>信息应该提供有助于从错误中恢复的建设性 意见。</li><li>信息应该指出错误可能导致哪些负面后果(例如， 破坏数据文件)，以便用户检查是否出现了这些问题， 并在确实出现问题时及时解决</li><li>信息应该伴随着听觉上或视觉上的提示，例如， 在显示信息时同时发出警告铃声，或者信息用闪烁方式显示，或者信息用明显表示出错的颜色显示。</li><li>信息不能带有指责色彩，也即，不能责怪用户。 当确实出现了问题的时候，有效的出错信息能提高 交互式系统的质量，减轻用户的挫折感。</li></ol></li><li>命令交互<br>  现在，面向窗口的、点击和拾取方式的界面已经减少 了用户对命令行的依赖。但是，许多高级用户仍然偏爱 面向命令行的交互方式<br>  在提供命令交互方式时，必须考虑下列设计问题<ol><li>是否每个菜单选项都有对应的命令？</li><li>采用何种命令形式？有3种选择：控制序列(例如， Ctrl+P)，功能键和键入命令</li><li>学习和记忆命令的难度有多大？忘记了命令怎么办？</li><li>用户是否可以定制或缩写命令？</li></ol></li></ul></li></ol></li><li>人机界面设计原则<ol><li>屏幕界面设计的原则可归为四点：<ul><li>界面简洁、控件摆放规范、颜色统一、符合用户习惯。</li></ul></li><li>T.Mandel提出三条用户界面设计的重要准则，称之 为“黄金”指导准则：<ul><li>让用户驾驭软件，而不是软件驾驭用户；</li><li>尽可能减少用户的记忆负担；</li><li>保持界面的一致性。</li></ul></li></ol></li><li>人机界面设计过程<br>  用户界面设计是一个迭代的过程，通常先创建设计模型，再用原型实现这个设计模型，并由用户试用和评估，然后根据用户意见进行修改。<ol><li>人机界面设计基本过程可以分为以下步骤：<ul><li>建立任务的目标和意图；</li><li>目标和意图明确后，建立界面需求规格模型；</li><li>以界面需求模型为依据创建用户界面原型；</li><li>用户试用并评估该界面原型；</li><li>设计者根据用户的意见修改设计并实现下一原型；</li><li>不断进行下去，直到用户感到满意为止；</li><li>在上述步骤中，以界面原型创建进行界面设计迭代。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1 详细设计的目的和任务</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.1-xiang-xi-she-ji-de-mu-de-he-ren-wu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.1-xiang-xi-she-ji-de-mu-de-he-ren-wu/</url>
      
        <content type="html"><![CDATA[<ul><li>详细设计的<mark style="background: #FF5582A6;">根本目的</mark>：确定应该怎样具体实现所要求的系统。<ol><li>为软件结构图中每一个模块确定采用的<mark style="background: #FF5582A6;">算法</mark>和<mark style="background: #FF5582A6;">块内数据结构</mark></li><li>用某种选定的详细设计工具更清晰地描述，在编码阶段可以把这个描述<mark style="background: #FF5582A6;">直接翻译</mark>成用某种程序设计语言书写的<mark style="background: #FF5582A6;">程序</mark>。</li></ol></li><li><mark style="background: #FF5582A6;">结构化程序设计</mark>是实现上述目标的关键技术，因 此是详细设计的逻辑基础。</li><li>详细设计的任务<ol><li>确定每个模块所采用的算法；</li><li>确定每个模块所使用的数据结构</li><li>确定每个模块的接口细节；</li><li>为每个模块设计出一组测试用例</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2 结构化程序设计(SP)</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.2-jie-gou-hua-cheng-xu-she-ji-sp/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/5-ruan-jian-xiang-xi-she-ji/5.2-jie-gou-hua-cheng-xu-she-ji-sp/</url>
      
        <content type="html"><![CDATA[<ul><li>结构化程序设计的概念是1965年为了从高级语言中<mark style="background: #FF5582A6;">取消GOTO语句</mark>而提出的</li><li>结构化程序设计经典定义： “如果一个程序的代码块仅仅通过<mark style="background: #FF5582A6;">顺序</mark>、<mark style="background: #FF5582A6;">选择</mark>和<mark style="background: #FF5582A6;">循环</mark>这3种基本控制结构进行连接，并且每个代码块<mark style="background: #FF5582A6;">只有一个入口和一个出口</mark>，则称这个程序是结构化的。 ”</li><li>结构化程序一般具有如下四个特征：<ol><li>一个入口</li><li>一个出口</li><li>程序中无死语句</li><li>程序中无死循环</li></ol></li><li>任何程序逻辑都可用<mark style="background: #FF5582A6;">顺序</mark>、<mark style="background: #FF5582A6;">选择</mark>和<mark style="background: #FF5582A6;">循环</mark>等三种基本结构, 以及选择和循环二种扩充结构来表示</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本章小结</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/ben-zhang-xiao-jie/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/ben-zhang-xiao-jie/</url>
      
        <content type="html"><![CDATA[<ul><li>软件总体设计的基本目的是用比较抽象概括的方式确定系统 如何完成预定的任务。总体设计阶段主要由两个小阶段组 成，首先进行系统设计，从数据流图出发设想完成系统功能 的若干种推荐方案，然后比较分析这些方案，最后和用户共 同选定一个最佳方案；然后进行软件结构设计，结构化设计 方法把软件结构主要划分为变换型和事务型两大类，并且提 出与之相应的变换型设计和事务型设计两种方法，以及综合 型数据流图的设计方法。系统流程图用来表达分析员对现有 系统的认识和描绘他对未来物理系统的设想</li><li>软件结构的模块化设计遵循抽象、信息隐蔽、分解、逐步求 精和模块独立性等一系列指导准则。模块独立性是一个良好 设计的关键，评价标准主要是模块的耦合和内聚。</li><li>数据库设计是指在一个给定的应用环境下，确定一个最优数 据模型和处理模式，主要包括数据库逻辑结构设计、物理结 构设计和数据规范化。</li><li>总体设计阶段产生的文档是总体设计说明书，它既是详细设 计、编码的基础，也是进行测试的依据之一</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.6 结构化设计方法</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.6-jie-gou-hua-she-ji-fang-fa/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.6-jie-gou-hua-she-ji-fang-fa/</url>
      
        <content type="html"><![CDATA[<ul><li>数据流图及其类型<ol><li><mark style="background: #FF5582A6;">变换流</mark>：信息通常以“外部世界”所具有的形式进入系统，经过处理后，又以这种形式离开系统<ul><li>![[Pasted image 20230621151714.png]]</li></ul></li><li>变换型结构是一种线性状的结构，具有明显的边界，可以明显地分成<mark style="background: #FF5582A6;">输入</mark>、<mark style="background: #FF5582A6;">主加工</mark>（或称变换、处理）内容耦合和<mark style="background: #FF5582A6;">输出</mark>三部分。</li><li>变换型数据流图基本呈线性形状的结构，由输入、变 换、输出三部分组成，变换是系统的变换中心。<ul><li>![[Pasted image 20230621151734.png]]</li></ul></li><li><mark style="background: #FF5582A6;">事务流</mark>：在事务型数据流图，数据项沿着输入同路到达一个处理 T ， T 根据输入数据的类型在若干动作序列中选出一个来执行。处理 T 称为事务中心。<ul><li>![[Pasted image 20230621151759.png]]</li></ul></li><li>事务型数据流完成以下任务：<ul><li>接受输入的数据</li><li>分析并确定对应的事务</li><li>选取与该事务对应的一条活动路径</li></ul></li></ol></li><li>结构化设计方法的步骤<ol><li>复审数据流图，必要时可进行修改或精化；<ul><li>对需求分析阶段得出的数据流图认真复查，并且在必要时 进行精化。</li><li>不仅要确保数据流图给出了目标系统的正确的逻辑模型， 而且应该使数据流图中每个处理都代表一个规模适中相对 独立的子功能。</li><li>目的：<ol><li>为了确保系统的输入数据和输出数据符合实际情况</li><li>为了确保是否需要进一步精化系统的 DFD 图</li></ol></li></ul></li><li>确定数据流图类型<ul><li>如果是变换型，确定逻辑输入和逻辑输出的<mark style="background: #FF5582A6;">边界</mark>， 找出变换中心，映射为变换结构的顶层和第一层；</li><li>如果是事务型，确定事务中心和活动路径，映射为 事务结构的顶层和第一层，建立软件结构的基本框架</li></ul></li><li>分解上层模块，设计中下层模块结构；</li><li>根据软件结构设计准则对软件结构求精并改进；</li><li>导出接口描述和全程数据结构；</li><li>复审。如果有错，转入修改完善，否则进入下一阶段详 细设计</li><li>![[Pasted image 20230622163126.png]]</li></ol></li><li>变换型分析设计<ol><li>确定逻辑输入和逻辑输出的边界，找出变换中心<ul><li>找到逻辑输入和逻辑输出</li><li>![[Pasted image 20230622163206.png]]</li></ul></li><li>第一级分解 – 设计系统模块结构图的顶层和第一层<ul><li>主模块:位于最顶层，一般以所建系统的名字命名，其任务是协调控制第一层模块</li><li>输入模块部分:为主模块提供加工数据，有几个逻辑输入就设计几个输入模块</li><li>变换模块部分:接受输入模块部分的数据，并对内部形式的数据加工，产生系统所有的内部输出数据</li><li>输出模块部分:将变换模块产生的输出数据，以用户可见的形式输出。有几个逻辑输出，就设计几个输出模块</li><li>![[Pasted image 20230622163439.png]]</li><li>![[Pasted image 20230622163458.png]]</li></ul></li><li>第二级分解 – 设计中下层模块。自顶向下，逐步求精<ul><li>对每一个输入模块设计其下层模块<ol><li>接收数据模块（即输入模块)</li><li>把接收的数据变换成它的上级模块所需的数据(即变换模块)</li><li>直到输入模块为物理输入，则细化停止</li></ol></li><li>对每一个输出模块设计其下层模块<ol><li>将得到的数据向输出形式进行转换</li><li>将转换后的数据进行输出</li><li>直到输出模块是物理输出，则细化停止</li></ol></li><li>对变化模块进行分解（无通用法则)</li></ul></li><li>对初始结构图优化<ul><li>为了产生合理的分解，得到尽可能高的内聚、尽 可能松散的耦合，为了得到一个易于实现、易于 测试和易于维护的软件结构，应该对初步分割得 到的模块进行再分解或合并</li></ul></li></ol></li><li>事务型分析设计<ol><li>在数据流图上确定事务中心、输入流和活动路径</li><li>. 第一级分解 —- 设计事务结构的顶层和第一层<ul><li>首先，为事务中心设计一个主模块</li><li>然后，为每一条活动路径设计一个事务处理模块</li><li>对其输入部分设计一个输入模块</li><li>如果一个事务数据流图的活动路径集中于一个加工， 则设计一个输出模块，否则第一层不设计输出模块</li></ul></li><li>第二级分解 —- 设计事务结构的中下层。自顶向下，逐步求精<ul><li>从事务中心的边界开始，把沿着接收流通路的处理映射成模块</li><li>发送分支的结构包含一个调度模块，它控制下层的所有活动模块；然 后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构</li></ul></li><li>对初始的事务结构优化工作同变换结构</li></ol></li><li>综合分析设计：<br>  实际中，一些大型软件系统数据流图往往既不是单纯的变换型， 也不是单纯的事务型，而是变换型结构和事务型结构的混合结构。 对于这种既有变换型又有事务型，两种类型混合在一起的综合型 数据流图的转换，通常采用变换分析为主、事务分析为辅的方式 进行软件结构设计。<ol><li>首先确定数据流图整体上的类型。</li><li>然后利用变换型数据流图的分析方法，先找出主加工，把软 件系统分为输入、变换、输出三部分，由此设计出软件系统的顶 层和第一层。</li><li>最后根据数据流图各个部分的结构特点，适当地运用“变换 分析”或“事务分析”就可得出初始软件结构图的某个方案</li><li>步骤<ol><li>功能描述：</li><li>设计步骤<ul><li>第 1 步 复查基本系统模型。</li><li>第 2 步 复查并精化数据流图</li><li>第 3 步 确定数据流图的类型</li><li>第 4 步 确定输入、变换和输出边界<br>  输入流、输出流的边界的确定具有一定的任 意性，因为不同的人对系统的理解不同</li><li><mark style="background: #FF5582A6;">第 5 步 设计系统的上层模块结构</mark><br>  上层的模块结构有两层，顶层是系统模块，第一层由输入模 块、变换模块和输出模块三个模块组成。</li><li>第 6 步 分解上层模块，设计下层模块。<ol><li><mark style="background: #FF5582A6;">输入部分</mark>下层模块的设计，从变换中心的输 入流边界开始沿着输入通路向外移动，把输入 通路中每个处理映射成软件结构中输入模块控 制下的一个低层模块。</li><li><mark style="background: #FF5582A6;">输出部分</mark>的下层模块设计从变换中心输出流边 界开始然后沿输出通路向外移动，把输出通路 中每个处理映射成系统结构中输出模块控制的 一个低层模块</li><li><mark style="background: #FF5582A6;">变换部分</mark>的映射是把变换中心内的每个处理，映射 成系统结构中变换模块控制下的若干个模块。</li></ol></li><li>第七步 精化模块结构<br>  在二级分解后，得到系统的初步结构图，根据<mark style="background: #FF5582A6;">模块独立性原理</mark>和<mark style="background: #FF5582A6;">启发规则</mark>进行精化</li></ul></li></ol></li><li>总结：<ul><li><mark style="background: #FF5582A6;">变换分析是软件系统结构设计的主要方法</mark>。一般，一个 大型的软件系统数据流图往往是变换型结构和事务型结 构的混合结构</li><li>此时一般以“变换分析”为主，“事务分析”为辅进行 软件结构设计 : 先找出主加工，设计出结构图的上层， 然后根据数据流图各部分的结构特点适当地运用“变换 分析”或“事务分析”就可得出初始结构图的某个方案</li></ul></li></ol></li><li>设计优化<br>  设计优化应在满足信息要求的情况下，力求做到在有效结构之下，使<mark style="background: #FF5582A6;">模块最少</mark>，<mark style="background: #FF5582A6;">接口最简单</mark>，一般设计优化应考虑以下几个方面：<ol><li>在不考虑时间因素的前提下开发并精 化软件结构；</li><li>在详细设计阶段选出最耗费时间的那 些模块，仔细地设计它们的处理过程 ( 算 法 ) ，以求提高效率</li><li>使用高级程序设计语言编写程序；</li><li>在软件中孤立出那些大量占用处理机资 源的模块</li><li>必要时重新设计或用依赖于机器的语言 重写上述大量占用资源的模块的代码，以求提 高效率<br>  上述优化方法遵守了一句格言： “先使它能工 作，然后再使它快起来。 ”</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.6 总体设计说明书</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.6-zong-ti-she-ji-shuo-ming-shu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.6-zong-ti-she-ji-shuo-ming-shu/</url>
      
        <content type="html"><![CDATA[<ul><li>总体设计说明书主要包括以下内容。<ol><li>引言：编写目的、项目背景、定义、参考资料；</li><li>任务概述：目标、运行环境、需求概述、条件与限制；</li><li>总体设计： 处理流程、总体结构和模块外部设计（给出软 件系统的结构图）、功能分配（表明各项功能与程序的关 系）</li><li>接口设计：外部接口（用户界面、软件与硬件接口）、内部 接口（模块之间的接口）；</li><li>数据结构设计：逻辑结构设计、物理结构设计、数据结构与 程序的关系；</li><li>运行设计：运行模块的组合、运行控制、运行时间；</li><li>出错处理设计：出错输出信息、出错处理对策（如设置后 备、性能降级、恢复及再启动等）；</li><li>安全保密设计</li><li>维护设计：说明为方便维护工作的设施，如维护模块等。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.4 数据库设计</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.4-shu-ju-ku-she-ji/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.4-shu-ju-ku-she-ji/</url>
      
        <content type="html"><![CDATA[<ul><li>数据库系统的三级模式概念</li><li>数据库逻辑设计原则<ol><li>数据库逻辑设计应该选择最适合于相应概念结构的数据模型，然后对 支持该数据模型的各种 DBMS 进行比较后，选择最合适的 DBMS 。</li><li>目前 DBMS 产品一般支持关系、网状、层次 3 种模型中的一种，对 于特定模型，各机器系统又有自己的一些限制，提供不同的环境与工 具。因此逻辑结构的设计一般分 3 步进行，如图 4.4 所示。<ul><li>![[Pasted image 20230620105337.png]]</li></ul></li><li>E-R 模型向关系模型的转换要解决的问题是如何将实体型和实体之间的联 系转换为关系模式，如何确定这些关系模式的属性和码。针对 E-R 图 中的实体、联系和属性，这种转换一般遵循如下原则。<ul><li>每个实体转换为一个关系模式，实体的属性就是关系的属性，实体的 码就是关系的码。</li><li>对于实体之间的联系，则根据其联系类型，分别按照以下情况转换：<ol><li>1:1 联系：将该联系可以转换并归并到任何一个实体端转换后的关系 模式中，同时将另一个实体的码和联系的属性一并加入到联系所在的实 体端所对应的关系模式；<ul><li>将该联系可以转换并归并到任何一个实体端转换后的关 系模式中，同时将另一个实体的码和联系的属性一并加 入到联系所在的实体端所对应的关系模式</li><li>![[Pasted image 20230620105615.png]]</li></ul></li><li>1:n 联系：将 1 端实体的码和联系的属性都转换归并到多端实体转换 后的关系模式中，转换以后关系模式的码为多端实体的码；<ul><li>将 1 端实体的码和联系的属性都转换归并到多端实体 转换后的关系模式中，转换以后关系模式的码为多端实 体的码</li><li>![[Pasted image 20230620105633.png]]</li></ul></li><li>m:n 联系：将联系转换为一个单独的关系模式，与该联系相连的实体 的码及联系本身的属性均转换为关系的属性，各实体的码组成该关系模 式的码或关系码的一部分；<ul><li>将联系转换为一个单独的关系模式，与该联系相连的实 体的码及联系本身的属性均转换为关系的属性，各实体 的码组成该关系模式的码或关系码的一部分</li><li>![[Pasted image 20230620110251.png]]</li></ul></li><li>3 个或 3 个以上实体之间的一个多元联系可以转换为一个关系模式， 与该多元联系相连的各实体的码及联系本身的属性均转换为关系的属 性，各实体的码组成该关系模式的码或关系码的一部分；<ul><li>1:1:1 可以在三个实体类型转换成的三个关系模式中 任意一个关系模式的属性中加入另两个关系模式的键 （作为外键）和联系类型的属性</li><li>1:1:N 在 N 端实体类型转换成的关系模式中加入两 个 1 端实体类型的键（作为外键）和联系类型的属性</li><li>1:M:N 将联系类型也转换成关系模式，其属性为 M 端和 N 端实体类型的键（作为外键）加上联系类型的属 性，而键（联系）为 M 端和 N 端实体键的组合</li><li>M:N:P 将联系类型也转换成关系模式，其属性为三 端实体类型的键（作为外键）加上联系类型的属性，而 键（联系）为三端实体键的组合</li></ul></li><li>具有相同码的关系模式可合并</li></ol></li></ul></li></ol></li><li>关系数据库规范化<ol><li>所谓规范化，就是用形式更为简洁、结构更加规范的关系模式取代原有关系 的过程</li><li>规范化方法是专门针对关系模型建立的一种数据库设计方法。</li><li>关系数据库中的规范化问题是指关系数据库中的关系必须满足一定的规范化 要求，对于不同的规范化程度可用范式来衡量。</li><li>关系数据库规范化理论主要解决的是如何构造合适的数据逻辑结构的问题。 <mark style="background: #FF5582A6;">范式</mark>是符合某一种级别的关系模式的集合，是衡量关系模式规范化程度的标准 ，达到标准的关系才是规范化的。</li><li>目前主要有 6 种范式：第一范式、第二范式、第三范式、 BC 范式、第四范 式和第五范式。满足最低要求的叫第一范式，简称为 1NF 。其余以此类推。显 然各种范式之间存在关系： 1NF 2NF 3NF BCNF 4NF 5NF ⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF ⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF ⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF ⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF ⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF 。</li><li>通常把某一关系模式 R 满足第 n 范式简记为 R nNF ∈nNF</li><li>最重要的是 3NF 和 BCNF ，它们是进行规范化的主要目标。一个低一级范 式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式的集合 ，这个过程称为<mark style="background: #FF5582A6;">规范化</mark></li><li><mark style="background: #FF5582A6;">规范化的基本思想</mark>是逐步消除数据依 赖中不合适的部分 ，使模式中的各关 系模式达到某种程 度的“分离” 。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.5 软件结构设计的图形工具</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.5-ruan-jian-jie-gou-she-ji-de-tu-xing-gong-ju/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.5-ruan-jian-jie-gou-she-ji-de-tu-xing-gong-ju/</url>
      
        <content type="html"><![CDATA[<ul><li>软件结构图<ol><li>软件结构图是软件系统的模块层次结构，用来表达软件 的<mark style="background: #FF5582A6;">组成模块及其调用关系</mark>。</li><li>软件结构图的主要内容有：<ul><li><mark style="background: #FF5582A6;">模块</mark>：用方框表示，方框中写上模块的名字，模块名最好能反映模块功能；</li><li><mark style="background: #FF5582A6;">模块的调用关系</mark> : 两个模块之间用单向箭头或直线连接起来表示它们的调用关 系；</li><li><mark style="background: #FF5582A6;">辅助符号</mark> : 弧形箭头表示循环调用；菱形表示选择或者条件调用</li></ul></li><li>附加符号：<ul><li>循环调用：模块 A 循环调用模块 B 、 C 、 D ；</li><li>选择调用：判定为真时调用模块 T1 ，为假时调用模块 T2</li></ul></li></ol></li><li>层次图<ol><li>层次图用来<mark style="background: #FF5582A6;">描绘软件的层次结构</mark>，适合在自顶向下设计 软件的过程中使用。</li><li>层次图和层次方框图的区别：<ul><li>![[Pasted image 20230620183022.png]]</li></ul></li><li>![[Pasted image 20230620183041.png]]</li></ol></li><li>HIPO 图<ol><li>HIPO 图是<mark style="background: #FF5582A6;">层次图</mark> + <mark style="background: #FF5582A6;">输入</mark> &#x2F; <mark style="background: #FF5582A6;">处理 </mark>&#x2F; <mark style="background: #FF5582A6;">输出图</mark>的英文缩写。</li><li>为了能使 HIPO 图具有可追踪性，在 H 图（层次图）里 除了最顶层的方框之外，每个方框都加上了<mark style="background: #FF5582A6;">编号</mark>。</li><li>和 H 图中每个方框相对应，应该有一张 <mark style="background: #FF5582A6;">IPO 图</mark>，<mark style="background: #FF5582A6;">描绘这个方框代表的模块的处理过程</mark>。模块在 H 图中的编号便于 追踪了解这个模块在软件结构中的位置</li><li>![[Pasted image 20230620183322.png]]</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2 软件结构设计准则</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.2-ruan-jian-jie-gou-she-ji-zhun-ze/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.2-ruan-jian-jie-gou-she-ji-zhun-ze/</url>
      
        <content type="html"><![CDATA[<ul><li>软件体系结构设计准则<ul><li>普通适用<ul><li>能够描述各种风格的软件系统结构，可以高效地处理多种多样的个体需求。</li></ul></li><li>在一定的时间内保持稳定<ul><li>确保接口一致，既能确保某一体系结构配置描述内相关接口描述的一致，又能确保建立关联的两个构件接口描述的一致性。</li></ul></li><li>普通、高效和稳定</li></ul></li><li>软件模块设计准则<ol><li>降低模块之间的耦合性，提高模块的内聚性；<ul><li>通过模块分解或合并，降低耦合提高内聚。</li></ul></li><li>模块结构的深度、宽度、扇出和扇入应<mark style="background: #FF5582A6;">适当</mark>；<ul><li><mark style="background: #FF5582A6;">深度</mark>：软件结构中模块的层数；<ol><li>标识系统的规模和复杂程度。</li></ol></li><li><mark style="background: #FF5582A6;">宽度</mark>：软件结构中同一层次上模块的最大个数。<ol><li>宽度越大的系统越复杂</li></ol></li><li><mark style="background: #FF5582A6;">扇出</mark>：一个模块直接调用的模块数目。<ol><li>扇出过大意味着模块过分复杂；</li><li>扇出过小意味着功能过度集中；</li><li>好的系统结构的平均扇出数一般是3-4，上限5-9。</li></ol></li><li><mark style="background: #FF5582A6;">扇入</mark>：有多少个上级模块直接调用它。</li><li>不违背模块独立性的条件下，扇入越大越好。</li><li>一般设计的比较好的软件结构，顶层扇出高，中层扇出较少，底层模块有高扇入。</li></ul></li><li>模块的作用范围应该在控制范围内；<ul><li>模块的作用范围：指受该模块内<mark style="background: #FF5582A6;">一个判断影响</mark>的所有模块的集合；</li><li>模块的控制范围：指<mark style="background: #FF5582A6;">模块本身以及其所有直接或者间接从属于它</mark>的模块集合；</li><li>在设计的好的软件结构中，<mark style="background: #FF5582A6;">所有受判断影响的模块都从属于作出判断的那个模块</mark>，最好局限于做出判定的那个模块本身及它的直属下级模块。</li></ul></li><li>模块接口设计要简单，以便降低复杂程度和冗余度；<ul><li>模块接口复杂是软件发生错误的一个主要原因，应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。</li></ul></li><li>设计功能可预测并能得到验证的模块；<ul><li>功能可预测：如果一个模块可以当作一个黑盒子，只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。</li><li>模块的功能应该能够预测，但也要防止模块功能过分局限。</li><li>![[Pasted image 20230608164807.png]]</li></ul></li><li>适当划分模块规模，以保持其独立性。<ul><li>经验表明，一个模块的规模不应过大，最好能写在一页纸内。通常规定50-100行语句，最多不超过500行。</li><li>过大的模块往往是由于分解不充分，但是进一步分解必须符合问题结构，一般说来，分解后不应该降低模块独立性。</li><li>过小的模块开销大于有效操作，而且模块数目过多将使系统接口复杂。</li><li>解决方法：<ol><li>进一步分解过大的模块</li><li>将频繁调用的小模块合并到上级模块中</li></ol></li></ul></li></ol><ul><li>以上介绍的软件结构设计准则是人们经过长期的软件开发实践总结出来的；</li><li>但是这些准则不是设计的目标，也不是在设计时必须普遍遵循的原理。</li><li>在实际应用时，应根据系统的大小、难易程度加以灵活应用</li></ul></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.3 软件设计的概念和原理</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.3-ruan-jian-she-ji-de-gai-nian-he-yuan-li/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.3-ruan-jian-she-ji-de-gai-nian-he-yuan-li/</url>
      
        <content type="html"><![CDATA[<ul><li>模块和模块化<ul><li>模块：软件结构的基础，是软件元素，是能够单独命名、独立完成一定功能的程序语句的集合。<ol><li>接口：给出可由其他模块访问的对象 (常量，变量，数据类型、函数)</li><li>实现：接口的实现（模块功能的执行机制）（私有、公有、保护变量，过程描述，源程序代码</li></ol></li><li>模块化：指解决一个复杂问题时自顶向下逐层把软件系统划分成若干模块的过程。<ol><li>50多年的历史</li><li>软件的单个属性，使得程序能够被理性的管理</li></ol></li><li>模块化思想：即把软件划分为多个可独立命名和访问的部件，每个部件称为一个模块，当把所有模块组装到一起时则获得满足问题需要的一个解。</li><li>为什么要模块化？<ol><li>模块化是为了使一个复杂的大型程序能被人的智力所管理；</li><li>如果一个大型程序仅由一个整体组成，它将很难被人所理解。使用多个模块。</li></ol></li><li>模块化的作用：<ol><li>采用模块化原理可以使软件结构清晰，不仅容易设计也容易阅读和理解；</li><li>模块化使软件容易测试和调试，因而有助于提高软件的可靠性；</li><li>模块化能够提高软件的可修改性；</li><li>模块化也有助于软件开发工程的组织管理。</li></ol></li><li>模块划分的准则：<ol><li><mark style="background: #FF5582A6;">模块可分解性</mark>：分解为子问题，降低整个系统的复杂性。注意不能过度分解。</li><li><mark style="background: #FF5582A6;">模块的组装性</mark>：设计的模块能够组装到系统中，并能够在其他系统中复用。</li><li><mark style="background: #FF5582A6;">模块的可理解性</mark>：模块设计要易于构造和修改。</li><li><mark style="background: #FF5582A6;">模块连续性</mark>：系统需求的微小变化只是导致单个模块、而不是整个系统的都要修改。把修改引起的副作用最小化。</li><li><mark style="background: #FF5582A6;">模块保护</mark>：模块内部出现异常情况，这种影响只是局限于模块内部，对外部的影响要尽可能小。</li></ol></li></ul></li><li>抽象<ul><li><mark style="background: #FF5582A6;">抽象</mark>是人类认识自然界中的复杂事物和复杂现象过程中使用的一种思维工具。</li><li>抽象：现实世界中一定事物、状态或过程之间总存在某些<mark style="background: #FF5582A6;">相似</mark>的或者<mark style="background: #FF5582A6;">共性</mark>的方面，把这些相似的方面集中或概括起来，暂时忽略它们之间的次要因素，这就是抽象。</li><li>在模块化问题求解时，可以在<mark style="background: #FF5582A6;">不同层次</mark>上进行抽象 。</li><li>软件工程的抽象过程：<ol><li>软件工程过程的每一步都是对软件解法的抽象层次的一次精化。</li><li>在可行性研究阶段，软件作为系统的一个完整部件。</li><li>在需求分析期间，软件解法是使用在问题环境内熟悉的方式描述的；</li><li>当由总体设计向详细设计过渡时，抽象的程度也随之减少了；</li><li>最后，当源程序写出来以后，也就达到了抽象的最底层。</li></ol></li><li>抽象与逐步求精<ol><li>“逐步求精”是与“抽象”密切相关的一个概念。是一种自顶向下设计的策略。</li><li>“逐步求精” 主要思想是，针对某个功能的宏观描述用逐步求精的方法不断地分解，逐步确立过程细节，直至该功能用程序语言描述的算法实现为止。求精的每一步都是用更为详细的描述代替上一层次的抽象描述。</li><li>在软件设计过程中，抽象与逐步求精一般结合起来进行应用。在建立较高层次的抽象模型后，对其进行求精得到更加具体的抽象模型，然后再进行精化，由此一直到达最终的软件实现。</li><li>系统的层次结构的上一层是下一层的抽象，下一层是上一层的求精。</li></ol></li></ul></li><li>信息隐蔽和局部化<ul><li>信息隐蔽：应该这样设计和确定模块，使得一个模块内包含的信息（过程和数据）对于不需要这些信息的模块来说，是不能访问的。</li><li>局部化：和信息隐蔽的概念密切相关，它是指把一些关系密切的软件元素物理地放的彼此靠近。显然，局部化有助于实现信息隐藏。</li><li>信息隐藏<mark style="background: #FF5582A6;">优点</mark><ol><li><mark style="background: #FF5582A6;">开发活动更加简单</mark>：开发人员只需要专注于本模块的开发，需要的数据可以由其他模块得到，处理好的数据也可以通过接口传给其他模块。每个模块的开发人员所要处理的复杂性显著降低。</li><li><mark style="background: #FF5582A6;">支持模块的并行开发</mark>：开发人员只需事先约定好接口设计（接口类型、参数、数据传输方向等），就可以按照设计独立开发自己负责的接口。</li><li><mark style="background: #FF5582A6;">减少测试和维护的工作量</mark>：因为模块之间信息是隐藏的，可以对每个模块单独测试、维护，测试发现只需在本模块修改</li></ol></li></ul></li><li>模块独立性及其度量<ul><li>模块独立的重要性：<ol><li>模块的独立性要求：每个模块完成一个相对独立的特定子功能，并且和其他模块之间的关系很简单。</li><li>有效模块化的软件比较容易开发出来。当许多人分工合作开发同一个软件时，这个优点尤其重要。</li><li>独立的模块比较容易测试和维护。这是因为相对说来，修改设计和程序需要的工作量比较小，错误传播范围小，需要扩充功能时能够“插入”模块。</li></ol></li><li>系统模块化设计，尽量使每个模块应相对独立，其功能相对单一，而模块之间的接口应尽可能简单。</li><li>模块的独立性可以从两个方面来度量：<ol><li><mark style="background: #FF5582A6;">耦合</mark>衡量<mark style="background: #FF5582A6;">不同模块彼此间</mark>相互依赖的紧密程度。耦合要低，即每个模块和其他模块之间的关系要简单。</li><li><mark style="background: #FF5582A6;">内聚</mark>衡量一个<mark style="background: #FF5582A6;">模块内部各个元素之间</mark>彼此结合的紧密程度的度量。 内聚要高，每个模块完成一个相对独立的特定子功能。</li><li>追求<mark style="background: #FF5582A6;">高内聚</mark>、<mark style="background: #FF5582A6;">低耦合</mark>。</li></ol></li><li>耦合<ol><li>![[Pasted image 20230618150333.png]]</li><li>耦合的强度所依赖的因素：<ul><li>一个模块对另一模块的引用</li><li>一个模块向另一个模块传递的数据量</li><li>一个模块施加到另一个模块的控制的数量</li><li>模块之间接口的复杂程度</li></ul></li><li>耦合等级的划分（由弱到强）<ul><li>低等级耦合：非直接耦合，两模块中任一个都不依赖对方能独立工作；</li><li>中等级耦合<ol><li>数据耦合，两个模块间通过参数交换信息，而且信息仅限于数据；</li><li>标记耦合，两个模块之间传递的是数据结构，而且被调用模块不需要作为参数传递过来的整个数据结构，只需要部署结构其中一部分数据元素；</li><li>控制耦合，一个模块向另一模块传递一个控制信号，接受控制信号的模块将依据该信号至进行必要的活动；</li><li>公共耦合，若干模块通过全局的数据环境相互作用；</li></ol></li><li>高级耦合：内容耦合，一个模块使用另一个模块内部的数据或控制信息 ；一个模块直接转移到另一个模块内部等</li></ul></li></ol><ul><li>尽量使用数据耦合，减少控制耦合，限制公共耦合，杜绝内容耦合。</li><li>耦合程度的度量<ol><li><mark style="background: #FF5582A6;">无直接耦合</mark><ul><li>如果两个模块中的每一个都能独立地工作而不需要另一个模块的存在，那么它们完全独立。</li><li>在一个软件系统中不可能所有模块之间都没有任何连接。</li></ul></li><li><mark style="background: #FF5582A6;">数据耦合</mark><ul><li>如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。</li><li>评价：<ol><li>系统中至少必须存在这种耦合。一般说来，一个系统内可以只包含数据耦合。</li><li>数据耦合是理想的目标。</li><li>维护更容易，对一个模块的修改不会使另一个模块产生退化错误。</li></ol></li></ul></li><li><mark style="background: #FF5582A6;">标记耦合</mark><ul><li>当把整个数据结构作为参数传递，而被调用的模块只需要使用其中一部分元素时，就出现了特征耦合（标记）。</li><li>评价：<ol><li>被调用的模块可使用的数据多于它确实需要的数据，这将导致对数据的访问失去控制。</li><li>无论何时把指针作为参数进行传递，都应该仔细检查该耦合。</li></ol></li></ul></li><li><mark style="background: #FF5582A6;">控制耦合</mark></li><li><mark style="background: #FF5582A6;">公共环境耦合</mark><ul><li>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区 、任何存储介质上的文件、物理设备等。</li><li>公共环境耦合的类型：<ol><li>一个模块往公共环境送数据，另一个模块从公共环境取数据。数据耦合的一种形式，是比较松散的耦合。</li><li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li><li>![[Pasted image 20230618152544.png]]</li></ol></li></ul></li><li><mark style="background: #FF5582A6;">内容耦合</mark><ul><li>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块之间就发生了内容耦合：</li><li>一个模块访问另一个模块的内部数据；</li><li>一个模块不通过正常入口转到另一个模块的内部</li><li>两个模块有一部分程序代码重叠；</li><li>一个模块有多个入口</li></ul></li></ol></li></ul></li><li>内聚<ol><li><mark style="background: #FF5582A6;">内聚</mark>：标志一个模块内各个元素彼此结合的紧密程度，它 是信息隐藏和局部化概念的自然扩展。简单地说，理想内 聚的模块只做一件事。</li><li><mark style="background: #FF5582A6;">要求</mark>：<ul><li>设计时应该力求做到高内聚，通常中等程度的内聚也可以采用 的，而且效果和高内聚相差不多；但是，低内聚不要使用。</li><li>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间 的松耦合。实践表明内聚更重要，应该把更多注意力集中到提 高模块的内聚程度上。</li></ul></li><li>好的设计满足：<ul><li>模块的功能单一</li><li>模块的各部分都和模块的功能直接相关</li><li>高内聚</li></ul></li><li>内聚划分为不同等级，内聚度越高越好。（由低到高）<ul><li>低级内聚：<ol><li>偶然内聚：模块内各成分之间没有关系，即使有关系，也很松散</li><li>逻辑内聚：模块完成的任务在逻辑上相关。</li><li>时间内聚：一个模块包含的多个任务必须在同一时间内执行。而这 些功能只是因为时间因素关联在一起</li></ol></li><li>中等级内聚：<ol><li>过程内聚：处理成分必须以特定的次序执行</li><li>通信内聚：模块中各成分都将对数据结构的同一区域进行操作</li></ol></li><li>高级内聚：<ol><li>顺序内聚：各成分均与同一功能相关，且一个成分的输出作为另一 个成分的输入。</li><li>功能内聚：所有成分形成一个整体，完成单个功能。而且这些成分 对完成该功能而言是充分必要的。<mark style="background: #FF5582A6;">最高等级的内聚</mark></li></ol></li><li>![[Pasted image 20230618170205.png]]</li><li>内聚<ol><li>偶然内聚<ul><li>如果一个模块完成一组任务，这些任务彼此间即 使有关系，关系也是很松散的，就叫偶然内聚</li><li>评价：<ol><li>模块内各元素之间没有实质性联系，很可能在一 种应用场合需要修改这个模块，在另一种应用场合又 不允许这种修改，从而陷入困境</li><li>可理解性差，可维护性产生退化。</li><li>模块是不可重用的</li></ol></li><li>解决方案.：将模块分成更小的模块，每个小模块执行一个操作</li></ul></li><li>逻辑内聚<ul><li>如果一个模块完成的任务在逻辑上属于相同或类 似的一类，则称为逻辑内聚</li><li>评级：<ol><li>接口难以理解，造成整体上不易理解。</li><li>完成多个操作的代码互相纠缠在一起，即使局部 功能的修改有时也会影响全局，导致严重的维护问题</li><li>难以重用</li></ol></li><li>解决方案：模块分解</li></ul></li><li>时间内聚<ul><li>如果一个模块包含的任务必须在同一段时间内执 行，就叫时间内聚，如初始化模块。</li><li>评价：<ol><li>时间关系在一定程度上反映了程序某些实质，所 以时间内聚比逻辑内聚好一些。</li><li>模块内操作之间的关系很弱，与其他模块的操作 却有很强的关联</li><li>时间内聚的模块不太可能重用</li></ol></li></ul></li><li>通信内聚<ul><li>如果模块中所有元素都使用同一个输入数据和 （或）产生同一个输出数据，则称为通信内聚，即在 同一个数据结构上操作</li><li>评价：<ol><li>模块中各操作紧密相连，比过程内聚更好</li><li>不能重用。</li></ol></li><li>解决方案：将模块分成多个模块，每个模块执行一个操作。</li></ul></li><li>顺序内聚<ul><li>如果一个模块内的处理元素和同一个功能密切相 关，而且这些处理必须顺序执行，则称为顺序内聚。</li><li>评价：<ol><li>根据数据流图划分模块时，通常得到顺序内聚的 模块，这种模块彼此间的连接往往比较简单</li></ol></li></ul></li><li>功能内聚<ul><li>如果模块内所有处理元素属于一个整体，完成一 个单一的功能，则称为功能内聚。功能内聚是最高程 度的内聚。</li><li>评价：<ol><li>模块可重用，应尽可能重用。</li><li>可隔离错误，维护更容易。</li><li>扩充产品功能时更容易</li></ol></li></ul></li></ol></li></ul></li><li><mark style="background: #FF5582A6;">结论</mark>：<ol><li>在设计软件时，尽可能做到高内聚。</li><li>偶然内聚、逻辑内聚和时间内聚属于低内聚， 通信内聚属于中内聚，顺序内聚和功能内聚属于高内聚</li></ol></li></ol></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1 软件总体设计的目标和任务</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.1-ruan-jian-zong-ti-she-ji-de-mu-biao-he-ren-wu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/4-ruan-jian-zong-ti-she-ji/4.1-ruan-jian-zong-ti-she-ji-de-mu-biao-he-ren-wu/</url>
      
        <content type="html"><![CDATA[<ul><li>总体设计阶段的基本目标和任务：系统应该如何实现？划分出组成系统的物理元素，比如程序、文件、数据库等。</li><li>总体设计的其他任务：设计软件的总体结构<ol><li>确定系统中的每个程序是由哪些模块组成的。</li><li>每个模块的功能。</li><li>模块和模块之间的接口、调用关系等。</li></ol></li><li>典型的总体设计过程包括以下9个步骤：<ol><li>设想供选择的方案<ul><li>根据需求分析阶段得出的数据流图，考虑各种可能的实现方案，力求从中选出最佳方案。</li></ul></li><li>选取合理的方案<ul><li>从前一步得到的一系列供选择的方案中选取若干个合理的方案。</li></ul></li><li>推荐最佳方案<ul><li>分析员应该综合分析对比各种合理方案的利弊，推荐一个最佳的方案，并且为推荐的方案制定详细的实现计划。</li></ul></li><li>功能分解<ul><li>首先进行结构设计，然后进行过程设计。</li><li>结构设计确定程序由哪些模块组成，以及这些模块之间的关系；过程设计确定每个模块的详细设计处理过程。</li><li>结构设计是总体设计阶段的任务，过程设计是详细设计阶段的任务。</li></ul></li><li>设计软件结构<ul><li>通常程序中的一个模块完成一个适当的子功能。应当把模块组织成良好的层次系统。软件结构可以用层次图或结构图来描述。</li><li>如果数据流图已经细化到适当的层次，则可以直接从数据流图映射出软件结构，这就是面向数据流的设计方法。</li></ul></li><li>设计数据库<ul><li>对于需要使用数据库的应用系统，软件工程师应该在需求分析阶段所确定的系统数据需求的基础上，进一步涉及数据库。</li></ul></li><li>制定测试计划<ul><li>在软件开发的早期阶段考虑测试问题，能促使软件设计人员在设计时注意提高软件的可测试性。</li></ul></li><li>书写文档<ul><li>应该用正式的文档记录总体设计的结果。</li></ul></li><li>审查和复审<ul><li>最后应该对总体设计的结果进行严格的技术审查和管理复审。</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.7 数据库内容的需求分析和描述</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.7-shu-ju-ku-nei-rong-de-xu-qiu-fen-xi-he-miao-shu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.7-shu-ju-ku-nei-rong-de-xu-qiu-fen-xi-he-miao-shu/</url>
      
        <content type="html"><![CDATA[<ul><li>数据库内容的需求分析<ul><li>数据库需求分析的任务是调查、收集、分析并定义用户对数据库的各种要求，是整个数据库设计的基础和起点.</li><li>该阶段的需求工作主要从以下三个方面进行：<ol><li>信息需求：指需要从数据库中获得的信息的内容和性质</li><li>处理需求：指用户要求系统完成的功能、处理时间、方式等</li><li>使用需求：包括数据库的安全性、完整性、一致性等限制； 输入&#x2F;输出格式和多用户方面的限制等； 响应速度、故障回复等性能要求；</li></ol></li><li>本章前面几节所介绍的需求获取和需求分析的方法对于软件系统的数据需求一样适用.</li><li>在需求分析基础上，对新系统中数据的逻辑模型通常采用实体—联系（Entity-Relationship, E-R）图来描述。</li><li>该阶段的需求工作主要包含2个步骤：<ol><li>建立各局部应用的E-R模型</li><li>建立全局E-R模型</li></ol></li></ul></li><li>数据库内容的需求分析描述<ul><li>用画图方式表示的E-R模型称为E-R图，E-R模型的各类元素在E-R图中用不同形状的结点表示。 构成E-R图的基本要素是实体、属性和联系，其表示方法为<ol><li><mark style="background: #FF5582A6;">数据对象（实体）</mark>：客观世界中存在的且可区分的事物,用<mark style="background: #FF5582A6;">矩形框</mark>代表实体；</li><li><mark style="background: #FF5582A6;">联系</mark>：客观事物之间的联系（三类1：1，1：N，M:N）,用连接相关实体的<mark style="background: #FF5582A6;">菱形框</mark>表示关系；<br>  3.<mark style="background: #FF5582A6;"> 属性</mark>：实体或联系所具有的性质，用<mark style="background: #FF5582A6;">椭圆形</mark>或<mark style="background: #FF5582A6;">圆角矩形</mark>表示实体的属性。并直线把实体或联系与其属性连接起来。</li></ol></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.8 需求规格说明书的撰写</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.8-xu-qiu-gui-ge-shuo-ming-shu-de-zhuan-xie/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.8-xu-qiu-gui-ge-shuo-ming-shu-de-zhuan-xie/</url>
      
        <content type="html"><![CDATA[<ul><li>需求规格说明书的主要内容应该包括以下几项：<ol><li>引言：编写目的、项目背景、定义、参考资料；</li><li>任务概述：目标、运行环境、条件与约束；</li><li>数据描述：静态数据、动态数据、数据库描述、数据字典等；</li><li>功能需求：功能划分、功能描述；</li><li>性能需求：数据精确度、时间特性、适应性；</li><li>运行需求：用户界面、硬件接口、软件接口、故障处理；</li><li>其它需求：包括可使用性、安全保密性、可维护性和可移植性等；</li><li>![[Pasted image 20230607173341.png]]</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.5 需求分析图形工具</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.5-xu-qiu-fen-xi-tu-xing-gong-ju/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.5-xu-qiu-fen-xi-tu-xing-gong-ju/</url>
      
        <content type="html"><![CDATA[<ul><li>层次方框图：<ol><li>层次方框图：用树形结构的一系列多层次的矩形框描述数据的层次结构；</li><li>树形结构的顶层是一个单独的矩形框，它代表完整的数据结构；</li><li>下面的各层矩形框代表这个数据的子集；</li><li>最底层的各个框代表组成这个数据的实际数据元素（不能再分割的元素）。</li><li>![[Pasted image 20230605153117.png]]</li></ol></li><li>Warnier图：<ol><li>Warnier图：和层次方框图类似，Warnier图也用树形结构描述信息，但是这种图形工具比层次方框图提供了更丰富的描述手段；</li><li>特点：用Warnier图可以表明信息的逻辑组织，也可以表示特定信息在某一类信息中是有条件地出现的。因为重复和条件约束是说明软件处理过程的基础，所以很容易把Warnier图转变成软件设计的工具。</li><li>![[Pasted image 20230605153157.png]]</li></ol></li><li>IPO图：<ol><li>IPO图：是<mark style="background: #FF5582A6;">输入</mark>、<mark style="background: #FF5582A6;">处理</mark>、<mark style="background: #FF5582A6;">输出图</mark>的简称，它是美国IBM公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。</li><li>基本形式：是在左边的框中列出有关的输入数据，在中间的框中列出主要的处理，在右边的框中列出产生的输出数据。在IPO图中还用箭头清楚地指出数据通信的情况。</li><li>![[Pasted image 20230605153251.png]]</li></ol></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.6 SA方法的应用</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.6-sa-fang-fa-de-ying-yong/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.6-sa-fang-fa-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<ul><li>建立系统的功能模型<ol><li>使用的工具为数据流图DFD</li><li>首先：建立系统环境图（顶层数据流图），确定系统边界</li><li>继之：自顶向下，逐步求精，建立系统的层次数据流图</li></ol></li><li>建立数据字典<ol><li>使用的工具为结构符：+、|、{} 等</li><li>定义数据流、数据存储、数据项</li></ol></li><li>给出加工小说明：集中描述一个加工“做什么”，即加工逻辑，也包括其他一些与加工有关的信息，如执行条件、优先级、执行频率、出错处理等</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.3 需求分析的常用方法</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.3-xu-qiu-fen-xi-de-chang-yong-fang-fa/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.3-xu-qiu-fen-xi-de-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<ul><li>功能分解方法<ol><li>该方法将一个系统看成是由若干功能构成的一个集合，每个功能又可划分若干个子功能（加工），一个子功能又进一步分解成若干个子功能（即加工步骤）。这样，功能分解方法有<mark style="background: #FF5582A6;">功能</mark>、<mark style="background: #FF5582A6;">子功能</mark>和<mark style="background: #FF5582A6;">功能接口</mark>三个组成要素。</li><li>把软件需求当作一棵倒置的功能树，每个结点都是一项具体的功能，从树根往下，功能由粗到细，树根是总功能，树枝是子功能，树叶是子功能，整棵树就是一个信息系统的全部功能树。</li><li>功能分解法体现了“<mark style="background: #FF5582A6;">自顶向下</mark>，<mark style="background: #FF5582A6;">逐步求精</mark>”的思想</li><li>该方法<mark style="background: #FF5582A6;">难以适应用户的需求变化</mark></li></ol></li><li>结构化分析方法<ol><li>结构化分析方法是一种从问题空间到某种表示的映射方法，是<mark style="background: #FF5582A6;">面向数据流</mark>进行需求分析的方法，软件功能由数据流图表示，是结构化方法中重要的、被普遍采用的方法，它由<mark style="background: #FF5582A6;">数据流图</mark>和<mark style="background: #FF5582A6;">数据字典</mark>构成系统的逻辑模型。</li><li>该方法使用简单，主要适用于数据处理领域问题。</li><li><mark style="background: #FF5582A6;"> 适合于传统软件工程思想</mark></li></ol></li><li>信息建模方法<ol><li>信息建模方法是从<mark style="background: #FF5582A6;">数据</mark>的角度来对现实世界建立模型的。</li><li>该方法基本工具是<mark style="background: #FF5582A6;">实体-联系图（E-R图）</mark>，由<mark style="background: #FF5582A6;">实体</mark>、<mark style="background: #FF5582A6;">属性</mark>和<mark style="background: #FF5582A6;">联系</mark>构成。</li><li>在信息模型中，实体是一个对象或一组对象。实体把信息收集在其中，关系是实体之间的联系或交互作用。</li></ol></li><li>面向对象方法<ol><li>面向对象的分析是把<mark style="background: #FF5582A6;">实体联系图中的概念</mark>与面向对象程序设计语言中的概念结合在一起形成的一种分析方法。面向对象分析的关键是识别、定义问题域内的<mark style="background: #FF5582A6;">类与对象（实体）</mark> ，并分析它们之间的关系，根据问题域中的操作规则和内存性质建立模型。</li><li>在该方法中采用了实体、关系和属性等信息模型分析中的概念，同时采用了封闭、类结构和继承性等面向对象程序设计语言中的概念。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.4 结构化分析方法</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.4-jie-gou-hua-fen-xi-fang-fa/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.4-jie-gou-hua-fen-xi-fang-fa/</url>
      
        <content type="html"><![CDATA[<ul><li>定义<ol><li>结构化分析（Structured Analysis简称SA）是面向<mark style="background: #FF5582A6;">数据流</mark>的需求分析方法，是20世纪70年代后期由Yourdon，Constantine及DeMarco等人提出和发展，并得到广泛的应用。</li><li>T·DeMarco：结构化分析就是使用<mark style="background: #FF5582A6;">数据流图</mark>、<mark style="background: #FF5582A6;">数据字典</mark>、<mark style="background: #FF5582A6;">结构化语言</mark>、<mark style="background: #FF5582A6;">判定树</mark>和<mark style="background: #FF5582A6;">判定表</mark>等工具，来建立一种新的称为结构化说明书的目标文档。</li></ol></li><li>自顶向下逐层分解的分析策略<ol><li>对于复杂的大项目，传统的策略是把复杂的问题“化整为零，各个击破”，这就是我们通常所说的“<mark style="background: #FF5582A6;">分解</mark>”。 </li><li>SA方法采用分解策略，把一个复杂庞大的问题分解成若干个小问题，然后再分别解决。 </li><li>分解可<mark style="background: #FF5582A6;">分层进行</mark>，要根据系统的逻辑特性和系统内部各成分之间的逻辑关系进行分解。在分解中要充分体现“<mark style="background: #FF5582A6;">抽象</mark>”的原则，逐层分解中的上一层就是下一层的抽象。</li></ol></li><li>结构化分析描述工具<ol><li>结构化分析方法目前的描述方法可划分成非形式化、半形式化和形式化三类。</li><li>利用图形等半形式化的描述方法表达需求的工具主要有：<ul><li><mark style="background: #FF5582A6;">数据流图</mark>：结构化建模的工具；</li><li><mark style="background: #FF5582A6;">数据字典</mark>：关于数据信息的集合，用于定义数据流图中的数据和加工；</li><li>描述加工逻辑的<mark style="background: #FF5582A6;">结构化语言</mark>、&lt;mark </li><li>style&#x3D;”background: #FF5582A6;”&gt;判定表</mark>和<mark style="background: #FF5582A6;">判定树</mark>等。</li></ul></li></ol></li><li>数据流图<ul><li>数据流图（Data Flow Diagram，DFD）是一种图形化技术，用于表示系统<mark style="background: #FF5582A6;">逻辑模型</mark>，它以直观的图形清晰地描述了系统数据的流动和处理过程。是分析员与用户之间极好的通信工具。</li><li>DFD 图中没有任何具体的物理元素，它只是描述数据在软件中流动和被处理的逻辑过程。</li><li><mark style="background: #FF5582A6;">源点或者终点</mark>：通常是系统<mark style="background: #FF5582A6;">之外</mark>的实体，可以是人、物或其他软件系统 ；一般只出现在数据流图的顶层图中。通过源点或者终点可以划分问题的范围，确定系统的边界。</li><li><mark style="background: #FF5582A6;">加工</mark>：是对数据进行处理的单元，一个处理框可以代表一系列程序、单个程序或程序的一个模块；每个加工的名字通常是动词短语，简明地描述完成什么处理。在分层的数据流图中，处理还应有编号。编号说明这个处理在层次分解中的位置。（体现了系统的功能，是对系统功能的抽象）</li><li><mark style="background: #FF5582A6;">数据流</mark>：是数据在系统内传播的路径（数据的流向），由一组固定的数据项组成。描述所有可能的数据流向，而不应该描绘出现某个数据流的条件；数据流应该用名词或名词短语命名。</li><li><mark style="background: #FF5582A6;">数据存储</mark>：用来存储数据，可以表示一个文件、文件的一部分、数据库的元素或者记录的一部分等 ，要考虑以什么样的机制存储数据。流向数据存储的数据流可理解为写入文件，或查询文件，从数据存储流出的数据可理解为从文件读数据或得到查询结果。</li><li>数据流图 4 种基本符号<ul><li>数据流、数据存储：支持数据抽象（动态、静态）。</li><li>加工：支持过程&#x2F;功能的抽象，用于表达系统内涵。</li><li>数据源、数据潭（终点）：支持系统边界抽象，用于表达系统外延。</li><li>用这4种基本符号，可以组成完备的数据流图。</li></ul></li><li>画数据流图的基本原则:<ol><li>数据流图中所有的符号必须是前面所述的四种基本符号和附加符号； </li><li>数据流图的主图（顶层）必须含有前面所述的四种符号，缺一不可； </li><li>数据流图主图上数据流必须封闭在外部实体之间。（外部实体可以是一个，也可以是多个）； </li><li>加工（变换数据处理）<mark style="background: #FF5582A6;">至少有一个输入数据流和一个输出数据流</mark>，反映出此加工数据的来源与加工的结果；</li><li>任何一个数据流子图必须与他父图上的一个加工相对应，父图中有几个加工，就可能有几张子图，两者的输入数据流和输出数据流必须一致，即所谓“<mark style="background: #FF5582A6;">平衡</mark>”；</li><li>图上的每个元素都必须有名字（流向数据存储或从数据存储流出的数据流除外）。</li></ol></li><li>画数据流图的步骤 ：<ol><li>先找<mark style="background: #FF5582A6;">外部实体</mark>（可以是人、物或其他软件系统），找到了外部实体，则系统与外部世界的界面就得以确定，系统的源点和终点也就找到了；</li><li>找出外部实体的<mark style="background: #FF5582A6;">输入和输出数据流</mark>；</li><li>在图的边上画出系统的外部实体；</li><li>从外部实体的<mark style="background: #FF5582A6;">输出流（源点）</mark>出发，按照系统的逻辑需要，逐步画出<mark style="background: #FF5582A6;">一系列变换数据的加工</mark>，直到找到外部实体处所需的<mark style="background: #FF5582A6;">输入流（终点）</mark>，形成数据流的封闭；</li><li>按照上述原则进行检查和修改。</li><li>最后按照上述步骤画出所有子图。</li></ol></li><li>画数据流图的注意事项：<ol><li>画数据流图时，只考虑数据流的静态关系，不考虑其动态关系（如启动、停止等与时间有关的问题），也不考虑出错处理问题。</li><li>画数据流图时，只考虑常规状态，不考虑异常状态，这两点一般留在设计阶段解决。</li><li>画数据流图不是画程序流程图，二者有本质的区别。数据流图只描述“做什么”，不描述“怎么做”和做的顺序。而程序流程图表示对数据进行加工的控制和细节。</li><li>不能期望数据流图一次画成，而是要经过各项反复才能完成。</li><li>描绘复杂系统的数据流图通常很大，对于画在几张纸上的图很难阅读和理解。一个比较好的方法是分层的描绘这个系统。在分层细画时，必须保持星系的持续性，父图和子图要平衡；每次只细画一个加工。</li></ol></li><li>画数据流图的用途：<ol><li>基本目的是利用它作为交流信息的工具<ul><li>供有关人员审查确认；</li><li>供用户理解和评价；</li></ul></li><li>另一个用途是作为分析和设计的工具；<ul><li>描述系统所完成的功能</li><li>辅助物理系统的设计时，以定时要求为指南，画出许多组自动化边界，对应不同的物理系统</li></ul></li></ol></li></ul></li><li>数据字典<ul><li>数据字典（Data Dictionary，DD）是关于数据的信息的集合，也就是对数据流图中所包含元素的定义的集合。 用于定义数据流和数据存储的结构，并给出构成所给出的数据流和数据存储的各数据项的基本数据类型。</li><li><mark style="background: #FF5582A6;">数据流图</mark>和<mark style="background: #FF5582A6;">数据字典</mark>共同构成系统的<mark style="background: #FF5582A6;">逻辑模型</mark>。</li><li>数据字典的内容：<ol><li>数据流：系统中数据的逻辑流向</li><li>数据流分量（数据基本项、数据项）：数据流分量是组成数据流和数据存储的最小单位项；</li><li>数据存储（文件）</li><li>加工（处理）</li><li>源点和终点是为了帮助理解系统和外界接口而列入的，不在系统之内，故一般不在字典中说明。</li></ol></li><li>数据字典的使用符号：<ol><li>&#x3D; 表示被定义为或等价于或由……组成；</li><li>＋ 表示“与”（和），用来连接两个数据元素；<ul><li>例：X &#x3D; a + b 表示 X 被定义为 a 和 b 组成。</li></ul></li><li>[…|…] 表示“或”，对[ ]中列举的数据元素可任选其中某一项；<ul><li>例：X &#x3D; [a | d] 表示 X 由 a 或 d 组成。</li></ul></li><li>{…} 表示“重复”，对{…}中内容可以重复使用；<ul><li>例：X &#x3D; {a} 表示 X 由零个或 n 个 a 组成。</li></ul></li><li>m{…|…}n 表示{…}中内容至少出现 m 次，最多出现 n 次。其中 m，n 为重复次数的上、下限；<ul><li>例：X&#x3D;2{B}6 表示X中至少出现 2 次 B，最多出现 6 次 B。</li></ul></li><li>（…） 表示“可选”，对（…）中的内容可选、可不选；</li></ol></li><li>数据字典举例<ol><li><mark style="background: #FF5582A6;">数据流</mark>表明系统中数据的逻辑处理和流向，可以是数据项或数据结构，包括：<ul><li>数据流的名称及编号；</li><li>简述；</li><li>数据流的来源；</li><li>数据流的去向；</li><li>数据流的组成；</li><li>数据流的流通量；</li><li>高峰期流通量。</li></ul></li><li><mark style="background: #FF5582A6;">数据项</mark>也称数据元素，具有独立逻辑含义的最小数据单位。在数据字典中对其定义包括：<ul><li>数据项的名称、编号、别名、简述；</li><li>数据项的取值范围；</li><li>数据项的长度。</li></ul></li><li><mark style="background: #FF5582A6;">处理逻辑(加工)</mark>：仅对数据流程图 (DFD) 中最底层的处理逻辑加以说明，包括：<ul><li>处理逻辑名称及编号；</li><li>简述；</li><li>输入；</li><li>处理过程；</li><li>输出；</li><li>处理频率</li></ul></li><li><mark style="background: #FF5582A6;">数据存储</mark>：数据流的暂停或永久保存的地方，包括：<ul><li>数据存储的编号；</li><li>名称；</li><li>简述；</li><li>组成；</li><li>关建字相关的处理</li></ul></li></ol></li></ul></li><li>加工逻辑的描述<ul><li>加工逻辑也称为“小说明”，是对数据流图中每个加工所作的说明。</li><li>描述加工“做什么”，即加工逻辑，也包括其他一些与加工有关的信息，如执行条件、优先级、执行频率、出错处理等。</li><li>描述加工逻辑一般用结构化语言、判定表和判定树。</li><li>结构化语言<ol><li>结构化语言介于自然语言与程序设计语言之间的语言；</li><li>它既有结构化程序的清晰易读的优点，又有自然语言简单易懂的优点</li></ol></li><li>结构化语言的特点<ol><li>关键字的固定语法，它提供了结构化控制结构、数据说明和模块化的特点。</li><li>自然语言的自由语法，它描述处理特点。</li><li>数据说明的手段。应该既包括简单的数据结构，有包括复杂的数据结构。</li><li>模块定义和调用技术，应该提供各种接口描述模式</li></ol></li><li>判定表<ol><li>当算法中包含多重嵌套的条件选择时，用程序流程图、盒图、PAD图或结构化语言都不易清楚地描述</li><li>判定表却能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</li></ol></li><li>一张判定表由4部分组成：<ol><li>左上部列出所有条件；</li><li>左下部是所有可能做的动作；</li><li>右上部是表示各种条件组合的一个矩阵；</li><li>右下部是和每种条件组合相对应的动作。</li></ol></li><li>判定树<ol><li>判定树是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系；</li><li>多年来判定树一直受到人们的重视，是一种比较常用的系统分析和设计的工具。</li><li>![[Pasted image 20230605152524.png]]</li></ol></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1 需求分析的任务和步骤</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.1-xu-qiu-fen-xi-de-ren-wu-he-bu-zou/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.1-xu-qiu-fen-xi-de-ren-wu-he-bu-zou/</url>
      
        <content type="html"><![CDATA[<ul><li>需求分析的任务<ul><li>定义<ol><li>需求分析的任务<mark style="background: #FF5582A6;">不是</mark>确定系统怎样完成它的工作；<mark style="background: #FF5582A6;">是</mark>确定系统必须完成哪些工作，也就是——对目标系统提出完整、准确、清晰而且具体的需求。</li><li>需求分析实际上是一个对用户意图不断进行揭示和判断的过程，它并不考虑系统地具体实现，而且完整地、严密地描述应当“<mark style="background: #FF5582A6;">做什么</mark>“的一种过程。</li></ol></li><li>需求分析阶段的具体任务包括<ol><li>确定对系统的综合需求<ul><li>功能需求：所开发软件系统必须提供的服务，划分出系统必须完成的所有功能。</li><li>性能需求：所开发软件的技术性能指标，比如存储容量、响应时间等。</li><li>环境需求：软件运行时所需要的软、硬件的需求。</li><li>接口需求：描述应用系统与它的环境通信的格式。</li><li>用户界面需求：人机交互方式、输入&#x2F;输出数据格式等。</li><li>其它需求，包括可靠性、安全性、保密性、可以执行等方面的需求。</li></ul></li><li>分析系统的数据需求<ul><li>建立数据模型——实体联系图（ER图）。</li><li>描述数据结构——层次方框图和Warnie图。</li></ul></li><li>建立软件的逻辑模型<ul><li>综合上述两项分析的结果可以确定系统的逻辑模型，通常用<mark style="background: #FF5582A6;">数据流图</mark>、<mark style="background: #FF5582A6;">数据字典</mark>、<mark style="background: #FF5582A6;">实体-联系图</mark>和<mark style="background: #FF5582A6;">主要的处理算法</mark>等描述目标系统的逻辑模型。</li></ul></li><li>编写软件需求规格说明书<ul><li>目的：明确定义目标系统的需求、系统构成及有关的接口</li><li>需求说明相当于用户与开发者之间的一份技术合同是测试验收阶段对软件进行确认和验收的基准</li></ul></li><li>需求分析评审<ul><li>评审的目的是发现需求分析的错误和缺陷，然后修改开发计划。</li></ul></li></ol></li><li>需求分析的步骤<ol><li>需求获取：调查研究；和用户沟通，确定系统的功能、性能</li><li>需求提炼：分析建模；对获取的信息进行抽象，转化为各种模型</li><li>需求描述：编写SRS（软件需求规格说明书）</li><li>需求验证：通过需求验证进行完善</li></ol></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2 需求获取的常用方法</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.2-xu-qiu-huo-qu-de-chang-yong-fang-fa/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/3-ruan-jian-xu-qiu-fen-xi/3.2-xu-qiu-huo-qu-de-chang-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<ul><li>需求获取的常用方法<ul><li>需求获取的常用方法<ol><li>自悟：角色转换</li><li>客户访谈（交谈）：分为正式的和非正式的两种基本形式</li><li>观察</li><li>建立联合分析小组：由用户、系统分析员、软件领域专家组成</li><li>问题分析与确认：多次和用户沟通，不断确认完善需求定义</li><li>提炼（复审）</li></ol></li><li>快速建立软件原型模型来获取需求<ol><li>在实际的软件开发中，快速原型法常常被用作一种有效的需求获取方法</li><li>第四代开发技术（4GT）是常用的快速原型工具</li><li>另外一种快速构件原型的方法是使用一组已有的正确的软件构件组装的方法来装配原型系统</li><li>快速建立软件原型<ul><li>快速建立软件原型是一种有效的需求获取方法。</li><li>快速原型的目的是尽快向用户提供一个演示目标系统主要功能的可运行的程序。</li></ul></li><li>快速原型的特性：<ul><li>“快速”。</li><li>“容易修改”：如果原型的第一版不是用户所需要的，就必须根据用户的意见迅速地修改它，构建出原型的第二版，以更好地满足用户需求。如果修改耗时过多，势必延误软件开发时间。</li><li>快速原型法基本思想: 在很短时间内建立起一个只包含基本数据库和一些基本功能的原型给用户使用,然后根据用户意见对原型进行修改,直到满意为止。</li><li>快速原型通常采用以下两种方法：<ol><li>第四代技术（4GT）<ul><li>第四代技术包括众多数据库查询和报表语言、程序和应用软件生成器以及其他非常高级的非过程语言。</li><li>第四代技术使得软件工程师能够快速地生成可执行的代码，它们是较理想的快速原型工具。</li></ul></li><li>可重用的软件构件<ul><li>另一种快速构建原型的方法是使用一组已有的软件构建来装配原型（而不是从头构造）。</li><li>软件构件可以是数据结构（或数据库），或软件体系结构构件（即程序），或过程构件（即模块）。</li></ul></li></ol></li></ul></li></ol></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.5  可行性研究报告的主要内容</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.5-ke-xing-xing-yan-jiu-bao-gao-de-zhu-yao-nei-rong/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.5-ke-xing-xing-yan-jiu-bao-gao-de-zhu-yao-nei-rong/</url>
      
        <content type="html"><![CDATA[<ul><li>不同的标准模板，可行性研究报告的格式各有不同，但主要内容应该包括以下几项： <ol><li>引言</li><li>可行性研究前提</li><li>对现有系统的分析</li><li>对所建设系统的分析：经济可行性、技术可行性、社会因素的可行性等</li><li>其他与设计有关选择方案</li><li>其他与设计有关的专门问题</li><li>结论意见</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3 系统流程图</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.3-xi-tong-liu-cheng-tu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.3-xi-tong-liu-cheng-tu/</url>
      
        <content type="html"><![CDATA[<ul><li>系统流程图的符号<ol><li>系统流程图符号中有五种基本符号是从程序流程图中借用来的（见图2.1），当以概括方式抽象描绘一个实际系统时，仅用此五种符号足够了。</li><li>但需要更具体地描绘一个物理系统时还需要使用图2.2中列出的11种系统符号。</li><li>图2.1<ul><li>![[Pasted image 20230602200256.png]]</li></ul></li><li>图2.2<ul><li>![[Pasted image 20230602200309.png]]</li></ul></li></ol></li><li>成本-效益分析<ul><li>定义<ol><li>成本-效益分析的目的使从经济角度评价开发一个新的软件项目是否可行。通过评估新的软件项目所需要的成本和可能产生的效益，便可以从经济上衡量这个项目的开发价值。</li><li>系统成本包括开发成本和运行维护成本。</li><li>系统效益包括有形的经济效益和无形的社会效益两种。</li><li>本章主要讨论有形的经济效益。</li></ol></li><li>货币的时间价值<ol><li>投资是现在进行的，而效益是将来获得的，因此，应该考虑货币的时间价值。</li><li>通常用利率的形式表示货币的时间价值。假设年利率为i，如果现在存入P元，则n年后可得到的钱数为F，若<mark style="background: #FF5582A6;">不记复利</mark>则：lF &#x3D; P * ( 1 + n * i ) 这也就是P元钱在n年后的价值。</li><li>反之，如果n年后能收入F元钱，那么这些钱现在的价值是：lP &#x3D; F &#x2F; ( 1 + n * i )</li></ol></li><li>投资回收期<ol><li>所谓<mark style="background: #FF5582A6;">投资回收期</mark>就是使累计的经济效益等于最初的投资费用所需要的时间。</li><li>显然，投资回收期越短，就可以越快获得利润，因此该项目就越值得投资开发。</li></ol></li><li>纯收入<ol><li><mark style="background: #FF5582A6;">纯收入</mark>，就是在整个生存周期之内系统的累计经济效益（折合成现在值）与投资之差。</li><li>如果纯收入为零，则工程项目的预期效益和存银行存款一样，但是开发一个系统要冒风险，因此，从经济观点看这个项目，可能是不值得投资开发的。如果纯收入小于零，那么这项工程项目根本不值得投资开发。</li></ol></li><li>可行性研究报告的主要内容<ol><li>不同的标准模板，可行性研究报告的格式各有不同，但主要内容应该包括以下几项：<ol><li>引言；</li><li>可行性研究前提；</li><li>对现有系统的分析；</li><li>对所建设系统的分析：经济可行性、技术可行性、社会因素的可行性等；</li><li>其他与设计有关选择方案；</li><li>其他与设计有关的专门问题；</li><li>结论意见。</li></ol></li></ol></li></ul></li><li>本章小结<ol><li>可行性研究阶段是进一步探讨问题定义阶段所确定的问题是否有可行的解。尤其对于大型软件的开发，可行性研究是必须的。这个阶段主要是从经济可行性、技术可行性、操作可行性和法律可行性四个方面来讨论该项目是否能够解决以及是否值得去解决。通过可行性研究可以减少技术风险和投资风险。</li><li>系统流程图用来表达分析员对现有系统的认识和描绘他对未来物理系统的设想。</li><li>成本&#x2F;效益分析是可行性研究的一项主要内容，它主要是从经济角度判断该项目是否继续下去的依据。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.4 成本-效益分析</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.4-cheng-ben-xiao-yi-fen-xi/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.4-cheng-ben-xiao-yi-fen-xi/</url>
      
        <content type="html"><![CDATA[<ul><li>成本-效益分析的<mark style="background: #FF5582A6;">目的</mark>使从经济角度评价开发一个新的软件项目是否可行。通过评估新的软件项目所需要的成本和可能产生的效益，便可以从经济上衡量这个项目的开发价值。</li><li>系统成本包括开发成本和运行维护成本。</li><li>系统效益包括有形的经济效益和无形的社会效益两种。本章主要讨论有形的经济效益。</li><li>货币的时间价值<ol><li>投资是现在进行的，而效益是将来获得的，因此，应该考虑货币的时间价值。</li><li>通常用利率的形式表示货币的时间价值。假设年利率为 i，如果现在存入 P 元，则 n年后可得到的钱数为 F，若<mark style="background: #FF5582A6;">不记复利</mark>则：<ul><li>F &#x3D; P * （1 + n * i）这也就是 P 元钱在 n 年后的价值。</li><li>反之，如果 n 年后能收入 F  元钱，那么这些钱现在的价值是：P &#x3D; F &#x2F;（1 + n * i）</li></ul></li></ol></li><li>投资回收期<ol><li>所谓<mark style="background: #FF5582A6;">投资回收期</mark>就是使累计的经济效益等于最初的投资费用所需要的时间。</li><li>显然，投资回收期越短，就可以越快获得利润，因此该项目就越值得投资开发。</li></ol></li><li>纯收入<ol><li>纯收入，就是在整个生存周期之内系统的累计经济效益（折合成现在值）与投资之差。</li><li>如果纯收入为零，则工程项目的预期效益和存银行存款一样，但是开发一个系统要冒风险，因此，从经济观点看这个项目，可能是不值得投资开发的。如果纯收入小于零，那么这项工程项目根本不值得投资开发。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1 可行性研究的目的和任务</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.1-ke-xing-xing-yan-jiu-de-mu-de-he-ren-wu/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.1-ke-xing-xing-yan-jiu-de-mu-de-he-ren-wu/</url>
      
        <content type="html"><![CDATA[<ul><li>目的<ol><li>用最小的代价在尽可能短的时间内确定问题是否能够解决。</li><li>是一次简化的系统分析和系统设计的过程。</li></ol></li><li>任务<ol><li>主要任务是：首先需要进行概要的分析研究，初步确定项目的规模和目标，确定项目的约束和限制，必须分析几种可能解法的利弊，从而判定原定系统的目标和规模是否现实，系统完成后带来的效益是否大到值得投资开发这个系统的程度。</li><li>从经济、技术、操作和法律四个方面来研究每种解法的可行性，做出明确结论来供用户参考，包括：<ul><li>经济可行性</li><li>技术可行性</li><li>操作可行性</li><li>法律可行性</li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2 可行性研究的步骤</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.2-ke-xing-xing-yan-jiu-de-bu-zou/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/2-ke-xing-xing-yan-jiu/2.2-ke-xing-xing-yan-jiu-de-bu-zou/</url>
      
        <content type="html"><![CDATA[<ul><li>步骤<ol><li>复查并确定系统规模和目标</li><li>研究目前正在使用的系统</li><li>建立新系统的高层逻辑模型</li><li>导出和评价各种方案</li><li>推荐可行方案</li><li>草拟初步的开发计划</li><li>编写可行性研究报告提交审查</li></ol></li><li>ll<ol><li>确定系统的目标<ul><li>系统分析人员要详细地阅读各种相关资料，并对用户和市场进行调查，从而确认目标系统要完成的任务。</li><li>同时，还要明确进行项目开发时的一切限制和约束，以及可以使用的各种资源。</li></ul></li><li>分析研究正在运行的系统<ul><li>对现有系统功能特点的充分了解是成功开发新系统的前提</li><li>对现有系统的研究包括阅读和分析各种文档资料，观察系统的运行状况和实地操作系统，收集和分析用户对现有系统的意见等。</li><li>可以说，现有系统是开发目标系统时重要的信息来源。</li></ul></li><li>设计新系统的高层逻辑模型<ul><li>一般来说，新系统应该完成现有系统的功能，并对现有系统中存在的问题进行改善或修复。</li><li>在分析研究了现有系统的基础上，就可以大体把握新系统的功能和结构，然后从较高层次上建立新系统的逻辑模型。</li></ul></li><li>提出可行的解决方案并对其进行评估和比较<ul><li>基于新系统的高层逻辑模型，系统分析人员可以从技术的角度提出多种解决方案，并从经济、社会和技术等多个方面对各种解决方案进行比较和评估。</li></ul></li><li>选择合适的解决方案<ul><li>在上述研究的基础上，回答该软件产品是否能够解决存在的问题，是否能够带来预期的效果和价值的问题。</li><li>如果该软件开发项目没有必要性和可能性，则应立即停止，并给出详细的理由。</li><li>如果有开发该软件产品的必要性和可能性，那么应该从上述的多个解决方案中选取出最合适、最可行的解决方案，列举出选择该方案的原因，从经济可行性、社会可行性和技术可行性三个方面对该方案进行可行性研究。</li></ul></li><li>草拟初步的开发计划——撰写可行性研究报告<ul><li>项目背景</li><li>管理概要</li><li>候选方案</li><li>系统描述</li><li>经济可行性分析、社会可行性分析、技术可行性分析</li><li>可行性研究的结论<ol><li>可以按计划进行软件项目的开发。</li><li>需要进行调整或改善后才能进行项目的开发</li><li>该软件项目不具有可行性，立即停止。</li></ol></li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4 软件开发模型</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.4-ruan-jian-kai-fa-mo-xing/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.4-ruan-jian-kai-fa-mo-xing/</url>
      
        <content type="html"><![CDATA[<ul><li>瀑布模型<ul><li>瀑布<ol><li>瀑布模型也称生存周期模型或线性顺序模型。这种模型是将软件生存周期各个活动规定为依据，线性顺序连接的若干阶段的模型，包括<mark style="background: #FF5582A6;">问题定义</mark>、<mark style="background: #FF5582A6;">可行性研究</mark>、<mark style="background: #FF5582A6;">需求分析</mark>、<mark style="background: #FF5582A6;">概要设计</mark>、<mark style="background: #FF5582A6;">详细设计</mark>、<mark style="background: #FF5582A6;">编码</mark>、<mark style="background: #FF5582A6;">测试</mark>和<mark style="background: #FF5582A6;">维护</mark>。</li><li>瀑布模型规定了由前至后、相互衔接的固定次序，恰如奔流不息拾级而下的瀑布。是<mark style="background: #FF5582A6;">自顶向下结构化开发模型</mark>。</li><li>通过每个阶段，提交以下产品：软件需求规约、设计文档、实际代码、测试用例、最终产品等。工作产品流经“正向”开发的基本步骤路径。</li><li>“反向”步骤流表示对前一个可提交产品的重复变更（又称“返工”）。<ul><li>由于所有开发活动的非确定性，因此是否需要重复变更，这仅在下一阶段或更加后面的阶段才能认识到。</li><li>返工不仅在以前阶段的某一地方需要，而且对当前正在进行的工作也是需要的</li></ul></li><li>在20世纪80年代之前，瀑布模型一直是唯一被广泛采用的生存周期模型，现在它仍然是软件工程中应用得最广泛的过程模型。传统软件工程方法学的软件过程，基本上可以用瀑布模型来描述。而且是<mark style="background: #FF5582A6;">以文档</mark>为驱动，<mark style="background: #FF5582A6;">适合于需求很明确的软件项目</mark>。</li></ol></li><li>瀑布模型的特点<ol><li>阶段的顺序性和依赖性：首先必须等前一阶段的工作完成之后，才能开始后一阶段的工作；其次前一阶段的输出文档就是后一阶段的输入文档；</li><li>推迟实现的观点：要尽量完善文档，然后才开始编写程序；</li><li>质量保证的观点：每一个阶段都必须完成所规定的相应文档；每一个阶段结束之前都必须对已完成的文档进行评审；</li><li>是一种理想的线性开发模式，缺乏灵活性。特别是无法解决软件需求不明确或不准确的问题；</li><li><mark style="background: #FF5582A6;">适合于系统要求明确的小系统</mark>。</li></ol></li><li>瀑布模型的优点<ol><li>在决定系统怎样做之前，存在一个需求阶段，鼓励对系统“做什么”进行规约（即设计之前的规约）。<ul><li>设计之前一定要明确需要做什么，在设计之前有一个确定的入口。这样方式为我们后续的开发奠定一个坚实的基础。</li></ul></li><li>在建造构件之前，存在一个设计阶段，鼓励规划系统结构（即编码之前的设计）。<ul><li>在编码之前一定要经过设计，软件的开发实际是在创造性的设计，是一个逻辑产品，软件是设计出来而不是制造出来的。所以我们要更加关注设计，也就是到底应怎么做。这是软件架构师和软件工程师智慧的结晶。</li></ul></li><li>在每一阶段结束时进行复审，允许获取方和用户的参与（可以有效控制产品的质量）。</li><li>前一步工作产品可作为下一步被认可的、文档化的基线。允许基线和配置早期接受控制。</li></ol></li><li>瀑布模型的不足<ol><li>客户必须能够完整、正确和清晰地表达他们的需求；开发人员一开始就必须理解需求。这是瀑布模型成功与否的<mark style="background: #FF5582A6;">最致命</mark>的缺点。</li><li>缺乏灵活性。一旦软件需求存在偏差，就会导致开发出的软件产品不能满足用户的实际要求。</li><li>在一个项目的早期阶段，过分地强调了基线和里程碑初的文档，可能要花费更多的时间，用于建立一些用处不大的文档。</li><li>直到项目项目结束之前，都不能演示系统的功能，增加了项目的风险。<mark style="background: #FF5582A6;">用户见面晚</mark>；<mark style="background: #FF5582A6;">纠错慢</mark>；<mark style="background: #FF5582A6;">难于克服系统分析员不懂专业领域的知识</mark>，<mark style="background: #FF5582A6;">用户不懂计算机的困难</mark>，成功率低。</li></ol></li></ul></li><li>增量模型<ul><li>增量<ol><li>也称为渐增模型，是瀑布模型的顺序特征和快速原型法的迭代特征相结合的产物，是一种<mark style="background: #FF5582A6;">非整体开发</mark>的模型。</li><li>软件在模型中是“<mark style="background: #FF5582A6;">逐渐</mark>”开发出来的，把软件产品作为一系列的增量构件来设计、编码、组装和测试。每个构件由多个相互作用的模型构成，并且能够完成特定的功能。</li><li><mark style="background: #FF5582A6;">开发出一部分</mark>，<mark style="background: #FF5582A6;">向用户展示一部</mark>分，可让用户<mark style="background: #FF5582A6;">及早看到部分软件</mark>，及早发现问题。</li></ol></li><li>增量模型优点：作为瀑布模型的第一个变体，具有瀑布模型的所有优点。此外，它还有以下优点：<ol><li>开发出一部分，向用户展示一部分，可让用户<mark style="background: #FF5582A6;">及早看到部分软件</mark>，及早发现问题。</li><li>由于用户可以很快看到部分软件功能，因此可以减少用户需求的变更。</li><li>开发由增量表示的小系统所承担的风险不大<ul><li>将复杂的软件划分成很多部分，分而治之，复杂性降低，风险也相应降低</li></ul></li><li>允许增量投资，即在项目开始时，可以仅对一个或两个增量投资。</li><li>所以：适用于软件部分<mark style="background: #FF5582A6;">需求不明确</mark>的软件项目开发。<mark style="background: #FF5582A6;">软件可维护性强</mark>。</li></ol></li><li>增量模型缺点：如果增量模型不适用于某些项目，或使用有误，则有以下缺点：<ol><li>如果没有对用户的变更要求进行规划，那么产生的初始增量可能会造成后来增量的不稳定；</li><li>如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；<ul><li>如果要用增量模型，最初有一些需求一定是可确定的，如果什么需求都不能确定，肯定不能用增量模型。所以，增量一定是对一个确定的需求开发的一个产品。而且，每一个增量开发内部都相当于一个瀑布模型。</li></ul></li><li>管理发生的成本、进度和配置的复杂性，可能会超出一些组织的能力<ul><li>不断的进行增量，而且每一个增量都要进行需求分析、设计、实现、测试、等过程，无形中增加了管理层的工作量、增加了管理协调的难度。</li></ul></li></ol></li></ul></li><li>演化模型<ul><li>是一种有弹性的过程模型，由一些小的开发步组成，每一步历经需求分析、设计、实现和验证，产生软件产品的一个增量，通过这些迭代，完成最终软件产品的开发。<ol><li>针对实现不能完整的定义需求的软件开发</li><li>针对用户的核心需求，开发核心系统</li><li>根据用户的反馈，实施活动的迭代</li></ol></li></ul></li><li>快速原型模型<ul><li>快速原型<ol><li>主要思想：首先快速建立一个能够反映用户主要需求的原型系统，让用户在计算机上试用它，通过实践让用户了解未来目标系统的概貌，以便判断哪些功能是符合需要的，哪些方面需要改进，用户会提出许多改进意见，开发人员按照用户的意见快速地修改原型系统，然后再次请用户试用，这样反复改进，最终建立完全符合用户需求的新系统。</li><li>根据用户提出的软件定义，快速的开发一个<mark style="background: #FF5582A6;">原型</mark>，在征求用户对原型意见的过程中，再进一步修改、完善，直至达成一致。<ul><li>模拟软件的人机界面</li><li>开发一个原型，实现已知需要实现的功能</li><li>向用户展示<mark style="background: #FF5582A6;">正在运行的类似软件</mark></li></ul></li></ol></li><li>优点<ol><li>与用户见面快</li><li>开发成功率高（能渐进地启发客户提出新的要求）</li><li><mark style="background: #FF5582A6;">适合于需求不确定的大系统</mark>。</li></ol></li><li>缺点<ol><li><mark style="background: #FF5582A6;">周期长</mark>，<mark style="background: #FF5582A6;">开发成本高</mark>：<ul><li>没有考虑软件的整体质量和长期的可维护性。</li><li>由于达不到质量要求产品可能被抛弃，而采用新的模型重新设计</li></ul></li></ol></li></ul></li><li>演化模型和快速原型模型的区别<ol><li>演化模型是一种原型化开发方法，与快速原型模型略有不同。</li><li>在快速原型模型中，原型的用途是获知用户真正的需求，一旦需求缺点了，原型即被抛弃了。</li><li>演化模型开发的过程则是从初始模型逐步演化为最终软件产品的渐进过程。</li><li>快速原型模型是一种“<mark style="background: #FF5582A6;">抛弃式</mark>”的原型化方法，而演化模型则是一种“<mark style="background: #FF5582A6;">渐进式</mark>”的原型化方法。</li></ol></li><li>螺旋模型<ul><li>螺旋<ol><li>螺旋模型加入了瀑布模型与增量模型都忽略了的<mark style="background: #FF5582A6;">风险分析</mark>，弥补了两种模型的不足。它是一种风险驱动的模型。</li><li>螺旋模型是一种<mark style="background: #FF5582A6;">迭代模型</mark>（延续了快速原型模型的特点)，它把开发过程分为几个螺旋周期，每迭代一次，螺旋线就前进一周。</li><li>特点<ul><li>瀑布模型+快速原型+风险分析</li><li>迭代过程</li><li>适合于<mark style="background: #FF5582A6;">大规模高风险</mark>、<mark style="background: #FF5582A6;">需求不明确</mark>的软件项目开发。</li></ul></li><li>螺旋模型沿着螺线旋转（一个螺旋式周期 ），每迭代一次，软件开发又前进一个层次。在四个象限上分别表达四个方面的活动：<ul><li><mark style="background: #FF5582A6;">制定计划</mark>——确定软件目标，选定实施方案，弄清项目开发的限制，选定完成目标的策略。</li><li><mark style="background: #FF5582A6;">风险分析</mark>——分析所选方案，考虑如何识别和消除风险，风险角度分析该策略。</li><li><mark style="background: #FF5582A6;">实施工程</mark>——实施软件开发，启动一个开发阶段</li><li><mark style="background: #FF5582A6;">客户评估</mark>——评价前一步开发工作，提出修正建议，计划下一轮的工作。</li></ul></li><li>![[Pasted image 20230601111636.png]]</li></ol></li><li>优点<ol><li>设计上的灵活性，可以在项目的各个阶段进行变更。</li><li>以小的分段来构建大型系统，使成本计算变得简单容易。</li><li>客户始终参与每个阶段的开发，保证了项目不偏离正确方向以及项目的可控性。</li><li>随着项目推进，客户始终掌握项目的最新信息，从而客户能够和管理层有效地交互。</li><li>客户认可这种公司内部的开发方式带来的良好的沟通和高质量的产品。</li></ol></li><li>缺点<ol><li>很难让用户确信这种演化方法的结果是可以控制的。建设周期长，而软件技术发展比较快，所以经常出现软件开发完毕后，和当前的技术水平有了较大的差距，无法满足当前用户需求。</li></ol></li></ul></li><li>喷泉模型<ul><li>喷泉<ol><li>喷泉模型：<mark style="background: #FF5582A6;">以用户需求为动力</mark>，以对象作为驱动的模型，<mark style="background: #FF5582A6;">适合面向对象的开发方法</mark>。</li><li>软件开发过程自下而上周期的各阶段是相互<mark style="background: #FF5582A6;">迭代</mark>和<mark style="background: #FF5582A6;">无间隙</mark>的特性</li><li><mark style="background: #FF5582A6;">迭代</mark>是指各阶段需要多次重复。一个循环接着下一个循环，不断的往前推进，每次都进行优化。例如，分析和设计阶段常常需要多次重复进行，以更好的实现需求。</li><li><mark style="background: #FF5582A6;">无间隙</mark>性是指在分析、设计和实现之间不存在明显的边界。</li><li>![[Pasted image 20230601113718.png]]</li></ol></li></ul></li><li>基于构件的开发模型<ul><li>基于构建的开发<ol><li>经过一定的设计和实现的<mark style="background: #FF5582A6;">类</mark>可称为<mark style="background: #FF5582A6;">构件</mark>，它们可以有不同的计算机软件系统中复用，在某个领域具有一定的通用性。</li><li>基于构件的开发模型是利用预先封装的软件构件来构造应用软件系统，从而提高软件的重用性和可靠性。</li></ol></li></ul></li><li>统一过程（RUP）模型<ul><li>![[Pasted image 20230601152107.png]]</li><li>统一过程<ol><li>软件统一开发过程是基于面向对象统一建模语言UML(Unified Modeling Language)的一种面向对象的软件过程模型。</li><li>RUP(Rational Unified Process)是一个通用的过程框架，可以用于各种不同模型的软件系统，各种不同的应用领域和不同规模的项目。</li><li>RUP的特点是由用例驱动，以构架为中心，采用迭代和增量的开发策略。RUP软件生存周期是一个<mark style="background: #FF5582A6;">二维的软件开发模型</mark></li><li>统一软件开发过程 开发生命周期是一个二维的软件开发模型。</li><li><mark style="background: #FF5582A6;"> 横轴</mark>通过<mark style="background: #FF5582A6;">时间</mark>组织，是过程展开的<mark style="background: #FF5582A6;">生命周期特征</mark>，体现开发过程的<mark style="background: #FF5582A6;">动态结构</mark>，用来描述它的术语主要包括周期、阶段、迭代和里程碑</li><li><mark style="background: #FF5582A6;">纵轴</mark>以<mark style="background: #FF5582A6;">内容</mark>来组织为自然的逻辑活动，体现开发过程的静态结构，用来描述它的术语主要包括活动、产物、工作者和工作流。</li></ol></li></ul></li><li>基于形式化的模型<ul><li>![[Pasted image 20230601152625.png]]</li><li>基于形式化<ol><li>典型的适合于形式化开发的模型：<ul><li><mark style="background: #FF5582A6;">变换模型</mark>是结合<mark style="background: #FF5582A6;">形式化软件开发方法和程序自动生成技术</mark>的一种软件开发模型。它采用严格的、数学的表示体系来表示软件规格说明，从软件需求形式化说明开始，经过<mark style="background: #FF5582A6;">一系列变换</mark>，最终的得到了系统的目标程序。</li><li>是一种<mark style="background: #FF5582A6;">增量开发模型</mark>。其基本思想是力求在分析和设计阶段就消除缺陷，却保正确，然后在无错误或“净室”的状态下实现软件的开发。</li></ul></li></ol></li><li>特点<ol><li>形式软件开发方式<ul><li>形式化需求规格说明</li><li>变换技术</li></ul></li><li>程序自动生成技术</li><li>确保正确</li></ol></li><li>基于形式化的模型——净室模型<ol><li>![[Pasted image 20230601152846.png]]</li><li>净室思想<ul><li>在分析和设计阶段消除错误</li><li>在“洁净”状态下实现软件制作</li></ul></li><li>形式化<ul><li>盒结构表示分析和实际</li><li>正确性验证</li></ul></li><li>增量模型</li></ol><p></p></li><li>各种软件开发模型的对比<ol><li>瀑布模型：经典，需求确定</li><li>快速原型模型：快速获取用户需求</li><li>增量模型：灵活，允许软件变化</li><li>螺旋模型：加入风险</li><li>喷泉模型：典型面向对象开发模型</li><li>基于构建的开发模型：提高软件重用性和可靠性</li><li>统一过程模型：基于UML和OO过程模型</li><li>基于形式化的模型：确保严格、无措</li></ol></li></ul></li><li>概括<br>  ![[Pasted image 20230601155619.png]]</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.5 传统的软件工程和面向对象的软件工程</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.5-chuan-tong-de-ruan-jian-gong-cheng-he-mian-xiang-dui-xiang-de-ruan-jian-gong-cheng/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.5-chuan-tong-de-ruan-jian-gong-cheng-he-mian-xiang-dui-xiang-de-ruan-jian-gong-cheng/</url>
      
        <content type="html"><![CDATA[<ul><li>传统软件工程方法<ol><li>采用结构化技术(结构化分析、结构化设计和结构化实现)来完成软件开发的各项任务</li><li>具体过程如下：<ul><li>采用结构化技术（结构化分析、结构化设计和结构化实现）完成软件开发的各项任务。</li><li>把软件生存周期划分成若干个阶段，然后顺序完成各个阶段的任务。</li><li>每一个阶段的开始和结束都有严格标准，前一阶段结束的标准是后一阶段工作开始的标准。</li><li>在每一阶段结束之前必须正式地进行严格的技术审查和管理复审。</li></ul></li></ol></li><li>面向对象软件工程方法<ol><li>重点：在软件生存周期的分析阶段。<ul><li>面向对象方法在开发的早期就定义了一系列面向问题领域的对象，即建立了对象模型，整个开发过程统一使用这些对象，并不过分充实和扩展对象模型。</li></ul></li><li>特点：<ul><li>开发阶段界限模糊</li><li>开发过程逐步求精</li><li>开发活动反复迭代</li></ul></li></ol></li><li>两种软件工程方法的对比<ol><li>与面向过程的软件工程的<mark style="background: #FF5582A6;">开发思想</mark>相比，面向对象开发方法不再是以功能划分为导向，而是以<mark style="background: #FF5582A6;">对象</mark>作为整个问题分析的中心，围绕对象展开系统的分析与设计工作。</li><li>在<mark style="background: #FF5582A6;">开发过程</mark>方面，面向对象软件工程和传统软件工程一样也是把软件开发划分为分析、设计、编码和测试等几个阶段，但各个阶段的具体工作不同。<ul><li>面向对象<ol><li>可行性研究</li><li>需求分析（确定类、对象）</li><li>软件设计（对象的设计）</li></ol></li><li>面向过程<ol><li>可行性研究</li><li>需求分析（确定用户需求）</li><li>软件设计（软件总体框架和模块内部算法的设计）</li></ol></li><li>面向对象（面向过程）<ol><li>软件编码</li><li>软件测试</li><li>软件维护</li></ol></li></ul></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3 软件过程和软件生存周期</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.3-ruan-jian-guo-cheng-he-ruan-jian-sheng-cun-zhou-qi/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.3-ruan-jian-guo-cheng-he-ruan-jian-sheng-cun-zhou-qi/</url>
      
        <content type="html"><![CDATA[<ul><li>软件过程<ul><li>ISO 9000把软件过程定义为：“把输入转化为输出的一组彼此相关的资源和活动”。</li><li>软件开发过程是把用户要求转化为<mark style="background: #FF5582A6;">软件需求</mark>，把软件需求转化为<mark style="background: #FF5582A6;">设计</mark>，用<mark style="background: #FF5582A6;">代码</mark>来实现设计，对代码进行<mark style="background: #FF5582A6;">测试</mark>，完成各阶段的<mark style="background: #FF5582A6;">文档编制</mark>并确认软件可以投入运行使用的过程。</li></ul></li><li>软件生存周期<ul><li>软件生存周期是借用工程中产品生存周期的概念而得来的，是指<mark style="background: #FF5582A6;">某一软件项目被提出来并着手实现开始直到该软件报废或停止使用为止</mark>。</li><li>软件的生存周期一般分为<mark style="background: #FF5582A6;">软件计划</mark>、<mark style="background: #FF5582A6;">软件开发</mark>和<mark style="background: #FF5582A6;">软件运行</mark>三个时期。</li><li>软件生命周期可划分为7个阶段<ul><li>![[Pasted image 20230530180144.png]]</li><li>软件计划时期<ol><li>问题定义</li><li>可行性研究</li></ol></li><li>软件开发时期<ol start="3"><li>需求分析</li><li>软件设计<ul><li>概要设计</li><li>详细设计</li></ul></li><li>编码</li><li>测试</li></ol></li><li>软件运行维护时期<ol start="7"><li>软件维护</li></ol></li></ul></li><li>问题定义：要求系统分析员与用户进行交流，弄清“用户需要计算机解决什么问题”然后提出关于“系统目标与范围的说明”，提交用户审查和确认。<ol><li>确定要开发软件系统的<mark style="background: #FF5582A6;">总目标</mark>；</li><li>给出<mark style="background: #FF5582A6;">功能</mark>、<mark style="background: #FF5582A6;">性能</mark>、<mark style="background: #FF5582A6;">可靠性</mark>以及<mark style="background: #FF5582A6;">接口</mark>等方面的要求；</li><li>提出“系统目标与范围的说明”，提交用户审查和确认。</li></ol></li><li>可行性研究：如果问题不值得解决，分析员应该建议，以避免时间、资源、人力和金钱的浪费；如果问题值得解决，分析员应该为工程制定一个初步的计划。<ol><li>完成该软件任务的<mark style="background: #FF5582A6;">可行性研究</mark>；</li><li>估计可利用的<mark style="background: #FF5582A6;">资源</mark>、<mark style="background: #FF5582A6;">成本</mark>、<mark style="background: #FF5582A6;">效益</mark>、<mark style="background: #FF5582A6;">开发进度</mark>；</li><li>制定出完成开发任务的<mark style="background: #FF5582A6;">实施计划</mark>，连同可行性研究报告，提交管理部门审查；</li><li>软件开发可行性研究方法主要有哪四个方面：<ul><li>经济可行性：进行成本&#x2F;效益分析。从经济角度判断系统开发是否“合算”；</li><li>技术可行性：进行技术风险评价。从开发者的技术实力、以往的工作基础、问题的复杂性等出发，判断系统开发在时间、费用等限制条件下成功的可能性；</li><li>法律可行性：确定系统开发可能导致的任何侵权、妨碍和责任；</li><li>方案的选择：评价系统或产品开发的几个可能的候选方案，最后给出结论意见</li></ul></li></ol></li><li>需求分析<ol><li>对用户提出的要求进行<mark style="background: #FF5582A6;">分析</mark>并给出<mark style="background: #FF5582A6;">详细的定义</mark></li><li>编写<mark style="background: #FF5582A6;">软件需求说明书</mark>或<mark style="background: #FF5582A6;">系统功能说明书</mark>及<mark style="background: #FF5582A6;">初步的系统用户手册</mark></li><li>提交管理机构<mark style="background: #FF5582A6;">评审</mark></li></ol></li><li>概要设计<ol><li>把各项需求转换成<mark style="background: #FF5582A6;">软件的体系结构</mark>。结构中每一组成部分都是意义明确的模块，每个模块都和某些需求相对应，编写<mark style="background: #FF5582A6;">概要设计说明书</mark>，提交评审。</li><li>主要任务是把需求分析得到的系统扩展用例图转换为<mark style="background: #FF5582A6;">软件结构</mark>和<mark style="background: #FF5582A6;">数据结构</mark>。<ul><li>软件结构：将一个复杂系统按功能进行<mark style="background: #FF5582A6;">模块划分</mark>、建立模块的<mark style="background: #FF5582A6;">层次结构</mark>及<mark style="background: #FF5582A6;">调用关系</mark>、确定模块间的<mark style="background: #FF5582A6;">接口</mark>及人机界面等。</li><li>数据结构：数据特征的描述、<mark style="background: #FF5582A6;">确定数据的结构特性</mark>、以及<mark style="background: #FF5582A6;">数据库的设计</mark>。</li></ul></li><li>概要设计建立的是目标系统的<mark style="background: #FF5582A6;">逻辑模型</mark>，与计算机无关。</li></ol></li><li>详细设计<ol><li>对每个模块要完成的工作进行具体的描述，为源程序编写打下基础，编写<mark style="background: #FF5582A6;">详细设计说明书</mark>，提交评审。</li><li>详细设计的主要任务：设计<mark style="background: #FF5582A6;">每个模块的实现算法</mark>、所需的<mark style="background: #FF5582A6;">局部数据结构</mark>。</li><li>详细设计的目标：实现模块功能的算法要逻辑上正确和算法描述要简明易懂。</li></ol></li><li>软件构造——编码<br>  <mark style="background: #FF5582A6;">把软件设计转换成计算机可以接受的程序代码</mark>，即以某一种特定程序设计语言表示的“源程序清单”；程序应当是结构良好、清晰易读的，且与设计相一致的。</li><li>软件测试：发现软件程序中的错误、对软件是否符合设计要求，以及是否符合合同中所要达到的技术要求，进行有关验证以及评估软件的质量。最终实现将高质量的软件系统交给用户的目的。<ol><li><mark style="background: #FF5582A6;">单元测试</mark>：查找各模块在功能和结构上存在的问题并加以纠正。</li><li><mark style="background: #FF5582A6;">集成测试</mark>：将已测试过的模块按一定顺序组装测试。</li><li><mark style="background: #FF5582A6;">确认测试</mark>：按规定的各项需求，逐项进行<mark style="background: #FF5582A6;">有效性确认测试</mark>，决定已开发的软件是否合格，能否交付用户使用。</li></ol></li><li>使用和维护<ol><li><mark style="background: #FF5582A6;">改正性维护</mark>：运行中发现软件中的错误需要修正。</li><li><mark style="background: #FF5582A6;">适应性维护</mark>：为了适应变化了的软件工作环境，需做适当变更</li><li><mark style="background: #FF5582A6;">完善性维护</mark>：为了增强软件的功能需做变更。</li></ol></li></ul></li></ul><p>软件生存周期的“V-模型”<br>    ![[Pasted image 20230530190515.png]]</p><ul><li>概要设计与详细设计的区别<ul><li><mark style="background: #FF5582A6;">概要设计</mark>就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。</li><li><mark style="background: #FF5582A6;">详细设计</mark>阶段就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。</li><li>概要设计阶段通常得到<mark style="background: #FF5582A6;">软件结构图</mark>。</li><li>详细设计阶段常用的描述方式有：<mark style="background: #FF5582A6;">流程图</mark>、<mark style="background: #FF5582A6;">N-S图</mark>、<mark style="background: #FF5582A6;">PAD图</mark>、<mark style="background: #FF5582A6;">伪代码</mark>等</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2 软件工程</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.2-ruan-jian-gong-cheng/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.2-ruan-jian-gong-cheng/</url>
      
        <content type="html"><![CDATA[<ul><li>软件工程的定义及目标<ul><li>软件工程定义<ul><li>软件工程是指导计算机软件开发和维护的一门工程学科，采用<mark style="background: #FF5582A6;">工程</mark>的概念、原理、技术和方法来<mark style="background: #FF5582A6;">开发和维护</mark>软件。</li><li>计算机百科全书上的软件工程定义：<ol><li>应用计算机科学、数学及管理科学等原理，以工程化方法制作软件的工程。它借鉴传统工程的原则、方法，创建软件以达到提高质量，降低成本的目的。</li><li>其中，计算机科学、数学用于构造模型与算法，工程科学用于制定规范、设计规范、评估成本及确定权衡，管理科学用于计划、资源、质量、成本等管理。</li><li>软件工程是一门指导计算机软件开发和维护的工程学科。软件工程是一门交叉性学科。</li></ol></li><li>1993年IEEE给出的定义<ul><li>软件工程的不同定义使用了不同的词句，强调的重点也有所差异，但是它的<mark style="background: #FF5582A6;">中心思想</mark>，是<mark style="background: #FF5582A6;">把软件当作一种工业产品</mark>，要求“采用工程化的原理和方法对软件进行计划、开发和维护。”<mark style="background: #FF5582A6;">宗旨</mark>是为了<mark style="background: #FF5582A6;">提高软件生产率</mark>、<mark style="background: #FF5582A6;">降低生产成本</mark>，<mark style="background: #FF5582A6;">以较小的代价获得高质量的软件产品</mark>。</li></ul></li></ul></li><li>软件工程的目标<ol><li>降低软件开发成本；</li><li>满足用户要求的全部软件功能；</li><li>符合用户要求，令用户满意的软件性能；</li><li>具有较好的易用性、可重用性和可移植性；</li><li>较低的维护成本，较高的可靠性；</li><li>按合同要求完成开发任务，及时交付用户使用。</li></ol></li><li>软件工程的主要研究内容是指<mark style="background: #FF5582A6;">软件开发技术</mark>和<mark style="background: #FF5582A6;">软件开发过程管理</mark>两个方面。<ol><li>在软件开发技术方面主要研究软件开发方法、软件开发过程、软件开发工具和技术。</li><li>在软件开发过程管理方面主要研究软件工程经济学和软件管理学。</li></ol></li><li>软件工程的基本原理<ol><li>用分阶段的生存周期计划严格管理<ul><li>软件生存周期要严格执行6类计划，项目概要计划、里程碑计划、项目控制计划、产品控制计划、验证计划、运行维护计划</li></ul></li><li>坚持进行阶段评审<ul><li>每一个阶段都要评审，评审中发现错误并及时改正。上一个阶段评审没有通过，不能进入下一个阶段的工作。</li></ul></li><li>实行严格的产品控制<ul><li>由于用户需求、认识等改变，要求软件产品功能改变，要严格控制。</li></ul></li><li><h2 id="采用现代程序设计技术"><a href="#采用现代程序设计技术" class="headerlink" title="采用现代程序设计技术"></a>采用现代程序设计技术</h2><h2 id=""><a href="#" class="headerlink" title=" - "></a> - </h2> - <ul><li>面向对象技术，重用性更高、维护性更便捷。</li></ul></li><li>结果应能清楚地审查</li><li>开发小组人员应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ol></li><li>软件工程的发展史<ol><li>程序设计时代<ul><li>在这个时期，程序员使用的开发语言主要是<mark style="background: #FF5582A6;">机器语言</mark>和<mark style="background: #FF5582A6;">汇编语言</mark>，负责从程序的开发、运行和维护的全过程，这是一种<mark style="background: #FF5582A6;">私人化的软件环境</mark>。</li></ul></li><li>程序系统时代</li><li>软件工程时代</li></ol></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1 软件和软件危机</title>
      <link href="/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.1-ruan-jian-he-ruan-jian-wei-ji/"/>
      <url>/2024/04/20/study/ruan-jian-gong-cheng/1-mian-xiang-guo-cheng-de-ruan-jian-gong-cheng/1-gai-shu/1.1-ruan-jian-he-ruan-jian-wei-ji/</url>
      
        <content type="html"><![CDATA[<ul><li>软件的定义、特点及分类<ul><li>软件的定义<ul><li>在计算机发展初期，软件就是指程序。</li><li>随着计算机技术的发展、计算机应用的日益普及、软件日益复杂、规模日益增大，人们开始意识到软件并不仅仅等于程序。</li><li>软件不是程序，而是<mark style="background: #FF5582A6;">程序</mark>、<mark style="background: #FF5582A6;">数据</mark>以及开发、使用和维护程序需要的所有<mark style="background: #FF5582A6;">文档</mark>的完整集合。<ol><li>程序：计算任务的处理对象和处理规则的描述；人们为了完成特定的功能而编制的一组指令集。</li><li>数据：程序能处理的具有一定数据结构的信息。</li><li>文档：为了便于了解程序所需的阐明性资料；与程序的开发、维护和使用有关的图文资料，如软件开发计划书、需求规格说明书、设计说明书、测试分析报告和用户手册等。</li></ol></li></ul></li><li>软件的特点<ul><li>软件是一种特殊的产品，与传统的工业产品相比，它具有以下一些独特的特点。<ol><li>软件是一种<mark style="background: #FF5582A6;">逻辑产品</mark>，而不是具体的物理实体，具有抽象性。<ul><li>它正确与否，一直到程序在机器上运行才能够真正知道，给设计、生产和管理带来许多困难</li></ul></li><li>软件产品的生产主要是<mark style="background: #FF5582A6;">开发研制</mark>，没有明显的制造过程。<ul><li>这就意味着，软件开发对分析设计人员对于专业知识以及经验都提出很高的要求；无法像汽车制造业制造汽车一样，通过构件的标准化组装而生产获得</li></ul></li><li>软件产品在使用过程中，不存在<mark style="background: #FF5582A6;">磨损</mark>、<mark style="background: #FF5582A6;">消耗</mark>、<mark style="background: #FF5582A6;">老化</mark>等问题。<ul><li>这是软件的优点，一款软件最终退出历史舞台，只是软件使用者不再使用它</li></ul></li><li>软件产品的开发主要是<mark style="background: #FF5582A6;">脑力劳动</mark>，还未完全摆脱手工开发方式，生产效率低。</li><li>软件是<mark style="background: #FF5582A6;">定制</mark>开发的。<ul><li>虽然整个工业向着基于构建的构造模式发展，然而大多数软件仍是根据实际的客户需求定制的</li><li>所以，如何捕获不同用户的不同需求，是软件开发非常重要的工作</li></ul></li><li>软件产品的成本相当昂贵，软件费用不断增加，软件的研制需要投入大量的人力、物力和资金，生产过程中还需对产品进行质量控制，对每件产品进行严格的检验。<ul><li>尤其是软件规模很大，软件非常复杂的时候，软件的成本可能呈几何增长</li></ul></li><li>软件对硬件和环境有不同程度的依赖性，为了减少这种依赖性，在软件开发中提出了软件的<mark style="background: #FF5582A6;">可移植性</mark>问题。软件易于<mark style="background: #FF5582A6;">复制-特点</mark>、<mark style="background: #FF5582A6;">优点</mark>。</li><li>软件是复杂的。软件是人类有史以来生产的复杂度最高的工业产品，软件是一个庞大的逻辑系统。软件开发，尤其是应用软件的开发常常涉及到其他领域的专门知识，这就对软件开发人员提出了很高的要求。<ul><li>软件开发人员：需要理解各个行业的业务流程、需求</li><li>需要和行业的专门的领域人才进行合作，获得软件需求</li></ul></li><li>软件的质量要求很高。</li><li>软件的开发与运行都离不开相关的计算机系统环境的支持</li><li>软件的开发工作牵涉到很多社会因素<ul><li>如机构设置、机制和管理方式，以及人们的观念和心理</li><li>不同于一般的工程项目，在软件项目开发过程中，实际开发（编写代码）的成本只是整个工程成本的一小部分，甚至可以说是“冰山一角”</li><li>而软件需求分析、测试、系统维护等任务将占据工程的很大一部分成本</li></ul></li></ol></li></ul></li><li>软件的分类<ul><li>按照软件的<mark style="background: #FF5582A6;">功能划分</mark>，软件一般可以分为<mark style="background: #FF5582A6;">系统软件</mark>、<mark style="background: #FF5582A6;">支撑软件</mark>和<mark style="background: #FF5582A6;">应用软件</mark>三类<ul><li>系统软件：<ol><li>居于计算机系统中最靠近硬件的一层。</li><li>其他软件一般都通过系统软件发挥作用。它与具体的应用领域无关，如编译程序和操作系统等。</li><li>编译程序把程序人员用高级语言书写的程序翻译成与之等价的、可执行的低级语言程序；</li><li>操作系统：负责管理系统的各种资源、控制程序的执行。</li></ol></li><li>支撑软件<ol><li>支撑软件的开发、维护与运行的软件。</li><li>70年代后期发展起来的软件开发环境以及后来的中间件可被看成现代支撑软件的代表。</li><li>软件开发环境主要包括环境数据库、各种接口软件和工具组。三者形成整体，协同支撑软件的开发与维护；</li><li>中间件是一种软件，它处于系统软件（操作系统和网络软件）与应用软件之间，它能使远距离相隔的应用软件可协同工作（互操作）。</li><li>vc++、Jbuilder、DCom、J2EE</li></ol></li><li>应用软件<ol><li>特定应用领域专用的软件。</li></ol></li></ul></li></ul></li></ul></li><li>软件危机的定义及表现形式<ul><li>软件危机的定义<br>  指在计算机软件的开发和维护过程中所遇到的<mark style="background: #FF5582A6;">一系列严重问题</mark>。</li><li>软件危机主要包含两方面的问题<ol><li>ü如何开发软件以满足多软件日益增长的需求；</li><li>ü如何维护数量不断增长的已有软件。</li></ol></li><li>软件危机的典型表现形式<ol><li>对软件开发成本和研制进度的估计常常很不精确。</li><li>“已完成”的软件不能满足用户要求。</li><li>软件产品质量差，可靠性得不到保证。</li><li>软件产品可维护性差。</li><li>软件成本在计算机系统总成本中所占的比例逐年上升。</li><li>软件开发生产率提高的速度，远远跟不上计算机应用速度普及深入的趋势。</li></ol></li></ul></li><li>软件危机的产生原因及解决途径<ul><li>产生原因<ol><li>软件是计算机系统中的逻辑部件，软件产品往往规模庞大，结构复杂。</li><li>软件开发的管理困难。</li><li>软件开发费用不断增加，维护费用急剧上升，直接威胁计算机应用的扩大。</li><li>软件开发技术落后。</li><li>生产方式落后。</li><li>开发工具落后，生产效率提高缓慢。</li></ol></li><li>解决途径<ol><li>首先应该对计算机软件有一个正确的认识，彻底清除“软件就是程序”的错误观念。</li><li>要使用好的开发技术和方法，并且要不断研究探索更好更有效的技术和方法。尽快消除在计算机系统早期发展阶段形成的一些错误观念和作法。</li><li>要有良好的组织、严密的管理，各类人员要相互配合，共同完成任务。充分认识软件开发不是某种个体劳动的神秘技巧。</li><li>应该开发和使用好的软件工具。</li></ol></li><li>为了解决<mark style="background: #FF5582A6;">软件危机</mark>，人们逐渐认识了软件的特性以及软件产品开发的内在规律，并尝试用<mark style="background: #FF5582A6;">工程化</mark>的思想去指导软件开发，于是<mark style="background: #FF5582A6;">软件工程</mark>诞生了。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyautogui</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/pyautogui/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/pyautogui/</url>
      
        <content type="html"><![CDATA[<h5 id="屏幕的分辨率"><a href="#屏幕的分辨率" class="headerlink" title="屏幕的分辨率"></a>屏幕的分辨率</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui  width, height &#x3D; pyautogui.size()  x, y &#x3D; pyautogui.position()    result &#x3D; pyautogui.onScreen(2000, 2222) print(f&quot;宽度：&#123;width&#125;, 高度：&#123;height&#125;&quot;)print(f&quot;&#123;x&#125;, &#123;y&#125;&quot;)print(f&quot;&#123;result&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>print(f&quot;宽度：&#123;width&#125;, 高度：&#123;height&#125;&quot;)</code>中的<code>f</code>将<code>width</code>和<code>height</code>替换成了获取的值，可以将其当成<code>%s</code>的作用。详情见<a href="https://realpython.com/python-f-strings/">f字符串</a></p><h5 id="鼠标的移动"><a href="#鼠标的移动" class="headerlink" title="鼠标的移动"></a>鼠标的移动</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(800, 800, duration&#x3D;2)  pyautogui.move(0, -200, duration&#x3D;0.1)  pyautogui.move(-200, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>duration</code>表示移动持续的时间，不设置<code>duration</code>则默认为0.1。</p><h5 id="拖动鼠标"><a href="#拖动鼠标" class="headerlink" title="拖动鼠标"></a>拖动鼠标</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(700, 530, duration&#x3D;2)  pyautogui.dragTo(1, 1, button&#x3D;&#39;left&#39;, duration&#x3D;2)  pyautogui.drag(100, 400, button&#x3D;&#39;right&#39;, duration&#x3D;2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dragTo</code>是拖动到某个点，<code>drag</code>是向某个方向拖动多少像素。</p><h5 id="鼠标的点击"><a href="#鼠标的点击" class="headerlink" title="鼠标的点击"></a>鼠标的点击</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    x, y &#x3D; pyautogui.position()    pyautogui.click(button&#x3D;&#39;left&#39;)  pyautogui.click(x, y, button&#x3D;&#39;left&#39;, clicks&#x3D;2, interval&#x3D;0.1, duration&#x3D;2)  pyautogui.doubleClick(x, y, button&#x3D;&#39;left&#39;)  pyautogui.tripleClick(x, y, button&#x3D;&#39;left&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="鼠标的按压和释放"><a href="#鼠标的按压和释放" class="headerlink" title="鼠标的按压和释放"></a>鼠标的按压和释放</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.click(328, 190)  pyautogui.moveTo(220, 480)  pyautogui.mouseDown(button&#x3D;&#39;left&#39;)  pyautogui.move(500, 0)  pyautogui.mouseUp(button&#x3D;&#39;left&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="鼠标的滚动"><a href="#鼠标的滚动" class="headerlink" title="鼠标的滚动&#96;&#96;"></a>鼠标的滚动&#96;&#96;</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(220, 480)  pyautogui.scroll(-10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="键盘的输入"><a href="#键盘的输入" class="headerlink" title="键盘的输入"></a>键盘的输入</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.click(960, 460)  pyautogui.write(&#39;This is a test!&#39;, interval&#x3D;0.5)  This is a test!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="键盘的按压"><a href="#键盘的按压" class="headerlink" title="键盘的按压"></a>键盘的按压</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.press(&#39;x&#39;)  pyautogui.press(&#39;crtl&#39;)  pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)    pyautogui.keyDown(&#39;crtl&#39;)  pyautogui.keyUp(&#39;ctrl&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5>]]></content>
      
      
      
        <tags>
            
            <tag> pyautogui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/opencv/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/opencv/</url>
      
        <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">cv2.cvtColor(src, code[, dst[, dstCn]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>src</code>：需要转换颜色空间的图像。</li><li><code>code</code>：颜色空间转换代码。</li><li><code>dst</code>（可选）：与源图像大小和深度相同的输出图像。</li><li><code>dstCn</code>（可选）：目标图像中的通道数。如果该参数为 0，则根据 <code>src</code> 和 <code>code</code> 自动推导通道数。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.destoryAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>窗口保持打开：如果不调用<code>cv2.destroyAllWindows()</code>，OpenCV创建的窗口将保持打开状态，直到用户手动关闭它们或程序终止。</li><li>可能导致资源泄漏：不关闭窗口可能会导致资源泄漏，特别是在循环中使用<code>cv2.imshow()</code>时，每次迭代都会创建新窗口，而不关闭旧窗口。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.imwrite(filename, image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>filename</code>可以指明路径，如果该路径不存在，则创建。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.imread(filename, image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>filename</code>为读出图片的名字 。</p><pre class="line-numbers language-none"><code class="language-none">cv2.IMREAD_COLORcv2.IMREAD_GRAYSCALEcv2.IMREAD_ANYCOLORcv2.IMREAD_UNCHANGEDcv2.IMREAD_ANYDEPTHcv2.IMREAD_ANYDEPTH|cv2.IMREAD_COLORcv2.IMREAD_REDUCED_GRAYSCALE_2cv2.IMREAD_REDUCED_COLOR_2cv2.IMREAD_REDUCED_GRAYSCALE_4cv2.IMREAD_REDUCED_COLOR_4cv2.IMREAD_REDUCED_GRAYSCALE_8cv2.IMREAD_REDUCED_COLOR_8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cv2.IMREAD_COLOR</code>：以彩色模式加载图像。这是默认选项，为每个通道提供 3 通道 BGR 图像，每个图像具有 8 位值（0-255）。</li><li><code>cv2.IMREAD_GRAYSCALE</code>：以灰度模式加载图像。这提供了一个 8 位灰度图像。</li><li><code>cv2.IMREAD_ANYCOLOR</code>：尝试加载图像，但不关心颜色格式，如果图象是彩色的，它将以彩色模式加载，否则以灰度模式加载。根据文件中的元数据，它提供每通道 8 位的 BGR 图像或 8 位的灰度图像。</li><li><code>cv2.IMREAD_UNCHANGED</code>：加载图像，包括[[杂项#^025801|图像的阿尔法通道]]，不进行任何修改。读取所有图像数据，包括 alpha 或透明通道（如果有）作为第四通道。</li><li><code>cv2.IMREAD_ANYDEPTH</code>：尝试加载图像，不关心位深度，图像的位深度是指每个像素的颜色通道的位数。这将以原始位深度加载灰度图像。 例如，如果文件表示此格式的图像，它将提供每通道 16 位的灰度图像。</li><li><code>cv2.IMREAD_ANYDEPTH | cv2.IMREAD_COLOR</code>：尝试加载图像，不关心位深度，以彩色模式加载。此组合以原始位深度加载 BGR 颜色的图像。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_2</code>：这会以原始分辨率的一半加载灰度图像。 例如，如果文件包含<code>640 x 480</code>的图像，则它将作为<code>640 x 480</code>的图像加载。</li><li><code>cv2.IMREAD_REDUCED_COLOR_2</code>：这将以每通道 8 位 BGR 的颜色加载图像，其分辨率为原始分辨率的一半。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_4</code>：这会以原始分辨率的四分之一加载灰度图像。</li><li><code>cv2.IMREAD_REDUCED_COLOR_4</code>：这将以每通道 8 位的颜色加载原始分辨率的四分之一的图像。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_8</code>：这会以原始分辨率的八分之一以灰度加载图像。</li><li><code>cv2.IMREAD_REDUCED_COLOR_8</code>：这将以每通道 8 位的颜色加载图像，其分辨率为原始分辨率的八分之一。<br>以不同的降采样级别加载图像。这些常量用于加载具有不同降采样级别的图像。数字表示降采样的级别，例如，”2”表示图像宽度和高度减小到原始大小的1&#x2F;2。</li></ul><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><pre class="line-numbers language-none"><code class="language-none">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple opencv-python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)    cv2.imshow(&quot;blue&quot;, image[:, :, 0])  cv2.imshow(&quot;green&quot;, image[:, :, 1])  cv2.imshow(&quot;red&quot;, image[:, :, 2])    gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  cv2.imshow(&quot;gray&quot;, gray)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="图像的裁剪"><a href="#图像的裁剪" class="headerlink" title="图像的裁剪"></a>图像的裁剪</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)    crop &#x3D; image[10:170, 40:200]    cv2.imshow(&quot;crop&quot;, crop)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    image &#x3D; np.zeros([300, 300, 3], dtype&#x3D;np.uint8)    cv2.line(image, (100, 200), (250, 250), (255, 255, 0), 2)  cv2.rectangle(image, (30, 100), (60, 150), (0, 255, 255), 4)  cv2.circle(image, (150, 100), 20, (255, 0, 255), 5)  cv2.putText(image, &quot;hello&quot;, (100, 50), 0, 1, (255, 255, 255), 1)    cv2.imshow(&quot;image&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="噪点去除"><a href="#噪点去除" class="headerlink" title="噪点去除"></a>噪点去除</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;plane.jpg&quot;)    gauss &#x3D; cv2.GaussianBlur(image, (5, 5), 0)  median &#x3D; cv2.medianBlur(image, 5)    cv2.imshow(&quot;image&quot;, image)  cv2.imshow(&quot;gauss&quot;, gauss)  cv2.imshow(&quot;median&quot;, median)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取转角"><a href="#获取转角" class="headerlink" title="获取转角"></a>获取转角</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)  gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    corners &#x3D; cv2.goodFeaturesToTrack(gray, 500, 0.1, 10)  for corner in corners:      x, y &#x3D; corner.ravel()      cv2.circle(image, (int(x), int(y)), 3, (255, 0, 255), -1)    cv2.imshow(&quot;corners&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="匹配菱形框"><a href="#匹配菱形框" class="headerlink" title="匹配菱形框"></a>匹配菱形框</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    image &#x3D; cv2.imread(&quot;poker.jpg&quot;)  gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    template &#x3D; gray[75:105, 235:265]    match &#x3D; cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)  location &#x3D; np.where(match &gt;&#x3D; 0.9)    w, h &#x3D; template.shape[0:2]  for p in zip(*location[::-1]):      x1, y1 &#x3D; p[0], p[1]      x2, y2 &#x3D; x1 + w, y1 + h      cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)    cv2.imshow(&quot;image&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="图像明暗变化梯度图"><a href="#图像明暗变化梯度图" class="headerlink" title="图像明暗变化梯度图"></a>图像明暗变化梯度图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    gray &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;, cv2.IMREAD_GRAYSCALE)    laplacian &#x3D; cv2.Laplacian(gray, cv2.CV_64F)  canny &#x3D; cv2.Canny(gray, 100, 200)    cv2.imshow(&quot;gray&quot;, gray)  cv2.imshow(&quot;laplacian&quot;, laplacian)  cv2.imshow(&quot;canny&quot;, canny)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="阈值处理"><a href="#阈值处理" class="headerlink" title="阈值处理"></a>阈值处理</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    gray &#x3D; cv2.imread(&quot;bookpage.jpg&quot;, cv2.IMREAD_GRAYSCALE)  ret, binary &#x3D; cv2.threshold(gray, 10, 255, cv2.THRESH_BINARY)  binary_adaptive &#x3D; cv2.adaptiveThreshold(      gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 155, 1)  ret1, binary_otsu &#x3D; cv2.threshold(gray, 0 ,255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)    cv2.imshow(&quot;gray&quot;, gray)  cv2.imshow(&quot;binary&quot;, binary)  cv2.imshow(&quot;adaptive&quot;, binary_adaptive)  cv2.imshow(&quot;otsu&quot;, binary_otsu)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="形态学算法（腐蚀、膨胀）"><a href="#形态学算法（腐蚀、膨胀）" class="headerlink" title="形态学算法（腐蚀、膨胀）"></a>形态学算法（腐蚀、膨胀）</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    gray &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;, cv2.IMREAD_GRAYSCALE)    _, binary &#x3D; cv2.threshold(gray, 200, 255, cv2. THRESH_BINARY_INV)  kernel &#x3D; np.ones((5, 5), np.uint8)    erosion &#x3D; cv2.erode(binary, kernel)  dilation &#x3D; cv2.dilate(binary, kernel)    cv2.imshow(&quot;binary&quot;, binary)  cv2.imshow(&quot;erosion&quot;, erosion)  cv2.imshow(&quot;dilation&quot;, dilation)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="使用numpy-array访问图像数据并显示图像"><a href="#使用numpy-array访问图像数据并显示图像" class="headerlink" title="使用numpy.array访问图像数据并显示图像"></a>使用<code>numpy.array</code>访问图像数据并显示图像</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  img[150, 120] &#x3D; [255, 255, 255]    cv2.imshow(&#39;1&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>操作 BGR 图像中坐标<code>(150, 120)</code>处的像素并将其变成白色像素，</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)    cv2.imshow(&#39;1&#39;, img)    img.itemset((150, 120, 0), 255)    print(img.item(150, 120, 0))      cv2.imshow(&#39;2&#39;, img)cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更改特定像素的蓝色值，例如坐标<code>(150, 120)</code>处的像素。 <code>numpy.array</code>类型提供了一种方便的方法<code>item</code>，它采用三个参数：<code>x</code>（或左侧）位置，<code>y</code>（或顶部）位置以及索引 （<code>x</code>，<code>y</code>）位置处的数组内（请记住，在 BGR 图像中，特定位置的数据是包含 B，G 和 R 值按此顺序排列），并在索引位置返回该值。 另一种方法<code>itemset</code>将特定像素的特定通道的值设置为指定值。 <code>itemset</code>接受两个参数：一个三元素元组（<code>x</code>，<code>y</code>和索引）和新值。</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  img[:, :, 1] &#x3D; 0    cv2.imshow(&#39;1&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>它基本上指示程序从所有行和列中获取所有像素，并将绿色值（三元素 BGR 数组的索引之一）设置为<code>0</code>。 如果显示此图像，您会注意到完全没有绿色。</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)    cv2.imshow(&#39;1&#39;, img)    my_roi &#x3D; img[0:100, 0:100]  img[300:400, 300:400] &#x3D; my_roi    cv2.imshow(&#39;2&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们可以通过使用 NumPy 的数组切片访问原始像素来做几件有趣的事情。 其中之一是定义<strong>兴趣区域</strong>（<strong>ROI</strong>）。 定义区域后，我们可以执行许多操作。 例如，我们可以将此区域绑定到变量，定义第二个区域，并将第一个区域的值分配给第二个区域（因此，将图像的一部分复制到图像中的另一个位置）</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  print(img.shape)  print(img.size)  print(img.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>shape</code>：这是一个描述数组形状的元组。 对于图像，它包含（按顺序）高度，宽度和（如果图像是彩色的）通道数。 <code>shape</code>元组的长度是确定图像是灰度还是彩色的有用方法。 对于灰度图像，我们有<code>len(shape) == 2</code>，对于彩色图像，我们有<code>len(shape) == 3</code>。</li><li><code>size</code>：这是数组中元素的数量。 在灰度图像的情况下，这与像素数相同。 在 BGR 图像的情况下，它是像素数的三倍，因为每个像素都由三个元素（B，G 和 R）表示。</li><li><code>dtype</code>：这是数组元素的数据类型。 对于每通道 8 位图像，数据类型为<code>numpy.uint8</code>。</li></ul><h5 id="读-写视频文件"><a href="#读-写视频文件" class="headerlink" title="读&#x2F;写视频文件"></a>读&#x2F;写视频文件</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    videoCapture &#x3D; cv2.VideoCapture(&#39;MyInputVid.mp4&#39;)  fps &#x3D; videoCapture.get(cv2.CAP_PROP_FPS)  size &#x3D; (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),          int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))  videoWriter &#x3D; cv2.VideoWriter(      &#39;MyOutputVid.mp4&#39;, cv2.VideoWriter_fourcc(*&#39;mp4v&#39;),      fps, size)    success, frame &#x3D; videoCapture.read()  while success:  # Loop until there are no more frames.      videoWriter.write(frame)      success, frame &#x3D; videoCapture.read()    videoCapture.release()  videoWriter.release()  cv2.destroyAllWindows()# 参考书代码import cv2videoCapture &#x3D; cv2.VideoCapture(&#39;MyInputVid.avi&#39;)fps &#x3D; videoCapture.get(cv2.CAP_PROP_FPS)size &#x3D; (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),        int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))videoWriter &#x3D; cv2.VideoWriter(    &#39;MyOutputVid.avi&#39;, cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),    fps, size)success, frame &#x3D; videoCapture.read()while success:  # Loop until there are no more frames.    videoWriter.write(frame)    success, frame &#x3D; videoCapture.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>注意</strong>参考书中适用的视频格式为<code>avi</code>，我将代码略加修改，适配了更常见的<code>mp4</code>格式。</li><li><code>VideoWriter</code>类的构造器的参数值得特别注意。 必须指定视频的文件名。 具有该名称的任何先前存在的文件都将被覆盖。 还必须指定视频编解码器。 可用的编解码器可能因系统而异。 支持的选项可能包括以下内容：<ol><li><code>0</code>：此选项是未压缩的原始视频文件。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;)</code>：此选项是未压缩的 YUV 编码，4:2:0 色度被二次采样。 这种编码具有广泛的兼容性，但会产生大文件。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;P&#39;,&#39;I&#39;,&#39;M&#39;,&#39;1&#39;)</code>：此选项是 MPEG-1。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;V&#39;,&#39;I&#39;,&#39;D&#39;)</code>：此选项是相对较旧的 MPEG-4 编码。 如果要限制生成的视频的大小，这是一个不错的选择。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;P&#39;,&#39;4&#39;,&#39;V&#39;)</code>：此选项是另一种相对较旧的 MPEG-4 编码。 如果要限制生成的视频的大小，这是一个不错的选择。 文件扩展名应为<code>.mp4</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;2&#39;,&#39;6&#39;,&#39;4&#39;)</code>：此选项是相对较新的 MPEG-4 编码。 如果您想限制最终视频的大小，这可能是最好的选择。 文件扩展名应为<code>.mp4</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;T&#39;,&#39;H&#39;,&#39;E&#39;,&#39;O&#39;)</code>：此选项为 <strong>Ogg Vorbis</strong>。 文件扩展名应为<code>.ogv</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;F&#39;,&#39;L&#39;,&#39;V&#39;,&#39;1&#39;)</code>：此选项是 Flash 视频。 文件扩展名应为<code>.flv</code>。</li></ol></li><li>但仍可能会遇见一些问题吗，下面是一些解决方案：<ol><li><strong>重新编译OpenCV</strong>：如果使用的是自定义构建的OpenCV，尝试重新编译OpenCV时确保启用了FFmpeg支持。在CMake配置时，启用相应的选项，以便OpenCV可以使用FFmpeg。然后重新构建OpenCV。</li><li><strong>使用不同的FourCC代码</strong>：尝试使用其他编解码器</li><li><strong>下载并安装对应的库</strong> </li><li><strong>检查OpenCV版本</strong>：如果 OpenCV 版本较旧，可能会存在问题。尝试更新到最新版本的 OpenCV，以获得更好的支持。</li></ol></li><li>还必须指定帧速率和帧大小。 由于我们正在从另一个视频复制，因此可以从<code>VideoCapture</code>类的<code>get</code>方法读取这些属性。</li></ul><h5 id="捕捉相机帧并输出相机"><a href="#捕捉相机帧并输出相机" class="headerlink" title="捕捉相机帧并输出相机"></a>捕捉相机帧并输出相机</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    cameraCapture &#x3D; cv2.VideoCapture(0)  fps &#x3D; 30  # An assumption  size &#x3D; (int(cameraCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),          int(cameraCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))  videoWriter &#x3D; cv2.VideoWriter(      &#39;MyOutputVid.avi&#39;, cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),      fps, size)    success, frame &#x3D; cameraCapture.read()  numFramesRemaining &#x3D; 10 * fps - 1 # 10 seconds of frames  while success and numFramesRemaining &gt; 0:      videoWriter.write(frame)      success, frame &#x3D; cameraCapture.read()      numFramesRemaining -&#x3D; 1    cameraCapture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在窗口中显示摄像机帧"><a href="#在窗口中显示摄像机帧" class="headerlink" title="在窗口中显示摄像机帧"></a>在窗口中显示摄像机帧</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    capture &#x3D; cv2.VideoCapture(0)    while True:      ret, frame &#x3D; capture.read()      cv2.imshow(&quot;camera&quot;, frame)      key &#x3D; cv2.waitKey(1)      if key !&#x3D; -1:          break    capture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>capture.read()</code> 是 OpenCV 中用于从视频捕获设备（例如摄像头）中读取一帧视频的函数。它返回两个值，第一个是布尔值（通常命名为 <code>ret</code>），表示是否成功读取帧，第二个是视频帧本身，通常是一个NumPy数组。</li><li><code>cv2.VideoCapture()</code> 是 OpenCV 中用于创建视频捕获对象的函数，可以用于从摄像头、视频文件或其他视频源中捕获视频帧。它接受一个参数，该参数可以是以下三种类型之一：<ol><li>整数（通常为0、1、2等）：表示要使用的摄像头的索引。通常情况下，0表示默认摄像头，1表示第二个摄像头（如果有多个摄像头）。  <pre class="line-numbers language-none"><code class="language-none">import cv2# 创建一个视频捕获对象，0表示默认摄像头capture &#x3D; cv2.VideoCapture(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>字符串：表示视频文件的路径，可以是本地文件路径或网络视频流的URL。</li><li>IP摄像头地址：如果您有网络摄像头，可以将其IP地址作为字符串传递给 <code>cv2.VideoCapture()</code>，以便从网络摄像头捕获视频。</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2clicked &#x3D; Falsedef onMouse(event, x, y, flags, param):    global clicked    if event &#x3D;&#x3D; cv2.EVENT_LBUTTONUP:        clicked &#x3D; TruecameraCapture &#x3D; cv2.VideoCapture(0)cv2.namedWindow(&#39;MyWindow&#39;)cv2.setMouseCallback(&#39;MyWindow&#39;, onMouse)print(&#39;Showing camera feed. Click window or press any key to stop.&#39;)success, frame &#x3D; cameraCapture.read()while success and cv2.waitKey(1) &#x3D;&#x3D; -1 and not clicked:    cv2.imshow(&#39;MyWindow&#39;, frame)    success, frame &#x3D; cameraCapture.read() cv2.destroyWindow(&#39;MyWindow&#39;)cameraCapture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>def onMouse(event, x, y, flags, param)</code>: 定义一个鼠标事件处理函数<code>onMouse</code>，该函数会在鼠标事件发生时被调用。它接受五个参数：<code>event</code>表示触发的事件类型，<code>x</code>和<code>y</code>表示鼠标事件发生的坐标，<code>flags</code>表示鼠标事件的附加标志，<code>param</code>表示可选参数。<ol><li>在<code>onMouse</code>函数中，当鼠标左键被释放（<code>cv2.EVENT_LBUTTONUP</code>事件）时，将全局变量<code>clicked</code>设置为True，表示用户点击了窗口。</li><li><code>event</code>参数表示触发的鼠标事件类型。在这个函数中，我们检查是否是左键释放事件 (<code>cv2.EVENT_LBUTTONUP</code>)。</li><li><code>x</code>和<code>y</code>参数表示鼠标事件发生的坐标，即鼠标指针在窗口上的位置。</li><li><code>flags</code>参数包含了与事件相关的附加标志，但在这个代码中没有使用。</li><li><code>param</code>参数是可选参数，通常用于传递额外的数据，但在这个代码中也没有使用。</li></ol></li><li><code>cv2.namedWindow(&#39;MyWindow&#39;)</code>: 创建一个名为”MyWindow”的窗口，用于显示摄像头捕获的视频。<ol><li><code>cv2.namedWindow()</code> 是OpenCV库中的一个函数，用于创建一个窗口以显示图像、视频或其他视觉数据。它的一般语法如下：&#96;cv2.namedWindow(winname, flags&#x3D;cv2.WINDOW_AUTOSIZE)</li><li><code>winname</code>: 表示要创建的窗口的名称或标识符。您可以自定义窗口的名称，以便在后续的操作中引用该窗口。</li><li><code>flags</code>（可选参数）: 指定窗口的标志。这是一个可选参数，默认值为<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口的大小会自动根据显示内容调整。您也可以将其设置为<code>cv2.WINDOW_NORMAL</code>，以允许手动调整窗口大小。</li></ol></li><li><code>cv2.setMouseCallback(&#39;MyWindow&#39;, onMouse)</code>: 在窗口”MyWindow”上设置鼠标事件回调函数，以便捕获鼠标事件。<ol><li><code>cv2.setMouseCallback()</code> 是OpenCV中的一个函数，用于设置鼠标事件的回调函数，以便在指定的窗口上捕获和处理鼠标事件。它的一般语法如下：<code>cv2.setMouseCallback(windowName, onMouse, param=None)</code></li><li><code>windowName</code>: 表示要在其上设置鼠标事件回调的窗口的名称。通常，您在使用<code>cv2.namedWindow()</code>创建窗口时指定的窗口名称。</li><li><code>onMouse</code>: 是一个回调函数，用于处理鼠标事件。当鼠标事件发生时，OpenCV将调用此函数并传递相关的事件信息。</li></ol></li><li>回调的事件参数是以下操作之一：<ul><li><code>cv2.EVENT_MOUSEMOVE</code>：此事件涉及鼠标移动。</li><li><code>cv2.EVENT_LBUTTONDOWN</code>：此事件是指按下左按钮时会使其按下。</li><li><code>cv2.EVENT_RBUTTONDOWN</code>：此事件是指按下该按钮时向下的右键。</li><li><code>cv2.EVENT_MBUTTONDOWN</code>：此事件是指按下中键时按下的中键。</li><li><code>cv2.EVENT_LBUTTONUP</code>：此事件是指释放时返回的左按钮。</li><li><code>cv2.EVENT_RBUTTONUP</code>：此事件指的是释放按钮时再次弹出的右键。</li><li><code>cv2.EVENT_MBUTTONUP</code>：此事件是指释放按钮时中间按钮再次出现。</li><li><code>cv2.EVENT_LBUTTONDBLCLK</code>：此事件表示双击左按钮。</li><li><code>cv2.EVENT_RBUTTONDBLCLK</code>：此事件表示双击右键。</li><li><code>cv2.EVENT_MBUTTONDBLCLK</code>：此事件是指双击中间按钮。</li></ul></li><li>鼠标回调的<code>flags</code>参数可能是以下事件的按位组合：<ul><li><code>cv2.EVENT_FLAG_LBUTTON</code>：此事件是指按下左按钮。</li><li><code>cv2.EVENT_FLAG_RBUTTON</code>：此事件表示按下了右键。</li><li><code>cv2.EVENT_FLAG_MBUTTON</code>：此事件是指按下中间按钮。</li><li><code>cv2.EVENT_FLAG_CTRLKEY</code>：此事件是指按下<code>Ctrl</code>键。</li><li><code>cv2.EVENT_FLAG_SHIFTKEY</code>：此事件是指按下<code>Shift</code>键。</li><li><code>cv2.EVENT_FLAG_ALTKEY</code>：此事件是指按下<code>Alt</code>键。</li></ul></li></ul><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5><h5 id="-3"><a href="#-3" class="headerlink" title=""></a></h5><h5 id="-4"><a href="#-4" class="headerlink" title=""></a></h5><h5 id="-5"><a href="#-5" class="headerlink" title=""></a></h5><h5 id="-6"><a href="#-6" class="headerlink" title=""></a></h5><h5 id="-7"><a href="#-7" class="headerlink" title=""></a></h5><h5 id="-8"><a href="#-8" class="headerlink" title=""></a></h5><h5 id="-9"><a href="#-9" class="headerlink" title=""></a></h5>]]></content>
      
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obsidian</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/obsidian/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/obsidian/</url>
      
        <content type="html"><![CDATA[<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><ul><li>输入<code>[[</code>后，会自动弹出列表对话框，其中包含了笔记名、图片名，选中想要链接的笔记。之后输入<code>^</code>，再次选择笔记中的文本，找到自己想要链接的具体内容；输入<code>|</code>显示链接的名字。在<code>[[]]</code>前加上<code>!</code>会显示出链接的内容。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> obsidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/numpy/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/numpy/</url>
      
        <content type="html"><![CDATA[<h5 id="生成数组或序"><a href="#生成数组或序" class="headerlink" title="生成数组或序"></a>生成数组或序</h5><pre class="line-numbers language-none"><code class="language-none">numpy.zeros(shape, dtype&#x3D;float, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>shape</code>：这是一个表示所需数组形状的元组或整数。例如，要创建一个2行3列的零数组，可以使用<code>shape=(2, 3)</code>。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。</li><li>行主序，横为行；列主序，竖为行。<pre class="line-numbers language-none"><code class="language-none">numpy.ones(shape, dtype&#x3D;None, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>shape</code>：这是一个表示所需数组形状的元组或整数。例如，要创建一个2行3列的全1数组，可以使用<code>shape=(2, 3)</code>。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。<pre class="line-numbers language-none"><code class="language-none">numpy.eye(N, M&#x3D;None, k&#x3D;0, dtype&#x3D;float, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>N</code>：矩阵的行数（以及列数，因为单位矩阵是方阵）。这是必需的参数。</li><li><code>M</code>（可选）：矩阵的列数。默认情况下，它等于 <code>N</code>，因此创建的是一个 <code>N x N</code> 的方阵。</li><li><code>k</code>（可选）：对角线的偏移。默认为0，表示主对角线上的元素为1。如果将其设置为正数或负数，将在主对角线上偏离 <code>k</code> 步的位置放置1。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。<pre class="line-numbers language-none"><code class="language-none">numpy.arange([start, ]stop, [step, ]dtype&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>start</code>（可选）：序列的起始值。如果不提供，默认为0。</li><li><code>stop</code>：序列的终止值（不包括该值）。</li><li><code>step</code>（可选）：序列中的值之间的间隔（步长）。如果不提供，默认为1。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下为<code>None</code>，它会自动推断为适当的数据类型。<pre class="line-numbers language-none"><code class="language-none">numpy.linspace(start, stop, num&#x3D;50, endpoint&#x3D;True, retstep&#x3D;False, dtype&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>start</code>：生成的范围的起始值。</li><li><code>stop</code>：生成的范围的结束值。生成的数组将包括此值。</li><li><code>num</code>（可选）：要生成的样本数量，默认为50。</li><li><code>endpoint</code>（可选）：如果为True（默认值），则生成的数组包括<code>stop</code>值；如果为False，生成的数组不包括<code>stop</code>值。</li><li><code>retstep</code>（可选）：如果为True，函数将返回一个元组，其中包括生成的数组和生成的步长值。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>None</code>，这意味着数据类型将根据输入的参数来确定。</li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">numpy.frombuffer(buffer, dtype&#x3D;float, count&#x3D;-1, offset&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>buffer</code>：要从中创建数组的缓冲区对象，通常是字节数组或字节对象。</li><li><code>dtype</code>：可选参数，指定数组的数据类型，默认为 <code>float</code>。你可以指定其他的数据类型，如 <code>int</code>、<code>str</code> 等。</li><li><code>count</code>：可选参数，要从缓冲区中读取的元素数量，默认为 -1，表示读取整个缓冲区的内容。</li><li><code>offset</code>：可选参数，指定从缓冲区的哪个位置开始读取数据，默认为 0，表示从缓冲区的开头开始读取。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/markdown-yu-fa/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h5 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h5><ul><li>在一行中用三个以上的星号*、减号-、底线_来建立一个分隔线，行内不能有其他东西，但可以在星号或减号蹭插入空格。<pre class="line-numbers language-none"><code class="language-none">********** * * <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><ul><li>如果段落上的文字要添加删除线，在文字的两端加上两个波浪线~~<pre class="line-numbers language-none"><code class="language-none">~~需要添加删除线的文本~~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h5><ul><li>下划线通过 HTML 的标签来实现<pre class="line-numbers language-none"><code class="language-none">&lt;u&gt;需要添加下划线的文本&lt;&#x2F;u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h5><ul><li>脚注是对文本的补充说明。<pre class="line-numbers language-none"><code class="language-none">[^需要注明的文本]：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h5><ul><li>Markdown 区块引用是在段落开头使用 &gt; 符号，然后后面紧跟一个空格符号。区块可以嵌套使用。<pre class="line-numbers language-none"><code class="language-none">&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; &gt;&gt; &gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h5><ul><li>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，在特殊符号前使用反斜杠” \ “转义特殊字符<pre class="line-numbers language-none"><code class="language-none">*文本斜体*\*正常文本\*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5>]]></content>
      
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂项</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/za-xiang/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/za-xiang/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://zh.wikipedia.org/wiki/JDK">JDK</a>，Java Development Kit。一种开源的针对Java开发人员的软件开发工具包。</li><li><a href="https://zh.wikipedia.org/wiki/Apache_Tomcat#">TomCat</a>，一种通过 Docket 部署 Web 网页的软件。</li><li><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E8%8E%93%E6%B4%BE">树莓派</a>，树莓派（Raspberry Pi）是一种基于 ARM 架构的微型计算机，采用了 ARM 处理器，这种处理器常用于智能手机和平板电脑等移动设备中。</li><li><a href="https://zh.wikipedia.org/wiki/%E4%BD%BF%E7%94%A8%E8%80%85%E7%B6%93%E9%A9%97">UX</a>，用户体验，User Experience，又译用户体验、用户体验，简称UX。</li><li><a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2">UI</a>，用户界面，User Interface，简称UI，亦称使用者界面是系统和用户之间进行交互和信息交换的介质，它实现信息的内部形式与人类可以接受形式之间的转换。</li><li><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1">SaaS软件即服务</a>，Software as a Service。简单地理解为在网页上运行的软件。</li><li>rss订阅，一种将所有平台上想要看到的信息整合到一个平台或软件的的XML应用</li><li><a href="https://zh.wikipedia.org/zh-cn/%E9%98%BF%E5%B0%94%E6%B3%95%E9%80%9A%E9%81%93">阿尔法通道</a>，表示图像的透明程度，0 表示完全透明，255 表示完全不透明。 ^025801</li><li>通道索引，在彩色图像中，每个像素通常由三个颜色通道组成：红色（R）、绿色（G）和蓝色（B），通常以0、1 和 2 来索引这三个通道。这些通道用于描述像素的颜色信息，它们的组合形成了图像的最终颜色。<ul><li>通道索引 0 对应于蓝色通道（Blue Channel）</li><li>通道索引 1 对应于绿色通道（Green Channel）</li><li>通道索引 2 对应于红色通道（Red Channel）</li></ul></li><li><a href="https://zh.wikipedia.org/wiki/YUV#YUV%E8%BD%89RGB">YUV</a>，YUV 编码是一种用于表示彩色图像的颜色空间编码系统。它将图像的颜色信息和亮度信息分开存储，以便有效地压缩和传输图像数据。YUV 编码通常用于视频压缩、视频编解码和图像处理领域。YUV 编码由三个分量组成：<ul><li><strong>Y（亮度）</strong>：表示图像的亮度信息，也称为亮度通道。Y 值决定了图像的明暗程度，因此它包含了图像的主要亮度信息。人眼对亮度更敏感，所以这个通道通常是高质量的，不容易丢失。</li><li><strong>U（色度）</strong>：表示颜色信息的色度通道。U 值决定了图像的蓝色和黄色分量，用于描述颜色的色度信息。通常，U 通道的值在蓝色和黄色之间变化。</li><li><strong>V（色度）</strong>：也是表示颜色信息的色度通道。V 值决定了图像的红色和绿色分量，用于描述颜色的另一部分色度信息。通常，V 通道的值在红色和绿色之间变化。</li><li>通过将亮度和色度信息分开存储，YUV 编码允许对图像进行高效的压缩，因为亮度通常占据了图像数据的大部分，而色度信息则相对较小。这在视频编码中特别有用，因为视频通常包含大量的静止背景，亮度信息在帧之间变化较小，而色度信息变化较大。</li><li>YUV 编码常见的变体包括 YCbCr（用于数字视频和广播）、YIQ（用于模拟视频广播）等。这些编码系统都遵循类似的原则，将亮度和色度信息分离以提高图像和视频的编解码效率。</li></ul></li><li>多径效应：指电磁波经不同路径传播后，各分量场到达接收端时间不同，按各自相位相互叠加而造成干扰，使得原来的信号失真，或者产生错误。比如电磁波沿不同的两条路径传播，而两条路径的长度正好相差半个波长，那么两路信号到达终点时正好相互抵消了（波峰与波谷重合）。这种现象在以前看模拟信号电视的过程中经常会遇到，在看电视的时候如果信号较差，就会看到屏幕上出现重影，这是因为电视上的电子枪从左向右扫描时，用后到的信号在稍靠右的地方形成了虚像。因此，多径效应是衰落的重要成因。多径效应对于数字通信、雷达最佳检测等都有着十分严重的影响。 ^634b06</li><li><strong>位</strong>（bit）：是最基本的概念，在计算机中，由于只有逻辑0和逻辑1的存在，因此很多东西、动作、数字都要表示为一串二进制的字码例如： 1001 0000 1101等等。其中每一个逻辑0或者1便是一个位。</li><li><strong>字节</strong>（Byte）： 是由 8 个位组成的一个单元，也就是 8 个 bit 组成1个 Byte 。在计算机科学中，字节用于表示 ASCII 字符。</li><li><strong>字</strong>： 16个位为一个字，它代表计算机处理指令或数据的二进制数位数，是计算机进行数据存储和数据处理的运算的单位。通常称 16 位是一个字，而32位呢，则是一个双字，64位是两个双字。</li><li>分组转发是指在互联网络中路由器转发IP分组的物理传输过程与数据报转发机制。根据分组的目的IP地址与源IP地址是否属于同一个子网可分为直接转发和间接转发。直接转发和间接转发是路由器需要根据分组的目的IP地址与源IP地址是否属于同一个网络来判断的。当分组的源主机和目的主机在同一个网络，或者是当目的路由器向目的主机传送时，分组就是直接转发。如果目的主机与源主机不在一个网络上，分组就要间接转发</li><li>UDP、TCP、IPv6、BGP、SOPF、RIP、ICMP、IP</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的优化</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/hexo-de-you-hua/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/hexo-de-you-hua/</url>
      
        <content type="html"><![CDATA[<h5 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h5><ul><li>目录下配置文件<code>_config.yml</code>配置:<pre class="line-numbers language-none"><code class="language-none">theme: hexo-theme-matery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="博客站点相关信息"><a href="#博客站点相关信息" class="headerlink" title="博客站点相关信息"></a>博客站点相关信息</h5><pre class="line-numbers language-none"><code class="language-none">title: 七破风的博客 # 网站标题subtitle: &#39;&#39; # 网站副标题description: &#39;&#39; #keywords: # 关键字author: Chipforn # 博客作者姓名language: zh-CN # 博客使用的语言timezone: &#39;&#39; # 时区，默认电脑时区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码高亮设置"><a href="#代码高亮设置" class="headerlink" title="代码高亮设置"></a>代码高亮设置</h5><ul><li>安装hexo代码高亮插件<pre class="line-numbers language-none"><code class="language-none">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置：<pre class="line-numbers language-none"><code class="language-none">highlight:  enable: falseprism_plugin:  mode: &#39;preprocess&#39;      theme: &#39;tomorrow&#39;  line_number: false      custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h5><ul><li>安装 hexo-generator-search 搜索插件<pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：<pre class="line-numbers language-none"><code class="language-none">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="文章字数统计插件"><a href="#文章字数统计插件" class="headerlink" title="文章字数统计插件"></a>文章字数统计插件</h5><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。</p><pre class="line-numbers language-none"><code class="language-none">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class="line-numbers language-none"><code class="language-none">postInfo:  date: true # 发布日期  update: true # 更新日期  wordCount: true # 文章字数统计  totalCount: true # 站点总文章字数  min2read: true # 文章阅读时长  readCount: true # 文章阅读次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo更新博客</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/hexo-geng-xin-bo-ke/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/hexo-geng-xin-bo-ke/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-next</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/hexo-next/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/hexo-next/</url>
      
        <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">&lt;!--&#123;%- if theme.footer.powered %&#125;  &lt;div class&#x3D;&quot;powered-by&quot;&gt;    &#123;%- set next_site &#x3D; &#39;https:&#x2F;&#x2F;theme-next.org&#39; %&#125;    &#123;%- if theme.scheme !&#x3D;&#x3D; &#39;Gemini&#39; %&#125;      &#123;%- set next_site &#x3D; &#39;https:&#x2F;&#x2F;&#39; + theme.scheme | lower + &#39;.theme-next.org&#39; %&#125;    &#123;%- endif %&#125;    &#123;&#123;- __(&#39;footer.powered&#39;, next_url(&#39;https:&#x2F;&#x2F;hexo.io&#39;, &#39;Hexo&#39;, &#123;class: &#39;theme-link&#39;&#125;) + &#39; &amp; &#39; + next_url(next_site, &#39;NexT.&#39; + theme.scheme, &#123;class: &#39;theme-link&#39;&#125;)) &#125;&#125;  &lt;&#x2F;div&gt;&#123;%- endif %&#125;--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-pure-master</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/hexo-theme-pure-master/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/hexo-theme-pure-master/</url>
      
        <content type="html"><![CDATA[<h5 id="菜单项"><a href="#菜单项" class="headerlink" title="菜单项"></a>菜单项</h5><pre class="line-numbers language-none"><code class="language-none"># menu 左侧菜单menu:  Home: .  Archives: archives  # 归档  Categories: categories  # 分类  Tags: tags  # 标签  Repository: repository  # github repositories 项目仓库  Books: books  # 书单  Links: links  # 友链  About: about  # 关于<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="菜单图标项"><a href="#菜单图标项" class="headerlink" title="菜单图标项"></a>菜单图标项</h5><pre class="line-numbers language-none"><code class="language-none"># Enable&#x2F;Disable menu icons 菜单图标menu_icons: # 图标更换网址：https:&#x2F;&#x2F;www.iconfont.cn&#x2F;  enable: true  # 是否启用导航菜单图标  home: icon-home-fill # 首页图标  archives: icon-archives-fill # 归档图标  categories: icon-folder # 分类图标  tags: icon-tags # 标签图标  repository: icon-project # 项目图标  books: icon-book-fill # 书单图标  links: icon-friendship # 友链图标  about: icon-cup-fill # 关于图标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="rss订阅"><a href="#rss订阅" class="headerlink" title="rss订阅"></a>rss订阅</h5><pre class="line-numbers language-none"><code class="language-none">rss: &#x2F;atom.xml # 博客rss地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="网站的信息"><a href="#网站的信息" class="headerlink" title="网站的信息"></a>网站的信息</h5><pre class="line-numbers language-none"><code class="language-none"># Site网站site:  logo:    enabled: true # 是否使用自己的logo    width: 40 # 宽度    height: 40 # 高度    url: ..&#x2F;images&#x2F;logo.png  title: 七破风的博客 # 页面名称标题  favicon: &#x2F;favicon.png # 网站头像文件的名字  board: &lt;p&gt;Welcome！&lt;&#x2F;p&gt; # 站点公告  copyright: false # 底部版权信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><pre class="line-numbers language-none"><code class="language-none"># config配置config:  skin: theme-black # 主题颜色 theme-black theme-blue theme-green theme-purple  layout: main-center # 布局方式 main-left main-center main-right  toc: true # 是否开启文章章节目录导航  menu_highlight: true # 是否开启当前菜单高亮显示  thumbnail: false # enable posts thumbnail, options: true, false，作用暂不清楚，或许是因为没有tag、category  excerpt_link: Read More  #New  isNewTabLinks: true #是否链接打开新标签页  autoUnfold: true # 默认展开文章目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="页码"><a href="#页码" class="headerlink" title="页码"></a>页码</h5><h5 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h5><h5 id="小部件归档模式"><a href="#小部件归档模式" class="headerlink" title="小部件归档模式"></a>小部件归档模式</h5><h5 id="搜索关键字-scrollpercent，把-false-改为-true。"><a href="#搜索关键字-scrollpercent，把-false-改为-true。" class="headerlink" title="搜索关键字 scrollpercent，把 false 改为 true。"></a>搜索关键字 <code>scrollpercent</code>，把 false 改为 true。</h5>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署 Hexo 时出现的问题</title>
      <link href="/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/bu-shu-hexo-shi-chu-xian-de-wen-ti/"/>
      <url>/2024/04/20/study/ping-chang-zhi-shi/hexo-de-you-hua/bu-shu-hexo-shi-chu-xian-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h5 id="打开个人界面出现"><a href="#打开个人界面出现" class="headerlink" title="打开个人界面出现"></a>打开个人界面出现</h5><pre class="line-numbers language-none"><code class="language-none">extends includes&#x2F;layout.pug block content include .&#x2F;includes&#x2F;mixins&#x2F;post-ui.pug #recent-posts.recent-posts +postUI include includes&#x2F;pagination.pug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行</p><pre class="line-numbers language-none"><code class="language-none">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是一个使用 <code>npm</code> 命令安装多个 Node.js 包的命令。<code>npm</code> 是 Node.js 的包管理器，它用于安装和管理 Node.js 库和应用程序。在这条命令中，您使用 <code>install</code> 命令来安装多个包，包括 <code>hexo-renderer-jade</code>、<code>hexo-generator-feed</code>、<code>hexo-generator-sitemap</code>、<code>hexo-browsersync</code> 和 <code>hexo-generator-archive</code>。您还使用了 <code>--save</code> 选项，表示将这些包保存到项目的依赖项中。</p><p>这些包似乎与 Hexo 静态站点生成器有关。Hexo 是一个流行的静态站点生成器，它可以帮助您快速创建博客、文档和其他类型的网站。这些包提供了 Hexo 的额外功能，例如渲染 Jade 模板、生成 RSS 订阅源和站点地图、实时预览和归档页面生成等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第 3 章存储系统</title>
      <link href="/2024/04/20/study/ji-suan-ji-zu-cheng-yuan-li/di-3-zhang-cun-chu-xi-tong/"/>
      <url>/2024/04/20/study/ji-suan-ji-zu-cheng-yuan-li/di-3-zhang-cun-chu-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1-存储系统概述"><a href="#3-1-存储系统概述" class="headerlink" title="3.1 存储系统概述"></a>3.1 存储系统概述</h1><h5 id="3-1-1-存储系统的层次结构"><a href="#3-1-1-存储系统的层次结构" class="headerlink" title="3.1.1 存储系统的层次结构"></a>3.1.1 存储系统的层次结构</h5><ul><li>在存储器系统设计时，应当综合考虑存储器容 量、速度和价格等因素，建立分层次的存储器 体系。</li><li>高速缓冲存储器简称cache，它是计算机系统 中的一个高速小容量半导体存储器。利用 cache高速存取指令和数据，提高计算机处理 效率，使数据存取速度和CPU的运算速度相匹 配。特点：存取速度快，但是存储容量小。</li><li>主存储器简称主存，是计算机系统的主要存储 器，用来存放计算机运行期间的大量程序和数 据。</li><li>外存储器简称外存，它是大容量辅助存储器。 目前主要使用磁盘存储器、磁带、光盘存储器。 特点：存储容量大、成本低。通常用来存储系 统程序和大型数据文件及数据库。 CPU不能 直接访问外存储器，为存储器的信息必须调入 内存储器后才能为CPU进行处理。</li></ul><h1 id="3-2-静态随机存取存储器"><a href="#3-2-静态随机存取存储器" class="headerlink" title="3.2 静态随机存取存储器"></a>3.2 静态随机存取存储器</h1><h1 id="3-3-动态随机存取存储器"><a href="#3-3-动态随机存取存储器" class="headerlink" title="3.3 动态随机存取存储器"></a>3.3 动态随机存取存储器</h1><h1 id="3-4-只读存储器"><a href="#3-4-只读存储器" class="headerlink" title="3.4 只读存储器"></a>3.4 只读存储器</h1><h1 id="3-5-并行存储器"><a href="#3-5-并行存储器" class="headerlink" title="3.5 并行存储器"></a>3.5 并行存储器</h1><h1 id="3-6-cache存储器"><a href="#3-6-cache存储器" class="headerlink" title="3.6 cache存储器"></a>3.6 cache存储器</h1><h1 id="3-7-虚拟存储器"><a href="#3-7-虚拟存储器" class="headerlink" title="3.7 虚拟存储器"></a>3.7 虚拟存储器</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第9章 无线网络和移动网络</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-9-zhang-wu-xian-wang-luo-he-yi-dong-wang-luo/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-9-zhang-wu-xian-wang-luo-he-yi-dong-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="9-1-无线局域网WLAN"><a href="#9-1-无线局域网WLAN" class="headerlink" title="9.1 无线局域网WLAN"></a>9.1 无线局域网WLAN</h1><h2 id="9-1-1-无线局域网的组成"><a href="#9-1-1-无线局域网的组成" class="headerlink" title="9.1.1 无线局域网的组成"></a>9.1.1 无线局域网的组成</h2><ul><li>无线局域网可分为两大类。第一类是<strong>有固定基础设施的</strong>，第二类是<strong>无固定基础设施的</strong>。</li><li><strong>IEEE 802.11</strong><ol><li>802.11标准规定无线局域网的最小构件是<strong>基本服务集BSS</strong>。一个基本服务集BSS包括一个基站和若干个移动站，所有的站在本BSS以内都可以直接通信，但在和本BSS以外的站通信时都必须通过本BSS的基站。</li><li>一个基本服务集可以是孤立的，也可通过接入点AP连接到一个<strong>分配系统DS</strong>，然后再连接到另一个基本服务集，这样就构成了一个<strong>扩展的服务集</strong> ESS。分配系统的作用就是使扩展的服务集ESS对上层的表现就像一个基本服务集BSS一样。分配系统可以使用以太网（这是最常用的）、点对点链路或其他无线网络。</li><li>若移动站使用<strong>重建关联</strong>服务，就可把这种关联转移到另一个接入点。当使用分离服务时，就可终止这种关联。</li><li>移动站与接入点AP建立关联的方法有两种。一种是被动扫描，即移动站等待接收接入点AP周期性发出的（例如每秒10次或100次）<strong>信标帧</strong>。信标帧中包含有若干系统参数（如服务集标识符SSID以及支持的速率等）。另一种是主动扫描，即移动站主动发出<strong>探测请求帧</strong>，然后等待从接入点发回的<strong>探测响应帧</strong>。</li></ol></li><li><strong>移动自组网络</strong><ol><li>无固定基础设施的无线局域网，它又叫做<strong>自组网络</strong>。这种自组网络没有上述基本服务集中的接入点AP，而是由一些处于平等状态的移动站相互通信组成的临时网络。</li><li>自组网络通常是这样构成的：一些可移动的设备发现在它们附近还有其他的可移动设备，并且要求和其他移动设备进行通信。</li><li>无线传感器网络的应用就是进行各种数据的采集、处理和传输，一般并不需要很高的带宽，但是在大部分时间必须保持低功耗，以节省电池的消耗。由于无线传感结点的存储容量受限，因此对协议栈的大小有严格的限制。此外，无线传感器网络还对网络安全性、结点自动配置、网络动态重组等方面有一定的要求。</li></ol></li></ul><h2 id="9-1-2-802-11局域网的物理层"><a href="#9-1-2-802-11局域网的物理层" class="headerlink" title="9.1.2 802.11局域网的物理层"></a>9.1.2 802.11局域网的物理层</h2><ul><li>![[Pasted image 20230815160504.png]]</li></ul><h2 id="9-1-3-802-11局域网的MAC层协议"><a href="#9-1-3-802-11局域网的MAC层协议" class="headerlink" title="9.1.3 802.11局域网的MAC层协议"></a>9.1.3 802.11局域网的MAC层协议</h2><ul><li><strong>CSMA&#x2F;CA协议</strong><ol><li>“碰撞检测”（CD）在无线环境下不能使用，理由如下：<ul><li>“碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道。一旦检测到碰撞，就立即停止发送。但由于无线信道的传输条件特殊，其信号强度的动态范围非常大，因此在802.11适配器上接收到的信号强度往往会远远小于发送信号的强度（信号强度可能相差百万倍）。如要在无线局域网的适配器上实现碰撞检测，在硬件上的花费就会过大。</li><li>更重要的是，即使我们能够在硬件上实现无线局域网的碰撞检测功能，也仍然无法避免碰撞的发生。这就表明，无线局域网不需要进行碰撞检测。</li></ul></li><li>“无线局域网不需要进行碰撞检测”是由无线信道本身的特点决定的。我们知道，无线电波能够向所有的方向传播，且其传播距离受限。当电磁波在传播过程中遇到障碍物时，其传播距离就会受到限制。</li><li>无线局域网可能出现检测错误的情况：检测到信道空闲，其实信道并不空闲；有时检测到信道忙，其实信道并不忙。</li><li>CSMA&#x2F;CA协议，CA表示Collision Avoidance，是碰撞避免的意思，<strong>协议的设计是要尽量减少碰撞发生的概率</strong>。</li><li>802.11局域网在使用CSMA&#x2F;CA的同时，还使用停止等待协议。这是因为无线信道的通信质量远不如有线信道的，因此无线站点每通过无线局域网发送完一帧后，要等到收到对方的确认帧后才能继续发送下一帧。这就是<strong>链路层确认</strong>。</li><li>802.11的MAC层在物理层的上面，它包括两个子层：<ul><li><strong>分布协调功能DCF</strong>。DCF不采用任何中心控制，而是在每一个结点使用CSMA机制的分布式接入算法，让各个站通过争用信道来获取发送权。因此DCF向上提供争用服务。802.11协议规定，所有的实现都<strong>必须有</strong> DCF功能。</li><li><strong>点协调功能PCF</strong>。PCF是<strong>选项</strong>，是用接入点AP集中控制整个BSS内的活动，因此自组网络就没有PCF子层。PCF使用集中控制的接入算法，用类似于探询的方法把发送数据权轮流交给各个站，从而避免了碰撞的产生。对于时间敏感的业务，如分组话音，就应使用提供无争用服务的点协调功能PCF。</li></ul></li><li>常用的两种帧间间隔的作用：<ul><li><strong>SIFS</strong>，即<strong>短帧间间隔</strong>，长度为28µs。SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站应当能够从发送方式切换到接收方式。使用SIFS的帧类型有：ACK帧、CTS帧（在后面第2小节“对信道进行预约”中介绍）、由过长的MAC帧分片后的数据帧，以及所有回答AP探询的帧和在PCF方式中接入点AP发送出的任何帧。</li><li><strong>DIFS</strong>，即<strong>分布协调功能帧间间隔</strong>，它比SIFS的帧间间隔要长得多，长度为128µs。在DCF方式中，DIFS用来发送数据帧和管理帧。</li></ul></li><li><strong>在信道从忙态转为空闲时，为了避免几个站同时发送数据（一旦发送就要把一帧发送完，不能中途停止），所有想发送数据的站就都要执行退避算法</strong>。</li><li>可把CSMA&#x2F;CA算法归纳如下：<ul><li>若站点<strong>最初</strong> 有数据要发送（而不是发送不成功再进行重传），且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</li><li>否则，站点执行CSMA&#x2F;CA协议的退避算法。一旦检测到信道忙，就冻结退避计时器。只要信道空闲，退避计时器就进行倒计时。</li><li>当退避计时器时间减少到零时（这时信道只可能是空闲的），站点就发送整个的帧并等待确认。发送站若收到确认，就知道已发送的帧被目的站正确收到了。这时如果要发送第二帧，就要从上面的第二个步骤开始，执行CSMA&#x2F;CA协议的退避算法，随机选定一段退避时间。</li></ul></li><li>以下几种情况必须使用退避算法：<ul><li>在发送第一个帧之前检测到信道处于忙态。</li><li>每一次的重传。</li><li>每一次的成功发送后再要发送下一帧。</li></ul></li></ol></li><li><strong>对信道进行预约</strong><ol><li>A在向B发送数据帧之前，先发送一个短的控制帧，叫做<strong>请求发送</strong> RTS，它包括源地址、目的地址和这次通信（包括相应的确认帧）所需的持续时间。当然，A在发送RTS帧之前，必须先监听信道。若信道空闲，则等待一段时间DIFS后，才能够发送RTS帧。若B正确收到A发来的RTS帧，且媒体空闲，则等待一段时间SIFS后，就向A发送一个叫做<strong>允许发送 CTS</strong>的控制帧，它也包括这次通信所需的持续时间。A收到CTS帧后，再等待一段时间SIFS后，就可发送数据帧。若B正确收到了A发来的数据帧，在等待时间SIFS后，就向A发送确认帧ACK。<ul><li>![[Pasted image 20230815161415.png]]</li></ul></li><li>使用RTS帧和CTS帧会使整个网络的通信效率有所下降。但由于这两种控制帧都很短，其长度分别为20字节和14字节，与数据帧（最长可达2346字节）相比开销不算大。相反，若不使用这种控制帧，则一旦发生碰撞而导致数据帧重发，浪费的时间就更多了。虽然如此，协议还是设有三种情况供用户选择。<ul><li>使用RTS帧和CTS帧。</li><li>只有当数据帧的长度超过某一数值时才使用RTS帧和CTS帧（显然，当数据帧本身就很短时，再使用RTS帧和CTS帧只能增加开销）。</li><li>不使用RTS帧和CTS帧。</li></ul></li></ol></li></ul><h2 id="9-1-4-802-11局域网的MAC帧"><a href="#9-1-4-802-11局域网的MAC帧" class="headerlink" title="9.1.4 802.11局域网的MAC帧"></a>9.1.4 802.11局域网的MAC帧</h2><ul><li>802.11帧共有三种类型，即<strong>控制帧、数据帧</strong>和<strong>管理帧</strong>。通过图9-10所示的802.11局域网的数据帧和三种控制帧的主要字段，可以进一步了解802.11局域网的MAC帧的特点。<ol><li>![[Pasted image 20230815162650.png]]</li></ol></li><li>从图9-10（a）可以看出，802.11数据帧由以下三大部分组成：<ol><li>MAC首部，共30字节。帧的复杂性都在帧的MAC首部。</li><li>帧主体，也就是帧的数据部分，不超过2312字节。这个数值比以太网的最大长度长很多。不过802.11帧的长度通常都小于1500字节。</li><li>帧检验序列FCS是MAC尾部，共4字节。</li></ol></li><li><strong>关于802.11数据帧的地址</strong></li><li><strong>序号控制字段、持续期字段和帧控制字段</strong><ol><li>介绍802.11数据帧中的其他一些字段：<ul><li><strong>序号控制字段</strong> 占16位，其中<strong>序号子字段</strong> 占12位（从0开始，每发送一个新帧就加1，到4095后再回到0），<strong>分片子字段</strong> 占4位（不分片则保持为0。如分片，则帧的序号子字段保持不变，而分片子字段从0开始，每个分片加1，最多到15）。重传的帧的序号和分片子字段的值都不变。序号控制的作用是使接收方能够区分开是新传送的帧还是因出现差错而重传的帧。这和运输层讨论的序号的概念是相似的。</li><li>持续期字段** 占16位。在9.1.3节第2小节“对信道进行预约”中已经讲过CSMA&#x2F;CA协议允许发送数据的站点预约信道一段时间（见前面的图9-8的例子），并把这个时间写入到持续期字段中。这个字段有多种用途（这里不对这些用途进行详细的说明），只有最高位为0时才表示持续期。这样，持续期不能超过2 15 –1＝32767，单位是微秒。</li><li><strong>帧控制字段</strong> 共分为11个子字段。<ol><li><strong>类型字段</strong>和<strong>子类型字段</strong>用来区分帧的功能。</li><li><strong>更多分片字段</strong> 置为1时表明这个帧属于一个帧的多个分片之一。</li><li><strong>有线等效保密字段</strong> WEP占1位。</li></ol></li></ul></li></ol></li></ul><h1 id="9-2-无线个人区域网WPAN"><a href="#9-2-无线个人区域网WPAN" class="headerlink" title="9.2 无线个人区域网WPAN"></a>9.2 无线个人区域网WPAN</h1><ul><li><strong>无线个人区域网</strong> WPAN就是在个人工作地方把属于个人使用的电子设备（如便携式电脑、平板电脑、便携式打印机以及蜂窝电话等）用无线技术连接起来自组网络，不需要使用接入点AP，整个网络的范围约为10m。</li><li><strong>蓝牙系统</strong></li><li><strong>低速WPAN</strong><ol><li>在低速WPAN中最重要的就是ZigBee。ZigBee技术主要用于各种电子设备（固定的、便携的或移动的）之间的无线通信，其主要特点：<ul><li>通信距离短（10～80m），传输数据速率低，并且成本低廉。</li><li>ZigBee的另一个特点是功耗非常低。</li><li>ZigBee网络容量大。</li></ul></li></ol></li><li><strong>高速WPAN</strong></li></ul><h1 id="9-3-无线城域网WMAN"><a href="#9-3-无线城域网WMAN" class="headerlink" title="9.3 无线城域网WMAN"></a>9.3 无线城域网WMAN</h1><p>- </p><h1 id="9-4-蜂窝移动通信网"><a href="#9-4-蜂窝移动通信网" class="headerlink" title="9.4 蜂窝移动通信网"></a>9.4 蜂窝移动通信网</h1><h2 id="9-4-1-蜂窝无线通信技术简介"><a href="#9-4-1-蜂窝无线通信技术简介" class="headerlink" title="9.4.1 蜂窝无线通信技术简介"></a>9.4.1 蜂窝无线通信技术简介</h2><h2 id="9-4-2-移动IP"><a href="#9-4-2-移动IP" class="headerlink" title="9.4.2 移动IP"></a>9.4.2 移动IP</h2><ul><li>为了支持移动性，在网络层应当增加以下的一些新功能：<ol><li><strong>移动站到外地代理的协议</strong> 。当移动站接入到被访网络时，必须向外地代理进行登记，以获得一个临时的转交地址。同样地，当移动站离开该被访网络时，它要向这个被访网络注销其原来的登记。</li><li><strong>外地代理到归属代理的登记协议</strong> 。外地代理要向移动站的归属代理登记移动站的转交地址。当移动站离开被访网络时，外地代理并不需要注销其在归属代理登记的转交地址。这是因为当移动站接入到另一个网络时，这个新的被访网络的外地代理就会到移动站的归属代理登记该移动站现在的转交地址，这样就取代了原来旧的转交地址。</li><li><strong>归属代理数据报封装协议</strong> 。归属代理收到发送给移动站的数据报后，将其再封装为一个新的数据报，其目的地址为移动站的转交地址，然后转发。</li><li><strong>外地代理拆封协议</strong> 。外地代理收到归属代理封装好的数据报后，取出原始数据报，并将此数据报发送给移动站。</li></ol></li></ul><h2 id="9-4-3-蜂窝移动通信网中对移动用户的路由选择"><a href="#9-4-3-蜂窝移动通信网中对移动用户的路由选择" class="headerlink" title="9.4.3 蜂窝移动通信网中对移动用户的路由选择"></a>9.4.3 蜂窝移动通信网中对移动用户的路由选择</h2><h2 id="9-4-4-GSM中的切换"><a href="#9-4-4-GSM中的切换" class="headerlink" title="9.4.4 GSM中的切换"></a>9.4.4 GSM中的切换</h2><h2 id="9-4-5-无线网络对高层协议的影响"><a href="#9-4-5-无线网络对高层协议的影响" class="headerlink" title="9.4.5 无线网络对高层协议的影响"></a>9.4.5 无线网络对高层协议的影响</h2><h1 id="9-5-两种不同的无线上网"><a href="#9-5-两种不同的无线上网" class="headerlink" title="9.5 两种不同的无线上网"></a>9.5 两种不同的无线上网</h1><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li>无线局域网可分为两大类。第一类是有固定基础设施的，第二类是无固定基础设施的。</li><li>无线局域网的标准是IEEE的802.11系列。使用802.11系列协议的局域网又称为Wi-Fi。</li><li>802.11无线以太网标准使用星形拓扑，其中心叫做接入点AP，它就是基本服务集内的基站。</li><li>应当弄清几种不同的接入：固定接入、移动接入、便携接入和游牧接入。</li><li>802.11无线以太网在MAC层使用CSMA&#x2F;CA协议。不能使用CSMA&#x2F;CD的原因是：在无线局域网中，并非所有的站点都能够听见对方（例如，当有障碍物出现在站点之间时），因此无法实现碰撞检测。使用CSMA&#x2F;CA协议是为了尽量减小碰撞发生的概率。</li><li>802.11无线局域网在使用CSMA&#x2F;CA的同时，还使用停止等待协议。</li><li>802.11标准规定，所有的站在完成发送后，必须再等待一段帧间间隔时间才能发送下一帧。帧间间隔的长短取决于该站要发送的帧的优先级。</li><li>在802.11无线局域网的MAC帧首部中有一个<strong>持续期</strong> 字段，用来填入<strong>在本帧结束后</strong> 还要占用信道多少时间（以微秒为单位）。</li><li>802.11标准允许要发送数据的站对信道进行预约，即在发送数据帧之前先发送RTS帧请求发送。在收到响应允许发送的CTS帧后，就可发送数据帧。</li><li>802.11的MAC帧共有三种类型，即控制帧、数据帧和管理帧。需要注意的是，MAC帧有四个地址字段。在有固定基础设施的无线局域网中，只使用其中的三个地址字段，即源地址、目的地址和AP地址。</li><li>几种无线网络简介：无线个人区域网（蓝牙系统、ZigBee和超高速WPAN）。无线城域网WiMAX。</li><li>当计算机移动到外地时，移动IP技术允许该计算机仍然保留其原来的IP地址。移动IP使用了一些新概念，如永久地址、归属地址、归属网络、被访网络或外地网络、归属代理、外地代理、转交地址、同址转交地址等。</li><li>移动IP使用了几种协议，如移动站到外地代理的协议，外地代理到归属代理的登记协议，归属代理数据报封装协议，外地代理拆封协议等。</li><li>移动IP的路由选择有间接路由选择和直接路由选择，后者需要使用通信者代理和锚外地代理。</li><li>蜂窝移动通信网中对移动用户的路由选择需要弄清一些概念：归属位置寄存器HLR和来访用户位置寄存器VLR，移动站漫游号码MSRN，归属网络交换中心，归属MSC，锚MSC，被访网络的MSC。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第8章 互联网上的音频、视频服务</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-8-zhang-hu-lian-wang-shang-de-yin-pin-shi-pin-fu-wu/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-8-zhang-hu-lian-wang-shang-de-yin-pin-shi-pin-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h1><ul><li>计算机网络最初是为传送数据设计的。互联网IP层提供的“<strong>尽最大努力交付</strong>”服务以及<strong>每一个分组独立交付</strong>的策略，对传送数据信息十分合适。互联网使用的TCP协议可以很好地解决IP层不能提供可靠交付这一问题。</li><li>多媒体信息（包括声音和图像信息）与不包括声音和图像的数据信息有很大的区别，其中最主要的两个特点如下：<ol><li><strong>多媒体信息的信息量往往很大</strong></li><li><strong>在传输多媒体数据时，对时延和时延抖动均有较高的要求</strong><ul><li>对模拟信号要经过采样和模数转换变为数字信号，然后将一定数量的比特组装成分组进行传送。这些分组在发送时的时间间隔都是<strong>恒定的</strong>，通常称这样的分组为<strong>等时的</strong>。这种等时分组进入互联网的速率也是恒定的。但传统的<strong>互联网本身是非等时的</strong>。这是因为在使用IP协议的互联网中，每一个分组是独立地传送，因而这些分组在到达接收端时就变成为<strong>非等时的</strong>。如果我们在接收端对这些以非恒定速率到达的分组边接收边还原，那么就一定会产生很大的失真。</li></ul></li></ol></li><li>在传送<strong>时延敏感</strong>的实时数据时，不仅<strong>传输时延不能太大</strong>，而且<strong>时延抖动也必须受到限制</strong></li><li>在互联网上传输实时数据的分组时有可能会出现差错或甚至丢失。如果利用TCP协议对这些出错或丢失的分组进行重传，那么时延就会大大增加。因此实时数据的传输在运输层就应采用用户数据报协议UDP而不使用TCP协议。这就是说，对于传送实时数据，我们<strong>宁可丢失少量分组</strong>（当然不能丢失太多），<strong>也不要太晚到达的分组</strong>。在连续的音频或视频数据流中，很少量分组的丢失对播放效果的影响并不大（因为这是由人来进行主观评价的），因而是可以容忍的。<strong>丢失容忍</strong>也是实时数据的另一个重要特点。</li><li>目前互联网提供的音频&#x2F;视频服务大体上可分为三种类型：<ol><li><strong>流式存储音频&#x2F;视频</strong> 　这种类型是先把已压缩的录制好的音频&#x2F;视频文件（如音乐、电影等）存储在服务器上。用户通过互联网下载这样的文件。流式存储音频&#x2F;视频文件的特点是能够<strong>边下载边播放</strong>，即在文件下载后不久就开始连续播放。</li><li><strong>流式实况音频&#x2F;视频</strong> 　这种类型和无线电台或电视台的实况广播相似，不同之处是音频&#x2F;视频节目的<strong>广播</strong>是通过互联网来传送的。流式实况音频&#x2F;视频是一对多（而不是一对一）的通信。它的特点是：音频&#x2F;视频节目不是事先录制好和存储在服务器中的，而是在发送方<strong>边录制边发送</strong>（不是录制完毕后再发送）。在接收时也要求能够连续播放。</li><li><strong>交互式音频&#x2F;视频</strong> 　这种类型是用户使用互联网和其他人进行实时交互式通信。</li></ol></li></ul><h1 id="8-2-流式存储音频、视频"><a href="#8-2-流式存储音频、视频" class="headerlink" title="8.2 流式存储音频、视频"></a>8.2 流式存储音频、视频</h1><h2 id="8-2-1-具有元文件的万维网服务器"><a href="#8-2-1-具有元文件的万维网服务器" class="headerlink" title="8.2.1 具有元文件的万维网服务器"></a>8.2.1 具有元文件的万维网服务器</h2><ul><li>元文件（请注意，不是源文件）就是一种非常小的文件，它描述或指明<strong>其他文件</strong>的一些重要信息。这里的元文件保存了有关这个音频&#x2F;视频文件的信息。</li><li>图8-5说明了使用元文件下载音频&#x2F;视频文件的几个步骤。<ol><li>浏览器用户点击所要看的音频&#x2F;视频文件的超链，使用HTTP的GET报文接入到万维网服务器。实际上，这个超链并没有直接指向所请求的音频&#x2F;视频文件，而是指向一个元文件。这个元文件有实际的音频&#x2F;视频文件的统一资源定位符URL。</li><li>万维网服务器把该元文件装入HTTP响应报文的主体，发回给浏览器。在响应报文中还有指明该音频&#x2F;视频文件类型的首部。</li><li>客户机浏览器收到万维网服务器的响应，分析其内容类型首部行，调用相关的媒体播放器（客户机中可能装有多个媒体播放器），把提取出的元文件传送给媒体播放器。</li><li>媒体播放器使用元文件中的URL直接和万维网服务器建立TCP连接，并向万维网服务器发送HTTP请求报文，要求下载浏览器想要的音频&#x2F;视频文件。</li><li>万维网服务器发送HTTP响应报文，把该音频&#x2F;视频文件发送给媒体播放器。媒体播放器在存储了若干秒的音频&#x2F;视频文件后（这是为了消除抖动），就以音频&#x2F;视频流的形式边下载、边解压缩、边播放。</li><li>![[Pasted image 20230814161524.png]]</li></ol></li></ul><h2 id="8-2-2-媒体服务器"><a href="#8-2-2-媒体服务器" class="headerlink" title="8.2.2 媒体服务器"></a>8.2.2 媒体服务器</h2><ul><li>为了更好地提供播放流式音频&#x2F;视频文件的服务，现在最为流行的做法就是使用两个分开的服务器。一个普通的万维网服务器，和另一个<strong>媒体播放器</strong>。媒体服务器和万维网服务器可以运行在一个端系统内，也可以运行在两个不同的端系统中。媒体服务器与普通的万维网服务器的最大区别就是，媒体服务器是专门为播放流式音频&#x2F;视频文件而设计的，因此能够更加有效地为用户提供播放流式多媒体文件的服务。因此媒体服务器也常被称为<strong>流式服务器</strong>。</li><li>起初人们选用UDP来传送。不采用TCP的主要原因是担心当网络出现分组丢失时，TCP的重传机制会使重传的分组不能按时到达接收端，使得媒体播放器的播放不流畅。</li><li>采用UDP会有以下几个缺点：<ol><li>发送端按正常播放的速率发送流媒体数据帧，但由于网络的情况多变，在接收端的播放器很难做到始终按规定的速率播放。例如，一个视频节目需要以1Mbit&#x2F;s的速率播放。如果从媒体服务器到媒体播放器之间的网络容量突然降低到1Mbit&#x2F;s以下，那么这时就会出现播放器的暂停，影响正常的观看。</li><li>很多单位的防火墙往往阻拦外部UDP分组的进入，因而使用UDP传送多媒体文件时会被防火墙阻拦掉。</li><li>使用UDP传送流式多媒体文件时，如果在用户端希望能够控制媒体的播放，如进行暂停、快进等操作，那么还需要使用另外的协议RTP和RTSP。这样就增加了成本和复杂性。</li></ol></li><li>观看实况转播，那么最好应当首先考虑使用UDP来传送。如果使用TCP传送，则当出现网络严重拥塞而产生播放的暂停时，就会使人难于接受。使用UDP传送时，即使因网络拥塞丢失了一些分组，对观看的感觉也会比突然出现暂停要好些。</li></ul><h2 id="8-2-3-实时流式协议RTSP"><a href="#8-2-3-实时流式协议RTSP" class="headerlink" title="8.2.3 实时流式协议RTSP"></a>8.2.3 实时流式协议RTSP</h2><ul><li><strong>实时流式协议 RTSP</strong>是为了给流式过程增加更多的功能而设计的协议。RTSP本身并不传送数据，而仅仅是使媒体播放器能够控制多媒体流的传送（有点像文件传送协议FTP有一个控制信道），因此RTSP又称为<strong>带外协议</strong>。</li><li>RTSP协议以客户服务器方式工作，它是一个应用层的<strong>多媒体播放控制协议</strong>，用来使用户在播放从互联网下载的实时数据时能够进行控制（像在影碟机上那样的控制），如：暂停&#x2F;继续、快退、快进等。因此，RTSP又称为“<strong>互联网录像机遥控协议</strong>”。</li><li>RTSP的语法和操作与HTTP协议的相似（所有的请求和响应报文都是ASCII文本）。但与HTTP不同的地方是RTSP是有状态的协议（HTTP是无状态的）。RTSP记录客户机所处于的状态（初始化状态、播放状态或暂停状态）。RFC 2326还规定，RTSP控制分组既可在TCP上传送，也可在UDP上传送。RTSP没有定义音频&#x2F;视频的压缩方案，也没有规定音频&#x2F;视频在网络中传送时应如何封装在分组中。RTSP不规定音频&#x2F;视频流在媒体播放器中应如何缓存。</li></ul><h1 id="8-3-交互式音频、视频"><a href="#8-3-交互式音频、视频" class="headerlink" title="8.3 交互式音频、视频"></a>8.3 交互式音频、视频</h1><h2 id="8-3-1-IP电话概述"><a href="#8-3-1-IP电话概述" class="headerlink" title="8.3.1 IP电话概述"></a>8.3.1 IP电话概述</h2><ul><li><strong>狭义的和广义的IP电话</strong><ol><li><strong>狭义</strong>的IP电话就是指在IP网络上打电话。</li><li><strong>广义</strong>的IP电话则不仅仅是电话通信，而且还可以是在IP网络上进行交互式多媒体实时通信（包括话音、视像等），甚至还包括<strong>即时传信</strong> IM。</li><li>分组话音通信发展得并不快的主要原因是：<ul><li>缺少廉价的高质量、低速率的话音信号编解码软件和相应的芯片。</li><li>计算机网络的传输速率和路由器处理速率均不够快，因而导致传输时延过大。</li><li>没有保证实时通信<strong>服务质量</strong> QoS（Quality of Service）的网络协议。</li><li>计算机网络的规模较小，而通信网只有在具有一定规模后才能产生经济效益。</li></ul></li></ol></li><li><strong>IP电话网关</strong><ol><li>IP电话网关的作用就是：<ul><li>在电话呼叫阶段和呼叫释放阶段<strong>进行电话信令的转换</strong></li><li>在通话期间<strong>进行话音编码的转换</strong></li></ul></li></ol></li><li><strong>IP电话的通话质量</strong><ol><li>IP电话的通话质量主要由两个因素决定，一个是<strong>通话双方端到端的时延和时延抖动</strong>，另一个是<strong>话音分组的丢失率</strong>。但这两个因素都是<strong>不确定的</strong>，而是取决于<strong>当时网络上的通信量</strong>。</li><li>一个用户使用IP电话的通话质量<strong>取决于当时其他许多用户的行为</strong>。</li><li>IP电话端到端时延是由以下几个因素造成的：<ul><li>话音信号进行模数转换要产生时延。</li><li>已经数字化的话音比特流要积累到一定的数量才能够装配成一个话音分组，这也会产生时延。</li><li>话音分组的发送需要时间，此时间等于话音分组长度与通信线路的数据率之比。</li><li>话音分组在互联网中经过许多路由器的存储转发时延。</li><li>话音分组到达接收端在缓存中暂存所引起的时延。</li><li>将话音分组还原成模拟话音信号的数模转换也要产生一定的时延。</li><li>话音信号在通信线路上的传播时延。</li><li>由终端设备的硬件和操作系统产生的接入时延。由IP电话网关引起的接入时延约为20～40ms，而用户PC声卡引起的接入时延为20～180ms。有的调制解调器（如V.34）还会再增加20～40ms的时延（由于进行数字信号处理、均衡等）。</li></ul></li><li>目前适合IP电话使用的ITU-T标准主要有以下两种：<ul><li>G.729　话音速率为8kbit&#x2F;s的<strong>共轭结构代数码激励线性预测</strong> CS-ACELP声码器。</li><li>G.723.1　话音速率为5.3&#x2F;6.3kbit&#x2F;s的<strong>线性预测编码</strong> LPC声码器。</li></ul></li><li>这两种标准的比较见表8-1。<ul><li>![[Pasted image 20230814162508.png]]</li></ul></li><li>接收端缓存空间和播放时延的大小对话音分组丢失率和端到端时延也有很大的影响。</li><li>提高路由器的转发分组的速率对提高IP电话的质量也是很重要的。</li></ol></li></ul><h2 id="8-3-2-IP电话所需要的几种应用协议"><a href="#8-3-2-IP电话所需要的几种应用协议" class="headerlink" title="8.3.2 IP电话所需要的几种应用协议"></a>8.3.2 IP电话所需要的几种应用协议</h2><ul><li>在IP电话的通信中，我们至少需要两种应用协议。一种是信令协议，它使我们能够在互联网上找到被叫用户。另一种是话音分组的传送协议，它使我们用来进行电话通信的话音数据能够以时延敏感属性在互联网中传送。</li></ul><h2 id="8-3-3-实时运输协议RTP"><a href="#8-3-3-实时运输协议RTP" class="headerlink" title="8.3.3 实时运输协议RTP"></a>8.3.3 实时运输协议RTP</h2><ul><li><strong>实时运输协议 RTP</strong>为实时应用提供端到端的运输，但不提供任何服务质量的保证。RTP是一个<strong>协议框架</strong>，因为它只包含了实时应用的一些共同功能。RTP自己并不对多媒体数据块做任何处理，而只是向应用层提供一些附加的信息，让应用层知道应当如何进行处理。</li><li>图8-12给出了RTP分组的首部格式：<ol><li><strong>有效载荷类型</strong>　占7位。这个字段指出后面的RTP数据属于何种格式的应用。收到RTP分组的应用层就根据此字段指出的类型进行处理。</li><li><strong>序号</strong> 　占16位。对每一个发送出的RTP分组，其序号加1。在一次RTP会话开始时的初始序号是随机选择的。序号使接收端能够发现丢失的分组，同时也能将失序的RTP分组重新按序排列好。</li><li><strong>时间戳</strong> 　占32位。时间戳反映了RTP分组中数据的第一个字节的采样时刻。在一次会话开始时时间戳的初始值也是随机选择的。即使在没有信号发送时，时间戳的数值也要随时间而不断地增加。接收端使用时间戳可准确知道应当在什么时间还原哪一个数据块，从而消除时延的抖动。时间戳还可以用来使视频应用中声音和图像同步。在RTP协议中并没有规定时间戳的<strong>粒度</strong>，这取决于有效载荷的类型。因此RTP的时间戳又称为<strong>媒体时间戳</strong>，以强调这种时间戳的粒度取决于信号的类型。</li><li><strong>同步源标识符</strong> 　占32位。同步源标识符SSRC是一个数，用来标志RTP流的来源。SSRC与IP地址无关，在新的RTP流开始时随机地产生。由于RTP使用UDP传送，因此可以有多个RTP流复用到一个UDP用户数据报中。SSRC可使接收端的UDP能够将收到的RTP流送到各自的终点。两个RTP流恰好都选择同一个SSRC的概率是极小的。若发生这种情况，这两个源就都重新选择另一个SSRC。</li><li><strong>参与源标识符</strong> 　这是选项，最多可有15个。<strong>参与源标识符</strong> CSRC也是一个32位数，用来标志来源于不同地点的RTP流。在多播环境中，可以用中间的一个站（叫做<strong>混合站</strong> mixer）把发往同一个地点的多个RTP流混合成一个流（可节省通信资源），在目的站再根据CSRC的数值把不同的RTP流分开。</li><li><strong>参与源数</strong> 　占4位。这个字段给出后面的参与源标识符的数目。</li><li><strong>版本</strong> 　占2位。当前使用的是版本2。</li><li><strong>填充</strong> P　占1位。在某些特殊情况下需要对应用数据块加密，这往往要求每一个数据块有确定的长度。如不满足这种长度要求，就需要进行填充。这时就把P位置1，表示这个RTP分组的数据有若干填充字节。在数据部分的最后一个字节用来表示所填充的字节数。</li><li><strong>扩展</strong> X　占1位。X置1表示在此RTP首部后面还有扩展首部。扩展首部很少使用。</li><li><strong>标记</strong> M　占1位。M置1表示这个RTP分组具有特殊意义。</li><li>![[Pasted image 20230814163018.png]]</li></ol></li></ul><h2 id="8-3-4-实时运输控制协议RTCP"><a href="#8-3-4-实时运输控制协议RTCP" class="headerlink" title="8.3.4 实时运输控制协议RTCP"></a>8.3.4 实时运输控制协议RTCP</h2><ul><li><strong>实时运输控制协议 RTCP</strong>的主要功能是：服务质量的监视与反馈、媒体间的同步（如某一个RTP发送的声音和图像的配合），以及多播组中成员的标志。RTCP分组（也可称为RTCP报文）也使用UDP来传送，但RTCP并不对音频&#x2F;视频分组进行封装。由于RTCP分组很短，因此可把多个RTCP分组封装在一个UDP用户数据报中。RTCP分组周期性地在网上传送，它带有发送端和接收端对服务质量的统计信息报告。</li><li>表8-2是RTCP使用的五种分组类型，它们都使用同样的格式。<ol><li>![[Pasted image 20230814163106.png]]</li><li><strong>结束分组</strong> BYE表示关闭一个数据流。</li><li><strong>特定应用分组</strong> APP使应用程序能够定义新的分组类型。</li><li><strong>接收端报告分组</strong> RR用来使接收端周期性地向所有的点用多播方式进行报告。接收端每收到一个RTP流（一次会话包含有许多的RTP流）就产生一个接收端报告分组RR。RR分组的内容有：所收到的RTP流的SSRC；该RTP流的分组丢失率（若分组丢失率太高，发送端就应当适当降低发送分组的速率）；在该RTP流中的最后一个RTP分组的序号；分组到达时间间隔的抖动等。<ul><li>发送RR分组有两个目的：<ol><li>可以使所有的接收端和发送端了解当前网络的状态；</li><li>可以使所有发送RTCP分组的站点自适应地调整自己发送RTCP分组的速率，使得起控制作用的RTCP分组不要过多地影响传送应用数据的RTP分组在网络中的传输。</li></ol></li></ul></li><li><strong>发送端报告分组</strong> SR用来使发送端周期性地向所有接收端用多播方式进行报告。发送端每发送一个RTP流，就要发送一个发送端报告分组SR。SR分组的主要内容有：该RTP流的同步源标识符SSRC；该RTP流中最新产生的RTP分组的时间戳和绝对时钟时间（或墙上时钟时间wall clock time）；该RTP流包含的分组数；该RTP流包含的字节数。</li><li><strong>源点描述分组</strong> SDES给出会话中参加者的描述，它包含参加者的规范名CNAME。规范名是参加者的电子邮件地址的字符串。</li></ol></li></ul><h2 id="8-3-5-H-323"><a href="#8-3-5-H-323" class="headerlink" title="8.3.5 H.323"></a>8.3.5 H.323</h2><ul><li>现在IP电话有两套信令标准：一套是ITU-T定义的H.323协议，另一套是IETF提出的<strong>会话发起协议</strong> SIP。</li><li>H.323标准指明了四种构件，使用这些构件连网就可以进行点对点或一点对多点的多媒体通信：<ol><li>H.323<strong>终端</strong> 　这可以是一个PC，也可以是运行H.323程序的单个设备。</li><li>网关** 　网关连接到两种不同的网络，使得H.323网络可以和非H.323网络（如公用电话网）进行通信。仅在一个H.323网络上通信的两个终端当然就不需要使用网关。</li><li><strong>网闸</strong> 　网闸相当于整个H.323网络的大脑。所有的呼叫都要通过网闸，因为网闸提供地址转换、授权、带宽管理和计费功能。网闸还可以帮助H.323终端找到距离公用电话网上的被叫用户最近的一个网关。</li><li><strong>多点控制单元</strong> MCU　MCU支持三个或更多的H.323终端的音频或视频会议。MCU管理会议资源、确定使用的音频或视频编解码器。</li></ol></li><li>H.323包括以下一些组成部分：<ol><li><strong>音频编解码器</strong> 　H.323要求至少要支持G.711（64kbit&#x2F;s的PCM）。建议支持如G.722（16kbit&#x2F;s的ADPCM），G.723.1（5.3&#x2F;6.3的LPC），G．728（16kbit&#x2F;s的低时延CELP）和G.729（8kbit&#x2F;s的CS-ACELP）等。</li><li><strong>视频编解码器</strong> 　H.323要求必须支持H.261标准（176×144像素）。</li><li>H.255.0<strong>登记信令</strong> ，即<strong>登记&#x2F;接纳&#x2F;状态</strong> RAS。H.323终端和网闸使用RAS来完成登记、接纳控制和带宽转换等功能。</li><li>H.225.0<strong>呼叫信令</strong> 　用来在两个H.323端点之间建立连接。</li><li>![[Pasted image 20230814163356.png]]</li></ol></li></ul><p>（5）H.245<strong>控制信令</strong> 　用来交换端到端的控制报文，以便管理H.323端点的运行。</p><p>（6）T.120<strong>数据传送协议</strong> 　这是与呼叫相关联的数据交换协议。用户在参加音频&#x2F;视频会议时，可以和其他与会用户共享屏幕上的白板。由于使用TCP协议，因此能够保证数据传送的正确（在传送音频&#x2F;视频文件时使用的是UDP，因此不能保证服务质量）。</p><p>（7）<strong>实时运输协议</strong> RTP和<strong>实时运输控制协议</strong> RTCP　这两个协议前面已讨论。</p><h2 id="8-3-6-会话发起协议SIP"><a href="#8-3-6-会话发起协议SIP" class="headerlink" title="8.3.6 会话发起协议SIP"></a>8.3.6 会话发起协议SIP</h2><ul><li>一套较为简单且实用的标准，即<strong>会话发起协议SIP</strong>，目前已成为互联网的建议标准。</li><li>SIP协议的出发点是以互联网为基础，而把IP电话视为互联网上的新应用。因此SIP协议只涉及到IP电话所需的信令和有关服务质量的问题，而没有提供像H.323那样多的功能。SIP没有强制使用特定的编解码器，也不强制使用RTP协议。</li><li>SIP使用文本方式的客户服务器协议。SIP系统只有两种构件，即<strong>用户代理</strong>和<strong>网络服务器</strong>。用户代理包括两个程序，即<strong>用户代理客户</strong> UAC和用户代理服务器UAS，前者用来发起呼叫，后者用来接受呼叫。网络服务器分为<strong>代理服务器</strong>和<strong>重定向服务器</strong>。代理服务器接受来自主叫用户的呼叫请求（实际上是来自用户代理客户的呼叫请求），并将其转发给被叫用户或下一跳代理服务器，然后下一跳代理服务器再把呼叫请求转发给被叫用户（实际上是转发给用户代理服务器）。重定向服务器不接受呼叫，它通过响应告诉客户下一跳代理服务器的地址，由客户按此地址向下一跳代理服务器重新发送呼叫请求。</li><li>SIP的地址十分灵活。它可以是电话号码，也可以是电子邮件地址、IP地址或其他类型的地址。但一定要使用SIP的地址格式，例如：<ol><li>电话号码　　　sip：zhangsan@8625-87654321</li><li>IPv4地址　　　sip：<a href="mailto:&#122;&#104;&#97;&#110;&#103;&#115;&#x61;&#x6e;&#64;&#50;&#x30;&#49;&#46;&#x31;&#50;&#46;&#51;&#52;&#46;&#53;&#54;">&#122;&#104;&#97;&#110;&#103;&#115;&#x61;&#x6e;&#64;&#50;&#x30;&#49;&#46;&#x31;&#50;&#46;&#51;&#52;&#46;&#53;&#54;</a></li><li>电子邮件地址　　sip：<a href="mailto:&#x7a;&#104;&#97;&#110;&#x67;&#115;&#x61;&#110;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#109;">&#x7a;&#104;&#97;&#110;&#x67;&#115;&#x61;&#110;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#111;&#109;</a></li></ol></li><li>SIP的会话共有三个阶段：建立会话、通信和终止会话。</li><li>SIP有一种跟踪用户的机制，可以找出被叫方使用的PC的IP地址（例如，被叫方使用DHCP，因而没有固定的IP地址）。为了实现跟踪，SIP使用登记的概念。SIP定义一些服务器作为SIP<strong>登记器</strong>。每一个SIP用户都有一个相关联的SIP登记器。用户在任何时候发起SIP应用时，都应当给SIP登记器发送一个SIP REGISTER报文，向登记器报告现在使用的IP地址。SIP登记器和SIP代理服务器通常运行在同一台主机上。</li><li>SIP还有一个配套协议是<strong>会话描述协议</strong> SDP。SDP在电话会议的情况下特别重要，因为电话会议的参加者是<strong>动态地加入和退出</strong>。SDP详细地指明了媒体编码、协议的端口号以及多播地址。</li></ul><h1 id="8-4-改进“尽最大努力交付”的服务"><a href="#8-4-改进“尽最大努力交付”的服务" class="headerlink" title="8.4 改进“尽最大努力交付”的服务"></a>8.4 改进“尽最大努力交付”的服务</h1><h2 id="8-4-1-使互联网提供服务质量"><a href="#8-4-1-使互联网提供服务质量" class="headerlink" title="8.4.1 使互联网提供服务质量"></a>8.4.1 使互联网提供服务质量</h2><ul><li>根据ITU-T在建议书E.800中给出的定义，<strong>服务质量QoS是服务性能的总效果，此效果决定了一个用户对服务的满意程度</strong>。</li><li>四种情况：<ol><li>一个1Mbit&#x2F;s的实时音频数据和一个FTP文件数据；<strong>给不同性质的分组打上不同的标记</strong>。</li><li>一个1Mbit&#x2F;s的实时音频数据和一个高优先级的FTP文件数据；使路由器增加一种机制——<strong>分类</strong>，即路由器根据某些准则（例如，根据发送数据的地址）对输入分组进行分类，然后对不同类别的通信量给予不同的优先级。</li><li>一个数据率异常的实时音频数据和一个FTP文件数据；使路由器能够对某个数据流进行通信量的<strong>管制</strong>，使得这个数据流不要影响其他正常的数据流在网络中通过。</li><li>H 1 和H 2 都发送数据率为1Mbit&#x2F;s的实时数据；<strong>呼叫接纳</strong>。</li></ol></li></ul><h2 id="8-4-2-调度和管制机制"><a href="#8-4-2-调度和管制机制" class="headerlink" title="8.4.2 调度和管制机制"></a>8.4.2 调度和管制机制</h2><ul><li><strong>调度机制</strong><ol><li>在先进先出的基础上增加<strong>按优先级排队</strong>，就能使优先级高的分组优先得到服务。</li><li>简单地按优先级排队会带来一个缺点，这就是在高优先级队列中总是有分组时，低优先级队列中的分组就长期得不到服务。这就不太公平。<strong>公平排队</strong> FQ可解决这一问题。公平排队是对每种类别的分组流设置一个队列，然后轮流使每一个队列一次只能发送一个分组。对于空的队列就跳过去。但公平排队也有不公平的地方，这就是长分组得到的服务时间长，而短分组就比较吃亏，并且公平排队并没有区分分组的优先级。</li><li>为了使高优先级队列中的分组有多的机会得到服务，可增加队列“<strong>权重</strong>”的概念，这就是<strong>加权公平排队</strong> WFQ。</li></ol></li><li><strong>管制机制</strong><ol><li>对一个数据流，可根据以下三个方面进行管制：<ul><li><strong>平均速率</strong> 　网络需要控制一个数据流的平均速率。这里的平均速率是指在<strong>一定的时间间隔内通过的分组数</strong>。</li><li><strong>峰值速率</strong> 　峰值速率限制了数据流在非常短的时间间隔内的流量。</li><li><strong>突发长度</strong> 　网络也限制在非常短的时间间隔内连续注入到网络中的分组数。</li></ul></li><li>要在网络中对进入网络的分组流按以上三个指标进行管制，可使用非常著名的<strong>漏桶管制器</strong>（可简称为<strong>漏桶</strong>）。</li></ol></li><li><strong>漏桶机制与加权公平排队相结合</strong><ol><li>把漏桶机制与加权公平排队结合起来，可以控制队列中的最大时延。</li></ol></li></ul><h2 id="8-4-3-综合服务IntServ与资源预留协议RSVP"><a href="#8-4-3-综合服务IntServ与资源预留协议RSVP" class="headerlink" title="8.4.3 综合服务IntServ与资源预留协议RSVP"></a>8.4.3 综合服务IntServ与资源预留协议RSVP</h2><ul><li>IntServ可对单个的应用会话提供服务质量的保证，其主要特点有二：<ol><li><strong>资源预留</strong>    一个路由器需要知道给不断出现的会话已经预留了多少资源（即链路带宽和缓存空间）。</li><li><strong>呼叫建立</strong>    一个需要服务质量保证的会话，必须首先在源点到终点路径上的<strong>每一个</strong> 路由器预留足够的资源，以保证其端到端的服务质量的要求。因此，在一个会话开始之前必须先有一个<strong>呼叫建立</strong>（又称为<strong>呼叫接纳</strong>）过程，它需要在其分组传输路径上的每一个路由器都参加。每一个路由器都要确定该会话所需的本地资源是否够用，同时还不要影响到已经建立的会话的服务质量。</li></ol></li><li>IntServ定义了两类服务：<ol><li><strong>有保证的服务</strong>，可保证一个分组在通过路由器时的排队时延有一个严格的上限。</li><li><strong>受控负载的服务</strong> ，可以使应用程序得到比通常的“尽最大努力”更加可靠的服务。</li></ol></li><li>IntServ共有以下四个组成部分：<ol><li><strong>资源预留协议</strong> RSVP，它是IntServ的信令协议。</li><li><strong>接纳控制</strong>，用来决定是否同意对某一资源的请求。</li><li><strong>分类器</strong>，用来把进入路由器的分组进行分类，并根据分类的结果把不同类别的分组放入特定的队列。</li><li><strong>调度器</strong>，根据服务质量要求决定分组发送的前后顺序。、</li></ol></li><li>IntServ&#x2F;RSVP所基于的概念是端系统中与分组流有关的状态信息。各路由器中的预留信息<strong>只存储有限的时间</strong>（这称为<strong>软状态</strong> soft-state），因而各终点对这些预留信息<strong>必须定期进行更新</strong>。RSVP协议不是运输层协议而是网络层的控制协议。RSVP不携带应用数据。图8-25给出了在路由器中实现的IntServ体系结构。<ol><li>![[Pasted image 20230814164223.png]]</li></ol></li><li>IntServ体系结构分为前台和后台两个部分。前台部分画在下面，包括两个功能块，即<strong>分类器与分组转发</strong>，分组的<strong>调度器</strong>。每一个进入路由器的分组都要通过这两个功能块。后台部分画在上面（有灰色阴影的部分），包括四个功能块和两个数据库。这四个功能块是：<ol><li>路由选择协议，负责维持路由选择数据库。由此可查找出对应于每一个目的地址和每一个流的下一跳地址。</li><li>RSVP协议，为每一个流预留必要的资源，并不断地更新通信量控制数据库。</li><li>接纳控制，当一个新的流产生时，RSVP就调用接纳控制功能块，以便确定是否有足够的资源可供这个流使用。</li><li>管理代理，用来修改通信量控制数据库和管理接纳控制功能块，包括设置接纳控制策略。</li></ol></li><li>综合服务IntServ体系结构存在的主要问题是：<ol><li><strong>状态信息的数量与流的数目成正比</strong>。例如，对于OC-48链路（2.5Gbit&#x2F;s）上的主干网路由器，通过64kbit&#x2F;s的音频流的数目就超过39000个。如果对数据率再进行压缩，则流的数目就更多。因此在大型网络中，按每个流进行资源预留会产生很大的开销。</li><li>IntServ<strong>体系结构复杂</strong> 。若要得到有保证的服务，<strong>所有的路由器都必须装有</strong> RSVP、<strong>接纳控制、分类器和调度器</strong>。这种路由器称为RSVP路由器。在应用数据传送的路径中只要有一个路由器是非RSVP路由器，整个的服务就又变为“尽最大努力交付”了。</li><li>综合服务IntServ所定义的<strong>服务质量等级数量太少，不够灵活</strong>。</li></ol></li></ul><h2 id="8-4-4-区分服务DiffServ"><a href="#8-4-4-区分服务DiffServ" class="headerlink" title="8.4.4 区分服务DiffServ"></a>8.4.4 区分服务DiffServ</h2><ul><li><strong>区分服务的基本概念</strong><ol><li>由于综合服务IntServ和资源预留协议RSVP都较复杂，很难在大规模的网络中实现，因此IETF提出了一种新的策略，即<strong>区分服务</strong> DiffServ。</li><li>区分服务DiffServ的要点如下：<ul><li>DiffServ力图不改变网络的基础结构，但在路由器中<strong>增加区分服务的功能</strong>。因此，DiffServ将IP协议中原有8位的IPv4的服务类型字段和IPv6的通信量类字段重新定义为<strong>区分服务</strong> DS（见图8-26）。路由器根据DS字段的值来处理分组的转发。因此，<strong>利用DS字段的不同数值就可提供不同等级的服务质量</strong>。DS字段现在只使用其中的前6位，即<strong>区分服务码点</strong> DSCP，再后面的两位目前不使用，记为CU。因此由DS字段的值所确定的服务质量实际上就是由DS字段中DSCP的值来确定。在使用DS字段之前，互联网的ISP要和用户商定一个<strong>服务等级协定</strong> SLA。在SLA中指明了被支持的服务类别（可包括吞吐量、分组丢失率、时延和时延抖动、网络的可用性等）和每一类别所容许的通信量。<ol><li>![[Pasted image 20230814164427.png]]</li></ol></li><li>网络被划分为许多个DS域。一个DS域在一个管理实体的控制下实现同样的区分服务策略。<strong>DiffServ将所有的复杂性放在DS域的边界结点中，而使DS域内部路由器工作得尽可能简单</strong>。边界结点可以是主机、路由器或防火墙等。为了简单起见，下面只讨论边界结点是边界路由器的情况（原理都是一样的）。图8-27给出了DS域、<strong>边界路由器</strong>和<strong>内部路由器</strong>的示意图。图中标有B的路由器都是边界路由器。<ol><li>![[Pasted image 20230814164517.png]]</li></ol></li><li>边界路由器中的功能较多，可分为<strong>分类器</strong>和<strong>通信量调节器</strong> 两大部分。调节器又由<strong>标记器、</strong>整形器<strong>和</strong>测定器**三个部分组成。分类器根据分组首部中的一些字段（如源地址、目的地址、源端口、目的端口或分组的标识等）对分组进行分类，然后将分组交给标记器。标记器根据分组的类别设置DS字段的值。以后在分组的转发过程中，就根据DS字段的值使分组得到相应的服务。测定器根据事先商定的SLA不断地测定分组流的速率（与事前商定的数值相比较），然后确定应采取的行动，例如，可重新打标记或交给整形器进行处理。整形器中设有缓存队列，可以将突发的分组峰值速率平滑为较均匀的速率，或丢弃一些分组。在分组进入内部路由器后，路由器就根据分组的DS值进行转发。图8-28给出了边界路由器中各功能块的关系。<ol><li>![[Pasted image 20230814164607.png]]</li></ol></li><li>DiffServ提供了一种<strong>聚合</strong>功能。DiffServ不是为网络中的每一个流维持供转发时使用的状态信息，而是把若干个流根据其DS值聚合成少量的流。路由器对相同DS值的流都按相同的优先级进行转发。这就大大简化了网络内部的路由器的转发机制。区分服务DiffServ不需要使用RSVP信令。</li></ul></li></ol></li><li><strong>每跳行为PHB</strong><ol><li>DiffServ定义了在转发分组时体现服务水平的<strong>每跳行为</strong> PHB</li><li>IETF的DiffServ工作组已经定义了两种PHB，即<strong>迅速转发</strong> PHB和<strong>确保转发</strong> PHB。</li><li><strong>迅速转发</strong> PBH可记为EF PHB，或EF。EF指明离开一个路由器的通信量的数据率必须等于或大于某一数值。因此EF PHB用来构造通过DS域的一个低丢失率、低时延、低时延抖动、确保带宽的端到端服务（即不排队或很少排队）。</li><li><strong>确保转发</strong> PHB可记为AF PHB或AF。AF用DSCP的第0～2位把通信量划分为四个等级（分别为001，010，011和100），并给每一种等级提供最低数量的带宽和缓存空间。对于其中的每一个等级再用DSCP的第3～5位划分出三个“丢弃优先级”（分别为010，100和110，从最低丢弃优先级到最高丢弃优先级）。当发生网络拥塞时，对于每一个等级的AF，路由器就首先把“丢弃优先级”较高的分组丢弃。</li></ol></li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li>多媒体信息有两个重要特点：（1）多媒体信息的信息量往往很大；（2）在传输多媒体数据时，对时延和时延抖动均有较高的要求。在互联网上传输多媒体数据时，我们都是指含有“边传输、边播放”的特点。</li><li>由多媒体信息构成的分组在发送时是等时的。这些分组在到达接收端时就变成为非等时的。当接收端缓存中的分组数达到一定的数量后，再以恒定速率按顺序将这些分组进行还原播放。这样就产生了播放时延，同时也可以在很大程度上消除时延的抖动。</li><li>在传送时延敏感的实时数据时，传输时延和时延抖动都必须受到限制。通常宁可丢失少量分组，也不要接收太晚到达的分组。</li><li>目前互联网提供的音频&#x2F;视频服务有三种类型：（1）流式存储音频&#x2F;视频，用户通过互联网边下载、边播放。（2）流式实况音频&#x2F;视频，其特点是在发送方边录制、边发送，在接收时也是要求能够连续播放。（3）交互式音频&#x2F;视频，如互联网电话或互联网电视会议。</li><li>流媒体（streamingm edia）就是流式音频&#x2F;视频，其特点是边下载、边播放，但不能存储在硬盘上成为用户的文件。</li><li>媒体服务器（或称为流式服务器）可以更好地支持流式音频和视频的传送。TCP能够保证流式音频&#x2F;视频文件的播放质量，但开始播放的时间要比请求播放的时间滞后一些（必须先在缓存中存储一定数量的分组）。对于实时流式音频&#x2F;视频文件的传送则应当选用UDP。</li><li>实时流式协议RTSP是为了给流式过程增加更多功能而设计的协议。RTSP本身并不传送数据，而仅仅是使媒体播放器能够控制多媒体流的传送。RTSP又称为“互联网录像机遥控协议”。</li><li>狭义的IP电话是指在IP网络上打电话。广义的IP电话则不仅是电话通信，而且还可以在IP网络上进行交互式多媒体实时通信（包括话音、视像等），甚至还包括即时传信IM（如QQ和Skype等）。</li><li>IP电话的通话质量主要由两个因素决定：（1）通话双方端到端的时延和时延抖动；（2）话音分组的丢失率。但这两个因素都是不确定的，而是取决于当时网络上的通信量。</li><li>实时运输协议RTP为实时应用提供端到端的运输，但不提供任何服务质量的保证。需要发送的多媒体数据块（音频&#x2F;视频）经过压缩编码处理后，先送给RTP封装成为RTP分组，装入运输层的UDP用户数据报后，再向下递交给IP层。可以把RTP看成是在UDP之上的一个运输层子层的协议。</li><li>实时运输控制协议RTCP是与RTP配合使用的协议。RTCP协议的主要功能是：服务质量的监视与反馈，媒体间的同步，以及多播组中成员的标志。RTCP分组也使用UDP来传送，但RTCP并不对音频&#x2F;视频分组进行封装。</li><li>现在IP电话有两套信令标准。一套是ITU-T定义的H.323协议，另一套是IETF提出的会话发起协议SIP。</li><li>H.323不是一个单独的协议而是一组协议。H.323包括系统和构件的描述、呼叫模型的描述、呼叫信令过程、控制报文、复用、话音编解码器、视像编解码器，以及数据协议等。H.323标准的四个构件是：（1）H.323终端；（2）网关；（3）网闸；（4）多点控制单元MCU。</li><li>会话发起协议SIP只涉及到IP电话所需的信令和有关服务质量的问题。SIP使用文本方式的客户服务器协议。SIP系统只有两种构件，即用户代理（包括用户代理客户和用户代理服务器）和网络服务器（包括代理服务器和重定向服务器）。SIP的地址十分灵活，它可以是电话号码，也可以是电子邮件地址、IP地址或其他类型的地址。</li><li>服务质量QoS是服务性能的总效果，此效果决定了一个用户对服务的满意程度。因此，有服务质量的服务就是能够满足用户的应用需求的服务。或者说，可提供一致的、可预计的数据交付服务。</li><li>服务质量可用若干基本的性能指标来描述，包括可用性、差错率、响应时间、吞吐量、分组丢失率、连接建立时间、故障检测和改正时间等。服务提供者可向其用户保证某一种等级的服务质量。</li><li>为了使互联网具有一定的服务质量，可采取以下一些措施：（1）分类，如区分服务；（2）管制；（3）调度；（4）呼叫接纳；（5）加权公平排队等。</li><li>综合服务IntServ可对单个的应用会话提供服务质量的保证，它定义了两类服务，即有保证的服务和受控负载的服务。IntServ共有以下四个组成部分，即（1）资源预留协议RSVP；（2）接纳控制；（3）分类器；（4）调度器。</li><li>区分服务DiffServ在路由器中增加区分服务的功能，把IP协议中原有的服务类型字段重新定义为区分服务DS，利用DS字段的不同数值提供不同等级的服务质量。DiffServ将所有的复杂性放在DS域的边界结点中，而使DS域内部路由器工作得尽可能地简单。DiffServ定义了在转发分组时体现服务水平的每跳行为PHB，包括EF和AF，即迅速转发PHB和确保转发PHB。****</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 网络安全</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-7-zhang-wang-luo-an-quan/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-7-zhang-wang-luo-an-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="7-1-网络安全问题概述"><a href="#7-1-网络安全问题概述" class="headerlink" title="7.1 网络安全问题概述"></a>7.1 网络安全问题概述</h1><h2 id="7-1-1计算机网络面临的安全性威胁"><a href="#7-1-1计算机网络面临的安全性威胁" class="headerlink" title="7.1.1计算机网络面临的安全性威胁"></a>7.1.1计算机网络面临的安全性威胁</h2><ul><li>计算机网络的通信面临两大类威胁，即<strong>被动攻击</strong>和<strong>主动攻击</strong>（见图7-1）。<ol><li>![[Pasted image 20230813195923.png]]</li></ol></li><li><strong>被动攻击</strong>是指攻击者从网络上窃听他人的通信内容。通常把这类攻击称为<strong>截获</strong>。在被动攻击中，攻击者只是观察和分析某一个<strong>协议数据单元</strong> PDU而不干扰信息流。即使这些数据对攻击者来说是不易理解的，他也可通过观察PDU的协议控制信息部分，了解正在通信的协议实体的地址和身份，研究PDU的长度和传输的频度，从而了解所交换的数据的某种性质。这种被动攻击又称为**流量分析。</li><li><strong>主动攻击</strong>有如下几种最常见的方式。<ol><li><strong>篡改</strong> 　攻击者故意篡改网络上传送的报文。这里也包括彻底中断传送的报文，甚至是把完全伪造的报文传送给接收方。这种攻击方式有时也称为更改报文流。</li><li><strong>恶意程序</strong> 　恶意程序种类繁多，对网络安全威胁较大的主要有以下几种：<ul><li><strong>计算机病毒</strong>，一种会“传染”其他程序的程序，“传染”是通过修改其他程序来把自身或自己的变种复制进去而完成的。</li><li><strong>计算机蠕虫</strong>，一种通过网络的通信功能将自身从一个结点发送到另一个结点并自动启动运行的程序。</li><li><strong>特洛伊木马</strong> ，一种程序，它执行的功能并非所声称的功能而是某种恶意功能。如一个编译程序除了执行编译任务以外，还把用户的源程序偷偷地复制下来，那么这种编译程序就是一种特洛伊木马。计算机病毒有时也以特洛伊木马的形式出现。</li><li><strong>逻辑炸弹</strong>，一种当运行环境满足某种特定条件时执行其他特殊功能的程序。如一个编辑程序，平时运行得很好，但当系统时间为13日又为星期五时，它会删去系统中所有的文件，这种程序就是一种逻辑炸弹。</li><li><strong>后门入侵</strong>，是指利用系统实现中的漏洞通过网络入侵系统。就像一个盗贼在夜晚试图闯入民宅，如果某家住户的房门有缺陷，盗贼就能乘虚而入。</li><li><strong>流氓软件</strong>，一种未经用户允许就在用户计算机上安装运行并损害用户利益的软件，其典型特征是：强制安装、难以卸载、浏览器劫持、广告弹出、恶意收集用户信息、恶意卸载、恶意捆绑等等。</li></ul></li><li><strong>拒绝服务</strong> DoS　指攻击者向互联网上的某个服务器不停地发送大量分组，使该服务器无法提供正常服务，甚至完全瘫痪。</li></ol></li><li>若从互联网上的成百上千个网站集中攻击一个网站，则称为<strong>分布式拒绝服务</strong> DDoS。有时也把这种攻击称为<strong>网络带宽攻击</strong>或<strong>连通性攻击</strong>。</li><li>对于主动攻击，可以采取适当措施加以检测。但对于被动攻击，通常却是检测不出来的。根据这些特点，可得出计算机网络通信安全的目标如下：<ol><li>防止析出报文内容和流量分析</li><li>防止恶意程序</li><li>检测更改报文流和拒绝服务</li></ol></li><li>对付被动攻击可采用各种数据加密技术，而对付主动攻击，则需将加密技术与适当的鉴别技术相结合。</li></ul><h2 id="7-1-2-安全的计算机网络"><a href="#7-1-2-安全的计算机网络" class="headerlink" title="7.1.2 安全的计算机网络"></a>7.1.2 安全的计算机网络</h2><ul><li>一个安全的计算机网络应设法达到以下四个目标：<ol><li><strong>保密性</strong><ul><li>保密性就是只有信息的发送方和接收方才能懂得所发送信息的内容，而信息的截获者则看不懂所截获的信息。</li></ul></li><li><strong>端点鉴别</strong><ul><li>安全的计算机网络必须能够鉴别信息的发送方和接收方的真实身份。</li></ul></li><li><strong>信息的完整性</strong><ul><li>即使能够确认发送方的身份是真实的，并且所发送的信息都是经过加密的，我们依然不能认为网络是安全的。还必须确认所收到的信息都是完整的，也就是信息的内容没有被人篡改过。</li></ul></li><li><strong>运行的安全性</strong><ul><li>现在的机构与计算机网络的关系越密切，就越要重视计算机网络运行的安全性。</li></ul></li></ol></li><li></li></ul><h2 id="7-1-3-数据加密模型"><a href="#7-1-3-数据加密模型" class="headerlink" title="7.1.3 数据加密模型"></a>7.1.3 数据加密模型</h2><ul><li>一般的数据加密模型如图7-2所示。<ol><li>![[Pasted image 20230813200600.png]]</li><li>用户A向B发送<strong>明文</strong><em>X</em>，但通过<strong>加密算法</strong><em>E</em>运算后，就得出<strong>密文</strong><em>Y</em>。 </li><li>图中所示的加密和解密用的<strong>密钥</strong> <em>K</em> （key）是一串秘密的字符串（即比特串）。公式（7-1）就是明文通过加密算法变成密文的一般表示方法。<ul><li><img src="http://localhost:8000/4ca37fc8-cbc0-4942-9116-f8066997b556/OEBPS/Images/Image00272.jpg"></li></ul></li><li>在传送过程中可能出现密文的<strong>截取者</strong> （或<strong>攻击者、入侵者</strong> ）。公式（7-2）表示接收端利用<strong>解密算法</strong> <em>D</em> 运算和<strong>解密密钥</strong> <em>K</em> ，解出明文_X_ 。解密算法是加密算法的逆运算。在进行解密运算时，如果不使用事先约定好的密钥就无法解出明文。<ul><li><img src="http://localhost:8000/4ca37fc8-cbc0-4942-9116-f8066997b556/OEBPS/Images/Image00274.jpg"></li></ul></li></ol></li><li>这里我们假定加密密钥和解密密钥都是一样的。但实际上它们可以是不一样的（即使不一样，这两个密钥也必然有某种相关性）。密钥通常由密钥中心提供。当密钥需要向远地传送时，一定要通过另一个安全信道。</li><li><strong>密码编码学</strong>是密码体制的设计学，而<strong>密码分析学</strong>则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为<strong>密码学</strong>。</li><li>如果不论截取者获得了多少密文，但在密文中都没有足够的信息来唯一地确定出对应的明文，则这一密码体制称为<strong>无条件安全的</strong>，或称为<strong>理论上是不可破的</strong>。在无任何限制的条件下，目前几乎所有实用的密码体制均是可破的。因此，人们关心的是要研制出<strong>在计算上（而不是在理论上）是不可破的密码体制</strong>。如果一个密码体制中的密码，不能在一定时间内被可以使用的计算资源破译，则这一密码体制称为<strong>在计算上是安全的</strong>。</li></ul><h1 id="7-2-两类密码体制"><a href="#7-2-两类密码体制" class="headerlink" title="7.2 两类密码体制"></a>7.2 两类密码体制</h1><h2 id="7-2-1-对称密钥密码体制"><a href="#7-2-1-对称密钥密码体制" class="headerlink" title="7.2.1 对称密钥密码体制"></a>7.2.1 对称密钥密码体制</h2><ul><li>所谓<strong>对称密钥密码体制</strong>，即<strong>加密密钥与解密密钥是使用相同的密码体制</strong>。<strong>数据加密标准</strong> DES属于对称密钥密码体制。</li><li>DES是一种分组密码。在加密前，先对整个的明文进行分组。每一个组为64位长的二进制数据。然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据。最后将各组密文串接起来，即得出整个的密文。使用的密钥占有64位（实际密钥长度为56位，外加8位用于奇偶校验）。</li><li><strong>DES的保密性仅取决于对密钥的保密，而算法是公开的</strong>。DES的问题是它的密钥长度。</li><li>三重DES，把一个64位明文用一个密钥加密，再用另一个密钥解密，然后再使用第一个密钥加密，即：<ol><li>![[Pasted image 20230813200941.png]]</li><li>这里，<em>X</em>是明文，<em>Y</em>是密文，<em>K<sub>1</sub></em> 和<em>K<sub>2</sub></em> 分别是第一个和第二个密钥，<em>DES <sub>K1</sub></em>(·)表示用密钥<em>K</em><sub>1</sub>进行DES加密，而<em>DES<sup>-1</sup><sub>K2</sub></em>(·)表示用密钥<em>K</em><sub>2</sub>进行DES解密。</li></ol></li></ul><h2 id="7-2-2-公钥密码体制"><a href="#7-2-2-公钥密码体制" class="headerlink" title="7.2.2 公钥密码体制"></a>7.2.2 公钥密码体制</h2><ul><li>公钥密码体制<strong>使用不同的加密密钥与解密密钥</strong>。</li><li>公钥密码体制的产生主要有两个方面的原因，一是由于对称密钥密码体制的<strong>密钥分配</strong>问题，二是由于对<strong>数字签名</strong>的需求。</li><li>在公钥密码体制中，<strong>加密密钥</strong><em>PK</em>是向公众公开的，而<strong>解密密钥</strong><em>SK</em>则是需要保密的。加密算法<em>E</em>和解密算法<em>D</em>也都是公开的。</li><li>公钥密码体制的加密和解密过程有如下特点：<ol><li><strong>密钥对</strong>在使用对称密钥时，由于双方使用同样的密钥，因此在通信信道上可以进行<strong>一对一的双向保密通信</strong> ，每一方既可用此密钥加密明文，并发送给对方，也可接收密文，用同一密钥对密文解密。产生器产生出接收者B的一对密钥：加密密钥<em>PK<sub>B</sub></em> 和解密密钥<em>SK<sub>B</sub><em>。发送者A所用的加密密钥</em>PK<sub>B</sub></em> 就是接收者B的公钥，它向公众公开。而B所用的解密密钥<em>SK<sub>B</sub></em> 就是接收者B的私钥，对其他人都保密。</li><li>发送者A用B的公钥<em>PK<sub>B</sub></em> 通过<em>E</em>运算对明文<em>X</em> 加密，得出密文<em>Y</em> ，发送给B。B用自己的私钥<em>SK<sub>B</sub></em> 通过<em>D</em> 运算进行解密，恢复出明文，即<ul><li>![[Pasted image 20230813201823.png]]</li><li>![[Pasted image 20230813201836.png]]</li></ul></li><li>虽然在计算机上可以容易地产生成对的<em>PK<sub>B</sub></em> 和<em>SK<sub>B</sub></em> ，但从已知的<em>PK<sub>B</sub></em> 实际上不可能推导出<em>SK<sub>B</sub></em> ，即从<em>PK<sub>B</sub></em> 到<em>SK<sub>B</sub></em> 是“<strong>计算上不可能的</strong>”。.</li><li>虽然公钥可用来加密，但却不能用来解密，即<ul><li>![[Pasted image 20230813201935.png]]</li></ul></li><li>先后对<em>X</em> 进行<em>D</em> 运算和<em>E</em> 运算或进行<em>E</em> 运算和<em>D</em> 运算，结果都是一样的：<ul><li>![[Pasted image 20230813201952.png]]</li></ul></li></ol></li><li>在使用对称密钥时，由于双方使用同样的密钥，因此在通信信道上可以进行<strong>一对一的双向保密通信</strong>，每一方既可用此密钥加密明文，并发送给对方，也可接收密文，用同一密钥对密文解密。<ul><li>在使用公开密钥时，在通信信道上可以是<strong>多对一的单向保密通信</strong>。</li><li><strong>任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量</strong>。</li></ul></li></ul><h1 id="7-3-数字签名"><a href="#7-3-数字签名" class="headerlink" title="7.3 数字签名"></a>7.3 数字签名</h1><ul><li>数字签名必须保证能够实现以下三点功能：<ol><li>接收者能够核实发送者对报文的签名。也就是说，接收者能够确信该报文的确是发送者发送的。其他人无法伪造对报文的签名。这叫做<strong>报文鉴别</strong>。</li><li>接收者确信所收到的数据和发送者发送的完全一样而没有被篡改过。这叫做<strong>报文的完整性</strong>。</li><li>发送者事后不能抵赖对报文的签名。这叫做<strong>不可否认</strong>。</li></ol></li></ul><h1 id="7-4-鉴别"><a href="#7-4-鉴别" class="headerlink" title="7.4 鉴别"></a>7.4 鉴别</h1><ul><li><strong>鉴别是要验证通信的对方的确是自己所要通信的对象，而不是其他的冒充者，并且所传送的报文是完整的，没有被他人篡改过</strong>。</li><li>鉴别细分为两种。一种是报文鉴别，即鉴别所收到的报文的确是报文的发送者所发送的，而不是其他人伪造的或篡改的。这就包含了端点鉴别和报文完整性的鉴别。另一种则是实体鉴别，即仅仅鉴别发送报文的实体。实体可以是一个人，也可以是一个进程（客户或服务器）。这就是端点鉴别。</li></ul><h2 id="7-4-1-报文鉴别"><a href="#7-4-1-报文鉴别" class="headerlink" title="7.4.1 报文鉴别"></a>7.4.1 报文鉴别</h2><ul><li><strong>密码散列函数</strong><ol><li>散列函数具有以下两个特点：<ul><li>散列函数的输入长度可以很长，但其<strong>输出长度则是固定的，并且较短</strong>。散列函数的输出叫做<strong>散列值</strong>，或更简单些，称为<strong>散列</strong>。</li><li>不同的散列值肯定对应于不同的输入，但不同的输入却可能得出相同的散列值。这就是说，散列函数的输入和输出并非一一对应的，而是多对一的。</li></ul></li><li>在密码学中使用的散列函数称为密码散列函数，其最重要的特点就是：要找到两个不同的报文，它们具有同样的密码散列函数输出，在计算上是不可行的。也就是说，密码散列函数实际上是一种<strong>单向函数</strong>。</li></ol></li><li><strong>实用的密码散列函数MD5和SHA-1</strong></li><li><strong>报文鉴别码</strong>*</li></ul><h2 id="7-4-2-实体鉴别"><a href="#7-4-2-实体鉴别" class="headerlink" title="7.4.2 实体鉴别"></a>7.4.2 实体鉴别</h2><ul><li>实体鉴别和报文鉴别不同。报文鉴别是对每一个收到的报文都要鉴别报文的发送者，而实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体只需验证一次。</li></ul><h1 id="7-5-密钥分配"><a href="#7-5-密钥分配" class="headerlink" title="7.5 密钥分配"></a>7.5 密钥分配</h1><ul><li>由于密码算法是公开的，网络的安全性就完全基于密钥的安全保护上。因此在密码学中出现了一个重要的分支——<strong>密钥管理</strong>。密钥管理包括：密钥的产生、分配、注入、验证和使用。</li><li><strong>密钥分配</strong>（或<strong>密钥分发</strong>）是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。例如，可以派非常可靠的信使携带密钥分配给互相通信的各用户。这种方法称为<strong>网外分配方式</strong>。但随着用户的增多和网络流量的增大，密钥更换频繁（密钥必须定期更换才能做到可靠），派信使的办法已不再适用，而应采用<strong>网内分配方式</strong>，即对密钥自动分配。</li></ul><h2 id="7-5-1-对称密钥的分配"><a href="#7-5-1-对称密钥的分配" class="headerlink" title="7.5.1 对称密钥的分配"></a>7.5.1 对称密钥的分配</h2><ul><li>对称密钥分配存在以下两个问题：<ol><li>如果<em>n</em> 个人中的每一个需要和其他<em>n</em> –1个人通信，就需要<em>n</em> （<em>n</em> –1）个密钥。但每两人共享一个密钥，因此密钥数是<em>n</em> （<em>n</em> –1）&#x2F;2。这常称为 ***n<sup>2</sup>*<em><em><strong>问题</strong> 。如果</em>n</em> 是个很大的数，所需要的密钥数量就非常大。</li><li>通信的双方怎样才能安全地得到共享的密钥呢？正是因为网络不安全，所以才需要使用加密技术。但密钥又需要怎样传送呢？</li></ol></li><li>目前常用的密钥分配方式是设立<strong>密钥分配中心</strong> KDC。KDC是大家都信任的机构，其任务就是给需要进行秘密通信的用户临时分配一个会话密钥（仅使用一次）。</li><li>目前最出名的密钥分配协议是Kerberos V5。</li><li>Kerberos使用两个服务器：<strong>鉴别服务器</strong> AS、<strong>票据授予服务器</strong> TGS。Kerberos只用于客户与服务器之间的鉴别，而不用于人对人的鉴别。</li></ul><h2 id="7-5-2-公钥的分配"><a href="#7-5-2-公钥的分配" class="headerlink" title="7.5.2 公钥的分配"></a>7.5.2 公钥的分配</h2><h1 id="7-6-互联网使用的安全协议"><a href="#7-6-互联网使用的安全协议" class="headerlink" title="7.6 互联网使用的安全协议"></a>7.6 互联网使用的安全协议</h1><h2 id="7-6-1-网络层安全协议"><a href="#7-6-1-网络层安全协议" class="headerlink" title="7.6.1 网络层安全协议"></a>7.6.1 网络层安全协议</h2><ul><li><strong>IPsec协议族概述</strong><ol><li>IPsec并不是一个单一协议，而是能够在IP层提供互联网通信安全的<strong>协议族</strong>。IPsec并没有限定用户必须使用何种特定的加密和鉴别算法。实际上，IPsec是个框架，它允许通信双方选择合适的算法和参数（例如，密钥长度）。为保证互操作性，IPsec还包含了一套加密算法，所有IPsec的实现都必须使用。</li><li>IPsec协议族中的协议可划分为以下三个部分：<ul><li>IP安全数据报格式的两个协议：<strong>鉴别首部AH</strong> 协议和<strong>封装安全有效载荷ESP</strong> 协议。</li><li>有关加密算法的三个协议。</li><li><strong>互联网密钥交换</strong> IKE协议。</li></ul></li><li>AH协议提供源点鉴别和数据完整性，但不能保密。而ESP协议比AH协议复杂得多，它提供源点鉴别、数据完整性和保密。IPsec支持IPv4和IPv6。在IPv6中，AH和ESP都是扩展首部的一部分。AH协议的功能都已包含在ESP协议中，因此使用ESP协议就可以不使用AH协议。</li><li>使用ESP或AH协议的IP数据报称为IP<strong>安全数据报</strong>（或IPsec数据报），它可以在两台主机之间、两个路由器之间或一台主机和一个路由器之间发送。</li><li>IP安全数据报有以下两种不同的工作方式：<ul><li><strong>运输方式</strong>。运输方式是在整个运输层报文段的前后分别添加若干控制信息，再加上IP首部，构成IP安全数据报。</li><li><strong>隧道方式</strong>。隧道方式是在原始的IP数据报的前后分别添加若干控制信息，再加上新的IP首部，构成一个IP安全数据报。</li></ul></li><li>无论使用哪种方式，最后得出的IP安全数据报的IP首部都是不加密的。只有使用不加密的IP首部，互联网中的各个路由器才能识别IP首部中的有关信息，把IP安全数据报在不安全的互联网中进行转发，从源点安全地转发到终点。</li></ol></li><li><strong>安全关联</strong><ol><li>在发送IP安全数据报之前，在源实体和目的实体之间必须创建一条网络层的逻辑连接，即<strong>安全关联SA</strong>。这样，<strong>传统的互联网中无连接的网络层就变为了具有逻辑连接的一个层</strong>。安全关联是从源点到终点的<strong>单向连接</strong>，它能够提供安全服务。如要进行双向安全通信，则两个方向都需要建立安全关联。</li><li>SA的状态信息应包括的项目：<ul><li>一个32位的连接标识符，称为<strong>安全参数索引SPI</strong> </li><li>安全关联SA的源点和终点的IP地址（即路由器R 1 和R 2 的IP地址）</li><li>所使用的加密类型（例如，DES或AES）</li><li>加密的密钥</li><li>完整性检查的类型（例如，使用报文摘要MD5或SHA-1的报文鉴别码MAC）</li><li>鉴别使用的密钥</li></ul></li></ol></li><li><strong>IP安全数据报的格式</strong><ol><li>图7-15是IP安全数据报的格式。<ul><li>![[Pasted image 20230813203425.png]]</li></ul></li></ol></li><li><strong>IPsec的其他构件</strong>*<ol><li>当主机要发送IP安全数据报时，就要在<strong>安全关联数据库</strong> SAD中查找相应的SA，以便获得必要的信息，来对该IP安全数据报实施安全保护。同样，当主机要接收IP安全数据报时，也要在SAD中查找相应的SA，以便获得信息来检查该分组的安全性。</li><li>除了安全关联数据库SAD，还需要另一个数据库，这就是<strong>安全策略数据库</strong> SPD。SPD指明什么样的数据报需要进行IPsec处理。这取决于源地址、源端口、目的地址、目的端口，以及协议的类型等。</li><li>对于大型的、地理位置分散的系统，为了创建SAD，我们需要使用自动生成的机制，即使用<strong>互联网密钥交换</strong> IKE协议。IKE的用途就是为IP安全数据报创建安全关联SA。</li><li>IKE是个非常复杂的协议，IKEv2是其新的版本，IKEv2以另外三个协议为基础：<ul><li>Oakley——是个密钥生成协议</li><li><strong>安全密钥交换机制</strong> SKEME——是用于密钥交换的协议。它利用公钥加密来实现密钥交换协议中的实体鉴别</li><li><strong>互联网安全关联和密钥管理协议</strong> ISAKMP——用于实现IKE中定义的密钥交换，使IKE的交换能够以标准化、格式化的报文创建安全关联SA</li></ul></li></ol></li></ul><h2 id="7-6-2-运输层安全协议"><a href="#7-6-2-运输层安全协议" class="headerlink" title="7.6.2 运输层安全协议"></a>7.6.2 运输层安全协议</h2><ul><li>广泛使用的有两个协议：<ol><li><strong>安全套接字层</strong> SSL</li><li><strong>运输层安全</strong> TLS</li></ol></li><li>SSL提供的安全服务可归纳为以下三种：<ol><li>SSL服务器鉴别，允许用户证实服务器的身份。支持SSL的客户端通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥。</li><li>SSL客户鉴别，SSL的可选安全服务，允许服务器证实客户的身份。</li><li>加密的SSL会话，对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改。</li></ol></li><li>SSL的工作过程：<ol><li><strong>协商加密算法</strong> </li><li><strong>服务器鉴别</strong> </li><li><strong>会话密钥计算</strong> </li><li><strong>安全数据传输</strong></li></ol></li></ul><p> </p><h2 id="7-6-3-应用层安全协议"><a href="#7-6-3-应用层安全协议" class="headerlink" title="7.6.3 应用层安全协议"></a>7.6.3 应用层安全协议</h2><ul><li>当我们使用IPSec或SSL时，我们假设双方在相互之间建立起一个会话并双向地交换数据。而在电子邮件中没有会话存在。</li><li>PGP是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。</li><li>PGP的工作原理并不复杂。它提供电子邮件的安全性、发送方鉴别和报文完整性。</li></ul><h1 id="7-7-系统安全：防火墙与入侵检测"><a href="#7-7-系统安全：防火墙与入侵检测" class="headerlink" title="7.7 系统安全：防火墙与入侵检测"></a>7.7 系统安全：防火墙与入侵检测</h1><h2 id="7-7-1-防火墙"><a href="#7-7-1-防火墙" class="headerlink" title="7.7.1 防火墙"></a>7.7.1 防火墙</h2><ul><li><strong>防火墙</strong>作为一种访问控制技术，通过严格控制进出网络边界的分组，禁止任何不必要的通信，从而减少潜在入侵的发生，尽可能降低这类安全威胁所带来的安全风险。由于防火墙不可能阻止所有入侵行为，作为系统防御的第二道防线，<strong>入侵检测系统</strong> IDS通过对进入网络的分组进行深度分析与检测发现疑似入侵行为的网络活动，并进行报警以便进一步采取相应措施。</li><li><strong>防火墙</strong>是一种特殊编程的路由器，安装在一个网点和网络的其余部分之间，目的是实施访问控制策略。这个访问控制策略是由使用防火墙的单位自行制定的。这种安全策略应当最适合本单位的需要。</li><li>互联网这边是防火墙的外面，而内部网络这边是防火墙的里面。一般都把防火墙里面的网络称为“<strong>可信的网络</strong>”，而把防火墙外面的网络称为“<strong>不可信的网络</strong>”。</li><li>防火墙技术一般分为以下两类：<ol><li><strong>分组过滤路由器</strong></li><li><strong>应用网关</strong>也称为<strong>代理服务器</strong></li></ol></li></ul><h2 id="7-7-2-入侵检测系统"><a href="#7-7-2-入侵检测系统" class="headerlink" title="7.7.2 入侵检测系统"></a>7.7.2 入侵检测系统</h2><ul><li><strong>入侵检测系统</strong> IDS在入侵还没有造成危害或在造成更大危害前，及时检测到入侵，以便尽快阻止入侵，把危害降低到最小IDS对进入网络的分组执行深度分组检查，当观察到可疑分组时，向网络管理员发出告警或执行阻断操作。</li><li>入侵检测方法一般可以分为基于特征的入侵检测和基于异常的入侵检测两种。</li></ul><h1 id="7-8-一些未来的发展方向"><a href="#7-8-一些未来的发展方向" class="headerlink" title="7.8 一些未来的发展方向"></a>7.8 一些未来的发展方向</h1><ul><li>椭圆曲线密码（Elliptic Curve Cryptography，简写为ECC）与AES这一系统现在已广泛用于电子护照中，也是下一代金融系统使用的加密系统。</li><li>移动安全（Mobile Security）移动通信带来的广泛应用（如移动支付，Mobile Payment）向网络安全提出了更高的要求。</li><li>量子密码（Quantum Cryptography）量子计算机的到来将使得目前许多使用中的密码技术无效，后量子密码学（Post-Quantum Cryptography）的研究方兴未艾。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li>计算机网络上的通信面临的威胁可分为两大类，即被动攻击（如截获）和主动攻击（如中断、篡改、伪造）。主动攻击的类型有更改报文流、拒绝服务、伪造初始化、恶意程序（病毒、蠕虫、木马、逻辑炸弹、后门入侵、流氓软件）等。</li><li>计算机网络安全主要有以下一些内容：保密性、安全协议的设计和访问控制。</li><li>密码编码学是密码体制的设计学，而密码分析学则是在未知密钥的情况下从密文推演出明文或密钥的技术。密码编码学与密码分析学合起来即为密码学。</li><li>如果不论截取者获得了多少密文，都无法唯一地确定出对应的明文，则这一密码体制称为无条件安全的（或理论上是不可破的）。在无任何限制的条件下，目前几乎所有实用的密码体制均是可破的。如果一个密码体制中的密码不能在一定时间内被可以使用的计算资源破译，则这一密码体制称为在计算上是安全的。</li><li>对称密钥密码体制是加密密钥与解密密钥相同的密码体制（如数据加密标准DES和高级加密标准AES）。这种加密的保密性仅取决于对密钥的保密，而算法是公开的。</li><li>公钥密码体制（又称为公开密钥密码体制）使用不同的加密密钥与解密密钥。加密密钥（即公钥）是向公众公开的，而解密密钥（即私钥或秘钥）则是需要保密的。加密算法和解密算法也都是公开的。</li><li>目前最著名的公钥密码体制是RSA体制，它是基于数论中的大数分解问题的体制。</li><li>任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量，而不是简单地取决于加密的体制（公钥密码体制或传统加密体制）。</li><li>数字签名必须保证能够实现以下三点功能：（1）报文鉴别，即接收者能够核实发送者对报文的签名；（2）报文的完整性，即接收者确信所收到的数据和发送者发送的完全一样而没有被篡改过；（3）不可否认，即发送者事后不能抵赖对报文的签名。</li><li>鉴别是要验证通信的对方的确是自己所要通信的对象，而不是其他的冒充者。鉴别与授权是不同的概念。</li><li>报文摘要MD是进行报文鉴别的一种简单方法。目前广泛使用的是SHA-1。</li><li>密钥管理包括：密钥的产生、分配、注入、验证和使用。密钥分配（或密钥分发）是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。目前常用的密钥分配方式是设立密钥分配中心KDC。</li><li>认证中心CA是一个值得信赖的机构，用来将公钥与其对应的实体（人或机器）进行绑定。每个实体都有CA发来的证书，里面有公钥及其拥有者的标识信息（人名或IP地址）。此证书被CA进行了数字签名。任何用户都可从可信的地方获得认证中心CA的公钥。</li><li>在网络层可使用IPsec协议族，IPsec包括鉴别首部协议AH和封装安全有效载荷协议ESP。AH协议提供源点鉴别和数据完整性，但不能保密。而ESP协议提供源点鉴别、数据完整性和保密。IPsec支持IPv4和IPv6。在IPv6中，AH和ESP都是扩展首部的一部分。IPsec数据报的工作方式有运输方式和隧道方式两种。</li><li>运输层的安全协议有SSL（安全套接字层）和TLS（运输层安全）。SSL最新的版本是SSL 3.0，它是保护万维网HTTP通信量所公认的事实上的标准。SSL不仅被所有常用的浏览器和万维网服务器所支持，而且也是TLS的基础。</li><li>PGP是一个完整的电子邮件安全软件包，包括加密、鉴别、电子签名和压缩等技术。PGP并没有使用什么新的概念，它只是把现有的一些加密算法（如RSA公钥加密算法或MD5报文摘要算法）综合在一起而已。</li><li>防火墙是一种特殊编程的路由器，安装在一个网点和网络的其余部分之间，目的是实施访问控制策略。防火墙里面的网络称为“可信的网络”，而把防火墙外面的网络称为“不可信的网络”。防火墙的功能有两个：一个是阻止（主要的），另一个是允许。</li><li>防火墙技术分为：网络级防火墙，用来防止整个网络出现外来非法的入侵（属于这类的有分组过滤和授权服务器）；应用级防火墙，用来进行访问控制（用应用网关或代理服务器来区分各种应用）。</li><li>入侵检测系统IDS是在入侵已经开始，但还没有造成危害或在造成更大危害前，及时检测到入侵，以便尽快阻止入侵，把危害降低到最小。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 应用层</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-6-zhang-ying-yong-ceng/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-6-zhang-ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1-域名系统-DNS"><a href="#6-1-域名系统-DNS" class="headerlink" title="6.1 域名系统 DNS"></a>6.1 域名系统 DNS</h1><ul><li>应用层的具体内容是精确定义通信规则：<ol><li>应用进程交换的报文类型，如请求报文和响应报文。</li><li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li><li>字段的语义，即包含在字段中的信息的含义。</li><li>进程何时、如何发送报文，以及对报文进行响应的规则。</li></ol></li></ul><h2 id="6-1-1-域名系统概述"><a href="#6-1-1-域名系统概述" class="headerlink" title="6.1.1 域名系统概述"></a>6.1.1 域名系统概述</h2><ul><li><strong>域名系统</strong> DNS 是互联网使用的命名系统，把机器名字转换为 IP 地址。</li><li>许多应用层软件经常直接使用域名系统 DNS。虽然计算机的用户只是<strong>间接</strong>使用域名系统，但 DNS 却为互联网的各种网络应用提供了核心服务。</li><li>用户与互联网上某台主机通信时，必须要知道对方的 IP 地址。应用层为了便于用户记忆各种网络应用设置了主机名，通过域名系统 DNS 把互联网上的主机名字转换为 IP 地址。</li><li>从理论上讲，整个互联网可以只使用一个域名服务器，使它装入互联网上所有的主机名，并回答所有对 IP 地址的查询。但是因为互联网规模很大，这样的域名服务器会因过负荷而无法正常工作，而且一旦域名服务器出现故障，整个互联网就会瘫痪。因此采用层次树状结构的命名方法，并使用分布式的<strong>域名系统</strong> DNS。</li><li>互联网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行<strong>解析</strong>，仅少量解析需要在互联网上通信，因此 DNS 系统的效率很高。由于 DNS 是分布式系统，即使单个计算机出了故障，也不会妨碍整个 DNS 系统的正常运行。</li><li>域名到 IP 地址的解析是由分布在互联网上的许多<strong>域名服务器程序</strong>共同完成的。域名服务器程序在专设的结点上运行，把运行域名服务器程序的机器称为<strong>域名服务器</strong>。</li><li>域名到 IP 地址的解析过程的要点如下：当某一个应用进程需要把主机名解析为 IP 地址时，该应用进程就调用<strong>解析程序</strong>，成为 DNS 的一个客户，把待解析的域名放在 DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器 (使用 UDP 是为了减少开销)。本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。应用进程获得目的主机的 IP 地址后即可进行通信。</li></ul><h2 id="6-1-2-互联网的域名结构"><a href="#6-1-2-互联网的域名结构" class="headerlink" title="6.1.2 互联网的域名结构"></a>6.1.2 互联网的域名结构</h2><ul><li>DNS 规定，域名中的标号都由英文字母和数字组成，<strong>每一个标号不超过 63 个字符</strong> (为了记忆方便，最好不要超过 12 个字符)，<strong>也不区分大小写字母</strong> (例如，CCTV 或 cctv 在域名中是等效的)。标号中除连字符 (-) 外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的顶级域名则写在最右边。<strong>由多个标号组成的完整域名总共不超过 255 个字符</strong>。DNS 既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由 ICANN 进行管理。用这种方法可使每一个域名在整个互联网范围内是唯一的，并且也容易设计出一种查找域名的机制。</li><li>原先的顶级域名共分为三大类：<ol><li><strong>国家顶级域名</strong> nTLD</li><li><strong>通用顶级域名</strong> gTLD</li><li><strong>基础结构域名</strong></li></ol></li><li>我国把二级域名划分为“<strong>类别域名</strong>”和“<strong>行政区域名</strong>”两大类。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218153419.png"></li></ul><h2 id="6-1-3-域名服务器"><a href="#6-1-3-域名服务器" class="headerlink" title="6.1.3 域名服务器"></a>6.1.3 域名服务器</h2><ul><li>域名服务器划分为以下四种不同的类型：<ol><li><strong>根域名服务器</strong> (root name server)：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析 (即转换为 IP 地址)，只要自己无法解析，就首先要求助于根域名服务器。假定所有的根域名服务器都瘫痪了，那么整个互联网中的 DNS 系统就无法工作。</li><li><strong>顶级域名服务器</strong> (即 TLD <strong>服务器</strong>)：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答。</li><li><strong>权限域名服务器</strong>：当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</li><li><strong>本地域名服务器</strong> (local name server)：当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</li></ol></li><li>为了提高域名服务器的可靠性，DNS 域名服务器把数据复制到几个域名服务器来保存，其中的一个是<strong>主域名服务器</strong>，其他的是<strong>辅助域名服务器</strong>。当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行，保证数据的一致性。</li><li>域名的解析过程:<ol><li>主机向本地域名服务器的查询一般采用<strong>递归查询</strong>。递归查询是：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器发出查询请求报文，而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果是所要查询的 IP 地址，或报错。</li><li>本地域名服务器向根域名服务器的查询通常采用<strong>迭代查询</strong>。迭代查询的特点是：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询，而不是替本地域名服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询，本地域名服务器就这样进行迭代查询。最后，知道了所要解析的域名的 IP 地址，然后把这个结果返回给发起查询的主机。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218171321.png"></li></ol></li><li>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</li></ul><h1 id="6-2-文件传送协议"><a href="#6-2-文件传送协议" class="headerlink" title="6.2 文件传送协议"></a>6.2 文件传送协议</h1><h2 id="6-2-1-FTP-概述"><a href="#6-2-1-FTP-概述" class="headerlink" title="6.2.1 FTP 概述"></a>6.2.1 FTP 概述</h2><ul><li>文件传送协议 FTP 是互联网上使用得最广泛的文件传送协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。FTP 屏蔽了各计算机系统的细节，适合于在异构网络中任意计算机之间传送文件。</li><li>基于 TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP 都是文件共享协议中的一大类，即<strong>复制整个文件</strong>，特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。</li><li>文件共享协议中的另一大类是<strong>联机访问</strong>。联机访问意味着允许多个程序同时对一个文件进行存取。和数据库系统的不同之处是用户不需要调用一个特殊的客户进程，而是由操作系统提供对远地共享文件进行访问的服务。使用户可以用远地文件作为输入和输出来运行任何应用程序，而操作系统中的文件系统则提供对共享文件的<strong>透明存取</strong>。透明存取的优点是：将原来用于处理本地文件的应用程序用来处理远地文件时，不需要对该应用程序作明显的改动。属于文件共享协议的有网络文件系统 NFS。</li></ul><h2 id="6-2-2-FTP-的基本工作原理"><a href="#6-2-2-FTP-的基本工作原理" class="headerlink" title="6.2.2 FTP 的基本工作原理"></a>6.2.2 FTP 的基本工作原理</h2><ul><li>文件传输协议 FTP 只提供文件传输的一些基本的服务，它使用 TCP 可靠的运输服务。FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li><li>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个<strong>主进程</strong>，负责接受新的请求；另外有若干个<strong>从属进程</strong>，负责处理单个请求。</li><li>主进程的工作步骤如下：<ol><li>打开熟知端口 (端口号为21)，使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li><li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发进行的。</li></ol></li><li>在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：“<strong>控制连接</strong>”和“<strong>数据连接</strong>”。控制连接在整个会话期间一直保持打开，FTP 客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。<strong>实际用于传输文件的是“数据连接”</strong>。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“<strong>数据传送进程</strong>”和“<strong>数据连接</strong>”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。由于 FTP 使用了一个分离的控制连接，因此 FTP 的控制信息是<strong>带外</strong>传送的。</li><li>使用两个独立的连接的主要好处是使协议更加简单和更容易实现，同时在传输文件时还可以利用控制连接对文件的传输进行控制。</li><li>网络文件系统 <strong>NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据</strong>。</li></ul><h2 id="6-2-3-简单文件传送协议-TFTP"><a href="#6-2-3-简单文件传送协议-TFTP" class="headerlink" title="6.2.3 简单文件传送协议 TFTP"></a>6.2.3 简单文件传送协议 TFTP</h2><ul><li>TCP&#x2F;IP 协议族中有一个<strong>简单文件传送协议</strong> TFTP，它是一个很小且易于实现的文件传送协议。虽然 TFTP 也使用客户服务器方式，但它使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</li><li>TFTP 的主要优点有两个：<ol><li>TFTP 可用于 UDP 环境。例如，当需要将程序或文件同时向许多机器下载时就往往需要使用 TFTP。</li><li>TFTP 代码所占的内存较小。这对较小的计算机或某些特殊用途的设备是很重要的。</li></ol></li><li>TFTP 的主要特点是：<ol><li>每次传送的数据报文中有 512 字节的数据，但最后一次可不足 512 字节。</li><li>数据报文按序编号，从 1 开始。</li><li>支持 ASCII 码或二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部。</li></ol></li></ul><h1 id="6-3-远程终端协议-TELNET"><a href="#6-3-远程终端协议-TELNET" class="headerlink" title="6.3 远程终端协议 TELNET"></a>6.3 远程终端协议 TELNET</h1><ul><li>TELNET 是一个简单的远程终端协议。用户用 TELNET 可在其所在地通过 TCP 连接注册到远地的另一台主机上。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。因此，TELNET 又称为<strong>终端仿真协议</strong>。</li><li>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行TELNET 服务器进程。和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。</li><li><strong>网络虚拟终端</strong> NVT 的格式定义很简单。所有的通信都使用 8 位一个字节。在运转时，NVT 使用 7 位 ASCII 码传送数据，而当高位置 1 时用作控制命令。ASCII 码共有 95 个可打印字符 (如字母、数字、标点符号) 和 33 个控制字符。所有可打印字符在 NVT 中的意义和在 ASCII 码中一样。但 NVT 只使用了 ASCII 码的控制字符中的几个。</li></ul><h1 id="6-4-万维网-WWW"><a href="#6-4-万维网-WWW" class="headerlink" title="6.4 万维网 WWW"></a>6.4 万维网 WWW</h1><h2 id="6-4-1-万维网概述"><a href="#6-4-1-万维网概述" class="headerlink" title="6.4.1 万维网概述"></a>6.4.1 万维网概述</h2><ul><li><strong>万维网</strong> WWW 并非某种特殊的计算机网络，<strong>而是一个大规模的、联机式的信息储藏所</strong>，英文简称为 Web。</li><li>万维网是一个分布式的<strong>超媒体</strong>系统，它是<strong>超文本</strong>系统的扩充。</li><li>分布式的和非分布式的超媒体系统有很大区别。在非分布式系统中，各种信息都驻留在单个计算机的磁盘中。由于各种文档都可从本地获得，因此这些文档之间的链接可进行一致性检查。</li><li><strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>。</li><li>万维网必须解决以下几个问题：<ol><li>怎样标志分布在整个互联网上的万维网文档？——万维网使用<strong>统一资源定位符</strong> URL 来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</li><li>用什么样的协议来实现万维网上的各种链接？——万维网使用<strong>超文本传送协议</strong> HTTP 来实现万维网上的各种链接。HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li><li>怎样使不同作者创作的不同风格的万维网文档，都能在互联网上的各种主机上显示出来，同时使用户清楚地知道在什么地方存在着链接？——万维网使用<strong>超文本标记语言</strong> HTML，使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来。</li></ol></li></ul><h2 id="6-4-2-统一资源定位符-URL"><a href="#6-4-2-统一资源定位符-URL" class="headerlink" title="6.4.2 统一资源定位符 URL"></a>6.4.2 统一资源定位符 URL</h2><ul><li><strong>URL 的格式</strong><ol><li><strong>统一资源定位符</strong> URL 是用来从互联网上得到的资源位置和访问这些资源的方法。</li><li>URL 是与互联网相连的机器上的任何可访问对象的一个指针。由于访问不同对象所使用的协议不同，所以 URL 还指出读取某个对象时所使用的协议。URL 的一般形式由以下四个部分组成：&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</li><li>URL 的第一部分是最左边的&lt;协议&gt;。&lt;协议&gt;是指使用什么协议来获取该万维网文档。现在最常用的协议就是 HTTP，其次是 FTP。在&lt;协议&gt;后面的“:&#x2F;&#x2F;”是规定的格式。它的右边是第二部分&lt;主机&gt;，指出这个万维网文档是在哪一台主机上。&lt;主机&gt;是指该主机在互联网上的域名。再后面是第三和第四部分&lt;端口&gt;和&lt;路径&gt;，有时可省略。</li></ol></li><li><strong>使用 HTTP 的 URL</strong><ol><li>对于万维网网点的访问要使用 HTTP 协议。HTTP 的 URL 的一般形式是：http:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</li><li>HTTP 的默认端口号是 80，通常可省略。若再省略文件的&lt;路径&gt;项，则 URL 就指到互联网上的某个<strong>主页</strong>。主页是个很重要的概念，它可以是以下几种情况之一：<ul><li>一个 WWW 服务器的最高级别的页面。</li><li>某一个组织或部门的一个定制的页面或目录。从这样的页面可链接到互联网上的与本组织或部门有关的其他站点。</li><li>由某一个人自己设计的描述他本人情况的 WWW 页面。</li></ul></li></ol></li></ul><h2 id="6-4-3-超文本传送协议-HTTP"><a href="#6-4-3-超文本传送协议-HTTP" class="headerlink" title="6.4.3 超文本传送协议 HTTP"></a>6.4.3 超文本传送协议 HTTP</h2><ul><li><strong>HTTP 的操作过程</strong><ol><li>HTTP 是<strong>面向事务的</strong>应用层协议是万维网上能够可靠地交换文件的重要基础。</li><li>用户浏览页面的方法有两种：<ul><li>键入 URL。</li><li>用鼠标点击一个可选部分所对应的链接。</li></ul></li><li>HTTP&#x2F;1.0 的主要缺点是：<ul><li>每请求一个文档要有两倍 RTT 开销。若一个主页上有很多链接的对象需要依次进行链接，每一次链接下载都导致 2×RTT 的开销。</li><li>万维网客户和服务器每一次建立新的 TCP 连接都要分配缓存和变量，特别是万维网服务器往往要同时服务于大量客户的请求，所以这种<strong>非持续连接</strong>会使万维网服务器的负担很重。</li></ul></li><li>HTTP&#x2F;1.1 协议使用<strong>持续连接</strong>较好地解决了这个问题。万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。</li><li>HTTP&#x2F;1.1 协议的持续连接有两种工作方式：<ul><li><strong>非流水线方式</strong><ol><li>特点：客户在收到前一个响应后才能发出下一个请求。因此，在 TCP 连接已建立后，客户每访问一次对象都要用去一个往返时间 RTT，这比非持续连接节省了建立 TCP 连接所需的一个 RTT 时间。</li><li>缺点：服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</li></ol></li><li><strong>流水线方式</strong><ol><li>特点：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用流水线方式时，客户访问<strong>所有的对象</strong>只需花费一个 RTT 时间。流水线工作方式使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li></ol></li></ul></li></ol></li><li><strong>代理服务器</strong><ol><li><strong>代理服务器</strong>是一种网络实体，又称<strong>万维网高速缓存</strong>。</li></ol></li><li><strong>HTTP 的报文结构</strong><ol><li>HTTP 有两类报文：<ul><li>请求报文——从客户向服务器发送请求报文，见图 6-12(a)。</li><li>响应报文——从服务器到客户的回答，见图 6-12(b)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812151126.png"></li></ul></li><li>由于 HTTP 是<strong>面向文本的</strong>，因此在报文中的每一个字段都是一些 ASCII 码串，各个字段的长度都是不确定的。</li><li>HTTP 请求报文和响应报文都是由三个部分组成：<ul><li><strong>开始行</strong>，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做<strong>请求行</strong>，而在响应报文中的开始行叫做<strong>状态行</strong>。在开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表“回车”和“换行”。</li><li><strong>首部行</strong>，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</li><li><strong>实体主体</strong>，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</li></ul></li><li>请求报文的第一行“请求行”有三个内容：<ul><li>方法</li><li>请求资源的 URL</li><li>HTTP 的版本。</li><li>HTTP 请求报文的一些方法：<img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218160354.png"></li></ul></li><li>HTTP 响应报文的主要特点：<ul><li>每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。</li><li>状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。</li><li><strong>状态码</strong>都是三位数字的，分为 5 大类，原先有 33 种，后来又增加了几种。这 5 大类的状态码都是以不同的数字开头的。<ol><li>1xx 表示通知信息，如请求收到了或正在进行处理。</li><li>2xx 表示成功，如接受或知道了。</li><li>3xx 表示重定向，如要完成请求还必须采取进一步的行动。</li><li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li></ol></li></ul></li></ol></li><li><strong>在服务器上存放用户的信息</strong><ol><li>HTTP 是一个典型的无状态协议。每个 HTTP 请求都是独立的，服务器在处理请求时不会保留关于客户端的状态信息。为了实现会话状态，Web 应用程序通常使用一些机制，如 cookies 或者会话标识符，来跟踪客户端的状态。这些机制在每个请求中传递标识符，存储在用户主机中，以便服务器能够识别和关联相关的状态信息。</li><li>“无状态协议”是指协议在处理每个请求时都没有记忆先前请求的状态。具体而言，对于 HTTP 来说，每个请求都是独立的，服务器不会记住之前任何请求的信息。这意味着每个请求都需要包含所有必要的信息，而服务器不能从之前的请求中获取上下文或状态。</li><li>在无状态协议中，服务器不保存客户端的状态信息，而是在每个请求中都从客户端接收到所有必要的信息以完成处理。这有助于简化协议的设计和实现，并使系统更易于扩展和管理。然而，这也意味着如果客户端和服务器之间需要维护会话状态，必须在请求和响应中包含足够的信息来实现这种状态管理。</li></ol></li></ul><h2 id="6-4-4-万维网的文档"><a href="#6-4-4-万维网的文档" class="headerlink" title="6.4.4 万维网的文档"></a>6.4.4 万维网的文档</h2><ul><li><strong>超文本标记语言 HTML</strong><ol><li><strong>超文本标记语言 HTML</strong>  是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍。但 HTML <strong>并不是应用层的协议</strong>，它只是万维网浏览器使用的一种语言。</li><li>HTML 允许在万维网页面中插入图像。</li><li>HTML 规定了链接的设置方法。</li><li>XML 是<strong>可扩展标记语言</strong>，与 HTML 很相似。但 XML 的设计宗旨是传输数据，而不是显示数据 (HTML 是为了在浏览器上显示数据)。更具体些，XML 用于标记电子文件，使其具有结构性的标记语言，可用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML 是一种简单、与平台无关并被广泛采用的标准。XML 相对于 HTML 的优点是它将用户界面与结构化数据分隔开来。</li><li>XHTML 是<strong>可扩展超文本标记语言</strong>，与 HTML 4.01 几乎是相同的。</li><li>CSS 是<strong>层叠样式表</strong>，它是一种样式表语言，用于为 HTML 文档定义布局。CSS 与 HTML 的区别是：HTML 用于结构化内容，而 CSS 则用于格式化结构化的内容。</li></ol></li><li><strong>动态万维网文档</strong><ol><li>静态文档的优点是简单。由于 HTML 是一种排版语言，因此静态文档可以由不懂程序设计的人员来创建。但静态文档的缺点是不够灵活。当信息变化时就要由文档的作者手工对文档进行修改。</li><li><strong>动态文档</strong>是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。当浏览器请求到达时，万维网服务器要运行另一个应用程序，并把控制转移到此应用程序。接着，该应用程序对浏览器发来的数据进行处理，并输出 HTTP 格式的文档，万维网服务器把应用程序的输出作为对浏览器的响应。由于对浏览器每次请求的响应都是临时生成的，因此用户通过动态文档所看到的内容是不断变化的。动态文档的主要优点是具有报告当前最新信息的能力。</li><li>动态文档和静态文档之间的主要差别体现在服务器一端，主要是<strong>文档内容的生成方法不同</strong>。而从浏览器的角度看，这两种文档并没有区别。</li><li>要实现动态文档就必须在以下两个方面对万维网服务器的功能进行扩充：<ul><li>增加另一个应用程序，处理浏览器发来的数据，并创建动态文档。</li><li>增加一个机制，使万维网服务器将浏览器发来的数据传送给这个应用程序，然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。</li></ul></li><li><strong>通用网关接口 CGI</strong> 是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。</li></ol></li><li><strong>活动万维网文档</strong><ol><li>有两种技术可用于浏览器屏幕显示的连续更新：<ul><li><strong>服务器推送</strong>，这种技术是将所有的工作都交给服务器。服务器不断地运行与动态文档相关联的应用程序，定期更新信息，并发送更新过的文档。<ol><li>缺点：为了满足很多客户的请求，服务器要运行很多服务器推送程序。这将造成过多的服务器开销。服务器推送技术要求服务器为每一个浏览器客户维持一个不释放的 TCP 连接。随着 TCP 连接的数目增加，每一个连接所能分配到的网络带宽就下降，这就导致网络传输时延的增大。</li></ol></li><li>另一种提供屏幕连续更新的技术是<strong>活动文档</strong>。<ol><li>这种技术是把所有的工作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段活动文档程序副本，使该程序副本在浏览器端运行。这时，活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。只要用户运行活动文档程序，活动文档的内容就可以连续地改变。由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。</li></ol></li></ul></li></ol></li></ul><h2 id="6-4-5-万维网的信息检索系统"><a href="#6-4-5-万维网的信息检索系统" class="headerlink" title="6.4.5 万维网的信息检索系统"></a>6.4.5 万维网的信息检索系统</h2><ul><li><strong>全文检索搜索与分类目录搜索</strong><ol><li>在万维网中用来进行搜索的工具叫做<strong>搜索引擎</strong>。搜索引擎的种类很多，但大体上可划分为两大类，<ul><li><strong>全文检索</strong>搜索引擎：全文检索搜索引擎是一种纯技术型的检索工具。<ol><li>优点：全文检索可以检索出大量的信息。</li><li>缺点：但缺点是查询结果不够准确，往往是罗列出了海量的信息，使用户无法迅速找到所需的信息。</li></ol></li><li><strong>分类目录</strong>搜索引擎：分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。因此，分类目录搜索也叫做分类网站搜索。<ol><li>优点：用户可根据网站设计好的目录有针对性地逐级查询所需要的信息，查询时不需要使用关键词，只需要按照分类 (先找大类，再找下面的小类)，因而查询的准确性较好。</li><li>缺点：分类目录查询的结果并不是具体的页面，而是被收录网站主页的 URL 地址，因而所得到的内容就比较有限。</li></ol></li></ul></li><li><strong>垂直搜索引擎</strong>针对某一特定领域、特定人群或某一特定需求提供搜索服务。</li><li><strong>元搜索引擎</strong>，把用户提交的检索请求发送到多个独立的搜索引擎上去搜索，并把检索结果集中统一处理，以统一的格式提供给用户，因此是搜索引擎之上的搜索引擎。它的主要精力放在提高搜索速度、智能化处理搜索结果、个性化搜索功能的设置和用户检索界面的友好性上。元搜索引擎的查全率和查准率都比较高。</li></ol></li><li><strong>Google 搜索技术的特点</strong></li></ul><h2 id="6-4-6-博客与微博"><a href="#6-4-6-博客与微博" class="headerlink" title="6.4.6 博客与微博"></a>6.4.6 博客与微博</h2><ul><li><strong>博客</strong></li><li><strong>微博</strong></li></ul><h2 id="6-4-7-社交网站"><a href="#6-4-7-社交网站" class="headerlink" title="6.4.7 社交网站"></a>6.4.7 社交网站</h2><h1 id="6-5-电子邮件"><a href="#6-5-电子邮件" class="headerlink" title="6.5 电子邮件"></a>6.5 电子邮件</h1><h2 id="6-5-1-电子邮件概述"><a href="#6-5-1-电子邮件概述" class="headerlink" title="6.5.1 电子邮件概述"></a>6.5.1 电子邮件概述</h2><ul><li>电子邮件的两个最重要的标准是：<strong>简单邮件传送协议</strong> SMTP 和<strong>互联网文本报文格式</strong> </li><li>由于互联网的 SMTP 只能传送可打印的 7 位 ASCII 码邮件，因此提出了<strong>通用互联网邮件扩充</strong> MIME 。MIME 在其邮件首部中说明了邮件的数据类型。在 MIME 邮件中可同时传送多种类型的数据。</li><li>一个电子邮件系统应具有图 6-17 所示的三个主要组成构件，即<strong>用户代理、邮件服务器</strong>，以及邮件发送协议 (如 SMTP) 和邮件读取协议 (如POP3)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812154053.png"></li></ol></li><li><strong>用户代理</strong> UA 是用户与电子邮件系统的接口，大多数情况下它是运行在用户电脑中的一个程序。因此用户代理又称为<strong>电子邮件客户端软件</strong>。用户代理向用户提供一个很友好的接口来发送和接收邮件。</li><li>用户代理至少应当具有以下四个功能：<ol><li><strong>撰写</strong>。给用户提供编辑信件的环境。例如，应让用户能创建便于使用的通讯录。回信时不仅能很方便地从来信中提取出对方地址，并自动地将此地址写入到邮件中合适的位置，而且还能方便地对来信提出的问题进行答复。</li><li><strong>显示</strong>。能方便地在计算机屏幕上显示出来信。</li><li><strong>处理</strong>。处理包括发送邮件和接收邮件。收件人应能根据情况按不同方式对来信进行处理。例如，阅读后删除、存盘、打印、转发等，以及自建目录对来信进行分类保存。有时还可在读取信件之前先查看一下邮件的发件人和长度等，对于不愿收的信件可直接在邮箱中删除。</li><li><strong>通信</strong>。发信人在撰写完邮件后，要利用邮件发送协议发送到用户所使用的邮件服务器。收件人在接收邮件时，要使用邮件读取协议从本地邮件服务器接收邮件。</li></ol></li><li>电子邮件由<strong>信封</strong>和**内容两部分组成。</li></ul><h2 id="6-5-2-简单邮件传送协议-SMTP"><a href="#6-5-2-简单邮件传送协议-SMTP" class="headerlink" title="6.5.2 简单邮件传送协议 SMTP"></a>6.5.2 简单邮件传送协议 SMTP</h2><ul><li>通过发送方和接收方的邮件服务器之间的 SMTP 通信的三个阶段介绍几个最主要的命令和响应信息：<ol><li><strong>连接建立</strong><ul><li>SMTP <strong>不使用中间的邮件服务器</strong>。</li></ul></li><li><strong>邮件传送</strong><ul><li>RCPT 命令的作用是：先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件。这样做是为了避免浪费通信资源，不至于发送了很长的邮件以后才知道地址错误。</li></ul></li><li><strong>连接释放</strong><ul><li>邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是“221 (服务关闭)”，表示 SMTP 同意释放 TCP 连接。邮件传送的全部过程即结束。</li></ul></li></ol></li></ul><h2 id="6-5-3-电子邮件的信息格式"><a href="#6-5-3-电子邮件的信息格式" class="headerlink" title="6.5.3 电子邮件的信息格式"></a>6.5.3 电子邮件的信息格式</h2><h2 id="6-5-4-邮件读取协议-POP3-和-IMAP"><a href="#6-5-4-邮件读取协议-POP3-和-IMAP" class="headerlink" title="6.5.4 邮件读取协议 POP3 和 IMAP"></a>6.5.4 邮件读取协议 POP3 和 IMAP</h2><ul><li>现在常用的邮件读取协议有两个：<ol><li>邮局协议第 3 个版本 POP3：<strong>邮局协议</strong> POP 是一个非常简单、功能有限的邮件读取协议。在传输层使用明文来传输密码，不对密码进行</li><li><strong>网际报文存取协议</strong> IMAP：比 POP3 复杂。IMAP 和 POP 都按客户服务器方式工作，但它们有很大的差别。<ul><li>用户在自己的计算机上可以操纵邮件服务器的邮箱，就像在本地操纵一样，IMAP 是一个联机协议。当用户计算机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。用户可以根据需要为自己的邮箱创建便于分类管理的层次式的邮箱文件夹，并且能够将存放的邮件从某一个文件夹中移动到另一个文件夹中。用户也可按某种条件对邮件进行查找。在用户未发出删除邮件的命令之前，IMAP 服务器邮箱中的邮件一直保存着。</li><li>优点：用户可以在不同的地方使用不同的计算机，随时上网阅读和处理自己在邮件服务器中的邮件，IMAP 还允许收件人只读取邮件中的某一个部分。</li><li>缺点：如果用户没有将邮件复制到自己的计算机上，则邮件一直存放在 IMAP 服务器上。要想查阅自己的邮件，必须先上网。</li></ul></li></ol></li><li>表 6-2 给出了 IMAP 和 POP3 的主要功能的比较。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812161852.png"></li></ol></li></ul><h2 id="6-5-5-基于万维网的电子邮件"><a href="#6-5-5-基于万维网的电子邮件" class="headerlink" title="6.5.5 基于万维网的电子邮件"></a>6.5.5 基于万维网的电子邮件</h2><ul><li>万维网电子邮件的好处是：不管在什么地方，只要能够找到上网的计算机，在打开任何一种浏览器后，就可以非常方便地收发电子邮件。</li></ul><h2 id="6-5-6-通用互联网邮件扩充-MIME"><a href="#6-5-6-通用互联网邮件扩充-MIME" class="headerlink" title="6.5.6 通用互联网邮件扩充 MIME"></a>6.5.6 通用互联网邮件扩充 MIME</h2><ul><li><strong>MIME 概述</strong><ol><li>电子邮件协议 SMTP 有以下缺点：<ul><li>SMTP 不能传送可执行文件或其他的二进制对象。</li><li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字就无法传送。即使在 SMTP 网关将 EBCDIC 码 (即扩充的二&#x2F;十进制交换码) 转换为 ASCII 码，也会遇到一些麻烦。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li><li>(SMTP 传送的邮件是明文，不利于保密。)</li><li>某些 SMTP 的实现并没有完全按照 SMTP 的互联网标准。常见的问题如下：<ol><li>回车、换行的删除和增加；</li><li>超过 76 个字符时的处理：截断或自动换行；</li><li>后面多余空格的删除；</li><li>将制表符 tab 转换为若干个空格。</li></ol></li></ul></li><li><strong>通用互联网邮件扩充 MIME</strong> 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程序和协议下传送。图 6-18 表示 MIME 和 SMTP 的关系。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812180720.png"></li></ul></li><li>MIME 主要包括以下三部分内容：<ul><li>5 个新的邮件首部字段，它们可包含在原来的邮件首部中。这些字段提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ul></li><li>MIME 增加的 5 个新的邮件首部的名称及其意义：<ul><li>MIME-Version：标志 MIME 的版本。现在的版本号是 1.0。</li><li>Content-Description：可读字符串，说明此邮件主体是否是图像、音频或视频。</li><li>Content-Id：邮件的唯一标识符。</li><li>Content-Transfer-Encoding：在传送时邮件的主体是如何编码的。</li><li>Content-Type：说明邮件主体的数据类型和子类型。</li></ul></li></ol></li><li><strong>内容传送编码</strong><ol><li>介绍三种常用的<strong>内容传送编码</strong><ul><li>最简单的编码就是 7 位 ASCII 码，而每行不能超过 1000 个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。</li><li>另一种编码称为 quoted-printable，这种编码方法适用于所传送的数据中只有少量的非 ASCII 码，例如汉字。</li><li>对于任意的二进制文件，可用 base64 编码。</li></ul></li></ol></li><li><strong>内容类型</strong><ol><li>MIME 标准规定 Content-Type 说明必须含有两个标识符，即内容<strong>类型</strong>和<strong>子类型</strong>，中间用“&#x2F;”分开。</li><li>除了内容类型和子类型，MIME 允许发件人和收件人自己定义专用的内容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串 X- 开始。</li><li>表 6-3 列出了 MIME 的内容类型、子类型举例及其说明。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812181229.png"></li></ul></li><li>MIME 标准为 multipart 定义了四种可能的子类型，每个子类型都提供重要功能。<ul><li>mixed 子类型允许单个报文含有多个相互独立的子报文，每个子报文有自己的类型和编码。mixed 子类型报文使用户能够在单个报文中附上文本、图形和声音，或者用额外数据段发送一个备忘录。在 mixed 后面还要用到一个关键字，即 Boundary＝，此关键字定义了分隔报文各部分所用的字符串 (由邮件系统定义)，只要在邮件的内容中不会出现这样的字符串即可。当某一行以两个连字符“–”开始，后面紧跟上述的字符串，就表示下面开始了另一个子报文。</li><li>alternative 子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件和软件系统的收件人发送备忘录时，这种类型的 multipart 报文很有用。例如，用户可同时用普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在查看图形时选择格式化的形式。</li><li>parallel 子类型允许单个报文含有可同时显示的各个子部分。</li><li>digest 子类型允许单个报文含有一组其他报文。</li></ul></li></ol></li></ul><h1 id="6-6-动态主机配置协议DHCP"><a href="#6-6-动态主机配置协议DHCP" class="headerlink" title="6.6 动态主机配置协议DHCP"></a>6.6 动态主机配置协议DHCP</h1><ul><li>连接到互联网的计算机的协议软件需要配置的项目包括：<ol><li>IP 地址；</li><li>子网掩码；</li><li>默认路由器的 IP 地址；</li><li>域名服务器的 IP 地址。</li></ol></li><li>互联网现在广泛使用的是<strong>动态主机配置协议</strong> DHCP，它提供了一种机制，称为<strong>即插即用连网</strong>。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。</li><li>DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。DHCP 给运行服务器软件而位置固定的计算机指派一个永久地址，而当这计算机重新启动时其地址不改变。</li><li>DHCP 使用客户服务器方式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送<strong>发现报文</strong> (将目的 IP 地址置为全 1，即 255.255.255.255)，这时该主机就成为 DHCP 客户。发送广播报文是因为现在还不知道 DHCP 服务器在什么地方，因此要发现 (DISCOVER) DHCP服务器的 IP 地址。这台主机目前还没有自己的 IP 地址，因此它将 IP 数据报的源 IP 地址设为全 0。这样，在本地网络上的所有主机都能够收到这个广播报文，但只有 DHCP 服务器才对此广播报文进行回答。DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做<strong>提供报文</strong>，表示“提供”了 IP 地址等配置信息。</li><li>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>，但并没有具体规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。</li></ul><h1 id="6-7-简单网络管理协议-SNMP"><a href="#6-7-简单网络管理协议-SNMP" class="headerlink" title="6.7 简单网络管理协议 SNMP"></a>6.7 简单网络管理协议 SNMP</h1><h2 id="6-7-1-网络管理的基本概念"><a href="#6-7-1-网络管理的基本概念" class="headerlink" title="6.7.1 网络管理的基本概念"></a>6.7.1 网络管理的基本概念</h2><ul><li><strong>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等。网络管理常简称为网管。</strong></li><li>网络是一个非常复杂的分布式系统。因为网络上有很多不同厂家生产的、运行着多种协议的结点，而这些结点还在相互通信和交换信息。</li><li>网络管理的一般模型<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812181706.png"></li><li><strong>管理站</strong>又称为<strong>管理器</strong>，是整个网络管理系统的核心，它通常是个有着良好图形界面的高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理站发出的。管理站的所在部门也常称为<strong>网络运行中心</strong> NOC。管理站中的关键构件是<strong>管理程序</strong> (如图 6-21 中有字母 M 的椭圆形图标所示)。管理程序在运行时就成为<strong>管理进程</strong>。管理站 (硬件) 或管理程序 (软件) 都可称为<strong>管理者</strong>或<strong>管理器</strong>，所以这里的 manager 不是指人而是指机器或软件。网络管理员才是指人。大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的设备。</li><li>在被管网络中有很多的<strong>被管设备</strong> (包括设备中的软件)。被管设备可以是主机、路由器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多<strong>被管对象</strong>。被管对象可以是被管设备中的某个硬件，也可以是某些硬件或软件 (例如，路由选择协议) 的配置参数的集合。被管设备有时可称为网络<strong>元素</strong>或简称为<strong>网元</strong>。在被管设备中也会有一些<strong>不能被管的对象</strong>。</li><li><strong>简单网络管理协议</strong> SNMP 中的管理程序和代理程序按客户服务器方式工作。管理程序运行 SNMP <strong>客户程序</strong>，而代理程序运行 SNMP <strong>服务器程序</strong>。在被管对象上运行的 SNMP 服务器程序不停地监听来自管理站的 SNMP 客户程序的请求 (或命令)。一旦发现了，就立即返回管理站所需的信息，或执行某个动作。在网管系统中往往是一个 (或少数几个) 客户程序与很多的服务器程序进行交互。</li><li><strong>若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有对象的影响必须尽量小些。</strong></li></ol></li><li>SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。在网络正常工作时，SNMP 可实现统计、配置和测试等功能。当网络出故障时，可实现各种差错检测和恢复功能。</li><li>若网络元素使用的不是 SNMP 协议而是另一种网络管理协议，那么 SNMP 协议就无法控制该网络元素。这时可使用<strong>委托代理</strong>，委托代理能提供如协议转换和过滤操作等功能对被管对象进行管理。</li><li>SNMP 的网络管理由三个部分组成，SNMP 本身、<strong>管理信息结构</strong> SMI 和<strong>管理信息库</strong> MIB。<ol><li>SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象 (变量) 名及其状态 (值)。SNMP 负责读取和改变这些数值。</li><li>SMI 定义了命名对象和定义对象类型 (包括范围和长度) 的<strong>通用规则</strong>，以及把对象和对象的值进行<strong>编码的规则</strong>。这样做是为了确保网络管理数据的语法和语义无二义性。但从 SMI 的名称并不能看出它的功能。</li><li>MIB 在被管理的实体中创建了命名对象，并规定了其类型。</li></ol></li></ul><h2 id="6-7-2-管理信息结构-SMI"><a href="#6-7-2-管理信息结构-SMI" class="headerlink" title="6.7.2 管理信息结构 SMI"></a>6.7.2 管理信息结构 SMI</h2><ul><li><strong>管理信息结构</strong> SMI 是 SNMP 的重要组成部分，SMI 的功能应当有三个：<ol><li>被管对象应怎样命名；</li><li>用来存储被管对象的数据类型有哪些；</li><li>在网络上传送的管理数据应如何编码。</li></ol></li><li><strong>被管对象的命名</strong><ol><li>SMI 规定，所有的被管对象都必须处在<strong>对象命名树</strong>上。图 6-22 给出了对象命名树的一部分。对象命名树的根没有名字，它的下面有三个顶级对象，都是世界上著名的标准制定单位，即 ITU-T，ISO，以及这两个组织的联合体，它们的标号分别是 0 到 2。在 ISO 的下面的一个标号为 3 的节点是 ISO 认同的的组织成员 org。在其下面有一个美国国防部 dod 的子树 (标号为 6)，再下面就是 internet (标号为 1)。在 internet 节点下面的标号为 2 的节点是 mgmt。再下面只有一个节点，即管理信息库 mib-2，其对象标识符为 1.3.6.1.2.1。在 mib-2 下面包含了所有被 SNMP 管理的对象。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182130.png"></li></ul></li></ol></li><li><strong>被管对象的数据类型</strong><ol><li>SMI 使用基本的<strong>抽象语法记法</strong> 1 (即 ISO 制定的 ASN.1) 来定义数据类型，但又增加了一些新的定义。因此 SMI 既是 ASN.1 的子集，又是 ASN.1 的超集。ASN.1 的记法很严格，它使得数据的含义不存在任何可能的二义性。</li><li>SMI 把数据类型分为两大类：<strong>简单类型和结构化类型</strong>。简单类型是最基本的、直接使用 ASN.1 定义的类型。表 6-4 给出了最主要的几种简单类型。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182253.png"></li></ul></li><li>SMI 定义了两种结构化数据类型，即 sequence 和 sequence of。</li></ol></li><li><strong>编码方法</strong><ol><li>SMI 使用 ASN.1 制定的<strong>基本编码规则</strong> BER 进行数据的编码。BER 指明了每种数据的类型和值。在发送端用 BER 编码，可把用 ASN.1 所表述的报文转换成唯一的比特序列。在接收端用 BER 进行解码，就可得到该比特序列所表示的 ASN.1 报文。</li><li>ASN.1 把所有的数据元素都表示为 T-L-V 三个字段组成的序列 (见图 6-23)。T 字段 (Tag) <strong>定义数据的类型</strong> ，L 字段 (Length) 定义 V <strong>字段的长度</strong> ，而 V 字段 (Value) <strong>定义数据的值</strong>。<ul><li>T 字段又叫做<strong>标记字段</strong> ，占 1 字节。T 字段比较复杂，因为它要定义的数据类型较多。T 字段又再分为以下三个子字段：<ol><li><strong>类别</strong> (2 位) 共四种：通用类 (00)，即 ASN.1 定义的类型；应用类 (01)，即 SMI 定义的类型；上下文类 (10)，即上下文所定义的类型；专用类 (11)，保留为特定厂商定义的类型。</li><li><strong>格式</strong> (1 位) 共两种，指出数据类型的种类：简单数据类型 (0)，结构化数据类型 (1)。</li><li><strong>编号</strong> (5 位) 用来标志不同的数据类型。编号的范围一般为 0～30。当编号大于 30 时，T 字段就要扩展为多个字节。</li></ol></li><li>L 字段又叫做<strong>长度字段</strong> (单字节或多字节)。当 L 字段为单字节时，其最高位为 0，后面的 7 位定义 V 字段的长度。当 L 字段为多个字节时，其最高位为 1，而后面的 7 位定义后续字节的字节数 (用二进制整数表示)。这时，所有的后续字节并置起来的二进制整数定义 V 字段的长度。</li><li>V 字段又叫做<strong>值字段</strong>，用于定义数据元素的值。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182351.png"></li></ul></li></ol></li></ul><h2 id="6-7-3-管理信息库-MIB"><a href="#6-7-3-管理信息库-MIB" class="headerlink" title="6.7.3 管理信息库 MIB"></a>6.7.3 管理信息库 MIB</h2><ul><li><strong>管理信息</strong>就是指在互联网的网管框架中<strong>被管对象的集合</strong>。被管对象必须维持可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚拟的信息存储器，所以才称为<strong>管理信息库</strong> MIB。管理程序就使用 MIB 中这些信息的<strong>值</strong>对网络进行管理 (如读取或重新设置这些值)。只有在 MIB 中的对象才是 SNMP 所能够管理的。</li></ul><h2 id="6-7-4-SNMP-的协议数据单元和报文"><a href="#6-7-4-SNMP-的协议数据单元和报文" class="headerlink" title="6.7.4 SNMP 的协议数据单元和报文"></a>6.7.4 SNMP 的协议数据单元和报文</h2><ul><li>SNMP 的功能通过探询操作来实现，即 SNMP 管理进程定时向被管理设备周期性地发送探询信息。探询的好处是：<ol><li>使系统相对简单</li><li>能限制通过网络所产生的管理信息的通信量。但探询管理协议不够灵活，而且所能管理的设备数目不能太多。探询系统的开销也较大。</li></ol></li><li>SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为<strong>陷阱</strong>，表示它能够捕捉“事件”。但这种陷阱信息的参数是受限制的。</li><li>当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达到某些门限值的事件 (这就叫做<strong>过滤</strong>)。这种方法的好处是：<ol><li>仅在严重事件发生时才发送陷阱；</li><li>陷阱信息很简单且所需字节数很少。</li></ol></li><li>SNMP 使用无连接的 UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保证可靠交付的。</li><li>和大多数 TCP&#x2F;IP 协议不一样，SNMP 报文没有固定的字段。它们使用标准 ASN.1 编码。因此，SNMP 报文用人工进行编码和理解时都比较困难。</li><li>SNMP 的报文格式<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812213115.png"></li><li>一个SNMP 报文共由四个部分组成，即<strong>版本、首部、安全参数</strong>和 SNMP 报文的<strong>数据部分</strong>。首部包括报文标识、最大报文长度、报文标志。报文标志占 1 字节，其中的每一位定义安全类型或其他信息。安全参数用来产生报文摘要。</li><li>在 SNMP PDU 前面还有两个有关加密信息的字段。这是当数据部分需要加密时才使用的两个字段。与网络管理直接相关的是后面的 SNMP PDU 部分。由 PDU <strong>类型、请求</strong> ID、<strong>差错状态、差错索引</strong>以及<strong>变量绑定</strong>这几个字段组成。</li><li>简单介绍一下其他字段的作用：<ul><li><strong>请求标识符</strong>　由管理进程设置的 4 字节整数值。代理进程在发送响应报文时也要返回此请求标识符。由于管理进程可同时向许多代理发出请求读取变量值的报文，因此设置了请求标识符可使管理进程能够识别返回的响应是对应于哪一个请求报文。</li><li><strong>差错状态</strong>　在请求报文中，这个字段是零。当代理进程响应时，就填入 0～18 中的一个数字。例如 0 表示 noError，1 表示 tooBig，2 表示 noSuchName，3 表示badValue。</li><li><strong>差错索引</strong>　在请求报文中，这个字段是零。当代理进程响应时，若出现 noSuchName，badValue 或 readOnly 的差错，代理进程就设置一个整数，指明有差错的变量在变量列表中的偏移。</li><li><strong>变量绑定</strong>　指明一个或多个变量的名和对应的值。在请求报文中，变量的值应忽略 (类型是 NULL)。</li></ul></li></ol></li></ul><h1 id="6-8-应用进程跨越网络的通信"><a href="#6-8-应用进程跨越网络的通信" class="headerlink" title="6.8 应用进程跨越网络的通信"></a>6.8 应用进程跨越网络的通信</h1><h2 id="6-8-1-系统调用和应用编程接口"><a href="#6-8-1-系统调用和应用编程接口" class="headerlink" title="6.8.1 系统调用和应用编程接口"></a>6.8.1 系统调用和应用编程接口</h2><ul><li>当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口。此接口再把控制权传递给计算机的操作系统。操作系统把这个调用转给某个内部过程，并执行所请求的操作。内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程。总之，只要应用进程需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执行必要的操作后把控制权返回给应用进程。因此，系统调用接口实际上是应用进程的控制权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为<strong>应用编程接口</strong> API。API <strong>从程序设计的角度</strong>定义了许多标准的系统调用函数。应用进程只要使用标准的系统调用函数就可得到操作系统的服务。因此从程序设计的角度看，也可以把 API 看成是应用程序和操作系统之间的接口。</li><li>在套接字以上的进程是受应用程序控制的，而在套接字以下的运输层协议软件则是受计算机操作系统的控制。因此，只要应用程序使用 TCP&#x2F;IP 协议进行通信，它就必须通过套接字与操作系统交互 (这就要使用系统调用函数) 并请求其服务。</li></ul><h2 id="6-8-2-几种常用的系统调用"><a href="#6-8-2-几种常用的系统调用" class="headerlink" title="6.8.2 几种常用的系统调用"></a>6.8.2 几种常用的系统调用</h2><ul><li><strong>连接建立阶段</strong></li><li><strong>数据传送阶段</strong></li><li><strong>连接释放阶段</strong></li></ul><h1 id="6-9-P2P应用"><a href="#6-9-P2P应用" class="headerlink" title="6.9 P2P应用"></a>6.9 P2P应用</h1><h2 id="6-9-1-具有集中目录服务器-P2P-工作方式"><a href="#6-9-1-具有集中目录服务器-P2P-工作方式" class="headerlink" title="6.9.1 具有集中目录服务器 P2P 工作方式"></a>6.9.1 具有集中目录服务器 P2P 工作方式</h2><ul><li>集中式目录服务器的最大缺点就是可靠性差，而且会成为其性能的瓶颈 (尤其是在用户数非常多的情况下)。</li></ul><h2 id="6-9-2-具有全分布式结构的P2P文件共享程序"><a href="#6-9-2-具有全分布式结构的P2P文件共享程序" class="headerlink" title="6.9.2 具有全分布式结构的P2P文件共享程序"></a>6.9.2 具有全分布式结构的P2P文件共享程序</h2><h2 id="6-9-3-P2P文件分发的分析"><a href="#6-9-3-P2P文件分发的分析" class="headerlink" title="6.9.3 P2P文件分发的分析"></a>6.9.3 P2P文件分发的分析</h2><h2 id="6-9-4-在-P2P-对等方中搜索对象"><a href="#6-9-4-在-P2P-对等方中搜索对象" class="headerlink" title="6.9.4 在 P2P 对等方中搜索对象"></a>6.9.4 在 P2P 对等方中搜索对象</h2><ul><li>在 P2P 文件系统中，对等方用户的数量非常多，并且处于一种无序的状态。任何一个对等方可以随时加入进来或随时退出。在这种情况下，怎样有效地找到所需的文件，也就是怎样有效地定位对等方及其资源，是 P2P 系统中重要的问题。</li><li>现在广泛使用的索引和查找技术叫做<strong>分布式散列表</strong> DHT。DHT 也可译为分布式哈希表，它是由大量对等方共同维护的散列表。</li><li>分布式散列表 DHT 利用散列函数，把资源名 K 及其存放的结点 IP 地址 N 都分别映射为<strong>资源名标识符</strong> KID 和<strong>结点标识符</strong> NID。</li><li>为了加速查找，在 Chord 环上可以增加一些<strong>指针表</strong>，它又称为<strong>路由表</strong>或<strong>查找器表</strong>。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所遵循的协议。应用层的许多协议都是基于客户服务器方式的。客户是服务请求方，服务器是服务提供方。</p></li><li><p>域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。DNS 是一个联机分布式数据库系统，并采用客户服务器方式。</p></li><li><p>域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序 (即域名服务器) 共同完成的。</p></li><li><p>互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制 IP 地址中的点没有关系。</p></li><li><p>域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。</p></li><li><p>文件传送协议 FTP 使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接。实际用于传输文件的是数据连接。</p></li><li><p>万维网 WWW 是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网上的一个站点链接到另一个站点。</p></li><li><p>万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在客户程序主窗口上显示出的万维网文档称为页面。</p></li><li><p>万维网使用统一资源定位符 URL 来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</p></li><li><p>万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议 HTTP。HTTP 使用 TCP 连接进行可靠的传送。但 HTTP 协议本身是无连接、无状态的。HTTP&#x2F;1.1 协议使用了持续连接 (分为非流水线方式和流水线方式)。</p></li><li><p>万维网使用超文本标记语言 HTML 来显示各种万维网页面。</p></li><li><p>万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。</p></li><li><p>活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。</p></li><li><p>在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索搜索引擎和分类目录搜索引擎两大类。</p></li><li><p>电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取，相当于“电子信箱”。</p></li><li><p>一个电子邮件系统有三个主要组成构件，即：用户代理、邮件服务器，以及邮件协议 (包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP)。用户代理和邮件服务器都要运行这些协议。</p></li><li><p>电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的视窗界面来发送和接收邮件。</p></li><li><p>从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送，都要使用 SMTP 协议。但用户代理从邮件服务器读取邮件时，则要使用 POP3 (或 IMAP) 协议。</p></li><li><p>基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏览器和邮件服务器之间的邮件传送使用 HTTP 协议，而在邮件服务器之间邮件的传送仍然使用 SMTP 协议。</p></li><li><p>简单网络管理协议 SNMP 由三部分组成：</p><ol><li>SNMP 本身，负责读取和改变各代理中的对象名及其状态数值</li><li>管理信息结构 SMI，定义命名对象和定义对象类型 (包括范围和长度) 的通用规则，以及把对象和对象的值进行编码的基本编码规则 BER</li><li>管理信息库 MIB，在被管理的实体中创建了命名对象，并规定了其类型。</li></ol></li><li><p>系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称为应用编程接口 API。API 是应用程序和操作系统之间的接口。</p></li><li><p>套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。</p></li><li><p>目前 P2P 工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应用所占的比例大得多。</p></li><li><p>BT 是很流行的一种 P2P 应用。BT 采用“最稀有的优先”的技术，可以尽早把最稀有的文件块收集到。此外，凡有当前以最高数据率向某个对等方传送文件块的相邻对等方，该对等方就优先把所请求的文件块传送给这些相邻对等方。这样做的结果是，这些对等方相互之间都能够以令人满意的速率交换文件块。</p></li><li><p>当对等方的数量很大时，采用 P2P 方式下载大文件，要比传统的客户−服务器方式快得多。</p></li><li><p>在 P2P 应用中，广泛使用的索引和查找技术是分布式散列表 DHT。</p></li><li><p>域名系统的主要功能是什么？域名系统中的根域名服务器、顶级域名服务器、权限域名服务器以及本地域名服务器有何区别？</p><blockquote><p>域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。<br>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析 (即转换为 IP 地址)，只要自己无法解析，就首先要求助于根域名服务器。域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。在域名系统中使用了层次结构的许多域名服务器。<br>顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答 (可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址)。一个服务器所负责管辖的 (或有权限的) 范围叫做区。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。<br>权限域名服务器是负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。<br>本地域名服务器离用户较近，一般不超过几个路由器的距离。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。当所要查询的主机也属于同一个本地 ISP 时，该本地域名服务器立即就能将所查询的主机名转换为它的 IP 地址，而不需要再去询问其他的域名服务器。</p></blockquote></li><li><p>简单文件传送协议 TFTP 与文件传送协议 FTP 的主要区别是什么？应用在什么场合？</p><blockquote><p>简单文件传送协议 TFTP 是一个很小且易于实现的文件传送协议。虽然 TFTP 也使用客户服务器方式，但它使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。FTP 使用 TCP 传送数据，因而是很可靠的。但正因如此，FTP 比 TFTP 复杂得多。TFTP 只支持文件传输而不支持交互。TFTP 有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。<br>TFTP 的主要优点有两个: (1) TFTP 可用于 UDP 环境；(2) TFTP 代码所占的内存较小。<br>TFTP 的工作很像停止等待协议。发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。发完数据后在规定时间内收不到确认就要重发数据 PDU。发送确认 PDU 的一方，若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。当我们只需要复制一个文件而不需要 FTP 协议的功能时，就只需要一个能够迅速复制这些文件的协议，TFTP 就是一个很好的选择。<br><strong>复杂性</strong>：TFTP 是一种非常简单的文件传输协议，功能相对有限。它设计简单，只支持文件的读写操作，没有目录列表、权限管理等高级功能；FTP 是一个功能更为丰富和复杂的协议。它支持文件上传、下载、删除、重命名等操作，同时提供目录列表、权限管理、登录认证等多种功能。<br><strong>设计</strong>：TFTP 的设计目标是轻量级和简单，它使用 UDP 进行通信，没有建立连接的过程，因此具有低开销但也更容易受到网络中断等问题的影响；FTP 是一个基于 TCP 的协议，它建立连接后进行通信，具有更为可靠的传输机制，但相对来说会有更多的开销。<br><strong>安全性</strong>：TFTP 在安全性方面较为薄弱，没有提供加密和身份验证机制，传输的数据是明文的，容易受到中间人攻击；FTP 的安全性相对更强，支持加密和登录认证，可以更好地保护数据传输的隐私和完整性。<br><strong>TFTP</strong>：由于其简单性，TFTP 通常用于一些特定的场景，如在内部网络中进行配置文件的传输、嵌入式设备的固件升级等。<br><strong>FTP</strong>：FTP 适用于更复杂的文件传输需求，例如，Web 开发中文件上传、下载，或者在服务器之间进行文件的备份和同步等。<br>总体来说，TFTP 适用于简单的、对复杂性和安全性要求不高的文件传输场景，而 FTP 适用于更为复杂和安全要求较高的文件传输场景。</p></blockquote></li><li><p>DHCP 协议用在什么情况下？当一台计算机第一次运行引导程序时，其 ROM 中有没有该主机的 IP 地址、子网掩码，或某个域名服务器的 IP 地址？</p><blockquote><p>动态主机配置协议 DHCP 提供了即插即用连网机制。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。因此，每当一台计算机加入到一个新的网络时就需要运行 DHCP 协议来获取这台计算机的 IP 地址。<br>当一台计算机第一次运行引导程序时，ROM 中并没有该计算机的 IP 地址、子网掩码或某个域名服务器的 IP 地址的任何一个。</p></blockquote></li><li><p>SNMP 协议使用 UDP 传送报文，为什么不使用 TCP？</p><blockquote><p>SNMP 使用无连接的 UDP (要发送数据时不需要有连接建立过程，数据发送完毕后，也不需要连接释放过程)，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保证可靠交付的，有丢失的可能。好在 SNMP 使用周期性地发送探询报文段的方法，来对网络资源进行实时监视，如果丢失了一个探寻报文，则经过一段时间后，会再发送一个。这样就比使用 TCP 要快速得多。</p></blockquote></li><li><p>FTP 的一些基础问题：</p><blockquote><p>控制连接先于数据连接被建立，并晚于数据连接被释放；<br>控制连接的端口号是 21；数据连接的端口号是 20；<br>匿名 FTP 访问通常使用 anonymous 作为用户名；</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 运输层</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-5-zhang-yun-shu-ceng/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-5-zhang-yun-shu-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-运输层协议概述"><a href="#5-1-运输层协议概述" class="headerlink" title="5.1 运输层协议概述"></a>5.1 运输层协议概述</h1><h2 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1 进程之间的通信"></a>5.1.1 进程之间的通信</h2><ul><li><strong>运输层向应用层提供通信服务</strong>，属于面向通信部分的最高层、用户功能中的最低层。当网络边缘部分中的两台主机使用网络核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时只用到下三层的功能。</li><li>进行通信的实体是主机中的进程，是主机中的一个<strong>进程</strong>和另一台主机中的一个<strong>进程</strong>交换数据。两台主机进行通信就是两台主机中的<strong>应用进程互相通信</strong>。IP 协议虽然能把分组送到目的主机，但是分组还停留在主机的网络层，没有交付主机中的应用进程。从运输层的角度看，<strong>通信的真正端点不是主机，而是主机中的进程</strong>。<strong>端到端的通信</strong>是应用进程之间的通信。</li><li>运输层有个重要功能：<strong>复用</strong>和<strong>分用</strong>。复用指在<strong>发送方</strong>不同的应用进程可以使用同一个运输层协议传送数据，分用指<strong>接收方</strong>的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</li><li><strong>运输层提供应用进程间的逻辑通信</strong>。逻辑通信的意思是：从应用层来看，只要把应用层报文交给运输层，运输层就可以把这报文传送到对方的运输层，<strong>好像这种通信就是沿水平方向直接传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接</strong>。</li><li><strong>网络层为主机之间提供逻辑通信，运输层为应用进程之间提供端到端的逻辑通信</strong>。</li><li>根据应用程序的不同需求，运输层有不同的运输协议，即<strong>面向连接的 TCP</strong> 和<strong>无连接的 UDP</strong>。</li><li><strong>运输层向高层用户屏蔽了下面网络核心的细节，使应用进程看见的是，好像在两个运输层实体之间有一条端到端的逻辑通信信道</strong>。当运输层<strong>采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的</strong>，但这种逻辑通信信道就相当于<strong>一条全双工的可靠信道</strong>。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条<strong>不可靠信道</strong>。</li></ul><h2 id="5-1-2-运输层的两个主要协议"><a href="#5-1-2-运输层的两个主要协议" class="headerlink" title="5.1.2 运输层的两个主要协议"></a>5.1.2 运输层的两个主要协议</h2><ul><li>TCP&#x2F;IP 运输层的两个主要协议即：<ol><li><strong>用户数据报协议</strong> UDP</li><li><strong>传输控制协议</strong> TCP</li></ol></li><li>图 5-3 给出了这两种协议在协议栈中的位置。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807163232.png"></li></ol></li><li>在 TCP&#x2F;IP 体系中，根据所使用的协议是 TCP 或 UDP，分别称之为 <strong>TCP 报文段</strong>或 <strong>UDP 用户数据报</strong></li><li>UDP 在传送数据之前<strong>不需要先建立连接</strong>。远地主机的运输层在收到 UDP 报文后，不需要回复。即使不提供可靠交付，但在某些情况下 UDP 仍是一种有效的工作方式。</li><li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此增加许多开销。使得协议数据单元的首部增大很多，占用许多的处理机资源。</li><li>表 5-1 给出了一些应用和应用层协议主要使用的运输层协议 (UDP 或 TCP)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807163339.png"></li></ol></li></ul><h2 id="5-1-3-运输层的端口"><a href="#5-1-3-运输层的端口" class="headerlink" title="5.1.3 运输层的端口"></a>5.1.3 运输层的端口</h2><ul><li><strong>复用</strong>：应用层的应用进程数据可以通过运输层再传送到网络层 (IP 层)。<strong>分用</strong>：运输层从网络层收到发送给各应用进程的数据后，必须分别交付指明的各应用进程。</li><li>进程的创建和撤销是动态的，通信的一方几乎无法识别对方机器上的进程。需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程是哪一个。</li><li>通信的终点是应用进程，只要把需要传送的报文交到目的主机某个合适的目的端口，剩下的工作就由 TCP 或 UDP 来完成。</li><li><strong>在协议栈层间的抽象的协议端口是软件端口</strong>。硬件端口是<strong>不同硬件设备</strong>进行交互的接口，而<strong>软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址</strong>。</li><li>当运输层收到 IP 层交上来的运输层报文时，能够根据首部中的目的端口号把数据交付应用层的目的应用进程。</li><li><strong>端口号只具有本地意义</strong>，是为了标志<strong>本计算机</strong>应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是<strong>没有关联</strong>的。</li><li>两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址 (为了找到对方的计算机)，而且要知道对方的端口号 (为了找到对方计算机中的应用进程)。</li><li>运输层的端口号分为下面的两大类：<ol><li><strong>服务器端使用的端口号</strong> 　<ul><li>最重要的一类叫<strong>熟知端口号</strong>或<strong>系统端口号</strong>，数值为 0~1023。IANA 把这些端口号指派给了 TCP&#x2F;IP 最重要的一些应用程序，让所有的用户都知道。当一种新的应用程序出现后，IANA 必须为它指派一个熟知端口，否则互联网上的其他应用进程就无法和它进行通信；</li><li>另一类叫做<strong>登记端口</strong>号，数值为 1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在 IANA 按照规定的手续登记，以防止重复。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231219144155.png"></li></ul></li><li><strong>客户端使用的端口号</strong>，数值为 49152～65535。这类端口号仅在客户进程运行时才动态选择，又叫<strong>短暂端口号</strong>。这类端口号留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已使用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。</li></ol></li></ul><h1 id="5-2-用户数据报协议-UDP"><a href="#5-2-用户数据报协议-UDP" class="headerlink" title="5.2 用户数据报协议 UDP"></a>5.2 用户数据报协议 UDP</h1><h2 id="5-2-1-UDP-概述"><a href="#5-2-1-UDP-概述" class="headerlink" title="5.2.1 UDP 概述"></a>5.2.1 UDP 概述</h2><ul><li>用户数据报协议 UDP 在 IP 的数据报服务之上增加了复用、分用以及差错检测的功能。UDP 的主要特点是：<ol><li>UDP 是<strong>无连接的</strong>，即发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。</li><li>UDP 使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li><li>UDP <strong>面向报文</strong>。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文，如图 5-4 所示。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。UDP 一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，会降低 IP 层的效率。若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，降低了 IP 层的效率。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181018.png"></li></ul></li><li>UDP <strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用 (如 IP 电话、实时视频会议等) 要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但不允许数据有太大的时延。</li><li>UDP <strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li>UDP <strong>的首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li></ol></li></ul><h2 id="5-2-2-UDP-的首部格式"><a href="#5-2-2-UDP-的首部格式" class="headerlink" title="5.2.2 UDP 的首部格式"></a>5.2.2 UDP 的首部格式</h2><ul><li>用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段很简单，只有 8 个字节 (图 5-5)，由四个字段组成，<strong>每个字段的长度都是两字节</strong> 。各字段意义如下：<ol><li><strong>源端口</strong> 　源端口号。在需要对方回信时选用。不需要时可用全 0。</li><li><strong>目的端口</strong> 　目的端口号。这在终点交付报文时必须使用。</li><li><strong>长度</strong> 　UDP 用户数据报的长度，其最小值是 8 (仅有首部)。</li><li><strong>检验和</strong> 　检测 UDP 用户数据报在传输中是否有错。有错就丢弃。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181355.png"></li></ol></li><li>当运输层从 IP 层收到 UDP 数据报时，根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程。图 5-6 是 UDP 基于端口分用的示意图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181414.png"></li></ol></li><li>如果接收方 UDP 发现收到的报文中的目的端口号不正确，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。</li><li>虽然在 UDP 之间的通信要用到端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字 (TCP 之间的通信必须要在两个套接字之间建立连接)。</li><li>UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。但 IP 数据报的检验和只检验 IP 数据报的首部，UDP 的检验和是<strong>把首部和数据部分一起都检验</strong>。在发送方，首先把全零放入检验和字段。再把伪首部以及 UDP 用户数据报看成是由许多 16 位的字串接起来的。若 UDP 用户数据报的数据部分不是偶数个字节，则要填入一个全零字节 (但此字节不发送)。然后按二进制反码计算出这些 16 位字的和。将此和的二进制反码写入检验和字段后，就发送这样的 UDP 用户数据报。在接收方，把收到的 UDP 用户数据报连同伪首部 (以及可能的填充全零字节) 一起，按二进制反码求这些 16 位字的和。当无差错时其结果应为全 1。否则就表明有差错出现，接收方就应丢弃这个 UDP 用户数据报 (也可以上交给应用层，但附上出现了差错的警告)。图 5-7 给出了一个计算 UDP 检验和的例子。这里假定用户数据报的长度是 15 字节，因此要添加一个全 0 的字节。这种简单的差错检验方法的检错能力并不强，但它的好处是简单，处理起来较快。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181600.png"></li></ol></li></ul><h1 id="5-3-传输控制协议-TCP-概述"><a href="#5-3-传输控制协议-TCP-概述" class="headerlink" title="5.3 传输控制协议 TCP 概述"></a>5.3 传输控制协议 TCP 概述</h1><h2 id="5-3-1-TCP-最主要的特点"><a href="#5-3-1-TCP-最主要的特点" class="headerlink" title="5.3.1 TCP 最主要的特点"></a>5.3.1 TCP 最主要的特点</h2><ul><li>TCP 的主要特点：<ol><li>TCP 是<strong>面向连接的运输层协议</strong>。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。</li><li>每一条 TCP 连接只能有两个端点，只能是点对点的 (一对一)。</li><li>TCP 提供<strong>可靠交付</strong>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li><li>TCP 提供<strong>全双工通信</strong>。允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序只需要把数据传送给 TCP 的缓存，TCP 把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层的应用进程读取缓存中的数据。</li><li><strong>面向字节流</strong>。TCP 中的“流”指的是<strong>流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块 (大小不等)，但 TCP 把应用程序交下来的数据仅仅看成一连串的<strong>无结构的字节流</strong>。并不知道所传送的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。</li></ol></li><li>TCP 和 UDP 在发送报文时采用的方式不同。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段包含多少个字节 (UDP 发送的报文长度是应用进程给出的)。如果应用进程传送到 TCP 缓存的数据块太长，TCP 就把它划分短一些再传送。如果应用进程一次只发来一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li></ul><h2 id="5-3-2-TCP-的连接"><a href="#5-3-2-TCP-的连接" class="headerlink" title="5.3.2 TCP 的连接"></a>5.3.2 TCP 的连接</h2><ul><li>TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是运输层的协议端口，而是<strong>套接字</strong>或<strong>插口</strong>。</li><li><strong>每一条 TCP 连接唯一地被通信两端的两个端点 (即两个套接字) 所确定</strong>。即：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807210504.png"></li><li>IP<sub>1</sub> 和 IP<sub>2</sub> 分别是两个端点主机的 IP 地址，而 port<sub>1</sub> 和 port<sub>2</sub> 分别是两个端点主机中的端口号。TCP 连接的两个套接字就是 socket<sub>1</sub> 和 socket<sub>2</sub>。</li></ol></li><li><strong>TCP 连接的端点是个抽象的套接字</strong>，即 (<strong>IP地址：端口号</strong> )。同一个 IP 地址可以有多个不同的 TCP 连接，同一个端口号也可以出现在多个不同的 TCP 连接中。</li><li><strong>socket 表示多种不同的意思</strong>。例如：<ol><li>允许应用程序访问连网协议的应<strong>用编程接口 API</strong>，即运输层和应用层之间的一种接口，称为 socket API，并简称为 socket。</li><li>在 socket API 中使用的一个<strong>函数名</strong>也叫做 socket。</li><li>调用 socket 函数的<strong>端点</strong>称为 socket，如“创建一个数据报 socket”。</li><li>调用 socket 函数时，其<strong>返回值</strong>称为 socket 描述符，可简称为 socket。</li><li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket <strong>实现</strong>。</li></ol></li></ul><h1 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4 可靠传输的工作原理"></a>5.4 可靠传输的工作原理</h1><ul><li>理想的传输条件有以下特点：<ol><li>传输信道不产生差错。</li><li>接收方总是来得及处理收到的数据。</li></ol></li></ul><h2 id="5-4-1-停止等待协议"><a href="#5-4-1-停止等待协议" class="headerlink" title="5.4.1 停止等待协议"></a>5.4.1 停止等待协议</h2><ul><li><strong>无差错情况</strong><ol><li>停止等待协议可用图 5-9 来说明。图 5-9(a) 是最简单的无差错情况。A 发送分组 M<sub>1</sub> ，发完暂停，等待 B 确认。B 收到了 M<sub>1</sub> 就向 A 发送确认。A 在收到了对确认后，就再发送下一个分组 M<sub>2</sub>。同样，在收到 B 确认后，再发送M<sub>3</sub>。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808145722.png"></li></ul></li></ol></li><li><strong>出现差错</strong><ol><li>图 5-9(b) 是分组在传输过程中出现差错的情况。B 接收 M<sub>1</sub> 时检测出了差错，丢弃 M<sub>1</sub>，其他什么也不做。这种情况下，B 不会发送任何信息。可靠传输协议是这样设计的：A 只要超过了一段时间没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</li><li>注意以下三点。<ul><li>A 在发送完一个分组后，<strong>必须保留已发送的分组的副本</strong>。只有在收到相应的确认后才能清除保留的分组副本。</li><li>分组和确认分组都必须进行**编号。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li><li>超时计时器设置的重传时间<strong>应当比数据在分组传输的平均往返时间更长一些</strong>。图 5-9(b) 中的一段虚线表示如果 M<sub>1</sub> 正确到达 B 同时 A 也正确收到确认的过程。重传时间应设定为比平均往返时间更长一些。如果重传时间设定得很长，那么通信的效率会很低。但如果重传时间设定得太短，以致产生不必要的重传，就浪费了网络资源。然而，在运输层重传时间的准确设定是非常复杂的，这是因为已发送出的分组到底会<strong>经过哪些网络</strong>，以及这些网络将会<strong>产生多大的时延</strong> (这取决于这些网络<strong>当时的拥塞情况</strong>)，这些都是<strong>不确定因素</strong>。</li></ul></li></ol></li><li><strong>确认丢失和确认迟到</strong><ol><li>图 5-10(a) 说明的是另一种情况。B 所发送的对 M<sub>1</sub> 的确认丢失了。A 在设定的超时重传时间内没有收到确认，无法知道是自己发送的分组出错、丢失，或者是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M<sub>1</sub>。假定 B 又收到了重传的分组 M<sub>1</sub><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150213.png"></li></ul></li><li>这时应采取两个行动：<ul><li><strong>丢弃这个重复的分组</strong> M<sub>1</sub>，不向上层交付。</li><li><strong>向 A 发送确认</strong>。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M<sub>1</sub> 就表示 A 没有收到对 M<sub>1</sub> 的确认。</li></ul></li><li>图 5-10(b) 也是一种可能出现的情况。传输过程中没有出现差错，但 B 对分组 M<sub>1</sub> 的确认迟到了。A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。B 仍然会收到重复的 M<sub>1</sub> ，并且同样要丢弃重复的 M<sub>1</sub>，并重传确认分组。</li></ol></li><li><strong>信道利用率</strong><ol><li>停止等待协议的优点是简单，缺点是信道利用率太低。可以用图 5-11 来说明这个问题。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150800.png"></li></ul></li><li>假定 A 发送分组需要的时间是 T<sub>D</sub>。T<sub>D</sub> 等于分组长度除以数据率。再假定分组正确到达 B 后，B 处理分组的时间忽略不计，同时立即发回确认。假定 B 发送确认分组需要时间 T<sub>A</sub>。如果 A 处理确认分组的时间也忽略不计，那么 A 在经过时间 (T<sub>D</sub>＋RTT＋T<sub>A</sub>) 后就可以再发送下一个分组，这里的 RTT 是往返时间。因为仅仅是在时间 T<sub>D</sub> 内才用来传送有用的数据 (包括分组的首部)，因此信道的利用率 U 可用下式计算：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150820.png"></li></ul></li><li>为了提高传输效率，发送方不使用低效率的停止等待协议，采用<strong>流水线传输</strong> (如图 5-12 所示)。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。这种传输方式可以获得很高的信道利用率。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151106.png"></li></ul></li></ol></li></ul><h2 id="5-4-2-连续-ARQ-协议"><a href="#5-4-2-连续-ARQ-协议" class="headerlink" title="5.4.2 连续 ARQ 协议"></a>5.4.2 连续 ARQ 协议</h2><ul><li>图 5-13(a) 表示发送方维持的<strong>发送窗口</strong>，表示位于发送窗口内的 5 个分组可连续发送出去，不需要等待对方的确认。提高了信道利用率。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151146.png"></li></ol></li><li>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。图 5-13(b) 表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。</li><li>接收方采用<strong>累积确认</strong>的方式，<strong>对按序到达的最后一个分组发送确认</strong>。</li><li>累积确认有优点也有缺点：<ol><li>优点是容易实现，即使确认丢失也不必重传。</li><li>缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。</li></ol></li></ul><h1 id="5-5-TCP-报文段的首部格式"><a href="#5-5-TCP-报文段的首部格式" class="headerlink" title="5.5 TCP 报文段的首部格式"></a>5.5 TCP 报文段的首部格式</h1><ul><li>TCP 面向字节流，但 TCP 传送的数据单元却是报文段。</li><li>一个 TCP 报文段分为首部和数据两部分。</li><li>TCP 报文段首部的前 20 个字节是固定的 (图 5-14)，后面有 4<em>n</em> 字节是根据需要而增加的选项。因此 TCP 首部的最小长度是 20 字节。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151426.png"></li></ol></li><li>首部固定部分各字段的意义如下：<ol><li><strong>源端口和目的端口</strong> 　各占 2 个字节，分别写入源端口号和目的端口号。</li><li><strong>序号</strong> 　占 4 字节。序号范围是［0，2<sup>32</sup>–1］，共 2<sup>32</sup> (即4 294 967 296) 个序号。序号增加到 2<sup>32</sup>–1 后，下一个序号就又回到 0。使用 mod 2<sup>32</sup> 运算。在一个 TCP 连接中传送的字节流中的<strong>每一个字节都按顺序编号</strong>。整个要传送的字节流的起始序号在连接建立时设置。首部中的序号字段值则指的是<strong>本报文段</strong>所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是 301，而携带的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。字段的名称也叫做“<strong>报文段序号</strong>”。</li><li><strong>确认号</strong> 　占 4 字节，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。例如，B 收到 A 发来的一个报文段，其序号字段值是 501，而数据长度是 200 字节 (序号 501～700)，这表明 B 收到到序号 700 为止的数据。因此，B 期望收到的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。若确认号＝<em>N</em>，则表明：到序号 <em>N</em>–1 为止的所有数据都已正确收到。</li><li><strong>数据偏移</strong> 　占 4 位，指出 TCP 报文段的首部长度。“数据偏移”的单位是 4 字节 (即以 32 位字为计算单位)。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度 (即选项长度不能超过 40 字节)。</li><li><strong>保留</strong> 　占 6 位，保留为今后使用，但目前应置为 0。</li><li><strong>紧急</strong> URG　当 URG＝1 时，紧急指针字段有效，发送应用进程告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。这时要与首部中<strong>紧急指针</strong>字段配合使用。</li><li><strong>确认</strong> ACK　当 ACK＝1 时确认号字段有效。当 ACK＝0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li>(x) <strong>推送</strong> PSH　当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 使用推送操作。这时，发送方 TCP 把 PSH 置 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH＝1 的报文段，就尽快地交付接收应用进程，不再等到整个缓存都填满了后再向上交付。</li><li><strong>复位</strong> RST　当 RST＝1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接。RST 置 1 还用来拒绝一个非法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位。</li><li><strong>同步</strong> SYN　在连接建立时用来同步序号。当 SYN＝1 而 ACK＝0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使  SYN＝1 和 ACK＝1。因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。</li><li><strong>终止</strong> FIN　用来释放一个连接。当 FIN＝1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li><li><strong>窗口</strong> 　占 2 字节。窗口值是［0，2<sup>16</sup>–1］之间的整数。窗口指的是发送本报文段的一方的<strong>接收窗口</strong>。窗口值<strong>告诉对方</strong> ：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量 (以字节为单位)。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<strong>窗口值作为接收方让发送方设置其发送窗口的依据</strong>。窗口字段明确指出了现在允许对方发送的数据量，经常动态变化。</li><li>(x) <strong>检验和</strong> 　占 2 字节。检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式与图 5-5 中 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的17 改为 6 (TCP 的协议号是 6)，把第 5 字段中的 UDP 长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。</li><li>(x) <strong>紧急指针</strong> 　占 2 字节。紧急指针仅在 URG＝1 时才有意义，它指出本报文段中的紧急数据的字节数 (紧急数据结束后就是普通数据)。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。</li><li><strong>选项</strong> 　长度可变，最长可达 40 字节。</li></ol></li><li>TCP 最初只规定了一种选项，即<strong>最大报文段长度</strong> MSS。MSS 是每一个 TCP 报文段中的<strong>数据字段的最大长度</strong>。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以 MSS 并不是整个 TCP 报文段的最大长度，而是“TCP 报文段长度减去 TCP 首部长度”。</li><li>随着互联网的发展，又增加了<strong>窗口扩大</strong>选项、<strong>时间戳</strong>选项、<strong>选择确认</strong>选项。<ol><li>窗口扩大选项<ul><li>窗口扩大选项是为了扩大窗口。TCP 首部中窗口字段长度是 16 位，因此最大的窗口大小为 64K 字节。</li><li>窗口扩大选项占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数从 16 增大到 (16＋S) 。移位值允许使用的最大值是 14，相当于窗口最大值增大到 2<sup>(16+14)</sup>–1＝2<sup>30</sup> –1。</li><li>窗口扩大选项可以在双方初始建立 TCP 连接时进行协商。如果接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送 S＝0 的选项，使窗口大小回到 16。</li></ul></li><li>时间戳选项<ul><li><strong>时间戳</strong>选项占 10 字节，最主要的字段是<strong>时间戳</strong>值字段 (4 字节) 和<strong>时间戳回送回答</strong>字段 (4 字节)。时间戳选项有以下两个功能：<ol><li>用来计算往返时间 RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出 RTT 来。</li><li>用于处理 TCP 序号超过 2<sup>32</sup> 的情况，又称<strong>防止序号绕回</strong> PAWS。TCP 报文段的序号只有 32 位，而每增加 2<sup>32</sup> 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次 TCP 连接的数据传送中序号很可能会被重复使用。</li></ol></li></ul></li></ol></li></ul><h1 id="5-6-TCP-可靠传输的实现"><a href="#5-6-TCP-可靠传输的实现" class="headerlink" title="5.6 TCP 可靠传输的实现"></a>5.6 TCP 可靠传输的实现</h1><h2 id="5-6-1-以字节为单位的滑动窗口"><a href="#5-6-1-以字节为单位的滑动窗口" class="headerlink" title="5.6.1 以字节为单位的滑动窗口"></a>5.6.1 以字节为单位的滑动窗口</h2><ul><li>TCP 的滑动窗口以字节为单位。假定 A 收到了 B <strong>发来</strong>的确认报文段，其中窗口是 20 字节，而确认号是 31 (这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了)。根据这两个数据，A 就构造出自己的发送窗口，如图 5-15 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808160923.png"></li></ol></li><li>A 发送窗口表示：在没有收到 B 的确认的情况下，A 可以把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。</li><li>发送窗口里面的序号表示允许发送的序号。窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，获得更高的传输效率。接收方会把自己的接收窗口数值放在窗口字段中发送给对方，A 的发送窗口一定不能超过 B 的接收窗口数值。</li><li>发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据不需要保留。而发送窗口前沿的前面部分表示不允许发送的，因为接收方没有为这部分数据保留临时存放的缓存空间。</li><li>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动 (没有收到新的确认) 和前移 (收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：一是没有收到新的确认，对方通知的窗口大小也不变；二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。</li><li>发送窗口前沿也有可能<strong>向后收缩</strong>。这发生在接收方的接收窗口缩小了。但 TCP 的标准<strong>强烈不赞成这样做</strong>。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。</li><li>发送方的应用进程把字节流写入 TCP 的发送缓存，接收方的应用进程从 TCP 的接收缓存中读取字节流。图 5-19 画出了发送方维持的发送缓存和发送窗口，以及接收方维持的接收缓存和接收窗口。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808161130.png"></li><li>图 5-19(a) 所示的发送方的情况，发送缓存用来暂时存放：<ul><li>发送应用程序传送给发送方 TCP 准备发送的数据</li><li>TCP 已发送出但尚未收到确认的数据</li></ul></li><li>图 5-19(b) 所示的接收方的情况，接收缓存用来暂时存放：<ul><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>未按序到达的数据。</li></ul></li></ol></li><li>强调以下三点：<ol><li>虽然 A 的发送窗口是根据 B 的接收窗口设置的，但在同一时刻，A 的发送窗口并不总是和 B 的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后。</li><li>对于不按序到达的数据如何处理，TCP 标准并无明确规定。如果接收方把不按序到达的数据丢弃，那么接收窗口的管理会比较简单，但这样做对网络资源的利用不利。因此 TCP 通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<strong>按序交付上层的应用进程</strong>。</li><li>TCP 要求接收方必须有累积确认的功能，减小传输开销。接收方可以在合适时发送确认，也可以在自己有数据要发送时把确认信息顺便<strong>捎带</strong>上。注意两点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认。二是捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ol></li><li>TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。</li></ul><h2 id="5-6-2-超时重传时间的选择"><a href="#5-6-2-超时重传时间的选择" class="headerlink" title="5.6.2 超时重传时间的选择"></a>5.6.2 超时重传时间的选择</h2><ul><li>由于 TCP 的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个 IP 数据报所选择的路由可能不同。如果把超时重传时间设置得太短，会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则使网络的空闲时间增大，降低了传输效率。</li><li>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。两个时间之差就是<strong>报文段的往返时间 RTT</strong>。TCP 保留了 RTT 的一个<strong>加权平均往返时间</strong> RTT<sub>S</sub> (又称为平滑的往返时间，S 表示 Smoothed)。每当第一次测量到 RTT 样本时，RTT<sub>S</sub> 值就取为所测量到的 RTT 样本值。但以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTT<sub>S</sub>：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162046.png"></li></ol></li><li>在上式中，0≤α&lt;1。若 α 很接近于零，表示新的 RTT<sub>S</sub> 值和旧的 RTT<sub>S</sub> 值相比变化不大，而对新的 RTT 样本影响不大 (RTT 值更新较慢)。若选择 α 接近于 1，则表示新的 RTT<sub>S</sub> 值受新的 RTT 样本的影响较大 (RTT 值更新较快)。</li><li>超时计时器设置的<strong>超时重传时间</strong> RTO 应略大于上面得出的加权平均往返时间 RTT<sub>S</sub> 。RFC 6298 建议使用下式计算 RTO：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162104.png"></li></ol></li><li>RTT<sub>D</sub> 是 RTT 的<strong>偏差</strong>的加权平均值，它与 RTT<sub>S</sub> 和新的 RTT 样本之差有关。RFC 6298 建议这样计算 RTT<sub>D</sub>。当第一次测量时，RTT<sub>D</sub> 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTT<sub>D</sub>：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162116.png"></li></ol></li><li>如图 5-20 所示，发送出一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段。经过了一段时间后，收到了确认报文段。现在的问题是：<strong>如何判定此确认报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认</strong>。由于重传的报文段和原来的报文段完全一样，因此源主机在收到确认后，就无法做出正确的判断，而正确的判断对确定加权平均 RTT<sub>S</sub> 的值关系很大。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162135.png"></li><li>若收到的确认是对重传报文段的确认，却被源主机当成是对原来的报文段的确认，则这样计算出的 RTT<sub>S</sub> 和超时重传时间 RTO 就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间 RTO 就越来越长；同样，若收到的确认是对原来的报文段的确认，但被当成是对重传报文段的确认，则由此计算出的RTT<sub>S</sub> 和 RTO 都会偏小。这就必然导致报文段过多地重传使，RTO 越来越短。</li><li>Karn 提出了一个算法：<strong>在计算加权平均 RTT<sub>S</sub> 时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均 RTT<sub>S</sub> 和 RTO 就较准确</strong>。</li><li>但是，这又引起新的问题：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</li><li>因此要对 Karn 算法进行修正。方法是：报文段每重传一次，就把超时重传时间 RTO 增大一些。典型的做法是取新的重传时间为旧的重传时间的 2 倍。当不再发生报文段的重传时，才根据上面给出的 (5-5) 式计算超时重传时间。</li><li>Karn 算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返时间的估测，使计算结果更加合理。</li></ol></li></ul><h2 id="5-6-3-选择确认-SACK"><a href="#5-6-3-选择确认-SACK" class="headerlink" title="5.6.3 选择确认 SACK"></a>5.6.3 选择确认 SACK</h2><ul><li><strong>选择确认</strong>的工作原理。TCP 的接收方在接收对方发送过来的数据字节流的序号不连续时会形成一些不连续的字节块 (如图 5-21 所示)。序号 1～1000 收到了，但序号 1001～1500 没有收到。接下来的字节流又收到了，缺少了 3001～3500。再后面从序号 4501 起又没有收到。接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162315.png"></li><li>从图 5-21 可看出，与前后字节不连续的每一个字节块都有两个边界：左边界和右边界。因此在图中用四个指针标记这些边界。第一个字节块的左边界 L<sub>1</sub> ＝1501，右边界 R<sub>1</sub> ＝3001 而不是 3000。左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。同理，第二个字节块的左边界 L<sub>2</sub> ＝3501，而右边界 R<sub>2</sub> ＝4501。</li></ol></li></ul><h1 id="5-7-TCP-的流量控制"><a href="#5-7-TCP-的流量控制" class="headerlink" title="5.7 TCP 的流量控制"></a>5.7 TCP 的流量控制</h1><h2 id="5-7-1-利用滑动窗口实现流量控制"><a href="#5-7-1-利用滑动窗口实现流量控制" class="headerlink" title="5.7.1 利用滑动窗口实现流量控制"></a>5.7.1 利用滑动窗口实现流量控制</h2><ul><li><strong>流量控制</strong>就是<strong>让发送方的发送速率不要太快，让接收方来得及接收</strong>。</li><li><strong>发送方的发送窗口不能超过接收方给出的接收窗口的数值</strong>。</li><li>TCP 的<strong>窗口单位是字节，不是报文段</strong>。</li><li>TCP 为每一个连接设有一个<strong>持续计时器</strong>。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</li></ul><h2 id="5-7-2-TCP-的传输效率"><a href="#5-7-2-TCP-的传输效率" class="headerlink" title="5.7.2 TCP 的传输效率"></a>5.7.2 TCP 的传输效率</h2><ul><li>用不同的机制来控制 TCP 报文段的发送时机：<ol><li>TCP 维持一个等于<strong>最大报文段长度</strong> MSS 的变量。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即 TCP 支持的<strong>推送</strong>操作。</li><li>发送方的一个计时器期限到了时，就把当前已有的缓存数据装入报文段 (但长度不能超过MSS) 发送出去。</li></ol></li><li>在 TCP 的实现中广泛使用 Nagle 算法。算法如下：<ol><li>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。</li><li>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。</li><li>只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，可明显地减少所用的网络带宽。</li><li>当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段，可以有效地提高网络的吞吐量。</li></ol></li><li><strong>糊涂窗口综合征</strong>，有时会使 TCP 的性能变坏。当 TCP 接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取 1 个字节 (这样就使接收缓存空间仅腾出 1 个字节)，然后向发送方发送确认，并把窗口设置为 1 个字节 (但发送的数据报是 40 字节长)。接着，发送方又发来 1 个字节的数据 (请注意，发送方发送的 IP 数据报是 41 字节长)。接收方发回确认，仍然将窗口设置为 1 个字节。这样进行下去，使网络的效率很低。</li><li>解决糊涂窗口综合征需要<strong>让接收方等待一段时间</strong>，使得接收缓存已有足够空间容纳一个最长的报文段，或者<strong>等到接收缓存已有一半空闲的空间</strong>。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</li></ul><h1 id="5-8-TCP-的拥塞控制"><a href="#5-8-TCP-的拥塞控制" class="headerlink" title="5.8 TCP 的拥塞控制"></a>5.8 TCP 的拥塞控制</h1><h2 id="5-8-1-拥塞控制的一般原理"><a href="#5-8-1-拥塞控制的一般原理" class="headerlink" title="5.8.1 拥塞控制的一般原理"></a>5.8.1 拥塞控制的一般原理</h2><ul><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>。可以把出现网络拥塞的条件写成如下的关系式：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809093124.png"></li></ol></li><li>若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</li><li>网络拥塞由许多因素引起：<ol><li>当某个结点缓存的容量太小时，到达该结点的分组因无存储空间暂存而不得不被丢弃。</li><li>由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数分组的排队等待时间将会大大增加，上层软件只能重传。</li><li>处理机处理的速率太慢可能引起网络的拥塞。</li><li>拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次，导致更多的分组流入网络和被网络中的路由器丢弃。</li></ol></li><li><strong>拥塞控制防止过多的数据注入到网络中，使网络中的路由器或链路不致过载</strong>。拥塞控制要做的有一个前提，就是<strong>网络能够承受现有的网络负荷</strong>。拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。但 TCP 连接的端点只要迟迟不能收到对方的确认信息，就猜想在当前网络中的某处很可能发生了拥塞，但无法知道拥塞到底发生在网络的何处，也无法知道发生拥塞的具体原因。</li><li><strong>流量控制往往指点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题 (接收端控制发送端)。流量控制所要做的就是抑制发送端发送数据的速率，使接收端来得及接收。</li><li>进行拥塞控制需要付出代价。首先需要获得网络内部流量分布的信息。在实施拥塞控制时，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制，产生了额外开销。拥塞控制有时需要将一些资源 (如缓存、带宽等) 分配给个别用户单独使用，使得网络资源不能更好地实现共享。</li><li>拥塞控制所起的作用<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809093722.png"></li></ul><ol><li>在图 5-23 中的横坐标是<strong>提供的负载</strong>，代表单位时间内输入给网络的分组数目。因此提供的负载也称为<strong>输入负载</strong>或<strong>网络负载</strong>。纵坐标是<strong>吞吐量</strong>，代表单位时间内从网络输出的分组数目。</li><li>具有理想拥塞控制的网络，在吞吐量饱和之前，网络吞吐量应等于提供的负载，故吞吐量曲线是 45° 的斜线。但当提供的负载超过某一限度时，由于网络资源受限，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了。</li><li>实际网络的情况就很不相同了。从图 5-23 可看出，随着提供的负载的增大，网络吞吐量的增长速率逐渐减小。也就是说，在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了。当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了<strong>轻度拥塞</strong>的状态。更值得注意的是，当提供的负载达到某一数值时，网络的吞吐量反而随提供的负载的增大而下降，这时<strong>网络就进入了拥塞状态</strong>。当提供的负载继续增大到某一数值时，网络的吞吐量就下降到零，网络已无法工作，这就是所谓的<strong>死锁</strong>。</li></ol></li><li>从原理上讲，寻找拥塞控制的方案是寻找使不等式 (5-7) 不再成立的条件。或者是增大网络的某些可用资源，或减少一些用户对某些资源的需求。</li><li>开环控制是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正。</li><li>闭环控制是基于反馈环路的概念，主要有以下几种措施：<ol><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>把拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ol></li><li>过于频繁地采取行动以缓和网络的拥塞，会使系统产生不稳定的振荡。但过于迟缓地采取行动又不具有任何实用价值。</li></ul><h2 id="5-8-2-TCP-的拥塞控制方法"><a href="#5-8-2-TCP-的拥塞控制方法" class="headerlink" title="5.8.2 TCP 的拥塞控制方法"></a>5.8.2 TCP 的拥塞控制方法</h2><ul><li>TCP 进行拥塞控制的算法有四种，<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。</li><li>发送方维持一个叫<strong>拥塞窗口</strong> cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。</li><li>发送方<strong>控制拥塞窗口</strong>的原则：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</li><li><strong>慢开始</strong>算法的思路：当主机开始发送数据时，由于并不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，可能引起网络发生拥塞。应该<strong>由小到大逐渐增大发送窗口，由小到大逐渐增大拥塞窗口数值</strong>。</li><li>旧的规定是这样的：在刚刚开始发送报文段时，先把初始拥塞窗口 cwnd 设置为 1 至 2 个发送方的最大报文段 SMSS 的数值，但新的 RFC 5681 把初始拥塞窗口 cwnd 设置为不超过 2 至 4 个 SMSS 的数值。具体的规定如下：<ol><li>若 SMSS&gt;2190 字节，则设置初始拥塞窗口 cwnd＝2×SMSS 字节，且<strong>不得超过 2 个报文段。</strong></li><li>若 SMSS&gt;1095 字节 且 SMSS≤2190 字节，则设置初始拥塞窗口 cwnd＝3×SMSS 字节，且<strong>不得超过</strong> 3 个报文段。</li><li>若 SMSS≤1095 字节，则设置初始拥塞窗口 cwnd＝4×SMSS 字节，且<strong>不得超过</strong> 4 个报文段。</li></ol></li><li>慢开始规定，在每收到一个<strong>对新的报文段的确认</strong>后，可以把拥塞窗口增加最多一个 SMSS 的数值。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102613.png"></li><li>其中 <em>N</em> 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。</li></ol></li><li>在一开始发送方先设置 cwnd＝1，发送第一个报文段 M<sub>1</sub>，接收方收到后确认 M<sub>1</sub>。发送方收到对 M<sub>1</sub> 的确认后，把 cwnd 从 1 增大到 2，于是发送方接着发送 M<sub>2</sub> 和 M<sub>3</sub> 两个报文段。接收方收到后发回对 M<sub>2</sub> 和 M<sub>3</sub> 的确认。发送方每收到一个<strong>对新报文段的确认</strong>就使发送方的拥塞窗口加 1，因此发送方在收到两个确认后，cwnd 就从 2 增大到 4，并可发送 M<sub>4</sub>～M<sub>7</sub> 共 4 个报文段 (见图 5-24)。因此使用慢开始算法后，<strong>每经过一个传输轮次</strong>，<strong>拥塞窗口</strong> cwnd <strong>就加倍</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102703.png"></li></ol></li><li>传输<strong>轮次</strong>。从图 5-24 可以看出，一个传输轮次所经历的时间就是往返时间 RTT。使用“传输轮次”是强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。例如，拥塞窗口 cwnd 的大小是 4 个报文段，那么这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这4个报文段的确认，总共经历的时间。</li><li>为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限</strong> ssthresh 状态变量。慢开始门限 ssthresh 的用法如下：<ol><li>当 cwnd&lt;ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd&gt;ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd&#x3D;ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ol></li><li><strong>拥塞避免</strong>算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“<strong>加法增大</strong>”AI 的特点。这表明在拥塞避免阶段，拥塞窗口 cwnd <strong>按线性规律缓慢增长</strong>，比慢开始算法的拥塞窗口增长速率缓慢得多。</li><li>采用快重传算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>。快重传算法要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了<strong>失序的报文段</strong>也要立即发出对已收到的报文段的重复确认。</li><li>快重传算法规定，发送方只要<strong>一连收到 3 个重复确认</strong>，就知道接收方确实没有收到报文段 M<sub>3</sub>，因而应当<strong>立即进行重传</strong> (即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约 20％。</li><li>TCP 的拥塞控制可以归纳为图 5-27 的流程图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102925.png"></li></ol></li><li>接收方的缓存空间有限，根据自己的接收能力设定了接收方窗口 rwnd，并把这个窗口值写入 TCP 首部中的窗口字段，传送给发送方。因此，<strong>接收方窗口</strong>又称为<strong>通知窗口</strong>。因此，从接收方对发送方的流量控制的角度考虑，<strong>发送方的发送窗口一定不能超过对方给出的接收方窗口值</strong> rwnd。</li><li>如果把拥塞控制和接收方对发送方的流量控制一起考虑，那么发送方的窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，也就是说：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809103014.png"></li><li>当 rwnd&lt;cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</li><li>当 cwnd&lt;rwnd 时，则是网络的拥塞程度限制发送方窗口的最大值。</li><li>rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。</li></ol></li></ul><h2 id="5-8-3-主动队列管理-AQM"><a href="#5-8-3-主动队列管理-AQM" class="headerlink" title="5.8.3 主动队列管理 AQM"></a>5.8.3 主动队列管理 AQM</h2><ul><li>网络层的策略对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。在最简单的情况下，路由器的队列通常都是按照“<strong>先进先出</strong>” FIFO 的规则处理到来的分组。由于队列长度有限，因此当队列已满时，以后再到达的所有分组将都被丢弃，这叫<strong>尾部丢弃策略</strong>。</li><li>路由器的尾部丢弃会导致一连串分组的丢失，使发送方出现超时重传、TCP 进入拥塞控制的慢开始状态，使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。更为严重的是，在网络中通常有很多的 TCP 连接，这些连接中的报文段通常是复用在网络层的 IP 数据报中传送。在这种情况下，若发生了路由器中的尾部丢弃，可能会同时影响到很多条 TCP 连接，使许多 TCP 连接<strong>在同一时间</strong>突然都进入到慢开始状态。这在 TCP 的术语中称为<strong>全局同步</strong>。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</li><li>为了避免发生网络中的全局同步现象，提出了<strong>主动队列管理</strong> AQM。所谓“主动”是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。应当在队列长度达到某个值得警惕的数值时 (即当网络拥塞有了某些拥塞征兆时)，就主动丢弃到达的分组。这样就提醒了发送方放慢发送的速率，可能使网络拥塞的程度减轻，甚至不出现网络拥塞。</li><li>实现<strong>随机早期检测</strong> RED 时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED 就按照规定的算法先计算当前的平均队列长度。<ol><li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。</li><li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li><li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率 <em>p</em> 把新到达的分组丢弃 (这就体现了丢弃分组的随机性)。</li></ol></li><li>RED 不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，而是在检测到网络拥塞的<strong>早期征兆</strong>时 (即路由器的平均队列长度达到一定数值时)，就以概率 <em>p</em> 丢弃个别的分组，让拥塞控制只在个别的 TCP 连接上进行，因而避免发生全局性的拥塞控制。</li></ul><h1 id="5-9-TCP-的运输连接管理"><a href="#5-9-TCP-的运输连接管理" class="headerlink" title="5.9 TCP 的运输连接管理"></a>5.9 TCP 的运输连接管理</h1><ul><li>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此，运输连接就有三个阶段，即：<strong>连接建立、数据传送和连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</li><li>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做<strong>客户</strong>，而被动等待连接建立的应用进程叫做<strong>服务器</strong>。</li></ul><h2 id="5-9-1-TCP-的连接建立"><a href="#5-9-1-TCP-的连接建立" class="headerlink" title="5.9.1 TCP 的连接建立"></a>5.9.1 TCP 的连接建立</h2><ul><li>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。图 5-28 画出了三报文握手建立 TCP 连接的过程。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809153847.png"></li><li>A 的 TCP 客户进程也是首先创建<strong>传输控制模块</strong> TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN＝1，同时选择一个初始序号 seq＝x。TCP 规定，SYN 报文段(即 SYN＝1 的报文段) 不能携带数据，但要<strong>消耗掉一个序号</strong>。这时，TCP 客户进程进入 SYN-SENT (同步已发送) 状态。</li><li>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack＝x＋1，同时也为自己选择一个初始序号 seq＝y。请注意，这个报文段也不能携带数据，但同样<strong>要消耗掉一个序号</strong>。这时 TCP 服务器进程进入 SYN-RCVD (同步收到) 状态。</li><li>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack＝y＋1，而自己的序号 seq＝x＋1。TCP 的标准规定，ACK 报文段可以携带数据。但<strong>如果不携带数据则不消耗序号</strong>，在这种情况下，下一个数据报文段的序号仍是 seq＝x＋1。这时，TCP 连接已经建立，A 进入 ESTABLISHED (已建立连接) 状态。</li><li>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。</li></ol></li></ul><h2 id="5-9-2-TCP-的链接释放"><a href="#5-9-2-TCP-的链接释放" class="headerlink" title="5.9.2 TCP 的链接释放"></a>5.9.2 TCP 的链接释放</h2><ul><li>数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于 ESTABLISHED 状态 (图 5-29)。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq＝u，它等于前面已传送过的数据的最后一个字节的序号加 1。这时 A 进入 FIN-WAIT-1 (终止等待 1)状态，等待 B 的确认。TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_%7B5BE8DB9C-8B4F-4d08-93E2-9B2367E7A0F0%7D.png">图 5-29</li><li>B 收到连接释放报文段后即发出确认，确认号是 ack＝u＋1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。然后 B 就进入 CLOSE-WAIT (关闭等待) 状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于<strong>半关闭</strong>状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。</li><li>A 收到来自 B 的确认后，就进入 FIN-WAIT-2 (终止等待2) 状态，等待 B 发出的连接释放报文段。</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN＝1。假定 B 的序号为 w (在半关闭状态 B 可能又发送了一些数据)。B 还必须重复上次已发送过的确认号 ack＝u＋1。这时 B 就进入 LAST-ACK (最后确认) 状态，等待 A 的确认。</li><li>A 在收到 B 的连接释放报文段后，对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack＝w＋1，而自己的序号是 seq＝u＋1 (根据 TCP 标准，前面发送过的 FIN 报文段要消耗一个序号)。然后进入到 TIME-WAIT (时间等待) 状态。现在 TCP 连接还没有释放掉。必须经过<strong>时间等待计时器</strong>设置的时间 2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做<strong>最长报文段寿命</strong>。从 A 进入到 TIME-WAIT 状态后，要经过 4 分钟才能进入到 CLOSED 状态，才能开始建立下一个新的连接。当 A 撤销相应的传输控制块 TCB 后，就结束了 TCP 连接。</li></ol></li></ul><h2 id="5-9-3-TCP-的有限状态机"><a href="#5-9-3-TCP-的有限状态机" class="headerlink" title="5.9.3 TCP 的有限状态机"></a>5.9.3 TCP 的有限状态机</h2><ul><li>为了更清晰地看出 TCP 连接的各种状态之间的关系，图 5-30 给出了 TCP 的有限状态机。图中每一个方框即 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。图中有三种不同的箭头，粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，另一种细线箭头表示异常变迁。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_%7B4FCAAF4F-C6ED-46fa-ADF1-31A8D0D139AF%7D.png"></li></ol></li></ul><h1 id="本章重要概念"><a href="#本章重要概念" class="headerlink" title="本章重要概念"></a>本章重要概念</h1><ul><li><p>运输层提供应用进程间的逻辑通信，运输层之间的通信并不是真正在两个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节 (如网络拓扑、所采用的路由选择协议等)，使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p></li><li><p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</p></li><li><p>运输层有两个主要的协议：TCP 和 UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的 (只提供尽最大努力服务)，但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。</p></li><li><p>运输层用一个 16 位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。</p></li><li><p>两台计算机中的进程要互相通信，不仅要知道对方的 IP 地址 (为了找到对方的计算机)，而且还要知道对方的端口号 (为了找到对方计算机中的应用进程)。</p></li><li><p>运输层的端口号分为服务器端使用的端口号 (0～1023 指派给熟知端口，1024～49151 是登记端口号) 和客户端暂时使用的端口号 (49152～65535)。</p></li><li><p>UDP 的主要特点是：</p><ol><li>无连接；</li><li>尽最大努力交付；</li><li>面向报文；</li><li>无拥塞控制；</li><li>支持一对一、一对多、多对一和多对多的交互通信；</li><li>首部开销小 (只有四个字段：源端口、目的端口、长度、检验和)。</li></ol></li><li><p>TCP 的主要特点是：</p><ol><li>面向连接；</li><li>每一条 TCP 连接只能是点对点的 (一对一)；</li><li>提供可靠交付的服务；</li><li>提供全双工通信；</li><li>面向字节流。</li></ol></li><li><p>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字 (socket) 或插口。套接字用 (IP地址：端口号) 来表示。</p></li><li><p>停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组，分组需要进行编号。</p></li><li><p>超时重传指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p></li><li><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，同时还要发送确认。</p></li><li><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已正确收到了。</p></li><li><p>TCP 报文段首部的前 20 个字节是固定的，后面有 4<em>N</em> 字节是根据需要而增加的选项。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。</p></li><li><p>TCP 首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 <em>N</em>，则表明：到序号 <em>N</em>-1 为止的所有数据都已正确收到。</p></li><li><p>TCP 首部中的窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着的。</p></li><li><p>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动 (没有收到新的确认) 和前移 (收到了新的确认)。发送窗口前沿通常是不断向前移动的。</p></li><li><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p></li><li><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</p></li><li><p>流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p></li><li><p>为了进行拥塞控制，TCP 的发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p></li><li><p>TCP 的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网络层，也可以使路由器采用适当的分组丢弃策略 (如主动队列管理 AQM)，以减少网络拥塞的发生。</p></li><li><p>运输连接有三个阶段，即连接建立、数据传送和连接释放。</p></li><li><p>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 的连接建立采用三报文握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。</p></li><li><p>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后就进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接。</p></li><li><p>为什么说 UDP 面向报文，TCP 面向字节流？</p><blockquote><p>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP 一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。反之，若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。<br>(1) UDP 被称为”面向报文”的协议，因为它将数据视为独立的报文，而不是连续的字节流。每个 UDP 报文都是一个独立的数据包，UDP 对报文的处理是原封不动地发送和接收，不保证它们的顺序，也不提供重传机制。每个 UDP 报文都是一个独立的实体，它们之间没有关联。<br>UDP 适用于一些实时性要求高、可以容忍一些数据丢失的应用场景，比如实时音视频传输、在线游戏等。<br>(2) TCP 则被称为”面向字节流”的协议，因为它将数据视为一个连续的字节流，而不是离散的报文。TCP 负责将应用层的数据划分为合适的数据块，然后将这些数据块封装为 TCP 报文段进行传输。在接收端，TCP 会负责重组这些字节流，确保按顺序交付给应用层。<br>TCP 提供了可靠的、面向连接的服务，通过序列号和确认机制保证数据的可靠传输，并能够处理数据的重传、流量控制和拥塞控制等问题。<br>TCP 适用于对数据可靠性和顺序性要求较高的应用，比如文件传输、网页访问等。</p></blockquote></li><li><p>为什么 UDP 首部中没有首部长度字段，而 TCP 首部中却有？</p><blockquote><p>UDP 数据报首部长度是固定的，不需要这个字段。<br>TCP 报文段除了固定长度的首部之外，还有选项字段，因此 TCP 报文段的首部长度是可变的。(TCP 报文段的首部长度字段就是“数据偏移”)</p></blockquote></li><li><p>流量控制与拥塞控制的主要区别是什么？发送窗口的大小取决于流量控制还是拥塞控制</p><blockquote><p>简单地说，流量控制是在一条 TCP 连接中的接收端采用的措施，用来限制对方 (发送端) 发送报文段的速率，以免在接收端来不及接收。流量控制只控制一个发送端。<br>拥塞控制是用来控制 TCP 连接中发送端发送报文段的速率，以免使互联网中的某处产生过载。拥寒控制可能会同时控制许多个发送端，限制它们的发送速率。不过每一个发送端只知道自己应当怎样调整发送速率，而不知道在互联网中还有哪些主机被限制了发送速率。<br>发送窗口的上限值是 Min[rwnd,cwnd]，即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个。接收窗口的大小体现了接收端对发送端施加的流量控制，而拥寨窗口的大小则是整个互联网的负载情况对发送端施加的拥寒控制。因此，当接收窗口小于拥塞窗口时，发送窗口的大小取决于流量控制，即取决于接收端的接收能力。但当拥塞窗口小于接收窗口时，则发送窗口的大小取决于拥塞控制，即取决于整个网络的拥塞状况。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 网络层</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-4-zhang-wang-luo-ceng/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-4-zhang-wang-luo-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h1><ul><li><strong>表4-1　虚电路服务与数据报服务的对比</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722192206.png"></li></ol></li></ul><h1 id="4-2-网际协议-IP"><a href="#4-2-网际协议-IP" class="headerlink" title="4.2 网际协议 IP"></a>4.2 网际协议 IP</h1><ul><li>网际协议 IP 是 TCP&#x2F;IP 体系中两个主要的协议之一，也是最重要的互联网标准协议之一。</li><li>与 IP 协议配套使用的还有三个协议：<ol><li><strong>地址解析协议 ARP</strong></li><li><strong>网际控制报文协议 ICMP</strong></li><li><strong>网际组管理协议 IGMP</strong></li></ol></li><li>图 4-2 画出了这三个协议和网际协议 IP 的关系。这一层中，ARP 画在最下面，因为 IP 经常使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722193402.png"></li></ol></li><li>网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP&#x2F;IP 体系中的网络层常常被称为<strong>网际层</strong>或 <strong>IP 层</strong>。</li></ul><h2 id="4-2-1-虚拟互连网络"><a href="#4-2-1-虚拟互连网络" class="headerlink" title="4.2.1 虚拟互连网络"></a>4.2.1 虚拟互连网络</h2><ul><li>用户的需求是多种多样的，<strong>没有一种单一的网络能够适应所有用户的需求</strong>。</li><li>将网络互相连接起来要使用<strong>中间设备</strong>。根据中间设备所在的层次，有以下不同的中间设备: <ol><li>物理层使用的中间设备叫做<strong>转发器</strong>。</li><li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>。</li><li>网络层使用的中间设备叫做<strong>路由器</strong>。</li><li>在网络层以上使用的中间设备叫做<strong>网关</strong>。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li></ol></li><li>图 4-3 (a) 表示有许多计算机网络通过路由器进行互连。由于参加互连的计算机网络都使用相同的<strong>网际协议</strong> IP，因此可以把互连以后的计算机网络看成如图 4-3 (b) 所示的一个<strong>虚拟互连网络</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722193637.png"></li></ol></li><li>利用 IP 协议可以使性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。</li><li>使用 IP 网的好处是: 当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节。</li><li>在图 4-4 所示的互联网中的源主机 H<sub>1</sub> 要把一个 IP 数据报发送给目的主机 H<sub>2</sub>。根据分组交换存储转发概念，主机 H<sub>1</sub> 先查找自己的路由表，看目的主机是否在本网络上。如在，则<strong>直接交付</strong>。如不在，则必须把 IP 数据报发送给某个路由器 (图中的 R<sub>1</sub>)。R<sub>1</sub> 在查找路由表后，知道应当把数据报转发给 R<sub>2</sub> 进行<strong>间接交付</strong>。这样一直转发下去，最后路由器 R<sub>5</sub> 和 H<sub>2</sub> 连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报<strong>直接交付</strong>目的主机 H<sub>2</sub>。图中画出了源主机、目的主机以及各路由器的协议栈。主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向 (用黑色粗线表示)。在 R<sub>4</sub> 和 R<sub>5</sub> 之间使用了卫星链路，R<sub>5</sub> 所连接的是个无线局域网。在 R<sub>1</sub> 到 R<sub>4</sub> 之间的三个网络则可以是任意类型的网络。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723110729.png"></li></ol></li><li><strong>互联网可以由多种异构网络互连组成</strong>。</li></ul><h2 id="4-2-2-分类的-IP-地址"><a href="#4-2-2-分类的-IP-地址" class="headerlink" title="4.2.2 分类的 IP 地址"></a>4.2.2 分类的 IP 地址</h2><ul><li><strong>IP 地址及其表示方法</strong><ol><li>互联网是一个<strong>单一的、抽象的网络</strong>。IP 地址是给互联网上的每台主机 (或路由器) 的每个接口分配一个在全世界范围唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上方便地进行寻址。</li><li>IP 地址的编址方法共经过了三个历史阶段：<ul><li><strong>分类的 IP 地址</strong>是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li><li><strong>子网的划分</strong>是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</li><li><strong>构成超网</strong>是比较新的无分类编址方法。1993年提出后很快就得到推广应用。</li></ul></li><li>“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成。第一个字段是<strong>网络号</strong>，它标志主机 (或路由器) 所连接到的网络，网络号是唯一的。第二个字段是<strong>主机号</strong>，它标志该主机 (或路由器)。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。一个 IP 地址<strong>在整个互联网范围内是唯一的</strong>。</li><li>这种两级的 IP 地址可以记为：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112010.png"></li><li>式 4-1 中的符号“::&#x3D;”表示“<strong>定义为</strong>”。图  4-5 给出了各种 IP 地址的网络号字段和主机号字段，A 类、B 类和 C 类地址都是<strong>单播地址</strong>，是最常用的。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112033.png"></li></ol></li><li>从图4-5 可以看出：<ol><li>A 类、B 类和 C 类地址的网络号字段分别为 1、2 和 3 个字节长，而在网络号字段的最前面有 1～3 位的<strong>类别位</strong> ，其数值分别规定为 0，10 和 110。</li><li>A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。</li><li>D 类地址 (前 4 位是 1110) 用于<strong>多播</strong>。</li><li>E 类地址 (前 4 位是 1111) 保留为以后用。</li></ol></li></ul></li><li>从 IP 地址的结构来看，<strong>IP</strong> 地址并不仅仅指明一台主机，还指明了主机所连接到的网络。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112436.png"></li></ol></li><li><strong>常用的三种类别的 IP 地址</strong><ol><li>A类地址<ul><li>A 类地址的网络号字段占 1 个字节，只有 7 位可供使用 (该字段的第一位固定为 0)，但可指派的网络号是 126 个 (即 2<sup>7</sup>–2)。减 2 的原因是：第一，IP 地址中的全 0 表示“<strong>这个</strong>”。网络号字段为全 0 的 IP 地址是个保留地址，意思是“<strong>本网络</strong>”；第二，网络号为 127 (即01111111) 保留作为本地软件<strong>环回测试</strong>本主机的进程之间的通信。若主机发送一个目的地址为环回地址 (例如127.0.0.1) 的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址不是网络地址。</li><li>A 类地址的主机号占 3 个字节，因此每一个 A 类网络中的最大主机数是 2<sup>24</sup>–2，即16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>单个网络地址</strong> (例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是5.0.0.0)，全 1 表示“<strong>所有的</strong>”，因此全 1 的主机号字段表示该网络上的所有主机。</li><li>IP 地址空间共有 2<sup>32</sup> (4294967296) 个地址。整个 A 类地址空间共有 2<sup>31</sup> 个地址，占整个IP地址空间的 50％。</li></ul></li><li>B 类地址<ul><li>B 类地址的网络号字段有 2 个字节，前面两位 (10) 已固定了，剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此不存在网络总数减 2 的问题。实际上 B 类网络地址 128.0.0.0 是不指派的，可以指派的 B 类最小网络地址是 128.1.0.0。因此 B 类地址可指派的网络数为 2<sup>14</sup>−1，即 16383。B 类地址的每一个网络上的最大主机数是 2<sup>16</sup>–2，即 65534。这里需要减2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 2<sup>30</sup> 个地址，占整个 IP地址空间的 25％。</li></ul></li><li>C 类地址<ul><li>C 类地址有 3 个字节的网络号字段，最前面的 3 位是 (110)，还有 21 位可以进行分配。C类网络地址 192.0.0.0 是不指派的，可指派的 C 类最小网络地址 192.0.1.0，因此 C 类地址可指派的网络总数是 2<sup>21</sup>−1，即 2097151。每一个 C 类地址的最大主机数是 2<sup>8</sup>–2，即254。整个 C 类地址空间共约有 2<sup>29</sup> 个地址，占整个 IP 地址的 12.5％。</li></ul></li><li>得出表 4-2 所示的 IP 地址的指派范围。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112931.png"></li></ul></li><li>表 4-3 给出了一般不使用的特殊 IP 地址，这些地址只能在特定的情况下使用。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112945.png"></li></ul></li><li>IP 地址具有以下一些重要特点：<ul><li>每个 IP 地址都由网络号和主机号两部分组成。IP 地址是一种<strong>分等级的地址结构</strong>。分两个等级的好处是：<ol><li>IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong> (第一级)，而剩下的主机号 (第二级) 由得到该网络号的单位自行分配。方便了 IP 地址的管理。</li><li>路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong> (不考虑目的主机号)，可以使路由表中的项目数大幅度减少，从而<strong>减小了路由表所占的存储空间以及查找路由表的时间</strong>。</li></ol></li><li>实际上 IP 地址是标志一台主机 (或路由器) 和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>。一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。</li><li>一个网络指具有相同网络号 net-id 的主机的集合，因此，<strong>用转发器或网桥连接的若干个局域网仍为一个网络</strong>，这些局域网具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li><li>在 IP 地址中，所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域)，互联网都会同等对待每一个 IP 地址。</li></ul></li><li><h2 id="图-4-7-画出了三个局域网-LAN1，LAN2-和-LAN3-通过三个路由器-R1，R2-和-R3-互连起来所构成的一个互联网-互联网用虚线圆角方框表示-。其中局域网-LAN2-是由两个网段通过网桥-B-互连的。图中的小圆圈表示需要有-IP-地址。"><a href="#图-4-7-画出了三个局域网-LAN1，LAN2-和-LAN3-通过三个路由器-R1，R2-和-R3-互连起来所构成的一个互联网-互联网用虚线圆角方框表示-。其中局域网-LAN2-是由两个网段通过网桥-B-互连的。图中的小圆圈表示需要有-IP-地址。" class="headerlink" title="图 4-7 画出了三个局域网 (LAN1，LAN2 和 LAN3) 通过三个路由器 (R1，R2 和 R3) 互连起来所构成的一个互联网 (互联网用虚线圆角方框表示)。其中局域网 LAN2 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有 IP 地址。 - "></a>图 4-7 画出了三个局域网 (LAN<sub>1</sub>，LAN<sub>2</sub> 和 LAN<sub>3</sub>) 通过三个路由器 (R<sub>1</sub>，R<sub>2</sub> 和 R<sub>3</sub>) 互连起来所构成的一个互联网 (互联网用虚线圆角方框表示)。其中局域网 LAN<sub>2</sub> 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有 IP 地址。<br> - <img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723113523.png"></h2><pre><code> 1. 在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。图中所示的网络号就是 IP 地址中的网络号字段的值。另一种表示方法是用主机号为全 0 的网络IP 地址。 2. 用网桥互连的网段仍然是一个局域网，只能有一个网络号。 3. 路由器总是具有两个或两个以上的 IP 地址。即路由器的每一个接口都有一个不同网络号的 IP 地址。 4. 当两个路由器直接相连时 (例如通过一条租用线路)，在连线两端的接口处，可以分配也可以不分配 IP 地址。如分配了 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” (如图中的 N&lt;sub&gt;1&lt;/sub&gt;，N&lt;sub&gt;2&lt;/sub&gt; 和 N&lt;sub&gt;3&lt;/sub&gt;)。之所以叫做“网络”是因为它有 IP 地址。但为了节省 IP 地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配 IP 地址。通常把这样的特殊网络叫做**无编号网络**或**无名网络**。</code></pre></li></ol></li></ul><h2 id="4-2-3-IP-地址与硬件地址"><a href="#4-2-3-IP-地址与硬件地址" class="headerlink" title="4.2.3 IP 地址与硬件地址"></a>4.2.3 IP 地址与硬件地址</h2><ul><li>图 4-8 说明了物理地址与 IP 地址的区别。从层次的角度看，<strong>物理地址是数据链路层和物理层使用的地址</strong>，IP <strong>地址是网络层和以上各层使用的地址，是一种逻辑地址</strong> (称 IP 地址为逻辑地址是因为 IP 地址是用软件实现的)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723113843.png"></li></ol></li><li>在发送数据时，数据从高层下到低层，然后到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中；连接在通信链路上的设备 (主机或路由器) 在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址；总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。</li><li>图 4-9 (a) 画的是三个局域网用两个路由器 R<sub>1</sub> 和 R<sub>2</sub> 互连起来。现在主机 H<sub>1</sub> 要和主机 H<sub>2</sub> 通信。这两台主机的 IP 地址分别是 IP<sub>1</sub> 和 IP<sub>2</sub>，而它们的硬件地址分别为 HA<sub>1</sub> 和 HA<sub>2</sub> (HA 表示 Hardware Address)。通信的路径是：H<sub>1</sub>→ 经过 R<sub>1</sub> 转发 → 再经过 R<sub>2</sub> 转发 →H<sub>2</sub>。路由器 R<sub>1</sub> 因同时连接到两个局域网上，因此它有两个硬件地址，即 HA<sub>3</sub> 和 HA<sub>4</sub>。同理，路由器 R<sub>2</sub> 也有两个硬件地址 HA<sub>5</sub> 和 HA<sub>6</sub>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723234703.png"></li><li>图 4-9 (b) 特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723234720.png"></li></ul></li></ol></li><li>强调指出以下几点：<ol><li><strong>在 IP 层抽象的互联网上只能看到 IP 数据报</strong>。虽然 IP 数据报要经过路由器 R<sub>1</sub> 和 R<sub>2</sub> 的两次转发，但源地址和目的地址始终是 IP<sub>1</sub> 和 IP<sub>2</sub>。图中的数据报上写的“从 IP<sub>1</sub> 到 IP<sub>2</sub>”表示前者是源地址，后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li><li>虽然在 IP 数据报首部有源站 IP 地址，但<strong>路由器只根据目的站的 IP 地址的网络号进行路由选择</strong>。</li><li><strong>在局域网的链路层，只能看见 MAC 帧</strong>。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图4-9 (b)。开始在 H<sub>1</sub> 到 R<sub>1</sub> 间传送时，MAC 帧首部中写的是从硬件地址 HA<sub>1</sub> 发送到硬件地址 HA<sub>3</sub>，路由器 R<sub>1</sub> 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新添加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 HA<sub>4</sub>和 HA<sub>5</sub>。路由器 R<sub>2</sub> 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变成为 HA<sub>6</sub> 和 HA<sub>2</sub>。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。</li><li>尽管互连在一起的网络的硬件地址体系各不相同，<strong>但 IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。在网络层上讨论问题时，能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信</strong>。</li></ol></li></ul><h2 id="4-2-4-地址解析协议-ARP"><a href="#4-2-4-地址解析协议-ARP" class="headerlink" title="4.2.4 地址解析协议 ARP"></a>4.2.4 地址解析协议 ARP</h2><ul><li>图 4-10 说明了 ARP 协议的作用。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724110352.png"></li></ol></li><li>在网络层中，数据包使用 IP 地址进行路由和传输。然而，在实际的网络链路上，数据帧必须使用该网络的硬件地址进行传输。</li><li><strong>地址解析协议</strong> ARP 是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新 (新增或超时删除)。</li><li>如果不使用 ARP 高速缓存，那么任何一台主机只要进行一次通信，就必须在网络上用广播方式发送 ARP 请求分组，使网络上的通信量增加。ARP 把已经得到的地址映射保存在高速缓存中，使该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。</li><li>ARP 对保存在高速缓存中的每一个映射地址项目设置<strong>生存时间</strong>，超过生存时间的项目就从高速缓存中删除掉。</li><li>ARP 解决<strong>同一个局域网上</strong>的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，就无法解析另一个局域网主机的硬件地址。</li><li>归纳出使用 ARP 的四种典型情况 (图 4-12)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724110844.png"></li><li>发送方是主机 (如 H<sub>1</sub>)，要把 IP 数据报发送到同一个网络上的另一台主机 (如 H<sub>2</sub>)。这时 H<sub>1</sub> 发送 ARP 请求分组 (在网 1 上广播)，找到目的主机 H<sub>2</sub> 的硬件地址。</li><li>发送方是主机 (如 H<sub>1</sub>），要把 IP 数据报发送到另一个网络上的一台主机 (如 H<sub>3</sub> 或 H<sub>4</sub>)。这时 H<sub>1</sub>发送 ARP 请求分组 (在网 1 上广播)，找到网 1 上的一个路由器 R<sub>1</sub> 的硬件地址。剩下的工作由路由器 R<sub>1</sub> 来完成。R<sub>1</sub> 要做的事情是下面的 (3) 或 (4)。</li><li>发送方是路由器 (如 R<sub>1</sub>)，要把 IP 数据报转发到与 R<sub>1</sub> 连接在同一个网络 (网 2) 上的主机 (如 H<sub>3</sub>)。这时 R<sub>1</sub> 发送 ARP 请求分组 (在网 2 上广播)，找到目的主机 H<sub>3</sub> 的硬件地址。</li><li>发送方是路由器 (如 R<sub>1</sub>)，要把 IP 数据报转发到网3上的一台主机 (如 H<sub>4</sub>)。H<sub>4</sub> 与 R<sub>1</sub> 不是连接在同一个网络上。这时 R<sub>1</sub> 发送 ARP 请求分组 (在网 2 上广播)，找到连接在网 2 上的一个路由器 R<sub>2</sub> 的硬件地址。剩下的工作由这个路由器 R<sub>2</sub> 来完成。</li></ol></li><li>存在着各式各样的网络，<strong>它们使用不同的硬件地址</strong>。要使这些异构网络能够互相通信就必须进行<strong>非常复杂的硬件地址转换工作</strong>，因此由用户或用户主机来完成这项工作几乎是不可能的事。</li></ul><h2 id="4-2-5-IP-数据报的格式"><a href="#4-2-5-IP-数据报的格式" class="headerlink" title="4.2.5 IP 数据报的格式"></a>4.2.5 IP 数据报的格式</h2><ul><li>图 4-13 是 IP 数据报的完整格式。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724111741.png"></li></ol></li><li>一个 IP 数据报由首部和数据两部分组成。首部的前一部分是<strong>固定长度</strong>，共 20 字节，所有 IP 数据报必须具有。在首部的固定部分的后面是一些<strong>可选字段</strong>，其长度可变。</li><li><strong>IP 数据报首部的固定部分中的各字段</strong><ol><li><strong>版本</strong>   占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4 (即 IPv4)。</li><li><strong>首部长度</strong>   占 4 位，可表示的最大十进制数值是 15。首部长度字段所表示数的单位是 32 位字长 (1 个 32 位字长是 4 字节)。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 0101。而当首部长度为最大值 1111 时，就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用，但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节 (即首部长度为 0101)，这时不使用任何选项。</li><li><strong>区分服务</strong>   占 8 位，用来获得更好的服务。只有在使用区分服务时，这个字段才起作用，在一般的情况下都不使用这个字段。</li><li><strong>总长度</strong>   总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 2<sup>16</sup>–1＝65535 字节。</li><li><strong>标识</strong>   占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li><li><strong>标志</strong>   占 3 位，目前只有两位有意义。<ul><li>标志字段中的最低位记为 <strong>MF</strong>。MF＝1 即表示后面“<strong>还有分片</strong>”的数据报。MF＝0 表示这已是若干数据报片中的最后一个。</li><li>标志字段中间的一位记为 <strong>DF</strong>，意思是“<strong>不能分片</strong>”。只有当 DF＝0 时才允许分片。</li></ul></li><li><strong>片偏移</strong>   占 13 位。片偏移指：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位，每个分片的长度是 8 字节 (64 位) 的整数倍。</li><li><strong>生存时间</strong> 　占 8 位。生存时间字段的英文缩写是 TTL，是数据报在网络中的<strong>寿命</strong>。由发出数据报的源点设置这个字段。目的是防止无法交付的数据报无限制地在互联网中兜圈子，消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。</li><li><strong>协议</strong>   占 8 位。协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP 层知道应将数据部分上交给哪个协议进行处理。</li><li><strong>首部检验和</strong>   占 16 位。这个字段<strong>只检验数据报的首部，但不包括数据部分</strong>。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和，但不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的 CRC 检验码而采用下面的简单计算方法：在发送方，先把 IP 数据报首部划分为许多 16 位字的序列，并把检验和字段置零。用反码算术运算把所有 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有 16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为 0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。图 4-15 说明了 IP 数据报首部检验和的计算过程。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230729164523.png"></li></ol></li><li><strong>源地址</strong> 　占 32 位。</li><li><strong>目的地址</strong> 　占 32 位。</li></ol></li><li><strong>IP 数据报首部的可变部分</strong><ol><li>IP 数据报首部的可变部分是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容丰富。</li><li>增加首部的可变部分是为了增加 IP 数据报的功能，同时也增加了每一个路由器处理数据报的开销。</li></ol></li></ul><h2 id="4-2-6-IP-层转发分组的流程"><a href="#4-2-6-IP-层转发分组的流程" class="headerlink" title="4.2.6 IP 层转发分组的流程"></a>4.2.6 IP 层转发分组的流程</h2><ul><li>若路由表指出到每一台主机应怎样转发，则所得出的路由表就会过于庞大，即<strong>每一行对应于一台主机</strong>；但若路由表指出到某个网络应如何转发，则每个路由器中的路由表就只包含 4 个项目，即<strong>每一行对应于一个网络</strong>。</li><li>在互联网上转发分组时，是<strong>从一个路由器转发到下一个路由器</strong>。</li><li>在路由表中，对每一条路由最主要的是以下两个信息：<strong>目的网络地址，下一跳地址</strong>。</li><li>根据目的网络地址来确定下一跳路由器，可得出以下的结果：<ol><li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ol></li><li>互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>。</li><li>采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，也可在需要考虑某种安全问题时采用这种特定主机路由。</li><li>路由器还可采用<strong>默认路由</strong>以减小路由表所占用的空间和搜索路由表所用的时间。</li><li><strong>分组转发算法</strong>如下：<ol><li>从数据报的首部提取目的主机的 IP 地址 <em>D</em>，得出目的网络地址为 <em>N</em>。</li><li>若 <em>N</em> 是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 <em>D</em> 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行 3。</li><li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。</li><li>若路由表中有到达网络 <em>N</em> 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 5。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。</li><li>报告转发分组出错。</li></ol></li></ul><h1 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3 划分子网和构造超网"></a>4.3 划分子网和构造超网</h1><h2 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1 划分子网"></a>4.3.1 划分子网</h2><ul><li><strong>从两级 IP 地址到三级 IP 地址</strong><ol><li>在 ARPANET 的早期，IP 地址的设计不够合理：<ul><li>IP <strong>地址空间的利用率有时很低</strong></li><li>给每一个物理网络分配一个网络号会<strong>使路由表变得太大</strong>因而使网络性能变坏</li><li><strong>两级 IP 地址不够灵活</strong></li></ul></li><li>为解决上述问题，在 IP 地址中增加了一个“<strong>子网号字段</strong>”，使两级 IP 地址变成为三级 IP地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做<strong>划分子网</strong>，或<strong>子网寻址</strong>或<strong>子网路由选择</strong>。划分子网已成为互联网的正式标准协议。</li><li>划分子网的基本思路如下：<ul><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个<strong>子网</strong>。划分子网是一个单位内部的事情。本单位以外的网络<strong>看不见</strong>这个网络是由多少个子网组成，因为这个单位<strong>对外仍然表现为一个网络</strong>。</li><li>划分子网的方法是从网络的主机号借用若干位作为子网号，主机号也就相应减少了同样的位数。于是两级 IP 地址在<strong>本单位内部</strong>就变为<strong>三级</strong> IP 地址：网络号、子网号和主机号。也可以用以下记法来表示：IP 地址 ::&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</li><li>凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。</li></ul></li></ol></li><li><strong>子网掩码</strong><ol><li>从 IP 数据报的首部<strong>无法看出</strong>源主机或目的主机所连接的网络是否进行了子网的划分。因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。必须使用<strong>子网掩码</strong>。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730151524.png"></li></ul></li><li>使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“与”运算，就立即得出网络地址来。</li><li>为了更便于查找路由表，即使在不划分子网时，还要使用子网掩码。</li><li>如果一个网络不划分子网，那么该网络的子网掩码就使用<strong>默认子网掩码</strong>。默认子网掩码中 1 的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相“与”，就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。<ul><li>A 类地址的默认子网掩码是 255.0.0.0，或 0xFF000000。</li><li>B 类地址的默认子网掩码是 255.255.0.0，或 0xFFFF0000。</li><li>C 类地址的默认子网掩码是 255.255.255.0，或 0xFFFFFF00。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730153614.png"></li></ul></li><li><strong>子网掩码是一个网络或一个子网的重要属性</strong>。</li><li>采用固定长度子网时，所划分的<strong>所有</strong>子网的子网掩码都是相同的<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730153818.png"></li><li>子网数是根据子网号 subnet-id 计算出来的。若 subnet-id 有 <em>n</em> 位，则共有 2<sup>n</sup> 种可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数。</li></ul></li><li>虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，<strong>现在全 1 和全 0 的子网号也可以使用了</strong>。</li><li><strong>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数</strong>。</li></ol></li></ul><h2 id="4-3-2-使用子网时分组的转发"><a href="#4-3-2-使用子网时分组的转发" class="headerlink" title="4.3.2 使用子网时分组的转发"></a>4.3.2 使用子网时分组的转发</h2><ul><li>使用子网划分后，路由表必须包含以下三项内容：<strong>目的网络地址、子网掩码和下一跳地址</strong>。</li><li>在划分子网的情况下，路由器转发分组的算法如下：<ol><li>从收到的数据报的首部提取目的 IP 地址 <em>D</em>。</li><li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 <em>D</em> 逐位相“<strong>与</strong>” (AND 操作)，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付)，转发任务结束。否则是间接交付，执行 3。</li><li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。</li><li>对路由表中的每一行 (目的网络地址，子网掩码，下一跳地址)，用其中的子网掩码和 <em>D</em> 逐位相“与” (AND操作)，其结果为 <em>N</em>。若 <em>N</em> 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行 5。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。</li><li>报告转发分组出错。</li></ol></li></ul><h2 id="4-3-3-无分类编址-CIDR-构造超网"><a href="#4-3-3-无分类编址-CIDR-构造超网" class="headerlink" title="4.3.3 无分类编址 CIDR (构造超网)"></a>4.3.3 无分类编址 CIDR (构造超网)</h2><ul><li><strong>网络前缀</strong><ol><li>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：<ul><li>B 类地址在 1992 年已分配了近一半，很快将分配完毕。</li><li>互联网主干网上的路由表中的项目数急剧增长。</li><li>整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽。</li></ul></li><li>早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用<strong>变长子网掩码</strong> VLSM 可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出<strong>无分类编址</strong>方法，它的正式名字是<strong>无分类域间路由选择</strong> CIDR。</li><li>CIDR 主要的特点有两个：<ul><li>CIDR <strong>消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念</strong>，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是“<strong>网络前缀</strong>” (简称“<strong>前缀</strong>”)，用来指明网络，后面部分则用来指明主机。因此 CIDR 使 IP 地址从三级编址 (使用子网掩码) 又回到了两级编址，但这已是<strong>无分类的两级编址</strong>。其记法是：IP 地址 ::&#x3D;{&lt;网络前缀&gt;,&lt;主机号&gt;}；CIDR 还使用“<strong>斜线记法</strong>”，或称为 <strong>CIDR 记法</strong> ，即在 IP 地址后面加上斜线“&#x2F;”，然后写上网络前缀所占的位数。</li><li>CIDR 把<strong>网络前缀都相同</strong>的连续的 IP 地址组成一个“CIDR <strong>地址块</strong>”。只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址 (即最小地址) 和最大地址，以及地址块中的地址数。</li></ul></li><li>为了更方便地进行路由选择，CIDR 使用 32 位的<strong>地址掩码</strong>。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为<strong>子网掩码</strong>。<strong>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数</strong>。</li><li>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong> (构成超网)，它使得路由表中的一个项目可以表示原来传统分类地址的很多个 (例如上千个) 路由。</li><li>路由聚合有利于减少路由器之间的路由选择信息的交换，提高了整个互联网的性能。</li><li>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。</li><li><strong>网络前缀越短，其地址块所包含的地址数就越多</strong>。</li></ol></li><li><strong>最长前缀匹配</strong><ol><li>在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要有相应的改变。每个项目由“<strong>网络前缀</strong>”和“<strong>下一跳地址</strong>”组成。在查找路由表时<strong>可能会得到不止一个匹配结果</strong>。</li><li><strong>最长前缀匹配</strong>是<strong>从匹配结果中选择具有最长网络前缀的路由</strong>，最长前缀匹配又称为<strong>最长匹配</strong>或<strong>最佳匹配</strong>。</li><li>网络前缀越长，地址块越小，路由越具体。</li></ol></li><li><strong>使用二叉线索查找路由表</strong><ol><li>使用 CIDR 后，由于要寻找最长前缀匹配，路由表的查找过程变得更加复杂了。</li><li>对无分类编址的路由表的最简单的查找算法是对所有可能的前缀进行循环查找，这种简单算法的缺点是查找的次数太多。最坏的情况是路由表中没有这个路由。</li><li>为了进行更加有效的查找，通常把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。最常用的就是<strong>二叉线索</strong>，它是一种特殊结构的树。IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。</li><li>为了提高二叉线索的查找速度，使用了各种<strong>压缩技术</strong>。</li></ol></li></ul><h1 id="4-4-网际控制报文协议-ICMP"><a href="#4-4-网际控制报文协议-ICMP" class="headerlink" title="4.4 网际控制报文协议 ICMP"></a>4.4 网际控制报文协议 ICMP</h1><ul><li>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了<strong>网际控制报文协议 ICMP</strong>。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议，但不是高层协议，而是 IP 层的协议。ICMP 报文作为 IP 层数据报的数据部分，加上数据报的首部，组成 IP 数据报发送出去。ICMP 报文格式如图 4-27 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230731164920.png"></li></ol></li></ul><h2 id="4-4-1-ICMP-报文的种类"><a href="#4-4-1-ICMP-报文的种类" class="headerlink" title="4.4.1 ICMP 报文的种类"></a>4.4.1 ICMP 报文的种类</h2><ul><li>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</li><li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段，其长度取决于 ICMP 的类型。表 4-8 给出了几种常用的 ICMP 报文类型。</li><li>ICMP 报文的代码字段能进一步区分某种类型中的几种不同情况。检验和字段用来检验整个 ICMP 报文。IP 数据报首部的检验和并不检验 IP 数据报的内容 (检验首部)，因此不能保证经过传输的 ICMP 报文不产生差错。</li><li>表 4-8 给出的 ICMP 差错报告报文共有四种：<ol><li><strong>终点不可达</strong> 　当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li><li><strong>时间超过</strong> 　当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li><strong>参数问题</strong> 　当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li><strong>改变路由 (重定向)</strong> 　路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器 (可通过更好的路由)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230802183434.png"></li></ol></li><li>对改变路由报文进行解释。在互联网的主机中要有一个路由表，当主机要发送数据报时，首先查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由 (通过和其他路由器交换路由信息)。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器 R (而不是默认路由器)。</li><li>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式 (图 4-28)。把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段。再加上相应的 ICMP 差错报告报文的前 8 个字节，就构成了 ICMP 差错报告报文。提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号 (对于 TCP 和 UDP) 以及运输层报文的发送序号 (对于 TCP)。这些信息对源点通知高层协议是有用的。整个 ICMP报文作为 IP 数据报的数据字段发送给源点。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230802184415.png"></li></ol></li><li>下面是不应发送 ICMP 差错报告报文的几种情况：<ol><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报，都不发送 ICMP 差错报告报文。</li><li>对具有特殊地址 (如 127.0.0.0 或 0.0.0.0) 的数据报，不发送 ICMP 差错报告报文。</li></ol></li><li>常用的 ICMP 询问报文有两种，即：<ol><li><strong>回送请求和回答</strong> 　ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</li><li><strong>时间戳请求和回答</strong> 　ICMP 时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。****</li></ol></li></ul><h2 id="4-4-2-ICMP的应用举例"><a href="#4-4-2-ICMP的应用举例" class="headerlink" title="4.4.2 ICMP的应用举例"></a>4.4.2 ICMP的应用举例</h2><ul><li>ICMP 的一个重要应用是分组网间探测 <strong>PING</strong>，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的一个例子，没有通过运输层的 TCP 或 UDP。</li><li>另一个非常有用的应用是 traceroute (这是 UNIX 操作系统中名字)，它用来跟踪一个分组从源点到终点的路径。在 Windows 操作系统中这个命令是 tracert。</li></ul><h1 id="4-5-互联网的路由选择协议"><a href="#4-5-互联网的路由选择协议" class="headerlink" title="4.5 互联网的路由选择协议"></a>4.5 互联网的路由选择协议</h1><h2 id="4-5-1-有关路由选择协议的几个基本概念"><a href="#4-5-1-有关路由选择协议的几个基本概念" class="headerlink" title="4.5.1 有关路由选择协议的几个基本概念"></a>4.5.1 有关路由选择协议的几个基本概念</h2><ul><li><strong>理想的路由算法</strong><ol><li>路由选择协议的核心是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点：<ul><li><strong>算法必须是正确的和完整的</strong>。“正确”是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li><li><strong>算法在计算上应简单</strong>。路由选择的计算不应使网络通信量增加太多的额外开销。</li><li><strong>算法应能适应通信量和网络拓扑的变化</strong>，要有<strong>自适应性</strong>。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“<strong>稳健性</strong>“。</li><li><strong>算法应具有稳定性</strong>。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li><li><strong>算法应是公平的</strong>。路由选择算法应对所有用户 (除对少数优先级高的用户) 都是平等的。</li><li><strong>算法应是最佳的</strong>。路由选择算法应当能找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li></ul></li><li>路由选择是个复杂的问题，因为它是网络中的所有结点共同协调工作的结果。其次，路由选择的环境是不断变化的，这种变化无法事先知道，此外，当网络发生拥塞时，需要有能缓解拥塞的路由选择策略。</li><li>从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，有两大类：<ul><li><strong>静态路由选择策略</strong>，也称<strong>非自适应路由选择</strong><ol><li>特点：简单、开销小，但不能及时适应网络状态的变化。对于很简单的小网络，采用静态路由选择，用人工配置每一条路由。</li></ol></li><li><strong>动态路由选择策略</strong>，也称<strong>自适应路由选择</strong><ol><li>特点：能较好地适应网络状态的变化，实现起来较复杂，开销也较大。因此，动态路由选择适用于较复杂的大网络。</li></ol></li></ul></li></ol></li><li><strong>分层次的路由选择协议</strong><ol><li>互联网采用的路由选择协议主要是自适应的 (即动态的)、分布式路由选择协议。由于以下两个原因，互联网采用分层次的路由选择协议：<ul><li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li><li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。</li></ul></li><li>可以把整个互联网划分为许多较小的<strong>自治系统</strong>，一般记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</li><li>在目前的互联网中，一个 ISP 就是一个自治系统。互联网就把路由选择协议划分为两大类：<ul><li><strong>内部网关协议</strong> IGP　在一个自治系统内部使用的路由选择协议，与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li><li><strong>外部网关协议</strong> EGP　若源主机和目的主机处在不同的自治系统中 (这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，需要使用协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4 (BGP-4)。</li></ul></li><li>自治系统之间的路由选择叫做<strong>域间路由选择</strong>，自治系统内部的路由选择叫做<strong>域内路由选择</strong>。</li><li>图 4-31 是两个自治系统互连在一起的示意图。每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议 (例如，可以是 RIP，也可以是 OSPF)，但每个自治系统都有一个或多个路由器 (图中的路由器 R<sub>1</sub> 和 R<sub>2</sub>) ,除运行本系统的内部路由选择协议外，还要运行自治系统间的路由选择协议 (BGP-4)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230803100909.png"></li></ul></li></ol></li></ul><h2 id="4-5-2-内部网关协议-RIP"><a href="#4-5-2-内部网关协议-RIP" class="headerlink" title="4.5.2 内部网关协议 RIP"></a>4.5.2 内部网关协议 RIP</h2><ul><li><strong>工作原理</strong><ol><li>RIP 是内部网关协议 IGP 中最先广泛使用的协议，是一种分布式的<strong>基于距离向量的路由选择协议</strong>，是互联网的标准协议，最大优点是简单。</li><li>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录 (因此，这是<strong>一组距离</strong>，即“<strong>距离向量</strong>”)。</li><li>RIP 认为好的路由通过的路由器的数目少，即“距离短”。它允许一条路径最多只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。<strong>RIP 只适用于小型互联网</strong>。</li><li>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由 (即最短路由)，哪怕还存在另一条高速 (低时延) 但路由器较多的路由。</li><li>RIP协议的特点是：<ul><li><strong>仅和相邻路由器交换信息</strong>。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。</li><li>路由器交换的信息是<strong>当前本路由器所知道的全部信息，即自己现在的路由表</strong>。即：“我到本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器”。</li><li><strong>按固定的时间间隔</strong>交换路由信息，然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ul></li><li>路由器在<strong>刚刚开始工作时</strong>，它的路由表是空的。然后路由器就得出直接相连的几个网络的距离 (这些距离定义为 1)。接着，每一个路由器只和<strong>数目非常有限的</strong>相邻路由器交换并更新路由信息。经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 </li><li>在一般情况下，RIP 协议可以<strong>收敛</strong>，且过程较快。“收敛”是在自治系统中所有的结点都得到正确的路由选择信息的过程。</li><li>路由表中主要的信息是：到某个网络的距离 (即最短距离)，以及应经过的下一跳地址。路由表更新的原则是找出到每个目的网络的<strong>最短距离</strong>。这种更新算法又称为<strong>距离向量算法</strong>。</li></ol></li><li><strong>距离向量算法</strong><ol><li>对<strong>每一个相邻路由器</strong>发送过来的 RIP 报文，进行以下步骤：<ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的<strong>所有项目</strong> ：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。每一个项目都有三个关键数据，即：到目的网络 N，距离是 d，下一跳路由器是 X。</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：若原来的路由表中没有目的网络 N，则把该项目添加到路由表中。否则 (即在路由表中有目的网络 N，这时就再查看下一跳路由器地址) 若下一跳路由器地址是 X，则把收到的项目替换原路由表中的项目。否则 (即这个项目是：到目的网络 N，但下一跳路由器不是 X) 若收到的项目中的距离 d 小于路由表中的距离，则进行更新，否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为 16 (距离为 16 表示不可达)。</li><li>返回。</li></ul></li><li>RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从<strong>每一个路由器到每一个目的网络的路由都是最短的</strong>。</li><li>所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表也应当是不同的。</li></ol></li><li><strong>RIP 协议的报文格式</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230803131532.png"></li><li>RIP 协议使用运输层的用户数据报 UDP 进行传送。</li><li>RIP 报文由首部和路由部分组成。</li><li>RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1 表示请求路由信息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为 0”是为了 4 字节字的对齐。</li><li>RIP 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。<strong>地址族标识符</strong> (地址类别) 字段用来标志所使用的地址协议。如采用 IP 地址就令这个字段的值为 2。<strong>路由标记</strong>填入<strong>自治系统号</strong> ASN，因为 RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个<strong>网络地址</strong>、该网络的<strong>子网掩码</strong>、<strong>下一跳路由器地址</strong>以及<strong>到此网络的距离</strong>。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4＋20×25＝504 字节。如超过，必须再用一个 RIP 报文来传送。</li><li>RIP 具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息 (20 字节) 的位置用作鉴别。这时应将地址族标识符置为全 1 (即 0xFFFF)，而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，这时最多只能再放入 24 个路由信息。</li><li>RIP 的问题是<strong>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器</strong>。网络出故障的传播时间往往需要较长的时间。这是 RIP 的主要缺点。</li><li>RIP 协议的优点是<strong>实现简单，开销小</strong>。</li><li>RIP 有很多缺点：RIP 限制了网络的规模，它能使用的最大距离为 15 (16 表示不可达)。其次，路由器之间交换的路由信息是路由器中的完整路由表，随着网络规模的扩大，开销也增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用 OSPF 协议。在规模较小的网络中，使用 RIP 协议。</li></ol></li></ul><h2 id="4-5-3-内部网关协议-OSPF"><a href="#4-5-3-内部网关协议-OSPF" class="headerlink" title="4.5.3 内部网关协议 OSPF"></a>4.5.3 内部网关协议 OSPF</h2><ul><li><strong>OSPF 协议的基本特点</strong><ol><li>协议的名字是<strong>开放最短路径优先</strong> OSPF，是为克服 RIP 的缺点开发出来的。</li><li>OSPF 只是一个协议的名字，<strong>并不表示其他的路由选择协议不是“最短路径优先”</strong>。所有的在自治系统内部使用的路由选择协议 (包括 RIP 协议) 都要寻找一条最短的路径。</li><li>OSPF 主要的特征是使用分布式的<strong>链路状态协议</strong>，不像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样：<ul><li>向本自治系统中<strong>所有路由器</strong>发送信息。使用的方法是<strong>洪泛法</strong>，就是路由器通过所有输出端口向所有相邻的路由器发送信息。每一个相邻路由器又再将此信息发往其所有的相邻路由器 (但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。RIP 协议仅仅向自己相邻的几个路由器发送信息。</li><li>发送的信息是与本路由器<strong>相邻的所有路由器的链路状态</strong>，但这只是路由器知道的<strong>部分信息</strong>。所谓“链路状态”就是说明本路由器和哪些路由器相邻，以及该链路的“<strong>度量</strong>”。度量用来表示费用、距离、时延、带宽等等。这些由网络管理人员决定，较灵活。有时为了方便就称度量为“<strong>代价</strong>”。对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。</li><li>只有当链路状态<strong>发生变化时</strong>，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li></ul></li><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库</strong>，这个数据库实际上是全网的拓扑结构图。</li><li>RIP 协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却<strong>不知道全网的拓扑结构</strong>。</li><li>OSPF 的<strong>更新过程收敛得快</strong>是其重要优点。</li><li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统划分为若干个更小的范围，叫做<strong>区域</strong>。图 4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符 (用点分十进制表示)。一个区域不能太大，在一个区域内的路由器最好不超过 200 个。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804152244.png"></li></ul></li><li>划分区域的好处是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做<strong>主干区域</strong>。主干区域的标识符规定为 0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息由<strong>区域边界路由器</strong>进行概括。在图 4-34 中，路由器 R<sub>3</sub>，R<sub>4</sub> 和 R<sub>7</sub> 都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫做<strong>主干路由器</strong>，如 R<sub>3</sub>，R<sub>4</sub>，R<sub>5</sub>，R<sub>6</sub> 和 R<sub>7</sub>。一个主干路由器可以同时是区域边界路由器，如 R<sub>3</sub>，R<sub>4</sub> 和 R<sub>7</sub>。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong> (如图中的 R<sub>6</sub>)。</li><li>采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复杂。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议能够用于规模很大的自治系统中。</li><li>OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong> (其 IP 数据报首部的协议字段值为 89)。OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li><li>OSPF 分组使用 24 字节的固定长度首部 (见图 4-35)，分组的数据部分可以是五种类型分组中的一种：<ul><li><strong>版本</strong> 　当前的版本号是 2。</li><li><strong>类型</strong> 　可以是五种类型分组中的一种。</li><li><strong>分组长度</strong> 　包括 OSPF 首部在内的分组长度，以字节为单位。</li><li><strong>路由器标识符</strong> 　标志发送该分组的路由器的接口的 IP 地址。</li><li><strong>区域标识符</strong> 　分组属于的区域的标识符。</li><li><strong>检验和</strong> 　用来检测分组中的差错。</li><li><strong>鉴别类型</strong> 　只有两种，0 (不用) 和1 (口令)。</li><li><strong>鉴别</strong> 　鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字符的口令。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804152901.png"></li></ul></li><li>除了以上的几个基本特点外，OSPF 还具有下列的一些特点：<ul><li>OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF <strong>对于不同类型的业务可计算出不同的路由</strong>。链路的代价可以是 1 至 65535 中的任何一个无量纲的数，因此十分灵活。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的<strong>负载平衡</strong>。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。</li><li>所有在 OSPF 路由器之间交换的分组 (例如，链路状态更新分组) 都具有鉴别的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</li><li>OSPF 支持可变长度的子网划分和无分类的编址 CIDR。</li><li>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过每 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复号。</li></ul></li></ol></li><li><strong>OSPF 的五种分组类型</strong><ol><li>OSPF 有五种分组类型：<ul><li><strong>类型 1，问候</strong>分组，用来发现和维持邻站的可达性。</li><li><strong>类型 2，数据库描述</strong>分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li><strong>类型 3，链路状态请求</strong>分组，向对方请求发送某些链路状态项目的详细信息。</li><li><strong>类型 4，链路状态更新</strong>分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是 OSPF 协议的核心部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有五种不同的链路状态。</li><li><strong>类型 5，链路状态确认</strong>分组，对链路更新分组的确认。</li></ul></li><li>OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要是指出有哪些路由器的链路状态信息 (以及其序号) 已经写入了数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。图 4-36 给出了 OSPF 的基本操作，说明了两个路由器需要交换各种类型的分组。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804153513.png"></li></ul></li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，与整个互联网的规模无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</li><li>OSPF 协议对多点接入的局域网采用了<strong>指定的路由器</strong>的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</li></ol></li></ul><h2 id="4-5-4-外部网关协议-BGP"><a href="#4-5-4-外部网关协议-BGP" class="headerlink" title="4.5.4 外部网关协议 BGP"></a>4.5.4 外部网关协议 BGP</h2><ul><li>内部网关协议主要是设法使数据报在一个 AS 中尽可能有效地从源站传送到目的站。</li><li>BGP 使用的环境不同，主要是因为以下原因：<ol><li><strong>互联网的规模太大，使得自治系统 AS 之间路由选择非常困难</strong>。</li><li><strong>自治系统 AS 之间的路由选择必须考虑有关策略</strong>。</li></ol></li><li>边界网关协议 BGP 力求寻找一条能够到达目的网络且比较好的路由，<strong>并非要寻找一条最佳路由</strong>。BGP 采用了<strong>路径向量路由选择协议</strong> ，它与距离向量协议 (如 RIP) 和链路状态协议 (如 OSPF) 都有很大的区别。</li><li>BGP 协议交换路由信息的结点数量级是<strong>自治系统个数</strong>的量级，比自治系统中的<strong>网络数</strong>少。</li><li>在 RFC 4271 中规定了 BGP-4 的四种报文：<ol><li>OPEN (打开) 报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。</li><li>UPDATE (更新) 报文，用来通告某一路由的信息，以及列出要撤销的多条路由。</li><li>KEEPALIVE (保活) 报文，用来周期性地证实邻站的连通性。</li><li>NOTIFICATION (通知) 报文，用来发送检测到的差错。</li></ol></li><li>图 4-41 给出了 BGP 报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度为 19 字节。通用首部为三个字段。<strong>标记</strong>字段为 16 字节长，用来鉴别收到的 BGP 报文。当不使用鉴别时，标记字段要置为全 1。<strong>长度</strong>字段指出包括通用首部在内的整个 BGP 报文以字节为单位的长度，最小值是 19，最大值是 4096。<strong>类型</strong>字段的值为 1 到 4，分别对应于上述四种 BGP 报文中的一种。<ol><li>OPEN <strong>报文</strong>共有 6 个字段，即<strong>版本</strong> (1 字节，现在的值是 4)、<strong>本自治系统号</strong> (2 字节，使用全球唯一的 16 位自治系统号，由 ICANN 地区登记机构分配)、<strong>保持时间</strong> (2 字节，以秒计算的保持为邻站关系的时间)、<strong>BGP 标识符</strong> (4 字节，通常就是该路由器的 IP 地址)、<strong>可选参数长</strong>(1 字节) 和<strong>可选参数</strong>。</li><li>UPDATE <strong>报文</strong>共有 5 个字段，即<strong>不可行路由长度</strong> (2 字节，指明下一个字段的长度)、<strong>撤销的路由</strong> (列出所有要撤销的路由)、<strong>路径属性总长度</strong> (2 字节，指明下一个字段的长度)、<strong>路径属性</strong> (定义在这个报文中增加的路径的属性) 和<strong>网络层可达性信息 NLRI</strong>。最后这个字段定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀。</li><li>KEEPALIVE <strong>报文</strong>只有 BGP 的 19 字节长的通用首部。</li><li>NOTIFICATION <strong>报文</strong>有 3 个字段，即差错代码 (1 字节)、差错子代码 (1 字节) 和差错数据 (给出有关差错的诊断信息)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804161110.png"></li></ol></li></ul><h2 id="4-5-5-路由器的构成"><a href="#4-5-5-路由器的构成" class="headerlink" title="4.5.5 路由器的构成"></a>4.5.5 路由器的构成</h2><ul><li><strong>路由器的结构</strong><ol><li>路由器是一种具有多个输入端口和多个输出端口的专用计算机，任务是转发分组。</li><li>典型的路由器的结构<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170016.png"></li><li>从图 4-42 可以看出，路由器结构可划分为两部分：<strong>路由选择</strong>部分和<strong>分组转发部分</strong>。</li><li>路由选择部分也叫<strong>控制部分</strong>，其核心构件是路由选择处理机。</li><li>分组转发由三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>。</li><li>交换结构又称为<strong>交换组织</strong>，作用是根据<strong>转发表</strong>对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中的网络”。</li><li>在图 4-42 中，路由器的输入和输出端口里面都各有三个方框，用方框中的 1，2 和 3 分别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。若接收到的分组是路由器之间交换路由信息的分组 (如 RIP 或 OSPF 分组等)，则把这种分组送交路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得出的结果，分组经过交换结构到达合适的输出端口。一个路由器的输入端口和输出端口安装在路由器的<strong>线路接口卡上</strong>。</li><li>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中 (如图 4-42 中的虚线箭头所示)。路由选择处理机负责对各转发表的副本进行更新。这些副本常称为“<strong>影子副本</strong>”。分散化交换可以避免在路由器中的某一点上出现瓶颈。</li></ul></li><li>输入端口对线路上收到的分组的处理<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170325.png"></li><li>当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个后到的分组必须在队列中排队等待，产生了一定的时延。图 4-43 给出了在输入端口的队列中排队的分组的示意图。</li></ul></li><li>输出端口把交换结构传送过来的分组发送到线路上<ul><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_networkSnipaste_2023-12-04_11-02-43.png"></li><li>观察在输出端口上的情况 (图 4-44 )。输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上是一个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</li></ul></li><li>分组在路由器的输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</li></ol></li><li><strong>交换结构</strong><ol><li>三种常用的交换方法<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170614.png"></li><li>最早的路由器：当路由器的某个输入端口收到一个分组时，用中断方式通知路由选择处理机。然后分组从输入端口复制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。</li><li>图 4-45 (a) 的示意图表示分组通过存储器进行交换。与早期的路由器的区别是，目的地址的查找和分组在存储器中的缓存是在输入端口中进行的。</li><li>图 4-45 (b) 是通过总线进行交换的示意图。数据报从输入端口通过共享的总线直接传送到合适的输出端口，不需要路由选择处理机的干预。由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线忙，则被阻塞不能通过交换结构，并在输入端口排队等待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品都采用这种通过总线的交换方式。</li><li>图4-45 (c) 是通过纵横交换结构进行交换。这种交换机构称为<strong>互连网络</strong>，它有 2<em>N</em> 条总线，可以使 <em>N</em> 个输入端口和 <em>N</em> 个输出端口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。但若该垂直总线已被占用 (有另一个分组正在转发到同一个输出端口)，则后到达的分组就被阻塞，必须在输入端口排队。</li></ul></li></ol></li></ul><h1 id="4-6-IPv6"><a href="#4-6-IPv6" class="headerlink" title="4.6 IPv6"></a>4.6 IPv6</h1><h2 id="4-6-1-IPv6-的基本首部"><a href="#4-6-1-IPv6-的基本首部" class="headerlink" title="4.6.1 IPv6 的基本首部"></a>4.6.1 IPv6 的基本首部</h2><ul><li>IPv6 支持无连接的传送，但将协议数据单元 PDU 称为<strong>分组</strong>，而不是 IPv4 的数据报。</li><li>IPv6 所引进的主要变化如下：<ol><li><strong>更大的地址空间</strong>。IPv6 把地址从 IPv4 的 32 位增大 4 倍，即增大到 128 位，使地址空间增大了2<sup>96</sup> 倍。这样大的地址空间在可预见的将来是不会用完的。</li><li><strong>扩展的地址层次结构</strong>。IPv6 由于地址空间很大，因此可以划分为更多的层次。</li><li><strong>灵活的首部格式</strong>。IPv6 数据报的首部和 IPv4 的并不兼容。IPv6 定义了许多可选的扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路由器对扩展首部不进行处理 (除逐跳扩展首部外)。</li><li><strong>改进的选项</strong>。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选项。但 IPv6 的<strong>首部长度是固定的</strong>，其选项放在有效载荷中。IPv4 所规定的选项是固定不变的，其选项放在首部的可变部分。</li><li><strong>允许协议继续扩充</strong>。因为技术总是在不断地发展而新的应用也还会出现。</li><li>支持即插即用 (即自动配置)。因此 IPv6 不需要使用 DHCP。</li><li><strong>支持资源的预分配</strong>。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。</li><li>IPv6 首部改为 8 <strong>字节对齐</strong> (即首部长度必须是 8 字节的整数倍)。原来的 IPv4 首部是 4 字节对齐。</li></ol></li><li>IPv6 数据报由两大部分组成，即<strong>基本首部和后面的有效载荷</strong>。有效载荷也称为净负荷。有效载荷允许有零个或多个<strong>扩展首部</strong>，再后面是数据部分 (图 4-46)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804173631.png"></li><li>与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：<ul><li>取消了首部长度字段，因为它的首部长度是固定的 (40 字节)。</li><li>取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。</li><li>取消了总长度字段，改用有效载荷长度字段。</li><li>取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。</li><li>把 TTL 字段改称为跳数限制字段，但作用是一样的。</li><li>取消了协议字段，改用下一个首部字段。</li><li>取消了检验和字段，加快了路由器处理数据报的速度。在数据链路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确传送到目的进程为止。因此在网络层的差错检测可以精简掉。</li><li>取消了选项字段，而用扩展首部来实现选项功能。</li></ul></li></ol></li><li>解释 IPv6 基本首部中各字段的作用 (参见图 4-47)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804173739.png"></li></ul><ol><li><strong>版本</strong>　占 4 位。它指明了协议的版本，IPv6 字段是 6。</li><li><strong>通信量类</strong>　占 8 位。这是为了区分不同的 IPv6 数据报的类别或优先级。</li><li><strong>流标号</strong>　占 20 位。IPv6 的一个新的机制是支持资源预分配，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流的抽象概念。所谓“流“<strong>是互联网络上从特定源点到特定终点 (单播或多播) 的一系列数据报 (如实时音频或视频传输)，“流”所经过的路径上的路由器都保证指明的服务质量</strong>。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频&#x2F;视频数据的传送有用。对于传统的电子邮件或非实时数据，流标号则没用，把它置为 0 即可。</li><li><strong>有效载荷长度</strong>　占 16 位。它指明 IPv6 数据报除基本首部以外的字节数 (所有扩展首部都算在有效载荷之内)。这个字段的最大值是 64KB (65535字节)。</li><li><strong>下一个首部</strong>　占 8 位。相当于 IPv4 的协议字段或可选字段。<ul><li>当 IPv6 数据报没有扩展首部时，下一个首部字段的作用和 IPv4 的协议字段一样，它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议 (例如：6 或17 分别表示应交付运输层 TCP 或 UDP)。</li><li>当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。</li></ul></li><li><strong>跳数限制</strong>　占 8 位。用来防止数据报在网络中无限期地存在。源点在每个数据报发出时即设定某个跳数限制 (最大为 255 跳)。每个路由器在转发数据报时，要先把跳数限制字段中的值减 1。当跳数限制的值为零时，就要把这个数据报丢弃。</li><li><strong>源地址</strong> 　占 128 位。是数据报的发送端的 IP 地址。</li><li><strong>目的地址</strong> 　占 128 位。是数据报的接收端的 IP 地址。</li></ol></li><li>IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，降低了路由器处理数据报的速度。然而实际上很多的选项在途中的路由器上是不需要检查的 (因为不需要使用这些选项的信息)。IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理，数据报途中经过的<strong>路由器都不处理这些扩展首部</strong> (只有一个首部例外，即逐跳选项扩展首部)，<strong>大大提高了路由器的处理效率</strong>。</li><li>在 RFC 2460 中定义了以下六种扩展首部：<ol><li>逐跳选项</li><li>路由选择</li><li>分片</li><li>鉴别</li><li>封装安全有效载荷</li><li>目的站选项</li></ol></li></ul><h2 id="4-6-2-IPv6-的地址"><a href="#4-6-2-IPv6-的地址" class="headerlink" title="4.6.2 IPv6 的地址"></a>4.6.2 IPv6 的地址</h2><ul><li>一个 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：<ol><li><strong>单播</strong>　单播是传统的点对点通信。</li><li><strong>多播</strong>　多播是一对多的通信，数据报发送到一组计算机中的每一个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li><li><strong>任播</strong>　IPv6 增加的一种类型。任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。</li></ol></li><li>IPv6 把实现 IPv6 的主机和路由器均称为<strong>结点</strong>。由于一个结点可能会使用多条链路与其他的一些结点相连，因此一个结点可能有多个与链路相连的接口。IPv6 给结点的每一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当作到达该结点的目的地址。</li><li>为了使地址再稍简洁些，IPv6 使用<strong>冒号十六进制记法</strong>，它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。</li><li>IPv6 的地址分类见表 4-10 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805093424.png"></li></ol></li><li>对表 4-10 所列举的几种地址简单解释如下。<ol><li><strong>未指明地址</strong> 　这是 16 字节的全 0 地址，可缩写为两个冒号“::”。这个地址不能用作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的 IP 地址。这类地址仅此一个。</li><li><strong>环回地址</strong> 　IPv6 的环回地址是 0:0:0:0:0:0:0:1，可缩写为 ::1。它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。</li><li><strong>多播地址</strong> 　功能和 IPv4 的一样。这类地址占 IPv6 地址总数的 1&#x2F;256。</li><li><strong>本地链路单播地址</strong>　有些单位的网络使用 TCP&#x2F;IP 协议，但<strong>并没有连接到互联网上</strong> 。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。这类地址占 IPv6 地址总数的 1&#x2F;1024。</li><li><strong>全球单播地址</strong> 　使用得最多的一类。IPv6 单播地址的划分方法非常灵活，可以如图 4-48 所示的任何一种。可把整个的 128 比特都作为一个结点的地址。也可用 <em>n</em> 比特作为子网前缀，用剩下的 (128–<em>n</em>) 比特作为接口标识符 (相当于 IPv4 的主机号)。当然也可以划分为三级，用 <em>n</em> 比特作为全球路由选择前缀，用 <em>m</em> 比特作为子网前缀，而用剩下的 (128–<em>n</em>–<em>m</em>) 比特作为接口标识符。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805093530.png"></li></ul></li></ol></li></ul><h2 id="4-6-3-从-IPv4-向-IPv6-过渡"><a href="#4-6-3-从-IPv4-向-IPv6-过渡" class="headerlink" title="4.6.3 从 IPv4 向 IPv6 过渡"></a>4.6.3 从 IPv4 向 IPv6 过渡</h2><ul><li><strong>双协议栈</strong><ol><li><strong>双协议栈</strong>是指在完全过渡到 IPv6 之前，使一部分主机 (或路由器) 装有双协议栈：一个 IPv4 和一个 IPv6。因此双协议栈主机 (或路由器) 既能够和 IPv6 的系统通信，又能够和 IPv4 的系统通信。双协议栈的主机 (或路由器) 记为 IPv6&#x2F;IPv4，表明它同时具有两种 IP 地址：一个 IPv6 地址和一个 IPv4 地址。</li></ol></li><li><strong>隧道技术</strong><ol><li>向 IPv6 过渡的另一种方法是<strong>隧道技术</strong>， 这种方法的要点是在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报。</li><li>要使双协议栈的主机知道 IPv4 数据报里面封装的数据是一个 IPv6 数据报，就必须把 IPv4 首部的协议字段的值设置为 41 (41 表示数据报的数据部分是 IPv6 数据报)。</li></ol></li></ul><h2 id="4-6-4-ICMPv6"><a href="#4-6-4-ICMPv6" class="headerlink" title="4.6.4 ICMPv6"></a>4.6.4 ICMPv6</h2><ul><li>和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数据报。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。</li><li>ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为 ICMPv6 报文，而把另一些报文定义为<strong>邻站发现</strong> ND 报文或<strong>多播听众交付</strong> MLD 报文。其实所有这些报文都是 ICMPv6 报文，只是功能和作用不同而已。</li></ul><h1 id="4-7-IP-多播"><a href="#4-7-IP-多播" class="headerlink" title="4.7 IP 多播"></a>4.7 IP 多播</h1><h2 id="4-7-1-IP-多播的基本概念"><a href="#4-7-1-IP-多播的基本概念" class="headerlink" title="4.7.1 IP 多播的基本概念"></a>4.7.1 IP 多播的基本概念</h2><ul><li>与单播相比，在一对多的通信中，多播可大大节约网络资源。图 4-53(a) 是视频服务器用单播方式向 90 台主机传送同样的视频节目。为此，需要发送 90 个单播，即同一个视频分组要发送 90 个副本。图 4-53(b) 是视频服务器用多播方式向属于同一个多播组的 90 个成员传送节目。这时，视频服务器只需把视频分组当作多播数据报来发送，并且<strong>只需发送一次</strong>。路由器 R<sub>1</sub> 在转发分组时，需要把收到的分组<strong>复制</strong>成 3 个副本，分别向 R<sub>2</sub>、R<sub>3</sub> 和 R<sub>4</sub> 各转发 1个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此<strong>不需要复制分组</strong>，在局域网上的多播组成员都能收到这个视频分组。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805150914.png"></li></ol></li><li>当多播组的主机数很大时 (如成千上万个)，多播明显地减轻网络中各种资源的消耗。在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件。能够运行多播协议的路由器称为<strong>多播路由器</strong>。多播路由器当然也可以转发普通的单播 IP 数据报。</li><li>在互联网上进行多播叫做 <strong>IP 多播</strong>。IP 多播所传送的分组需要使用多播 IP 地址。</li><li>多播数据报的目的地址不能写入主机的 IP 地址。因为在同一时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入如此多的主机 IP 地址。目的地址写入的是多播组的标识符，然后设法让加入到这个多播组的主机 IP 地址与多播组的标识符关联起来。</li><li><strong>多播地址只能用于目的地址，不能用于源地址</strong>。此外，对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，永远不会收到响应。</li><li>IP 多播可以分为两种。一种是在本地局域网上进行硬件多播，另一种是在互联网上进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付多播组的所有成员。</li></ul><h2 id="4-7-2-在局域网上进行硬件多播"><a href="#4-7-2-在局域网上进行硬件多播" class="headerlink" title="4.7.2 在局域网上进行硬件多播"></a>4.7.2 在局域网上进行硬件多播</h2><h2 id="4-7-3-网际组管理协议-IGMP-和多播路由选择协议"><a href="#4-7-3-网际组管理协议-IGMP-和多播路由选择协议" class="headerlink" title="4.7.3 网际组管理协议 IGMP 和多播路由选择协议"></a>4.7.3 网际组管理协议 IGMP 和多播路由选择协议</h2><ul><li><strong>IP 多播需要两种协议</strong><ol><li>图 4-55 是在互联网上传送多播数据报的例子。图中标有 IP 地址的四台主机都参加了一个多播组，其组地址是 226.15.37.123。显然，多播数据报应传送到路由器 R<sub>1</sub>，R<sub>2</sub> 和 R<sub>3</sub>，而不应传送到路由器 R<sub>4</sub>，因为与 R<sub>4</sub> 连接的局域网上现在没有这个多播组的成员。路由器需要用<strong>网际组管理协议</strong> IGMP 来识别多播组的成员信息。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806153909.png"></li><li>图 4-55 强调了 IGMP 的<strong>本地使用范围</strong> 。IGMP 并非在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上等等。IGMP 协议是让<strong>连接在本地局域网</strong>上的多播路由器知道<strong>本局域网上</strong>是否有主机 (严格讲，是主机上的某个进程) 参加或退出了某个多播组。</li></ul></li><li>仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员，需要使用<strong>多播路由选择协议</strong>。</li><li>**多播转发必须动态地适应多播组成员的变化 (这时网络拓扑并未发生变化)**。</li><li><strong>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址</strong>。</li><li><strong>多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络</strong>。</li></ol></li><li><strong>网际组管理协议 IGMP</strong><ol><li>和网际控制报文协议 ICMP 相似，IGMP 使用 IP 数据报传递其报文 (即 IGMP 报文加上 IP 首部构成 IP 数据报)，但它也向 IP 提供服务。因此，IGMP 不是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。</li><li>从概念上讲，IGMP 的工作可分为两个阶段：<ul><li>第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li><li>第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续当组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍没有一台主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li></ul></li><li>IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些具体措施如下：<ul><li>在主机和多播路由器之间的所有通信都是使用 IP 多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加 IP 多播的主机不会收到 IGMP 报文。</li><li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，不需要对每一个组都发送询问报文。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。</li><li>在 IGMP 的询问报文中有一个数值 <em>N</em>，它指明一个最长响应时间。当收到询问时，主机在 0 到 <em>N</em> 之间随机选择发送响应所需经过的时延。因此，若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。</li><li>同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。</li></ul></li><li>多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据报使用硬件多播。多播路由器只需要知道网络上是否至少还有一台主机是本组成员即可。实际上，对询问报文每一个组只需有一台主机发送响应。</li><li>如果一台主机上有多个进程都加入了某个多播组，那么这台主机对发给这个多播组的每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。</li></ol></li><li><strong>多播路由选择协议</strong><ol><li>多播路由选择实际上就是要找出以源主机为根节点的<strong>多播转发树</strong>。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据报，但在多播转发树上的路由器不会收到重复的多播数据报。</li><li>已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：<ul><li><strong>洪泛与剪除</strong>。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。一开始，路由器转发多播数据报使用洪泛的方法 (广播)。为了避免兜圈子，采用了叫做<strong>反向路径广播 RPB</strong> 的策略。RPB 的要点是：每一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进行这种检查很容易，只要从本路由器寻找到源点的最短路径上 (之所以叫做反向路径，因为在计算最短路径时把源点当作终点) 的第一个路由器是否是刚才把多播数据报送来的路由器。若是，就向所有其他方向转发刚才收到的多播数据报 (进入的方向除外)，否则就丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上 (也就是说，存在几条同样长度的最短路径)，那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。图 4-57 的例子说明了这一概念。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806161532.png"></li></ol></li><li><strong>隧道技术</strong>。隧道技术适用于多播组的位置在地理上很分散的情况。例如在图 4-58中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R<sub>1</sub> 和 R<sub>2</sub> 之间的网络并不支持多播，因而 R<sub>1</sub> 和 R<sub>2</sub> 不能按多播地址转发数据报。为此，路由器 R<sub>1</sub> 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的<strong>单播</strong>数据报，然后通过“<strong>隧道</strong>”从 R<sub>1</sub> 发送到 R<sub>2</sub> 。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806161545.png"></li></ol></li><li><strong>基于核心的发现技术</strong>。这种方法对于多播组的大小在较大范围内变化时都适合。对每一个多播组 G 指定一个<strong>核心路由器</strong>，给出它的 IP 单播地址。核心路由器创建出对应于多播组 G 的转发树。如果有一个路由器 R<sub>1</sub> 向这个核心路由器发送数据报，在途中经过的每一个路由器都要检查其内容。当数据报到达参加了多播组 G 的路由器 R<sub>2</sub> 时，R<sub>2</sub> 就处理这个数据报。如果 R<sub>1</sub> 发出的是一个多播数据报，其目的地址是 G 的组地址，R<sub>2</sub> 就向多播组 G 的成员转发这个多播数据报。如果 R<sub>1</sub> 发出的数据报是一个请求加入多播组 G 的数据报，R<sub>2</sub> 就把这个信息加到它的路由中，并用隧道技术向 R<sub>1</sub> 转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。</li></ul></li><li>使用的多播路由选择协议：<ul><li><strong>距离向量多播路由选择协议</strong> DVMRP 是在互联网上使用的第一个多播路由选择协议。它使用 DVMRP 在路由器之间传播路由信息。</li><li><strong>基于核心的转发树 CBT</strong>。这个协议使用核心路由器作为转发树的根节点。一个大的自治系统 AS 可划分为几个区域，每一个区域选择一个核心路由器。</li><li><strong>开放最短通路优先的多播扩展 MOSPF</strong>。这个协议是单播路由选择协议 OSPF 的扩充，使用于一个机构内。MOSPF 使用多播链路状态路由选择创建出基于源点的多播转发树。</li><li><strong>协议无关多播-稀疏方式 PIM-SM</strong>。这个协议使用和 CBT 同样的方法构成多播转发树。“协议无关”强调：虽然在建立多播转发树时是使用单播数据报来和远程路由器联系的，但这并不要求使用特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。</li><li><strong>协议无关多播-密集方式 PIM-DM</strong>。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。PIM-DM 不使用核心路由器，而是使用洪泛方式转发数据报。</li></ul></li></ol></li></ul><h1 id="4-8-虚拟专用网-VPN-和网络地址转换-NAT"><a href="#4-8-虚拟专用网-VPN-和网络地址转换-NAT" class="headerlink" title="4.8 虚拟专用网 VPN 和网络地址转换 NAT"></a>4.8 虚拟专用网 VPN 和网络地址转换 NAT</h1><h2 id="4-8-1-虚拟专用网-VPN"><a href="#4-8-1-虚拟专用网-VPN" class="headerlink" title="4.8.1 虚拟专用网 VPN"></a>4.8.1 虚拟专用网 VPN</h2><ul><li><strong>在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</strong>。RFC 6890 全面地给出了所有特殊用途的 IPv4 地址，但三个专用地址块的指派并无变化，即：<ol><li>10.0.0.0 到 10.255.255.255 (或记为 10.0.0.0&#x2F;8，它又称为 24 位块)</li><li>172.16.0.0 到 172.31.255.255 (或记为 172.16.0.0&#x2F;12，它又称为 20 位块)</li><li>192.168.0.0 到 192.168.255.255 (或记为 192.168.0.0&#x2F;16，它又称为 16 位块)</li></ol></li><li>有时一个机构的许多部门分布的范围很广，这些部门要互相交换信息，有两种方法：<ol><li>租用电信公司的通信线路为本机构专用。这种方法简单方便，但线租金高，一般难于承受。</li><li>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为<strong>虚拟专用网</strong> VPN。</li></ol></li><li>“专用网”是指为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信的网络。如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么<strong>所有通过互联网传送的数据都必须加密</strong>。</li><li>VPN 只是<strong>在效果上</strong>和专用网一样。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</li><li>由场所 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为<strong>内联网</strong>，表示场所 A 和 B 都属于同一个机构。</li><li>有时一个机构的 VPN 需要有某些<strong>外部机构</strong> (通常就是合作伙伴) 参加进来。这样的 VPN 就称为<strong>外联网</strong>。</li><li>还有一种类型的 VPN，是<strong>远程接入</strong> VPN。</li></ul><h2 id="4-8-2-网络地址转换-NAT"><a href="#4-8-2-网络地址转换-NAT" class="headerlink" title="4.8.2 网络地址转换 NAT"></a>4.8.2 网络地址转换 NAT</h2><ul><li>装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个有效的外部全球 IP 地址。</li><li>图 4-60 给出了 NAT 路由器的工作原理。在图中，专用网 192.168.0.0 内所有主机的 IP 地址都是本地 IP 地址 192.168.x.x。NAT 路由器至少要有一个全球 IP 地址，才能和互联网相连。图 4-60 表示出 NAT 路由器有一个全球 IP 地址 172.38.1.5。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806174735.png"></li></ol></li><li>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和互联网上的不同主机进行通信。</li><li>使用端口号的 NAT 也叫做<strong>网络地址与端口号转换</strong> NAPT，而不使用端口号的 NAT 就叫做传统的 NAT。</li></ul><h1 id="4-9-多协议标记交换-MPLS"><a href="#4-9-多协议标记交换-MPLS" class="headerlink" title="4.9 多协议标记交换 MPLS"></a>4.9 多协议标记交换 MPLS</h1><ul><li>MPLS 利用面向连接技术，使每个分组携带一个叫做<strong>标记</strong>的小整数。当分组到达交换机 (即标记交换路由器) 时，交换机读取分组的标记，并用标记值来检索分组转发表，比查找路由表来转发分组要快得多。</li><li>MPLS 常与<strong>异步传递方式</strong> ATM 联系起来，因为它们都采用了面向连接的工作方式。</li><li>MPLS 具有以下三个方面的特点：<ol><li>支持面向连接的服务质量。</li><li>支持流量工程，平衡网络负载。</li><li>有效地支持虚拟专用网 VPN。</li></ol></li></ul><h2 id="4-9-1-MPLS-的工作原理"><a href="#4-9-1-MPLS-的工作原理" class="headerlink" title="4.9.1 MPLS 的工作原理"></a>4.9.1 MPLS 的工作原理</h2><ul><li><strong>基本工作过程</strong><ol><li>在传统的 IP 网络中，分组每到达一个路由器，都必须查找路由表，并按照“最长前缀匹配”的原则找到下一跳的 IP 地址。当网络很大时，查找含有大量项目的路由表要花费很多的时间。在出现突发性的通信量时，往往还会使缓存溢出，引起分组丢失、传输时延增大和服务质量下降。</li><li>MPLS 的一个重要特点是在 MPLS 域的入口处，给每一个 IP 数据报打上固定长度“标记”，<strong>然后对打上标记的 IP 数据报用硬件进行转发</strong>，使 IP 数据报转发的过程大大加快。采用硬件技术对打上标记的 IP 数据报进行转发就称为<strong>标记交换</strong> 。“交换”也表示在转发时不再上升到第三层查找转发表，而是<strong>根据标记在第二层 (链路层) 用硬件进行转发</strong>。MPLS 可使用多种链路层协议，如 PPP、以太网、ATM 以及帧中继等。图 4-61是 MPLS 协议的基本原理的示意图。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175138.png"></li></ul></li><li>MPLS 域是指该域中有许多彼此相邻的路由器，并且所有的路由器都是支持 MPLS 技术的<strong>标记交换路由器</strong> LSR。LSR 同时具有标记交换和路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择功能构造转发表。</li><li>MPLS 的基本工作过程如下：<ul><li>MPLS 域中的各 LSR 使用专门的<strong>标记分配协议 LDP</strong> 交换报文，并找出和特定标记相对应的路径，即<strong>标记交换路径</strong> LSP。例如在图中的路径 A→B→C→D。各 LSR 根据这些路径构造出转发表。这个过程和路由器构造自己的路由表相似。MPLS 是面向连接的，因为在标记交换路径 LSP上 的第一个 LSR 就根据 IP 数据报的初始标记确定了整个的标记交换路径，就像一条虚连接一样。</li><li>当一个 IP 数据报进入到 MPLS 域时，MPLS <strong>入口结点</strong>就给它打上标记，并按照转发表把它转发给下一个 LSR。以后的所有 LSR 都按照标记进行转发；给 IP 数据报打标记的过程叫做<strong>分类</strong>。严格的<strong>第三层 (网络层) 分类</strong>只使用了 IP 首部中的字段，如源 IP 地址和目的 IP 地址等。大多数运营商实现了<strong>第四层 (运输层) 分类</strong>，而有些运营商则实现了<strong>第五层 (应用层) 分类</strong>。</li><li>在全网内统一分配全局标记数值是非常困难的，因此<strong>一个标记仅仅在两个标记交换路由器 LSR 之间才有意义</strong>。分组每经过一个 LSR，LSR 做两件事：一是转发，二是更换新的标记，即把<strong>入标记</strong>更换成为<strong>出标记</strong>。这就叫做<strong>标记对换</strong>。做这两件事所需的数据需要写在转发表中。例如，图 4-61 中的标记交换路由器 B 从入接口 0 收到一个入标记为 3 的 IP 数据报，查找了如下的转发表：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175430.png"></li></ol></li><li>当 IP 数据报离开 MPLS 域时，MPLS <strong>出口结点</strong>就把 MPLS 的标记去除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。</li></ul></li></ol></li><li><strong>转发等价类 FEC</strong><ol><li>MPLS 有个很重要的概念是<strong>转发等价类</strong> FEC。所谓“转发等价类”就是路由器<strong>按照同样方式对待</strong>的 IP 数据报的集合。这里“按照同样方式对待”表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等。FEC 的例子是：<ul><li>目的 IP 地址与某一个特定 IP 地址的前缀匹配的 IP 数据报；</li><li>所有源地址与目的地址都相同的 IP 数据报；</li><li>具有某种服务质量需求的 IP 数据报。</li></ul></li></ol></li></ul><h2 id="4-9-2-MPLS-首部的位置与格式"><a href="#4-9-2-MPLS-首部的位置与格式" class="headerlink" title="4.9.2 MPLS 首部的位置与格式"></a>4.9.2 MPLS 首部的位置与格式</h2><ul><li>MPLS 不要求下层的网络都使用面向连接的技术。因此一对 MPLS 路由器之间的物理连接，既可以由一个专用电路组成，如 OC-48 线路，也可以使用像以太网这样的网络。但是这些网络并不提供打标记的手段，而 IPv4 数据报首部也没有多余的位置存放 MPLS 标记。需要使用一种封装技术：在把 IP 数据报封装成以太网帧之前，先要插入一个 MPLS 首部。从层次的角度看，MPLS 首部就处在第二层和第三层之间 (图 4-63)。在把加上 MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为 8847 16 ，在多播的情况下为 8848 16 。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的 IP 数据报。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175802.png"></li></ol></li><li>图 4-64 给出了 MPLS 首部的格式。给 IP 数据报打上标记其实就是在以太网的帧首部和 IP 数据报的首部之间插入一个 4 字节的 MPLS 首部。具体的标记在“标记值”这个字段中。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175822.png"></li><li>MPLS 首部共包括以下四个字段：<ul><li><strong>标记值</strong> 　占 20 位。由于一个 MPLS 标记占 20 位，因此从理论上讲，在设置 MPLS 时可以使用标记的所有 20 位，因而可以同时容纳高达 2<sup>20</sup> 个流 (即 1048576 个流)。但是，实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管理和设置每条交换路径。</li><li><strong>试验</strong> 　占 3 位，目前保留用于试验。</li><li><strong>栈</strong> S　占 1 位，在有“标记栈”时使用。</li><li><strong>生存时间</strong> TTL　占 8 位，用来防止 MPLS 分组在 MPLS 域中兜圈子。</li></ul></li></ol></li></ul><h1 id="本章重要概念"><a href="#本章重要概念" class="headerlink" title="本章重要概念"></a>本章重要概念</h1><ul><li><p>TCP&#x2F;IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。</p></li><li><p>IP 网是虚拟的，因为从网络层上看，IP 网是一个统一的、抽象的网络。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统一的、抽象的 IP 地址处理主机之间的通信问题。</p></li><li><p>在互联网上的交付有两种：</p><ol><li>在本网络上的直接交付 (不经过路由器) </li><li>到其他网络的间接交付 (经过至少一个路由器，但最后一次一定是直接交付)。</li></ol></li><li><p>一个 IP 地址在整个互联网范围内是唯一的。分类的 IP 地址包括 A 类、B 类和 C 类地址 (单播地址)，以及 D 类地址 (多播地址)。E 类地址未使用。</p></li><li><p>分类的 IP 地址由网络号字段 (指明网络) 和主机号字段 (指明主机) 组成。网络号字段最前面的类别位指明 IP 地址的类别。</p></li><li><p>IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。</p></li><li><p>IP 地址标志一台主机 (或路由器) 和一条链路的接口。多归属主机同时连接到两个或更多的网络上。这样的主机同时具有两个或更多的 IP 地址，其网络号必须是不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。</p></li><li><p>用转发器或网桥连接起来的若干个局域网仍为一个网络。所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网) 都是平等的。</p></li><li><p>物理地址 (硬件地址) 是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，在数据链路层看不见数据报的 IP 地址。</p></li><li><p>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。一些长度可变的可选字段放在固定首部的后面。</p></li><li><p>IP 首部中的生存时间字段给出了 IP 数据报在互联网中所能经过的最大路由器数，可防止 IP 数据报在互联网中兜圈子。</p></li><li><p>地址解析协议 ARP 把 IP 地址解析为硬件地址，它解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。ARP 的高速缓存大大减少网络上的通信量。</p></li><li><p>在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。</p></li><li><p>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线“&#x2F;”，然后写上前缀所占的位数。前缀 (或网络前缀) 用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的IP地址组成一个“CIDR 地址块”。IP 地址的分配都以 CIDR 地址块为单位。</p></li><li><p>CIDR 的 32 位地址掩码 (或子网掩码) 由一串 1 和一串 0 组成，而 1 的个数就是前缀的长度。只要把 IP 地址和地址掩码逐位进行“逻辑与 (AND) ”运算，就很容易得出网络地址。A 类地址的默认地址掩码是 255.0.0.0。B 类地址的默认地址掩码是 255.255.0.0。C 类地址的默认地址掩码是 255.255.255.0。</p></li><li><p>路由聚合 (把许多前缀相同的地址用一个来代替) 有利于减少路由表中的项目，减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p></li><li><p>“转发”和“路由选择”不同。“转发”是单个路由器的动作。“路由选择”是许多路由器共同协作的过程，这些路由器相互交换信息，目的是生成路由表，再从路由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使用路由表这一名词。</p></li><li><p>自治系统 (AS) 是在单一的技术管理下的一组路由器。一个自治系统对其他自治系统表现出的是一个单一的和一致的路由选择策略。</p></li><li><p>路由选择协议有两大类：</p><ol><li>内部网关协议 (或自治系统内部的路由选择协议)，如 RIP 和 OSPF；</li><li>外部网关协议 (或自治系统之间的路由选择协议)，如 BGP-4。</li></ol></li><li><p>RIP 是分布式的基于距离向量的路由选择协议，适用于小型互联网，按固定的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器。</p></li><li><p>OSPF 是分布式的链路状态协议，适用于大型互联网，只在链路状态发生变化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路的“度量”。“度量”可表示费用、距离、时延、带宽等，统称为“代价”。所有的路由器最终都能建立一个全网的拓扑结构图。</p></li><li><p>BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP力求寻找一条能够到达目的网络 (可达) 且比较好的路由 (不兜圈子)，而并非要寻找一条最佳路由。</p></li><li><p>网际控制报文协议 ICMP 是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 并非为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p></li><li><p>ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。</p></li><li><p>要解决 IP 地址耗尽的问题，根本的办法是采用有更大地址空间的新版本 IP 协议，即 IPv6。</p></li><li><p>IPv6 所带来的主要变化是：</p><ol><li>更大的地址空间 (采用 128 位的地址)；</li><li>灵活的首部格式；</li><li>改进的选项；</li><li>支持即插即用；</li><li>支持资源的预分配；</li><li>IPv6 首部改为 8 字节对齐。</li></ol></li><li><p>IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。</p></li><li><p>IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。</p></li><li><p>IPv6 的地址使用冒号十六进制记法。</p></li><li><p>向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的 IPv6 系统能够向后兼容。向 IPv6 过渡可以使用双协议栈或使用隧道技术。</p></li><li><p>与单播相比，在一对多的通信中，IP 多播可大大节约网络资源。IP 多播使用 D 类 IP 地址。IP 多播需要使用网际组管理协议 IGMP 和多播路由选择协议。</p></li><li><p>虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体。VPN 内部使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都必须加密。</p></li><li><p>使用网络地址转换 NAT 技术，可以在专用网络内部使用专用 IP 地址，而仅在连接到互联网的路由器使用全球 IP 地址。这样就大大节约了宝贵的 IP 地址。</p></li><li><p>MPLS 的特点：</p><ol><li>支持面向连接的服务质量；</li><li>支持流量工程，平衡网络负载；</li><li>有效地支持虚拟专用网 VPN。</li></ol></li><li><p>MPLS 在入口结点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层 (链路层) 用硬件进行转发 (在标记交换路由器中进行标记对换)，因而转发速率大大加快。</p></li><li><p>子网划分为什么全0全1子网号不能使用？</p><blockquote><p>看看 RFC950 提到的原因：<br>假设我们有一个网络：192.168.0.0&#x2F;24，我们现在需要两个子网，那么按照 RFC950，应该使用使用两位子网号，即 &#x2F;26，得到两个可以使用的子网 192.168.0.64&#x2F;26 和 192.168.0.128&#x2F;26<br>对于主网络 192.168.0.0&#x2F;24，网络地址是192.168.0.0，广播地址是 192.168.0.255<br>对于子网 192.168.0.0&#x2F;26 (子网号全 0)，网络地址是 192.168.0.0，广播地址是 192.168.0.63<br>对于子网 192.168.0.64&#x2F;26，网络地址是 192.168.0.64，广播地址是 192.168.0.127<br>对于子网 192.168.0.128&#x2F;26，网络地址是 192.168.0.128，广播地址是 192.168.0.191<br>对于子网 192.168.0.192&#x2F;26 (子网号全1)，网络地址是 192.168.0.192，广播地址是 192.168.0.255</p><p>可以看出，对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。这样的重叠将导致极大的混乱。比如，一个发往192.168.0.255 的广播是发给主网络的还是子网的？这就是为什么在当时不建议使用全 0 和全 1 子网。</p></blockquote></li><li><p>IP, ARP, RARP, ICMP 协议的作用：</p><blockquote><p>网际协议 IP: 使用 IP 协议就可以把互连以后的计算机网络看成是一个虚拟互连网络。所谓虚拟互连网络也就是逻辑互连网络，或称为互联网。我们知道，各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用 IP 协议的虚拟互连网络可简称为 IP 网。使用 IP 网的好处是: 当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节 (如具体的编址方案、路由选择协议，等等)。<br>地址解析协议 ARP: 用来把一个机器 (主机或路由器) 的 IP 地址转换为相应的物理地址 (或硬件地址)。<br>逆地址解析协议 RARP: 和 ARP 相反，用来把一个机器 (主机或路由器)的物理地址 (或硬件地址) 转换为相应的 IP 地址。<br>网际控制报文协议 ICMP: 用来使主机或路由器报告差错情况和提供有关异常情况的报告，这样就可以更有效地转发 IP 数据报和提高交付成功的机会。</p></blockquote></li><li><p>IP 地址分为几类？各如何表示？IP 地址的主要特点是什么？</p><blockquote><p>在 IPv4 的地址中，所有的地址都是 32 位，并且可记为: IP 地址 ::&#x3D;&lt;网络号&gt;,主机号&gt;<br>IP 地址共分为五类:<br>A 类地址: 网络号字段为 1 字节，最前面的 1 位是 0<br>B 类地址: 网络号字段为 2 字节，最前面的 2 位是 10。<br>C 类地址: 网络号字段为 3 字节，最前面的 3 位是 110<br>D 类地址: 用于多播，最前面的 4 位是 1110。<br>E 类地址: 保留今后使用，最前面的 4 位是 1111。<br>IP 地址具有以下一些重要特点:<br>(1) 每一个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种分等级的地址结构。<br>(2) 实际上 IP 地址是标志一个主机(或路由器)和一条链路的接口。换言之，IP 地址并不仅仅指明一个主机，同时还指明了主机所连接到的网络。<br>(3) 按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连<br>(4) 在 IP 地址中，所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网) 都是平等的。</p></blockquote></li><li><p>IP 地址与硬件地址的区别，为什么使用两种不同的地址？</p><blockquote><p>从层次的角度看，物理地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址 (称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的)。<br>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的 IP 地址把这个复杂问题解决了。连接到互联网的主机只需拥有统一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便。当需要把 IP 地址转换为物理地址时，调用 ARP 的复杂过程都由计算机软件自动进行，而用户是看不见这种调用过程的。因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来很大的方便。</p></blockquote></li><li><p>IGP 和 EGP 这两类协议的主要区别？</p><blockquote><p>IGP 是内部网关协议，即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。EGP 是外部网关协议。若源主机和目的主机处在不同的自治系统中 (这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4 (BGP-4)。</p></blockquote></li><li><p>试简述 RIP, OSPF 和 BGP 路由选择协议的主要特点。</p><blockquote><p>RIP 是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大优点就是简单。RIP 协议的特点是:<br>(1) 仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。<br>(2) 路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。也就是说，交换的信息是:“我到本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器”。<br>(3) 按固定的时间间隔交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。<br>OSPF 最主要的特征就是使用分布式的链路状态协议。OSPF 协议的特点是:<br>(1) 向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法，这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。<br>(2) 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。<br>(3) 只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。<br>BGP 是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议。BGP 协议的主要特点是:<br>(1) BGP 在自治系统之问交换“可达性”信息 (即“可到达”或“不可到达”)。例如，告诉相邻路由器:“到达目的网络 N 可经过 AS<sub>x</sub>”<br>(2) 自治系统之间的路由选择必须考虑有关策略。<br>(3) BGP 只能是力求寻找一条能够到达目的网络且比较好的路由 (不能兜圈子)，而并非要寻找一条最佳路由。</p></blockquote></li><li><p>IGMP 协议的要点是什么？隧道技术在多播中是怎样使用的？</p><blockquote><p>IGMP 是网际组管理协议，它不是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。IGMP 并非是在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上，等等。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机 (严格讲，是主机上的某个进程) 参加或退出了某个多播组。显然，仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。<br>从概念上讲，IGMP的工作可分为两个阶段。<br>第一阶段: 当某个主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器<br>第二阶段: 组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一个主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。隧道技术适用于多播组的位置在地理上很分散的情况。例如在图 T-4-43 中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R<sub>1</sub> 和 R<sub>2</sub> 之间的网络并不支持多播，因而 R<sub>1</sub> 和 R<sub>2</sub>不能按多播地址转发数据报。为此，路由器 R<sub>1</sub> 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的单播数据报，然后通过“隧道”从 R<sub>1</sub> 发送到 R<sub>2</sub>。<br><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network20231217162537.png"><br>单播数据报到达路由器 R 后，再由路由器 R 剥去其首部，使它又恢复成原来的多播数据报，继续向多个目的站转发。</p></blockquote></li><li><p>VPN 的优缺点：</p><blockquote><p>优点是比专用网造价便宜，缺点是技术复杂，并且当进行加密通信时，需要更加安全的加密措施。</p></blockquote></li><li><p>什么是 NAT ？NAPT 有哪些特点？NAT 的优缺点有哪些？</p><blockquote><p>NAT 是网络地址转换。NAPT 是网络地址与端口号转换，是使用端口号的 NAT。<br>NAP 的优点是可以通过使用 NAT 路由器使专用网用户与互联网用户连接。缺点是通过 NAT 路由器的通信必须由专用网内的主机发起，另一个缺点是当 NAT 路由器只有一个全球 IP 地址时，专用网内部只能有一个主机接入互联网。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 数据链路层</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-3-zhang-shu-ju-lian-lu-ceng/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-3-zhang-shu-ju-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h1><ul><li>数据链路层属于计算机网络的低层。数据链路层使用的信道有以下两种类型：<ol><li><strong>点对点信道</strong>。使用一对一的点对点通信方式。</li><li><strong>广播信道</strong>。使用一对多的广播通信方式，过程复杂。广播信道上连接的主机很多，必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ol></li><li>本章重要的内容：<ol><li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议 (PPP 协议以及 CSMA&#x2F;CD 协议) 的特点。</li><li>数据链路层的三个基本问题：封装成帧、透明传输和差错检测。</li><li>以太网 MAC 层的硬件地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。</li></ol></li></ul><h2 id="3-1-1-数据链路和帧"><a href="#3-1-1-数据链路和帧" class="headerlink" title="3.1.1 数据链路和帧"></a>3.1.1 数据链路和帧</h2><ul><li><strong>链路</strong>是从一个结点<strong>到相邻结点</strong>的一段物理线路，中间没有其他的交换结点。在进行数据通信时，两台计算机之间的通信路径要经过许多段链路。链路只是一条路径的组成部分。</li><li>当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些通信协议控制数据的传输。把实现这些协议的硬件和软件加到链路上，构成了数据链路。常用的方法是使用<strong>网络适配器</strong>来实现协议。一般适配器都包括了数据链路层和物理层这两层的功能。</li><li>数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是 IP 数据报 (或简称为<strong>数据报、分组</strong>或<strong>包</strong>)。</li><li>点对点信道的数据链路层在进行通信时的主要步骤如下：<ol><li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。</li><li>结点 A 把封装好的帧发送给结点 B 的数据链路层。</li><li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。</li></ol></li><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network%7BB2EB60AE-6404-40b9-9EEA-BE05ACDFE73D%7D.png"></li></ul><h2 id="3-1-2-三个基本问腿"><a href="#3-1-2-三个基本问腿" class="headerlink" title="3.1.2 三个基本问腿"></a>3.1.2 三个基本问腿</h2><ul><li>数据链路层协议有多种，但有三个基本问题是共同的：<strong>封装成帧、透明传输和差错检测</strong>：<ol><li><strong>封装成帧</strong><ul><li><strong>封装成帧</strong>是在一段数据的前后添加首部和尾部，构成了一个帧。</li><li>帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。</li><li>首部和尾部的作用是进行<strong>帧定界</strong> (即确定帧的界限)。首部和尾部还包括许多控制信息。</li><li>为了提高帧的传输效率，应当使帧的<strong>数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元</strong>(MTU)。</li><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_networkSnipaste_2023-11-20_16-00-59.png"></li></ul></li><li><strong>透明传输</strong><ul><li>由于帧的开始和结束的标记使用指明的控制字符，因此，所传输的数据中任何 8 比特的组合不允许和用作帧定界的控制字符的比特编码一样，否则会出现帧定界的错误。</li><li>当传送的帧是用文本文件组成的帧时 (文本文件中的字符都是从键盘上输入的)，其数据部分不会出现像 SOH 或 EOT 这样的帧定界控制字符。不管从键盘上输入什么字符都可以放在这样的帧中传输过去，这样的传输就是透明传输。</li><li>当数据部分是非 ASCII 码的文本文件时 (如二进制代码的计算机程序或图像等)。如果数据中的某个字节的二进制代码和 SOH 或 EOT 这种控制字符一样 (见图 3-6)，数据链路层会<strong>错误地</strong>找到帧的边界，把部分帧收下，而把剩下的那部分数据丢弃。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711095956.png"></li></ol></li><li>解决透明传输问题，必须使<strong>数据中</strong>可能出现的控制字符 SOH 和 EOT 在接收端不被解释为控制字符。方法是：发送端的数据链路层在数据中出现控制字符的前面插入一个<strong>转义字符</strong> ESC。在接收端的数据链路层，在把数据送往网络层之前删除插入的转义字符。这被称为<strong>字节填充</strong>或<strong>字符填充</strong>。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。图 3-7 表示用字节填充法解决透明传输的问题。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711100111.png"></li></ol></li></ul></li><li><strong>差错检测</strong><ul><li>现实的通信链路不是理想的。比特在传输过程中可能会产生差错：1 可能变成 0，而 0 可能变成 1。这就叫做<strong>比特差错</strong>。比特差错是传输差错中的一种。</li><li>一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong> (BER)。</li><li>为保证数据传输的可靠性，在数据链路层广泛使用<strong>循环冗余检验</strong> (CRC) 的检错技术。</li><li>通过例子说明循环冗余检验的原理。<ol><li>在发送端，把数据划分为组，假定每组 <em>k</em> 个比特。待传送的数据 <em>M</em>＝101001 (<em>k</em>＝6)。CRC 运算就是在数据 <em>M</em> 的后面添加供差错检测用的 <em>n</em> 位<strong>冗余码</strong>，构成一个帧发送出去，一共发送 (<em>k</em> ＋ <em>n</em>) 位。在所要发送的数据后面增加 <em>n</em> 位的冗余码，虽然增大了数据传输的开销，但可以进行差错检测。</li><li>这 <em>n</em> 位冗余码可用以下方法得出。用二进制的<strong>模 2 运算</strong>进行 2<sup>n</sup> 乘 <em>M</em> 的运算，这相当于在 <em>M</em> 后面添加 <em>n</em> 个 0。得到的 (<em>k</em>＋<em>n</em>) 位的数除以收发双方事先商定的长度为 (<em>n</em>＋1) 位的除数 <em>P</em>，得出商是 <em>Q</em> 而余数是 <em>R</em> (<em>n</em> 位，比 <em>P</em> 少一位)。在图 3-8 所示的例子中，<em>M</em>＝101001 (即 <em>k</em>＝6)。假定除数 <em>P</em>＝1101 (即 <em>n</em>＝3)。经模 2 除法运算后的结果是：商 <em>Q</em>＝110101 (这个商并没有什么用处)，余数 <em>R</em>＝001。余数 <em>R</em> 作为冗余码拼接在数据 <em>M</em> 的后面发送出去。这种为了进行检错而添加的冗余码常称为<strong>帧检验序列</strong> (FCS)。因此加上 FCS 后发送的帧是 101001001，共有 (<em>k</em>＋<em>n</em>) 位。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711102631.png"></li></ol></li><li>循环冗余检验 CRC 和帧检验序列 FCS 并不是同一个概念。CRC 是一种<strong>检错方法</strong>，而 FCS 是添加在数据后面的<strong>冗余码</strong>，在检错方法上可选用 CRC，也可不选用 CRC。</li><li>在接收端对收到的每一帧经过 CRC 检验后，有两种情况：<ol><li>得出的余数 <em>R</em>＝0，判定这个帧没有差错，接受。</li><li>余数 <em>R</em>≠0，这个帧有差错 (但无法确定究竟是哪一位或哪几位出现了差错)，丢弃。</li></ol></li><li>用多项式来表示循环冗余检验过程。用多项式 <em>P</em>(<em>X</em>) ＝<em>X</em><sup>3</sup> ＋<em>X</em><sup>2</sup>＋1表示上面的除数 <em>P</em>＝1101 (最高位对应于 <em>X</em><sup>3</sup>，最低位对应于 <em>X</em><sup>0</sup>)。多项式 <em>P</em>(<em>X</em>) 称为<strong>生成多项式</strong>。现在广泛使用的生成多项式 <em>P</em>(<em>X</em>) 有以下几种：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711104339.png"></li></ol></li><li>在数据链路层，发送端帧检验序列 FCS 的生成和接收端的 CRC 检验都是用硬件完成的，处理很迅速，不会延误数据的传输。</li><li>在数据链路层若<strong>仅仅</strong>使用循环冗余检验 CRC 差错检测技术，只能做到对帧的<strong>无差错接受</strong>，即：“<strong>凡是接收端数据链路层接受的帧均无差错</strong>”。</li><li>传输差错分为两大类：<ol><li>最基本的比特差错</li><li>收到的帧并没有出现比特差错，却出现了<strong>帧丢失、帧重复</strong>或<strong>帧失序</strong>。例如，发送方连续传送三个帧：1，2，3。假定接收端收到的每一个帧都没有比特差错，但却出现下面的几种情况：<ul><li><strong>帧丢失</strong> ：收到 1，3 (丢失 2)。</li><li><strong>帧重复</strong> ：收到1，2，2，3 (收到两个 2)。</li><li><strong>帧失序</strong> ：收到1，3，2 (后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样)。</li></ul></li></ol></li><li>现在的通信线路的质量大大提高，由通信链路质量不好引起差错的概率大大降低。现在互联网采取了区别对待的方法：<ol><li>对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议来完成。</li><li>对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</li></ol></li></ul></li></ol></li></ul><h1 id="3-2-点对点协议-PPP"><a href="#3-2-点对点协议-PPP" class="headerlink" title="3.2 点对点协议 PPP"></a>3.2 点对点协议 PPP</h1><ul><li>在通信线路质量较差的年代，使用可靠传输协议是种好办法，能实现可靠传输的<strong>高级数据链路控制</strong> (HDLC) 成为流行的数据链路层协议。对于点对点的链路，简单的<strong>点对点协议</strong> (PPP) 是目前使用得最广泛的数据链路层协议。</li></ul><h2 id="3-2-1-PPP-协议的特点"><a href="#3-2-1-PPP-协议的特点" class="headerlink" title="3.2.1 PPP 协议的特点"></a>3.2.1 PPP 协议的特点</h2><ul><li>PPP 协议是用户计算机和 ISP 进行通信时使用的数据链路层协议。</li><li><strong>PPP 协议应满足的需求</strong><ol><li><strong>简单</strong> 　在设计互联网体系结构时复杂的部分在 TCP 协议中，而网际协议 IP 比较简单，它提供的是不可靠的数据报服务。在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。</li><li><strong>封装成帧</strong> 　PPP 协议规定特殊的字符作为<strong>帧定界符</strong>，以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</li><li><strong>透明性</strong> 　PPP 协议保证数据传输的透明性。如果数据中碰巧出现了和帧定界符一样的比特组合时，要采取有效的措施来解决问题。</li><li><strong>多种网络层协议</strong> 　PPP 协议能够在<strong>在同一条物理链路上同时支持多种网络层协议</strong> (如 IP 和 IPX 等) 的运行。当点对点链路所连接的是局域网或路由器时，PPP 协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。</li><li><strong>多种类型链路</strong> 　除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。</li><li><strong>差错检测</strong> 　PPP 协议必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong>。若在数据链路层不进行差错检测，那么出现差错的无用帧还要在网络中继续向前转发，白白浪费许多的网络资源。</li><li><strong>检测连接状态</strong> 　PPP 协议必须具有一种能够及时自动检测出链路是否处于正常工作状态的机制。当出现故障的链路隔了一段时间后又重新恢复正常工作时，就需要这种及时检测功能。</li><li><strong>最大传送单元</strong> 　PPP 协议必须对每种类型的点对点链路设置<strong>最大传送单元</strong> MTU 的标准默认值，目的是为了促进各种实现之间的互操作性。如果高层协议发送的分组过长并超过 MTU 的数值，PPP 就要丢弃这样的帧，并返回差错。MTU 是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，<strong>不是帧的总长度</strong>。</li><li><strong>网络层地址协商</strong> 　PPP 协议必须提供一种机制使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址。协商的算法应尽可能简单，并且能够在所有的情况下得出协商结果。</li><li><strong>数据压缩协商</strong> 　PPP 协议必须提供一种方法来协商使用数据压缩算法。但 PPP 协议并不要求将数据压缩算法进行标准化。</li></ol></li><li><strong>PPP 协议的组成</strong><ol><li>一个将 IP 数据报封装到串行链路的方法。PPP 既支持异步链路，也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。</li><li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议</strong> (LCP)。</li><li>一套<strong>网络控制协议</strong> (NCP)，其中的每一个协议支持不同的网络层协议。</li></ol></li></ul><h2 id="3-2-2-PPP-协议的帧格式"><a href="#3-2-2-PPP-协议的帧格式" class="headerlink" title="3.2.2 PPP 协议的帧格式"></a>3.2.2 PPP 协议的帧格式</h2><ul><li><strong>各字段的意义</strong><ol><li>PPP 的帧格式如图 3-10 所示。PPP 帧的首部和尾部分别为四个字段和两个字段。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714175950.png"></li><li>首部的第一个字段和尾部的第二个字段都是标志字段 F (Flag)，规定为 0x7E (符号“0x”表示它后面的字符是用十六进制表示的。十六进制的 7E 的二进制表示是 01111110)。标志字段表示一个帧的开始或结束。因此标志字段就是 PPP 帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃；首部中的地址字段 A 规定为 0xFF (即 11111111)，控制字段 C 规定为 0x03 (即 00000011)。这两个字段并没有携带 PPP 帧的信息；PPP 首部的第四个字段是 2 字节的协议字段。当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。若为 0xC021，则信息字段是 PPP 链路控制协议 LCP 的数据，而 0x8021 表示这是网络层的控制数据；信息字段的长度是可变的，不超过 1500 字节；尾部中的第一个字段 (2 字节) 是使用 CRC 的帧检验序列 FCS。</li></ol></li><li><strong>字节填充</strong><ol><li>PPP 使用异步传输时，把转义符定义为 0x7D (即 01111101)，并使用<strong>字节填充</strong>，RFC 1662 规定了如下所述的填充方法：<ul><li>把信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D，0x5E)。</li><li>若信息字段中出现一个 0x7D 的字节 (即出现了和转义字符一样的比特组合)，则把 0x7D 转变成为 2 字节序列 (0x7D，0x5D)。</li></ul></li></ol></li><li><strong>零比特填充</strong><ol><li>PPP 协议用在 SONET&#x2F;SDH 链路时，使用同步传输 (一连串的比特连续传送) 而不是异步传输 (逐个字符地传送)。在这种情况下，PPP 协议采用零比特填充方法来实现透明传输。</li><li>零比特填充的做法是：在发送端，扫描整个信息字段。只要发现有 5 个连续 1，则立即填入一个 0。因此经过这种零比特填充后的数据，可以保证在信息字段中不会出现 6 个连续 1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除，以还原成原来的信息比特流 (图 3-11)。这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714180243.png"></li></ol></li></ul><h2 id="3-2-3-PPP-协议的工作状态"><a href="#3-2-3-PPP-协议的工作状态" class="headerlink" title="3.2.3 PPP 协议的工作状态"></a>3.2.3 PPP 协议的工作状态</h2><ul><li>当用户拨号接入 ISP 后，建立了一条从用户个人电脑到 ISP 的物理连接。这时，用户个人电脑向 ISP 发送一系列的链路控制协议 LCP 分组 (封装成多个 PPP 帧)，以便建立 LCP 连接。这些分组及其响应选择了将要使用的一些 PPP 参数。接着进行网络层配置，网络控制协议 NCP 为新接入的用户个人电脑分配一个临时的 IP 地址。用户个人电脑成为互联网上的一个有 IP 地址的主机；当用户通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放物理层的连接。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_RR12G7EOJ~98TROOF1YPF_Y.png"></li><li>PPP 链路的起始和终止状态永远是图 3-12 中的“<strong>链路静止</strong>”状态，这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接。</li><li>当用户个人电脑通过调制解调器呼叫路由器时，路由器能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP 进入“<strong>链路建立</strong>”状态，目的是建立链路层的 LCP 连接。</li><li>这时 LCP 开始协商<strong>配置选项</strong>，即发送 LCP 的<strong>配置请求帧</strong>。这是个 PPP 帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：<ul><li><strong>配置确认帧</strong>　所有选项都接受</li><li><strong>配置否认帧</strong>　所有选项都理解但不能接受。</li><li><strong>配置拒绝帧</strong>　选项有的无法识别或不能接受，需要协商。</li></ul></li><li>LCP 配置选项包括链路上的最大帧长、所使用的<strong>鉴别协议</strong>的规约，以及不使用 PPP 帧中的地址和控制字段。</li><li>协商结束后双方就建立了 LCP 链路，接着就进入“<strong>鉴别</strong>”状态。在这一状态，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用<strong>口令鉴别协议</strong> (PAP)，发起通信的一方需要发送身份标识符和口令。系统允许用户重试若干次。如果需要有更好的安全性，可使用更加复杂的<strong>口令握手鉴别协议</strong> (CHAP)。若鉴别身份失败，则转到“<strong>链路终止</strong>”状态。若鉴别成功，则进入“<strong>网络层协议</strong>”状态。</li><li>在“<strong>网络层协议</strong>”状态，PPP 链路两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。现在的路由器能同时支持多种网络层协议。PPP 协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个 PPP 协议进行通信。</li><li>如果在 PPP 链路上运行的是 IP 协议，则对 PPP 链路的每一端配置 IP 协议模块时要使用 NCP 中支持 IP 的协议——IP <strong>控制协议</strong> (IPCP)。IPCP 分组也封装成 PPP 帧 (其中的协议字段为 0x8021) 在 PPP 链路上传送。在低速链路上运行时，双方可以协商使用压缩的 TCP 和 IP 首部，以减少在链路上发送的比特数。</li><li>网络层配置完毕后，链路进入可进行数据通信的“<strong>链路打开</strong>”状态。链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可发送<strong>回送请求</strong> LCP 分组和<strong>回送回答</strong> LCP 分组，以检查链路的状态。</li><li>数据传输结束后，可以由链路的一端发出<strong>终止请求</strong> LCP 分组请求终止链路连接，在收到对方发来的<strong>终止确认</strong> LCP 分组后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，会从“<strong>链路打开</strong>”状态转到“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”状态。</li></ol></li></ul><h1 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h1><h2 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h2><ul><li>局域网按网络拓扑进行分类。图 3-13(a) 是<strong>星形网</strong> 。由于<strong>集线器</strong>的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了广泛的应用。图 3-13(b) 是<strong>环形网</strong> ，图 3-13(c) 为<strong>总线网</strong>，各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。总线网以传统以太网最为著名。局域网经过了四十年的发展，以太网已经在局域网市场中占据了绝对优势。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714234326.png"></li></ol></li><li>共享信道要着重考虑的一个问题是如何使众多用户能够合理而方便地共享通信媒体资源。在技术上有两种方法：<ol><li><strong>静态划分信道</strong>，如频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价高，不适合局域网使用。</li><li><strong>动态媒体接入控制</strong> ，又称<strong>多点接入</strong>，特点是信道并非在用户通信时固定分配给用户。分为两类：<ul><li><strong>随机接入</strong> 　特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，在共享媒体上会产生<strong>碰撞</strong> (即发生了<strong>冲突</strong>)，使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</li><li><strong>受控接入</strong> 　特点是用户不能随机地发送信息，必须服从控制。典型代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询</strong>，或称为<strong>轮询</strong>。</li></ul></li></ol></li><li><strong>以太网的两个标准</strong><ol><li>为了使数据链路层能更好地适应多种局域网标准，局域网的数据链路层又拆成两个子层，即<strong>逻辑链路控制</strong> (LLC) 子层和<strong>媒体接入控制</strong> (MAC) 子层。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230715094124.png"></li></ol></li><li><strong>适配器的作用</strong><ol><li>适配器的一个功能是：进行数据串行传输和并行传输的转换。</li><li>适配器所实现的功能包含了数据链路层及物理层这两个层次的功能。</li><li>计算机的硬件地址在适配器的 ROM 中，而软件地址——IP 地址，在计算机的存储器中。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230715095506.png"></li></ol></li></ul><h2 id="3-3-2-CSMA-CD-协议"><a href="#3-3-2-CSMA-CD-协议" class="headerlink" title="3.3.2 CSMA&#x2F;CD 协议"></a>3.3.2 CSMA&#x2F;CD 协议</h2><ul><li>局域网上的计算机被称为“<strong>主机</strong>”、“<strong>工作站</strong>”、“<strong>站点</strong>”或“<strong>站</strong>”。</li><li>为了通信的简便，以太网采取两种措施：<ol><li>采用灵活的<strong>无连接</strong>的工作方式，不必先建立连接，可以直接发送数据。适配器对发送的数据帧<strong>不进行编号，也不要求对方发回确</strong>。<strong>以太网提供的服务是尽最大努力的交付</strong>，即<strong>不可靠的交付</strong>。当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。<strong>对有差错帧是否需要重传则由高层来决定</strong>。例如，如果高层使用 TCP 协议，那么 TCP 就会发现丢失了一些数据。于是经过一定的时间后，TCP 就把这些数据重新传递给以太网进行重传。<strong>但以太网并不知道这是重传帧，而是当作新的数据帧来发送</strong>。</li><li>以太网发送的数据使用<strong>曼彻斯特编码</strong>的信号。二进制基带数字信号通常是高、低电压交替出现的信号。使用这种信号的问题是当出现一长串的连 1 或连 0 时，接收端就无法从收到的比特流中提取位同步 (即比特同步) 信号。如图 3-16 所示，曼彻斯特编码的编码方法是把每一个码元分成两个相等的间隔。码元 1 是前一个间隔为低电压而后一个间隔为高电压。码元 0 则正好相反，从高电压变到低电压 (也可采用相反的约定，即 1 是“前高后低”而 0 是“前低后高”)，保证了在每一个码元的正中间出现一次电压的转换，接收端利用这种电压的转换很方便地把位同步信号提取出来。缺点是它所占的频带宽度比原始的基带信号增加了一倍 (因为每秒传送的码元数加倍了)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716104158.png"></li></ul></li></ol></li><li>CSMA&#x2F;CD 协议的要点：<ol><li><strong>多点接入</strong>　　总线型网络，计算机以多点接入的方式连接在一根总线上。实质是”载波监听”和”碰撞检测”。</li><li><strong>载波监听</strong>　　用电子技术检测总线上有没有其他计算机也在发送。载波监听是检测信道。<strong>不管在发送前，还是在发送中，每个站都必须不停地检测信道</strong>。在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则暂时不发送数据，等到信道变为空闲时才发送。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。</li><li><strong>碰撞检测</strong>　　<strong>边发送边监听</strong>，即适配器边发送数据边检测信道上的信号电压的变化情况，以判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度会增大 (互相叠加)。当适配器检测到信号电压变化幅度超过门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，总线上传输的信号严重失真，无法从中恢复出有用的信息来。任何一个正在发送数据的站，一旦发现总线上出现了碰撞，其适配器要停止发送。“碰撞检测”也称为“<strong>冲突检测</strong>”。</li><li>因为电磁波在总线上以有限的速率传播，所以即使每个站在发送数据之前已经监听到信道为“<strong>空闲</strong>”，还会出现数据在总线上的碰撞。这和开会相似，一听见会场安静，我们就立即发言，但偶尔也会发生几个人同时抢着发言而产生冲突的情况。</li><li>图 3-17 所示的例子可以说明这种情况。设图中的局域网两端的站 A 和 B 相距 1km，用同轴电缆相连。<strong>电磁波在</strong> 1km <strong>电缆的传播时延约为</strong> 5µs。因此，A 向 B 发出的数据，在约 5µs 后才能传送到 B。 若在 A 发送的数据到达 B 前，B 也发送，则在某个时间和 A 发送的帧会发生碰撞。碰撞的结果是两个帧都变得无用。在局域网的分析中，常把总线上的<strong>单程端到端传播时延</strong>记为 τ。A 发送数据后，<strong>最迟要两倍的总线端到端的传播时延</strong> (2τ)，或总线的端到端往返传播时延才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延  (这两个站之间的距离最大) 为端到端传播时延。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716104615.png"><ul><li>下面是图 3-17 中的一些重要的时刻。<br> 在 <em>t</em>＝0 时，A 发送数据。B 检测到信道为空闲。<br> 在 <em>t</em>＝<em>τ−δ</em> 时，A 发送的数据还没有到达 B 时，由于 B 检测到信道是空闲的，因此 B 发送数据。<br> 经过时间 <em>δ</em>&#x2F;2 后，即在 <em>t</em>＝<em>τ−δ</em>&#x2F;2 时，A 发送的数据和 B 发送的数据发生了碰撞。但这时 A 和 B 都不知道发生了碰撞。<br> 在 <em>t</em>＝<em>τ</em>  时，B 检测到发生了碰撞，于是停止发送数据。<br> 在 <em>t</em>＝2<em>τ−δ</em> 时，A 也检测到发生了碰撞，因而也停止发送数据。<br> A 和 B 发送数据均失败，它们都要推迟一段时间再重新发送。</li><li><strong>每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性</strong>。这一小段时间是<strong>不确定的</strong>，它取决于另一个发送数据的站到本站的距离。因此，以太网<strong>不能保证</strong>某一时间之内一定能够把自己的数据帧成功地发送出去。这一特点称为<strong>发送的不确定性</strong>。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</li><li>从图 3-17 可看出，最先发送数据帧的 A 站，在发送数据帧后<strong>至多</strong>经过时间 2<em>τ</em> 就可知道所发送的数据帧是否遭受了碰撞。这就是 <em>δ</em>→0 的情况。因此以太网的端到端往返时间 2<em>τ</em> 称为<strong>争用期</strong>。争用期又称为<strong>碰撞窗口</strong>。因为一个站在发送完数据后，只有通过争用期的“考验”，即<strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。这时，就可以放心把这一帧数据顺利发送完毕。</li></ul></li><li>在使用 CSMA&#x2F;CD 协议时，一个站<strong>不能同时进行发送和接收 (但必须边发送边监听信道</strong>)，以太网不能进行全双工通信而只能进行**双向交替通信 (半双工通信)**。</li><li>以太网使用<strong>截断二进制指数退避</strong>算法确定碰撞后重传的时机。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后立即再发送数据，而是<strong>推迟</strong> (即退避 ) 一个随机的时间。因为如果几个发生碰撞的站都在监听信道，那么都会同时发现信道变成了空闲。如果大家都同时再重新发送，那么肯定又会发生碰撞。为了使各站进行重传时再次发生冲突的概率减小，具体的退避算法如下：<ul><li>协议规定了基本退避时间为争用期 2<em>τ</em>，具体的<strong>争用期时间是</strong> 51.2µs。对于 10Mbit&#x2F;s 以太网，在争用期内可发送 512bit，即 64 字节。也可以<strong>直接使用比特作为争用期的单位</strong>，争用期是 512bit，即发送 512bit 所需的时间。</li><li>从离散的整数集合［0，1，…，(2<em>k</em> −1)］中随机取出一个数，记为 <em>r</em>。重传应推后的时间就是 <em>r</em> 倍的争用期。参数 <em>k</em> 按下面的公式 (3-1) 计算：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716154602.png"></li><li>可见当重传次数不超过 10 时，参数 <em>k</em> 等于重传次数；但当重传次数超过 10 时，<em>k</em> 就等于 10。</li></ol></li><li>当重传达 16 次仍不能成功时，则丢弃该帧，并向高层报告。</li></ul></li><li>以太网在发送数据时，如果在争用期 (共发送了 64 字节) 没有发生碰撞，那么后续发送的数据就一定不会发生冲突。如果发生碰撞，一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节，因此<strong>凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧</strong>。只要收到了这种无效帧，就应当立即将其丢弃。</li><li><strong>强化碰撞</strong>是当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送 32 比特或 48 比特的<strong>人为干扰信号</strong>，以便让所有用户都知道现在已经发生了碰撞。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716154825.png"></li><li>A 站从发送数据开始到发现碰撞并停止发送的时间间隔是 *T<sub>B</sub>*。A 站得知碰撞已经发生时所发送的强化碰撞的干扰信号的持续时间是 <em>T<sub>J</sub></em> 。图中的 B 站在得知发生碰撞后，也要发送人为干扰信号。发生碰撞使 A浪费时间 <em>T<sub>B</sub></em> ＋ <em>T<sub>J</sub><em>。可是整个信道被占用的时间还要增加一个单程端到端的传播时延 t。因此总线被占用的时间是 <em>T<sub>B</sub></em> ＋</em>T<sub>J</sub></em> ＋τ。</li></ul></li><li>CSMA&#x2F;CD 协议的要点如下：<ul><li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须<strong>先检测信道</strong>。</li><li>检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲 (保证了帧间最小间隔)，就发送这个帧。</li><li>在发送过程中仍不停地检测信道，即网络适配器要<strong>边发送边监听</strong>。有两种可能性：<ol><li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 (1)。</li><li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 <em>r</em> 倍 512 比特时间后，返回到步骤(2)，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。</li></ol></li></ul></li></ol></li></ul><h2 id="3-3-3-使用集线器的星形拓扑"><a href="#3-3-3-使用集线器的星形拓扑" class="headerlink" title="3.3.3 使用集线器的星形拓扑"></a>3.3.3 使用集线器的星形拓扑</h2><ul><li>10BASE-T <strong>双绞线以太网的出现，是局域网发展史上的一个重要的里程碑</strong>，从此以太网的拓扑就从总线型变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。双绞线比无源电缆可靠、价格便宜且使用方便。</li><li>使双绞线能够传送高速数据的措施是把双绞线的绞合度做得非常精确。这样不仅可使特性阻抗均匀以减少失真，而且减少了电磁波辐射和无线电频率的干扰。</li><li>集线器的特点如下：<ol><li>从表面上看，使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一个传统以太网那样运行。<strong>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是 CSMA&#x2F;CD 协议</strong>。网络中的各站必须竞争对传输媒体的控制，并且在<strong>同一时刻至多只允许一个站发送数据</strong>。</li><li>一个集线器有许多<strong>接口</strong>，用两对双绞线与一台计算机上的适配器相连，很像一个<strong>多接口的转发器</strong>。</li><li><strong>集线器工作在物理层</strong>，它的每个接口仅仅<strong>简单地转发比特</strong>——收到 1 就转发 1，收到 0 就转发 0，<strong>不进行碰撞检测</strong>。若两个接口同时有信号输入 (即发生碰撞)，那么所有的接口都将收不到正确的帧。图 3-20 是具有三个接口的集线器的示意图。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716163035.png"></li></ul></li><li>集线器采用专门的芯片，进行自适应串音回波抵消。可使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰 (这种干扰即近端串音)。每个比特在转发之前还要进行再生整形并重新定时。</li></ol></li></ul><h2 id="3-3-4-以太网的信道利用率"><a href="#3-3-4-以太网的信道利用率" class="headerlink" title="3.3.4 以太网的信道利用率"></a>3.3.4 以太网的信道利用率</h2><ul><li>一个站在发送帧时出现了碰撞。经过一个争用期 2<em>τ</em> 后，可能又出现了碰撞，经过若干个争用期后发送成功。假定发送帧需要的时间是 *T<sub>0</sub>*。它等于帧长 (bit) 除以发送速率 (10Mbit&#x2F;s)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716221408.png"></li><li>成功发送一个帧需要占用信道的时间是 <em>T<sub>0</sub></em>+<em>τ</em>，比这个帧的发送时间要多一个单程端到端时延 <em>τ</em>。这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。在极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是 <em>τ</em>。因此，必须在经过时间 <em>T<sub>0</sub></em>+<em>τ</em> 后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</li><li>要提高以太网的信道利用率，就必须减小 <em>τ</em> 与 <em>T<sub>0</sub></em> 之比。在以太网中定义了参数 <em>a</em>，它是以太网<strong>单程端到端时延</strong> <em>τ</em> 与<strong>帧的发送时间</strong> <em>T<sub>0</sub></em> 之比：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716222853.png"></li><li>当 <em>a</em>→0 时，表示只要发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常少。反之，表明争用期所占的比例越大，使得每发生一次碰撞就浪费了不少的信道资源，信道利用率明显降低。因此，以太网的<strong>参数</strong> <em>a</em> <strong>的值应当尽可能小些</strong> 。这就要求分子 <em>τ</em> 的数值要小些，分母 <em>T<sub>0</sub></em> 的数值要大些。当数据率一定时，<strong>以太网的连线的长度受到限制</strong>，同时<strong>以太网的帧长不能太短</strong>。</li></ul></li><li>考虑一种<strong>理想化</strong>的情况。假定以太网上的各站发送数据都不会产生碰撞，并且能够有效地利用网络的传输资源，即总线一旦空闲就有某一个站立即发送数据。这样，发送一帧占用线路的时间是 <em>T<sub>0</sub></em> ＋<em>τ</em>，而帧本身的发送时间是 *T<sub>0</sub>*。于是我们可计算出极限信道利用率 <em>S<sub>max</sub></em> 为：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716225325.png"></li><li>虽然实际的以太网不可能有这样高的极限信道利用率，<strong>只有当参数</strong> <em>a</em> <strong>远小于 1 才能得到尽可能高的极限信道利用率</strong>。若参数 <em>a</em> 远大于1，则极限信道利用率就远小于 1，实际的信道利用率就更小了。据统计，当以太网的利用率达到 30％ 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</li></ul></li></ol></li></ul><h2 id="3-3-5-以太网的-MAC-层"><a href="#3-3-5-以太网的-MAC-层" class="headerlink" title="3.3.5 以太网的 MAC 层"></a>3.3.5 以太网的 MAC 层</h2><ul><li><strong>MAC 层的硬件地址</strong><ol><li>在局域网中，<strong>硬件地址</strong>又称<strong>物理地址</strong>或 <strong>MAC 地址</strong> (因为这种地址用在 MAC 帧中)。</li><li>在所有计算机系统的设计中，<strong>标识系统</strong>都是一个核心问题。在标识系统中，地址是识别某个系统的标识符。<ul><li><strong>名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处</strong>。</li><li><strong>严格地讲，名字与系统的所在地无关</strong>。就像我们每一个人的名字一样，不随我们所处的地点而改变。但是 IEEE 802 标准为局域网规定了一种 48 位的全球地址，是指局域网上的每一台计算机中<strong>固化在适配器的 ROM 中的地址</strong>。<ol><li>假定连接在局域网上的一台计算机的适配器坏了，我们更换了一个新的适配器，那么这台计算机的局域网的“地址”就改变了。</li><li>假定我们把位于南京的某局域网上的一台笔记本电脑携带到北京，并连接在北京的某局域网上。虽然这台电脑的地理位置改变了，但只要电脑中的适配器不变，那么该电脑在北京的局域网中的“地址”仍然和它在南京的局域网中的“地址”一样。</li></ol></li></ul></li><li>在生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM 中。因此，MAC 地址也叫做<strong>硬件地址</strong>或<strong>物理地址</strong>，实际上就是<strong>适配器地址</strong>或<strong>适配器标识符</strong> EUI-48。当这块适配器插入(或嵌入) 到某台计算机后，适配器上的标识符 EUI-48 就成为这台计算机的 MAC 地址了。</li><li>地址记法中有两种标准：<ul><li>第一种记法是把每一字节的<strong>最低位</strong>写在最左边 (最左边的最低位是第一位)。</li><li>第二种记法是把每一字节的<strong>最高位</strong>写在最左边 (最左边的最高位是第一位)。</li><li>在发送数据时，两种记法都是按照字节的顺序发送，但每一个字节中先发送哪一位则不同：第一种记法先发送最低位，第二种记法先发送最高位。</li></ul></li><li>适配器有<strong>过滤功能</strong>。但适配器从网络上每收到一个 MAC 帧就先用硬件检查 MAC 帧中的目的地址。如果是发往本站的帧，则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。这里“发往本站的帧”包括以下三种帧：<ul><li><strong>单播帧</strong> (一对一)，即收到的帧的 MAC 地址与本站的硬件地址相同。</li><li><strong>广播帧</strong> (一对全体)，即发送给本局域网上所有站点的帧 (全 1 地址)。</li><li><strong>多播帧</strong> (一对多)，即发送给本局域网上一部分站点的帧。</li></ul></li></ol></li><li><strong>MAC 帧的格式</strong><ol><li>常用的以太网 MAC 帧格式有两种标准，一种是 DIX Ethernet V2 标准 (即以太网 V2 标准)，另一种是 IEEE 的 802.3 标准。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717111013.png"></li></ul></li><li>以太网 V2 的 MAC 帧较为简单，由五个字段组成。前两个字段分别为 6 字节长的<strong>目的地址</strong>和<strong>源地址</strong>字段。第三个字段是 2 字节的<strong>类型字段</strong>，用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。第四个字段是<strong>数据字段</strong>，其长度在 46 到 1500 字节之间 (46 字节是这样得出的：最小长度 64 字节减去 18 字节的首部和尾部就得出数据字段的最小长度)。最后一个字段是 4 字节的<strong>帧检验序列</strong> FCS (使用 CRC 检验)。当传输媒体的误码率为 1×10<sup>−8</sup> 时，MAC 子层可使未检测到的差错小于 1×10<sup>−14</sup>。</li><li>为了接收端实现位同步，从 MAC 子层向下传到物理层时要在帧的前面插入 8 字节 (由硬件生成)，它由两个字段构成：<ul><li>7 个字节的<strong>前同步码</strong> (1 和 0 交替码)，作用是使接收端的适配器在接收 MAC 帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现位同步”。</li><li><strong>帧开始定界符</strong>，定义为 10101011。它的前六位的作用和前同步码一样，最后的两个连续的 1 就是告诉接收端适配器：“MAC 帧的信息马上就要来了，请适配器注意接收”。</li></ul></li><li>IEEE 802.3 标准规定凡出现下列情况之一的即为无效的 MAC 帧：<ul><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>收到的帧的 MAC 客户数据字段的长度不在 46～1500 字节之间。考虑到 MAC 帧首部和尾部的长度共有 18 字节，可以得出有效的 MAC 帧长度为 64～1518 字节之间。</li></ul></li></ol></li></ul><h1 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h1><h2 id="3-4-1-在物理层扩展以太网"><a href="#3-4-1-在物理层扩展以太网" class="headerlink" title="3.4.1 在物理层扩展以太网"></a>3.4.1 在物理层扩展以太网</h2><ul><li>扩展主机和集线器之间距离的一种方法是使用一对光纤和一对光纤调制解调器，如图 3-23 所示：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717223544.png"></li></ol></li><li>光纤调制解调器的作用是进行电信号和光信号的转换。光纤的时延小，带宽宽，使用这种方法可以使主机和几公里以外的集线器相连接。</li><li>如果使用多个集线器，可以连接成覆盖更大范围的多级星形结构的以太网。例如，一个学院的三个系各有一个 10BASE-T 以太网 (a)，可通过一个主干集线器把各系的以太网连接起来，成为一个更大的以太网 (b)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717223829.png"></li><li>有以下好处：<ul><li>使这个学院不同系的以太网上的计算机能够进行跨系的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ul></li><li>但这种多级结构的集线器以太网也带来了一些缺点：<ul><li>如图 (a) 所示的例子，在三个系的以太网互连起来之前，每一个系的以太网是一个独立的<strong>碰撞域</strong> (冲突域)，在任一时刻，在每一个碰撞域中只能有一个站在发送数据。每一个系的以太网的最大吞吐量是 10Mbit&#x2F;s，因此三个系总的最大吞吐量共有 30Mbit&#x2F;s。在三个系的以太网通过集线器互连起来后就把三个碰撞域变成一个碰撞域 (范围扩大到三个系)，如图 (b) 所示，而这时的最大吞吐量仍然是一个系的吞吐量 10Mbit&#x2F;s。这就是说，当某个系的两个站在通信时所传送的数据会通过所有的集线器进行转发，使得其他系的内部在这时都不能通信 (一发送数据就会碰撞)。</li><li>如果不同的系使用不同的以太网技术 (如数据率不同)，那么就不可能用集线器将它们互连起来。如果在图 3-24 中，一个系使用 10Mbit&#x2F;s 的适配器，而另外两个系使用10&#x2F;100Mbit&#x2F;s 的适配器，那么用集线器连接起来后，大家都只能工作在 10Mbit&#x2F;s 的速率。集线器基本上是个多接口的转发器，不能把帧进行缓存。</li></ul></li></ol></li></ul><h2 id="3-4-2-在数据链路层扩展以太网"><a href="#3-4-2-在数据链路层扩展以太网" class="headerlink" title="3.4.2 在数据链路层扩展以太网"></a>3.4.2 在数据链路层扩展以太网</h2><ul><li>使用<strong>网桥</strong>扩展以太网的方法在数据链路层进行。网桥对收到的帧根据其 MAC 帧的目的地址进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是根据此帧的目的 MAC 地址，查找网桥中的地址表，然后确定将该帧转发到哪一个接口，或者是把它丢弃。</li><li><strong>交换式集线器</strong>淘汰了网桥。交换式集线器称为以太网<strong>交换机</strong>或<strong>第二层交换机</strong>，强调这种交换机<strong>工作在数据链路层</strong>。</li><li><strong>以太网交换机的特点：</strong><ol><li>以太网交换机实质上是一个<strong>多接口的网桥</strong>，通常都有十几个或更多的接口，和工作在物理层的转发器、集线器有很大的差别。以太网交换机的每个接口都直接与一个单台主机或另一个以太网交换机相连，一般都在全双工方式。以太网交换机还具有并行性，能同时连通多对接口，使多对主机能同时通信 (而网桥只能一次分析和转发一个帧)。相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong>。</li><li>以太网交换机的接口有存储器，能在输出端口繁忙时把到来的帧进行缓存。如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的接口繁忙时，发送帧的这两台主机的接口会把收到的帧暂存一下，以后再发送出去。</li><li>以太网交换机是一种即插即用设备，其内部的帧<strong>交换表</strong> (地址表) 是通过自学习算法自动地逐渐建立起来的。以太网交换机由于使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</li><li>以太网交换机的性能远超普通的集线器，而且价格不贵。</li><li>以太网交换机都具有多种速率的接口，方便了各种不同情况的用户。</li></ol></li><li><strong>以太网交换机的自学习功能</strong><ol><li>假定在图 3-25 中的以太网交换机有 4 个接口，各连接一台计算机，其 MAC 地址分别是 A，B，C 和 D。在一开始，以太网交换机里面的交换表是空的 (a)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718171025.png"></li><li>A 先向 B 发送一帧，从接口 1 进入到交换机。交换机收到帧后，先查找交换表，没有查到应从哪个接口转发这个帧 (在 MAC 地址这一列中，找不到目的地址为 B 的项目)。接着，交换机把这个帧的源地址 A 和接口 1 写入交换表中，并向除接口 1 以外的所有接口广播这个帧。</li><li>C 和 D 丢弃这个帧，因为目的地址不对。B 收下这个帧。也称<strong>过滤</strong>。</li><li>从新写入交换表的项目 (A，1) 可以看出，以后不管从哪一个接口收到帧，只要其目的地址是 A，就应当把收到的帧从接口 1 转发出去。依据是：既然 A 发出的帧是从接口 1 进入到交换机的，那么从交换机的接口 1 转发出的帧也应可以到达 A。</li><li>假定接下来 B 通过接口 3 向 A 发送一帧。交换机查找交换表，发现交换表中的 MAC 地址有 A。表明要发送给 A 的帧 (即目的地址为 A 的帧) 应从接口 1 转发。于是就把这个帧传送到接口 1 转发给 A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的项目 (B，3)，表明今后如有发送给 B 的帧，就应当从接口 3 转发出去。</li><li>经过一段时间后，只要主机 C 和 D 也向其他主机发送帧，以太网交换机中的交换表就会把转发到 C 或 D 应当经过的接口号 (2 或 4) 写入到交换表中。这样，交换表中的项目就齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口。</li></ul></li><li>考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。用这样的方法保证交换表中的数据符合当前网络的实际状况。</li><li>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，非常方便。</li><li>为了增加网络的可靠性，在使用以太网交换机组网时，会增加一些冗余的链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子。用图 3-26 的例子来说明这个问题。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718172449.png"></li><li>在图3-26 中，假定一开始主机 A 通过接口交换机 #1 向主机 B 发送一帧。交换机 #1 收到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向：离开交换机 #1 的接口 3→ 交换机 #2 的接口 1→ 接口 2→ 交换机 #1 的接口 4→ 接口 3→ 交换机 #2 的接口 1→……。无限制地循环兜圈子下去，消耗网络资源。</li><li>为了解决这种兜圈子问题，制定了一个<strong>生成树协议</strong> STP。要点是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</li></ul></li></ol></li><li><strong>从总线以太网到星形以太网</strong><ol><li>随着以太网上站点数目的增多，总线结构以太网的可靠性下降。与此同时，大规模集成电路以及专用芯片的发展，使得星形结构的以太网交换机既便宜又可靠。在这种情况下，采用以太网交换机的星形结构成为首选拓扑，而传统的总线以太网也很快从市场上消失了。</li><li>总线以太网使用 CSMA&#x2F;CD 协议，以半双工方式工作。但以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA&#x2F;CD 协议，而是以全双工方式工作。以太网交换机的帧结构未改变，<strong>仍然采用以太网的帧结构</strong>。</li></ol></li></ul><h2 id="3-4-3-虚拟局域网"><a href="#3-4-3-虚拟局域网" class="headerlink" title="3.4.3 虚拟局域网"></a>3.4.3 虚拟局域网</h2><ul><li>虚拟局域网 VLAN 这样定义：虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，这些网段具有某些共同的需求。每一个 VLAN 的帧都有明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN。</li><li>虚拟局域网其实是局域网给用户提供的一种服务，并不是新型局域网。</li><li>图 3-27 画的是使用了四个交换机的网络拓扑。设有 10 台计算机分配在三个楼层中，构成了三个局域网，即: LAN<sub>1</sub>:  (A<sub>1</sub>，A<sub>2</sub>，B<sub>1</sub>，C<sub>1</sub>)，LAN<sub>2</sub>: (A<sub>3</sub>，B<sub>2</sub>，C<sub>2</sub>)，LAN<sub>3</sub>: (A<sub>4</sub>，B<sub>3</sub>，C<sub>3</sub>)；这 10 个用户划分为三个工作组，也就是说划分为三个虚拟局域网 VLAN。即: VLAN<sub>1</sub>: (A<sub>1</sub>，A<sub>2</sub>，A<sub>3</sub>，A<sub>4</sub>)，VLAN<sub>2</sub>: (B<sub>1</sub>，B<sub>2</sub>，B<sub>3</sub>)；VLAN<sub>3</sub>：(C<sub>1</sub>，C<sub>2</sub>，C<sub>3</sub>)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718180349.png"></li><li>从图 3-27 可看出，每一个 VLAN 的计算机可处在不同的局域网中，也可以不在同一层楼中。</li></ol></li></ul><h1 id="3-5-高速以太网"><a href="#3-5-高速以太网" class="headerlink" title="3.5 高速以太网"></a>3.5 高速以太网</h1><h2 id="3-5-1-100BASE-T-以太网"><a href="#3-5-1-100BASE-T-以太网" class="headerlink" title="3.5.1 100BASE-T 以太网"></a>3.5.1 100BASE-T 以太网</h2><ul><li>100BASE-T 是在双绞线上传送 100Mbit&#x2F;s 基带信号的星形拓扑以太网，CSMA&#x2F;CD 协议，它又称为<strong>快速以太网</strong>。</li><li>100BASE-T 可使用以太网交换机提供很好的服务质量，可在全双工方式下工作而无冲突发生。因此，CSMA&#x2F;CD 协议对全双工方式工作的快速以太网是不起作用的 (但在半双工方式工作时则一定要使用 CSMA&#x2F;CD 协议)。快速以太网使用的 MAC 帧格式仍然是 IEEE 802.3标准规定的帧格式。</li><li><strong>从细缆以太网升级到快速以太网的用户必须重新布线</strong>。</li></ul><h2 id="3-5-2-吉比特以太网"><a href="#3-5-2-吉比特以太网" class="headerlink" title="3.5.2 吉比特以太网"></a>3.5.2 吉比特以太网</h2><ul><li>吉比特以太网的标准 IEEE 802.3z 有以下特点：<ol><li>允许在 1Gbit&#x2F;s 下以全双工和半双工两种方式工作。</li><li>使用 IEEE 802.3 协议规定的帧格式。</li><li>在半双工方式下使用 CSMA&#x2F;CD 协议，而在全双工方式不使用 CSMA&#x2F;CD 协议。</li><li>与 10BASE-T 和 100BASE-T 技术向后兼容。</li></ol></li><li>吉比特以太网的物理层使用两种成熟的技术：<ol><li>来自现有的以太网。</li><li>美国国家标准协会 ANSI 制定的<strong>光纤通道</strong>，采用成熟技术就能大大缩短吉比特以太网标准的开发时间。</li></ol></li><li>吉比特以太网工作在半双工方式时，必须进行碰撞检测。由于数据率提高了，因此只有减小最大电缆长度或增大帧的最小长度，才能使参数 <em>a</em> 保持为较小的数值。若将吉比特以太网最大电缆长度减小到 10m，网络的实际价值就大大减小。而若将最短帧长提高到 640 字节，则在发送短数据时开销太大。因此，吉比特以太网仍然保持一个网段的最大长度为 100m，采用了<strong>载波延伸</strong>的办法，使最短帧长仍为 64 字节，同时将争用期增大为 512 字节。凡发送的 MAC 帧长不足 512 字节时，就用一些特殊字符填充在帧的后面，使 MAC 帧的发送长度增大到 512 字节，这对有效载荷并无影响。接收端在收到以太网的 MAC 帧后，要把所填充的特殊字符删除后才向高层交付。当原来仅 64 字节长的短帧填充到 512 字节时，所填充的 448 字节就造成了很大的开销。为此，吉比特以太网还增加了一种功能称为<strong>分组突发</strong>。这就是当很多短帧要发送时，第一个短帧要采用上面所说的载波延伸的方法进行填充。但随后的一些短帧则可一个接一个地发送，它们之间只需留有必要的帧间最小间隔即可。这样就形成一串分组的突发，直到达到 1500 字节或稍多一些为止。当吉比特以太网工作在全双工方式时 (即通信双方可同时进行发送和接收数据)，不使用载波延伸和分组突发。</li></ul><h2 id="3-5-3-10-吉比特以太网"><a href="#3-5-3-10-吉比特以太网" class="headerlink" title="3.5.3 10 吉比特以太网"></a>3.5.3 10 吉比特以太网</h2><ul><li>10GE 的帧格式与 10Mbit&#x2F;s，100Mbit&#x2F;s 和 1Gbit&#x2F;s 以太网的<strong>帧格式完全相同</strong>，并保留了 802.3 标准规定的<strong>以太网最小帧长和最大帧长</strong>。使用户在将其已有的以太网进行升级时，仍能和较低速率的以太网很方便地通信。</li><li>10GE <strong>只工作在全双工方式，不存在争用问题，也不使用</strong> CSMA&#x2F;CD <strong>协议</strong>。使得 10GE 的传输距离大大提高了 (因为不再受必须进行碰撞检测的限制)。</li><li>现在以太网的工作范围已经从局域网 (校园网、企业网) 扩大到城域网和广域网，从而实现了端到端的以太网传输。这种工作方式的好处是：<ol><li>以太网是一种经过实践证明的成熟技术，无论是互联网服务提供者 ISP 还是端用户都愿意使用以太网。对 ISP 来说，使用以太网还需要在更大的范围进行试验。</li><li>以太网的互操作性很好，不同厂商生产的以太网都能可靠地进行互操作。</li><li>在广域网中使用以太网时，价格大约只有同步光纤网 SONET 的五分之一和异步传递方式 ATM 的十分之一。以太网还能够适应多种传输媒体，如铜缆、双绞线以及各种光缆。使具有不同传输媒体的用户在进行通信时不必重新布线。</li><li>端到端的以太网连接使帧的格式全都是以太网的格式，而不需要再进行帧的格式转换，简化了操作和管理。但是，以太网和现有的其他网络，如帧中继或 ATM 网络，仍然需要有相应的接口才能进行互连。</li></ol></li><li>以太网从 10Mbit&#x2F;s 到 10Gbit&#x2F;s 甚至到 100Gbit&#x2F;s 的演进，证明了以太网是：<ol><li>可扩展的 (速率从 10Mbit&#x2F;s 到 100Gbit&#x2F;s)。</li><li>灵活的 (多种媒体、全&#x2F;半双工、共享&#x2F;交换)。</li><li>易于安装。</li><li>稳健性好。</li></ol></li></ul><h2 id="3-5-4-使用以太网进行宽带接入"><a href="#3-5-4-使用以太网进行宽带接入" class="headerlink" title="3.5.4 使用以太网进行宽带接入"></a>3.5.4 使用以太网进行宽带接入</h2><ul><li>以太网接入的一个重要特点是它可以提供双向的宽带通信，并且可以根据用户对带宽的需求灵活地进行带宽升级。当城域网和广域网都采用吉比特以太网或 10 吉比特以太网时，采用以太网接入可以实现端到端的以太网传输，中间不需要再进行帧格式的转换。提高了数据的传输效率且降低了传输的成本。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>链路是从一个结点到相邻结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件 (如网络适配器) 和软件 (如协议的实现)。</p></li><li><p>数据链路层使用的信道有点对点信道和广播信道两种。</p></li><li><p>数据链路层传送的协议数据单元是帧。数据链路层的三个基本问题则是：封装成帧、透明传输和差错检测。</p></li><li><p>循环冗余检验 CRC 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码。</p></li><li><p>点对点协议 PPP 是数据链路层使用最多的一种协议，它的特点是: </p><ol><li>简单；</li><li>只检测差错，而不是纠正差错；</li><li>不使用序号，也不进行流量控制；</li><li>可同时支持多种网络层协议。</li></ol></li><li><p>PPPoE 是为宽带上网的主机使用的链路层协议。</p></li><li><p>局域网的优点是：</p><ol><li>具有广播功能，从一个站点可很方便地访问全网；</li><li>便于系统的扩展和逐渐演变；提高了系统的可靠性、可用性和生存性。</li></ol></li><li><p>共享通信媒体资源的方法有两种: </p><ol><li>静态划分信道 (各种复用技术)；</li><li>动态媒体接入控制，又称为多点接入 (随机接入或受控接入)。</li></ol></li><li><p>IEEE 802  委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制 (LLC) 子层 (与传输媒体无关) 和媒体接入控制 (MAC) 子层 (与传输媒体有关) 。但现在 LLC 子层已成为历史。</p></li><li><p>计算机与外界局域网的通信要通过通信适配器 (网络适配器)，它又称为网络接口卡或网卡。计算机的硬件地址就在适配器的 ROM 中。</p></li><li><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做。</p></li><li><p>以太网采用的协议是具有冲突检测的载波监听多点接入 CSMA&#x2F;CD。协议的要点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。因此，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上各站点都平等地争用以太网信道。</p></li><li><p>传统的总线以太网基本上都是使用集线器的双绞线以太网。这种以太网在物理上是星形网，但在逻辑上则是总线形网。集线器工作在物理层，它的每个接口仅仅简单地转发比特，不进行碰撞检测。</p></li><li><p>以太网的硬件地址，即 MAC 地址实际上就是适配器地址或适配器标识符，与主机所在的地点无关。源地址和目的地址都是 48 位长。</p></li><li><p>以太网的适配器有过滤功能，它只接收单播帧、广播帧或多播帧。</p></li><li><p>使用集线器可以在物理层扩展以太网 (扩展后的以太网仍然是一个网络)。</p></li><li><p>交换式集线器常称为以太网交换机或第二层交换机 (工作在数据链路层)，是一个多接口的网桥，每个接口都直接与某台单主机或另一个集线器相连，且工作在全双工方式。以太网交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。</p></li><li><p>高速以太网有 100Mbit&#x2F;s 的快速以太网、吉比特以太网和 10Gbit&#x2F;s 的 10 吉比特以太网。最近还发展到 100 吉比特以太网。在宽带接入技术中，也常使用高速以太网进行接入。</p></li><li><p>数据链路层的三个基本问题 (封装成帧、透明传输和差错检测) 为什么都必须加以解决？</p><blockquote><p>封装成帧就是在一段数据的前后分别添加首部和尾(在首部和尾部里面有许多必要的控制信息)，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<br>所谓“透明传输”就是上层交下来的数据，不管是什么形式的比特组合，都必须能够正确传送。由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何比特组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。数据链路层不应当对要传送的数据提出限制，即不应当规定某种形式的比特组合不能够传送。<br>如果数据链路层没有差错检测，那么当目的主机收到其他主机发送来的数据时，在交给高层后，如果应用程序要求收到的数据必须正确无误，那么目的主机的高层软件可以对收到的数据进行差错检测。如果发现数据中有差错，就可以请求源主机重传这些数据。这样做就可以达到正确接收数据的目的。但这种工作方式有一个很大的缺点，就是一些在传输过程中出现了错误的数据 (请注意，这些已经是没有用处的数据) 还会继续在网络中传送，这样就浪费了网络的资源。例如，源主机到目的主机的路径中共有 20 个结点。在传送数据时，第一个结点就检测出了差错。如果数据链路层有差错检测的功能，就可以把这个有差错的帧丢弃以后就不再传送了。否则这个没有用处的帧还要在网络上继续传送，还要陆续通过后面的 19 个结点，这就造成了网络资源的浪费。</p></blockquote></li><li><p>局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</p><blockquote><p>局域网最主要的特点是: 网络为一个单位所拥有，且地理范围和站点数目均有限在局域网刚刚出现时，局域网比广域网具有更高的数据率、更低的时延和更小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率局域网的地理范围较小，且为一个单位所拥有，采用广播通信方式十分简单方便。但广域网的地理范围很大，如果采用广播通信方式势必造成通信资源的极大浪费，因此广域网不采用广播通信方式。</p></blockquote></li><li><p>说明 10BASE-T中的“10”“BASE”和“T”所代表的意思。</p><blockquote><p>“10”代表这种以太网具有 10 Mbit&#x2F;s 的数据率，BASE 表示连接线上的信号是基带信号，T 代表双绞线 (Twisted-pair)。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 物理层</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-2-zhang-wu-li-ceng/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-2-zhang-wu-li-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h1><ul><li>物理层的作用是屏蔽掉传输媒体和通信手段的差异，使数据链路层感觉不到这些差异，只考虑如何完成本层的协议和服务，不考虑网络具体的传输媒体和通信手段是什么。</li><li>用于物理层的协议也常称为物理层<strong>规程</strong>。</li><li>将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：<ol><li><strong>机械特性</strong> 　指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。</li><li><strong>电气特性</strong> 　指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong> 　指明某条线上出现的某一电平的电压的意义。</li><li><strong>过程特性</strong> 　指明对于不同功能的各种可能事件的出现顺序。</li></ol></li><li>数据在计算机内部多采用并行输出方式。但数据在通信线路上的传输方式一般是<strong>串行传输</strong>，即逐个比特按照时间顺序传输。物理层还要完成传输方式的转换。</li></ul><h1 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h1><h2 id="2-2-1-数据通信系统的模型"><a href="#2-2-1-数据通信系统的模型" class="headerlink" title="2.2.1  数据通信系统的模型"></a>2.2.1  数据通信系统的模型</h2><ul><li>如图 2-1 所示，数据通信系统可划分为三大部分，即<strong>源系统</strong>、<strong>传输系统</strong>和<strong>目的系统</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230704174305.png"></li></ol></li><li>源系统包括两个部分：<ol><li><strong>源点</strong> 　源点设备产生要传输的数据。源点又称为<strong>源站</strong>，或<strong>信源</strong>。</li><li><strong>发送器</strong> 　通常源点生成的数字比特流要通过发送器编码后才能在传输系统中进行传输。典型的发送器就是调制器。</li></ol></li><li>目的系统也包括两个部分：<ol><li><strong>接收器</strong> 　接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器是解调器，它把来自传输线路上的模拟信号进行解调，提取出在发送端置入的消息，还原出发送端产生的数字比特流。</li><li><strong>终点</strong> 　终点设备从接收器获取传送来的数字比特流，然后把信息输出。终点又称为<strong>目的站</strong>，或<strong>信宿</strong>。</li></ol></li><li>在源系统和目的系统之间的传输系统可以是简单的传输线，也可以是连接在源系统和目的系统之间的复杂网络系统。</li><li>通信的目的是传送<strong>消息</strong>。如话音、文字、图像、视频等都是消息。<strong>数据</strong>是运送消息的实体。根据RFC 4949 给出的定义，数据是使用特定方式表示的信息，是有意义的符号序列。这种信息的表示可用计算机或其他机器处理或产生。<strong>信号</strong>则是数据的电气或电磁的表现。</li><li>根据信号中代表消息的参数的取值方式不同，信号分为两大类：<ol><li><strong>模拟信号</strong>，或<strong>连续信号</strong>——代表消息的参数的取值是连续的。例如在图 2-1中，用户家中的调制解调器到电话端局之间的用户线上传送的就是模拟信号。</li><li><strong>数字信号</strong>，或<strong>离散信号</strong>——代表消息的参数的取值是离散的。例如在图 2-1中，用户家中的计算机到调制解调器之间，或在电话网中继线上传送的就是数字信号。在使用时间域 (或简称为时域) 的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表 0 状态而另一种代表 1 状态。</li></ol></li></ul><h2 id="2-2-2-有关信道的几个基本概念"><a href="#2-2-2-有关信道的几个基本概念" class="headerlink" title="2.2.2 有关信道的几个基本概念"></a>2.2.2 有关信道的几个基本概念</h2><ul><li>信道用来表示向某一个方向传送信息的媒体。一条通信电路包含一条发送信道和一条接收信道。</li><li>从通信的双方信息交互的方式来看，有三种基本方式：<ol><li><strong>单向通信</strong> 　又称为<strong>单工通信</strong>，只有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信</strong> 　又称为<strong>半双工通信</strong>，通信的双方都可以发送信息，但不能同时发送。这种通信方式是一方发送另一方接收，过一段时间后可以再反过来。</li><li><strong>双向同时通信</strong> 　又称为<strong>全双工通信</strong>，通信的双方可以同时发送和接收信息。</li></ol></li><li>单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道 (每个方向各一条)。双向同时通信的传输效率最高。</li><li>来自信源的信号称为<strong>基带信号</strong>。计算机输出的代表各种文字或图像文件的数据信号就属于基带信号。基带信号包含有低频成分，甚至有直流成分，许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行<strong>调制</strong>。</li><li>调制可分为两大类。一类是对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号，这类调制称为<strong>基带调制</strong>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此把这种过程称为<strong>编码</strong>。另一类调制需要使用<strong>载波</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>，使用载波的调制称为<strong>带通调制</strong>。<ol><li><strong>常用编码方式</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222731.png"></li><li><strong>不归零制</strong> 　正电平代表 1，负电平代表 0。</li><li><strong>归零制</strong> 　正脉冲代表 1，负脉冲代表 0。</li><li><strong>曼彻斯特编码</strong> 　位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。</li><li><strong>差分曼彻斯特编码</strong> 　在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。</li><li>从信号波形中可以看出，曼彻斯特编码产生的信号频率比不归零制高。从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率 (这叫做没有自同步能力)，而曼彻斯特编码具有自同步能力。</li></ul></li><li><strong>基本的带通调制方法</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222830.png"></li><li><strong>调幅</strong> (AM)　载波的振幅随基带数字信号而变化。0 或 1 分别对应于无载波或有载波输出。</li><li><strong>调频</strong> (FM)　载波的频率随基带数字信号而变化。0 或 1 分别对应于频率 <em>f<sub>1</sub></em> 或 <em>f<sub>2</sub>。</em></li><li><strong>调相</strong> (PM)　载波的初始相位随基带数字信号而变化。0 或 1 分别对应于相位 0 度或 180度。</li><li>为了达到更高的信息传输速率，必须采用更复杂的多元制的振幅相位混合调制方法。例如，<strong>正交振幅调制</strong> QAM。</li></ul></li></ol></li></ul><h2 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h2><ul><li>数字通信的优点是：虽然信号在信道上传输时会不可避免地产生失真，但在接收端只要从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就没有影响。例如图 2-4(a) 表示信号通过实际的信道传输后虽然有失真，但在接收端可识别并恢复出原来的码元。图 2-4(b)信号失真严重，在接收端无法识别码元是 1 还是 0。码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形的失真就越严重。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222925.png"></li></ol></li><li>限制码元在信道上的传输速率的因素下两个：<ol><li><strong>信道能够通过的频率范围</strong><ul><li>信道所能通过的频率范围是有限的，信号中的许多高频分量不能通过信道。像图 2-4 所示的发送信号是一种矩形脉冲信号，包含很丰富的高频分量。如果信号中的高频分量在传输时受到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，每一个码元所占的时间界限也不再是很明确的，而是前后都拖了“尾巴”。这样，在接收端收到的信号波形就失去了码元之间的清晰界限。这种现象叫做<strong>码间串扰</strong>。严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。<strong>在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的识别成为不可能</strong> 。</li><li>信道的频带越宽，能够通过的信号高频分量越多，就可以用更高的速率传送码元而不出现码间串扰。</li></ul></li><li><strong>信噪比</strong><ul><li>噪声存在于所有的电子设备和通信信道中。由于噪声是随机产生的，它的瞬时值有时会很大，因此噪声会使接收端对码元的识别产生错误 (1 误判为 0 或 0 误判为 1)。噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。因此，信噪比很重要。所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为 S&#x2F;N，并用分贝 (dB) 作为度量单位。即：</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705223051.png"></li><li>香农公式指出：<strong>信道的极限信息传输速率</strong> <em>C</em> 是</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705223107.png"></li><li><em>W</em> 为信道的带宽（以 Hz 为单位）；<em>S</em> 为信道内所传信号的平均功率；<em>N</em> 为信道内部的高斯噪声功率。</li><li>香农公式表明，<strong>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高</strong>。香农公式的意义在于：只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</li><li>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，可以用编码的方法<strong>让每一个码元携带更多比特的信息量</strong>来提高信息的传输速率。</li></ul></li></ol></li></ul><h1 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h1><ul><li><strong>传输媒体</strong>也称为传输介质或传输媒介，是数据传输系统中在发送器和接收器之间的物理通路。</li><li>传输媒体分为两大类，<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。在导引型传输媒体中，电磁波被导引沿着固体媒体 (铜线或光纤) 传播，而非导引型传输媒体是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。图 2-5 是电信领域使用的电磁波的频谱。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706092821.png"></li></ul><h2 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1 导引型传输媒体"></a>2.3.1 导引型传输媒体</h2><ol><li><strong>双绞线</strong><ul><li>双绞线也称双扭线，把两根互相绝缘的铜导线并排放在一起，然后用规则的方法<strong>绞合</strong>就构成了双绞线。绞合可减少对相邻导线的电磁干扰。几乎所有的电话都用双绞线连接到电话交换机。从用户电话机到交换机的双绞线称为<strong>用户线</strong>或<strong>用户环路</strong>。</li><li>模拟传输和数字传输可以使用双绞线，通信距离一般为几到十几公里。距离太长时就要加放大器将衰减的信号放大到合适的数值 (对于模拟传输)，或者加上中继器对失真的数字信号进行整形 (对于数字传输)。导线越粗，其通信距离就越远，价格也越高。在数字传输时，若传输速率为每秒几个兆比特，则传输距离可达几公里。由于双绞线的价格便宜且性能也不错，因此使用十分广泛。</li><li>为了提高双绞线抗电磁干扰的能力，可在双绞线的外面加上一层用金属丝编织成的屏蔽层。这就是<strong>屏蔽双绞线</strong>，简称为 STP。它的价格比<strong>无屏蔽双绞线</strong> UTP 要高。图 2-6 是无屏蔽双绞线和屏蔽双绞线的示意图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706095419.png"></li></ol></li></ul></li><li><strong>同轴电缆</strong><ul><li>同轴电缆由内导体铜质芯线、绝缘层、网状编织的外导体屏蔽层以及保护塑料外层所组成 (图2-7)。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706095526.png"></li></ol></li></ul></li><li><strong>光缆</strong><ul><li>光纤通信就是利用光导纤维传递光脉冲来进行通信。有光脉冲相当于 1，没有光脉冲相当于 0。由于可见光的频率非常高，约为10<sup>8</sup> MHz 的量级，因此一个光纤通信系统的传输带宽大于目前其他各种传输媒体的带宽。</li><li>光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</li><li>光纤不仅具有通信容量大的优点，而且还有其他特点：<ol><li>传输损耗小，中继距离长，远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。这在有大电流脉冲干扰的环境下尤为重要。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。这在电缆管道拥塞不堪的情况下特别有利。</li></ol></li></ul></li></ol><h2 id="2-3-2-非导引型传输媒体"><a href="#2-3-2-非导引型传输媒体" class="headerlink" title="2.3.2 非导引型传输媒体"></a>2.3.2 非导引型传输媒体</h2><ol><li>短波通信 (高频通信) 靠电离层的反射。电离层的不稳定所产生的衰落现象和电离层反射所产生的多径效应，使得短波信道的通信质量较差。当必须使用短波无线电台传送数据时，一般是低速传输，即速率为一个标准模拟话路传几十至几百比特&#x2F;秒</li><li>无线电微波通信在数据通信中占有重要地位。微波在空间是直线传播。由于微波会穿透电离层进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。传统的微波通信有两种，即<strong>地面微波接力通信</strong>和<strong>卫星通信</strong>。<ol><li>微波接力通信可传输电话、电报、图像、数据等信息。<ul><li>特点：<ol><li>微波波段频率高，频段范围宽，通信信道的容量大。</li><li>工业干扰和天电干扰的频谱成分比微波频率低得多，对微波通信的危害比对短波和米波 (即甚高频) 通信小，因而微波传输质量高。</li><li>与相同容量和长度的电缆载波通信比较，微波接力通信建设投资少，见效快，易于跨越山区、江河。</li></ol></li><li>缺点：<ol><li>相邻站之间必须直视 (常称为视距 LOS)，不能有障碍物。有时一个天线发射出的信号会分成几条略有差别的路径到达接收天线，因而造成失真。</li><li>微波的传播会受恶劣气候的影响。</li><li>与电缆通信系统比较，微波通信的隐蔽性和保密性差。</li><li>中继站的使用和维护要耗费较多的人力和物力。</li></ol></li></ul></li><li>卫星通信的特点是通信距离远，且通信费用与通信距离无关。<ul><li>和微波接力通信相似，卫星通信的频带宽，通信容量大，信号受到的干扰小，通信稳定。</li><li>卫星通信的另一特点是有<strong>较大的传播时延</strong> 。</li><li>“卫星信道的传播时延较大”不等于“用卫星信道传送数据的时延较大”。因为传送数据的总时延除了传播时延外，还有发送时延、处理时延和排队时延等。传播时延在总时延中所占的比例有多大，取决于具体情况。但利用卫星信道进行交互式的网上游戏显然是不合适的。</li><li>卫星通信适合于广播通信，因为它的覆盖面很广。从安全方面考虑，卫星通信系统的保密性则相对较差。</li><li>卫星通信的费用较高。</li></ul></li></ol></li></ol><h1 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h1><h2 id="2-4-1-频分复用、时分复用和统计时分复用"><a href="#2-4-1-频分复用、时分复用和统计时分复用" class="headerlink" title="2.4.1 频分复用、时分复用和统计时分复用"></a>2.4.1 频分复用、时分复用和统计时分复用</h2><ul><li>图 2-13(a) 表示 A<sub>1</sub>，B<sub>1</sub> 和 C<sub>1</sub> 分别使用一个单独的信道进行通信，总共需要三个信道。如果在发送端使用一个复用器，它们可以合起来使用一个共享信道进行通信。在接收端使用分用器，把合起来传输的信息分别送到相应的终点。图 2-13(b) 是复用的示意图。复用要付出代价。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707095902.png"></li></ol></li><li>最基本的复用就是<strong>频分复用</strong> (FDM) 和<strong>时分复用</strong> (TDM)。<ol><li><strong>频分复用</strong><ul><li>频分复用最简单，其特点如图 2-14(a) 所示。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽资源</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707100801.png"></li><li>使用频分复用时，若每一个用户占用的带宽不变，则当复用的用户数增加时，复用后的信道的总带宽就跟着变宽。</li></ul></li><li><strong>时分复用</strong><ul><li>时分复用是将时间划分为一段段等长的时分复用帧 (TDM 帧)。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。在图 2-14(b) 中画出了 4 个用户 A，B，C 和 D。每一个用户所占用的时隙周期性地出现 (周期是 TDM 帧的长度）。因此 TDM 信号也称<strong>等时</strong>信号。<strong>时分复用的所有用户是在不同的时间占用同样的频带宽度</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707100841.png"></li><li>使用时分复用时，每一个时分复用帧的长度是不变的，始终是 125µs。若有 1000 个用户进行时分复用，则每一个用户分配到的时隙宽度就是 125µs 的千分之一，即 0.125µs，时隙宽度变得非常窄。</li></ul></li><li>这两种复用方法的优点是技术成熟，缺点是不灵活。时分复用则更有利于数字信号的传输。</li></ol></li><li>在进行通信时，<strong>复用器</strong>总和<strong>分用器</strong>成对地使用。在复用器和分用器之间是用户共享的高速信道。分用器的作用和复用器相反，把高速信道传送过来的数据进行分用，分别送交到相应的用户。</li></ul><h2 id="2-4-2-波分复用"><a href="#2-4-2-波分复用" class="headerlink" title="2.4.2 波分复用"></a>2.4.2 波分复用</h2><ul><li><strong>波分复用</strong> (WDM) 就是<strong>光的频分复用</strong>。</li><li><strong>光复用器</strong>：波分复用的复用器又称为<strong>合波器</strong>。</li><li><strong>光分用器</strong>：波分复用的分用器又称为<strong>分波器</strong>。</li><li>光信号传输了一段距离后会衰减，对衰减了的光信号进行放大才能继续传输。</li><li><strong>掺铒光纤放大器</strong> (EDFA)。不需要进行光电转换直接对光信号进行放大。</li></ul><h2 id="2-4-3-码分复用"><a href="#2-4-3-码分复用" class="headerlink" title="2.4.3 码分复用"></a>2.4.3 码分复用</h2><ul><li><strong>码分复用</strong> (CDM) 是一种共享信道的方法。也叫作<strong>码分多址</strong> (CDMA)。每个用户可在同样的时间使用同样的频带进行通信。由于<strong>各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰</strong>。码分复用发送的信号有很强的抗干扰能力，<strong>其频谱类似于白噪声，不易被发现</strong>。采用 CDMA 可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率。</li><li>在 CDMA 中，每个比特时间划分为 m 个短的间隔，称为<strong>码片</strong>。</li><li>使用 CDMA 的每个站被指派一个唯一的 m bit <strong>码片序列</strong>。一个站如果要发送比特 1，则发送它自己的 m bit 码片序列。如果要发送比特 0，则发送该码片序列的二进制反码。<ol><li>例如指派给 S 站的 8 bit 码片序列是 0001 1011。当 S 发送比特 1 时，它就发送序列 0001 1011，而当 S 发送比特 0 时，就发送 1110 0100。将码片中的 0 写为 – 1，将 1 写为＋1。因此 S 站的码片序列是 (–1 –1 –1＋1＋1 –1＋1＋1)。</li></ol></li><li>假定 S 站要发送信息的数据率为 b bit&#x2F;s。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit&#x2F;s，S 站所占用的频带宽度也提高到原来数值的 m 倍。这种通信方式是<strong>扩频</strong>通信中的一种。扩频通信有两类。<ol><li>一种是<strong>直接序列扩频</strong> (DSSS)，如码片序列。</li><li>另一种是<strong>跳频扩频</strong> (FHSS)。</li></ol></li><li>CDMA 系统的特点是这种体制给每个站分配的码片序列不仅必须各不相同，还必须互相<strong>正交</strong>。在实用的系统中使用<strong>伪随机码序列</strong>。</li><li>数学公式可清楚地表示码片序列的正交关系。令向量 <em><strong>S</strong></em> 表示站 S 的码片向量，再令 <em><strong>T</strong></em> 表示其他任何站的码片向量。两个不同站的码片序列正交，就是向量 <em><strong>S</strong></em> 和 <em><strong>T</strong></em> 的规格化<strong>内积</strong>都是 0：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230709160115.png"></li></ol></li><li>向量 <em><strong>S</strong></em> 为 (–1 –1 –1＋1＋1 –1＋1＋1)，同时设向量 <em><strong>T</strong></em> 为 (–1 –1＋1 –1＋1＋1＋1 –1)，相当于 T 站的码片序列为 00101110。将向量 <em><strong>S</strong></em> 和 <em><strong>T</strong></em> 的各分量值代入 (2-3) 式就可看出这两个码片序列是正交的。向量 <em><strong>S</strong></em> 和各站码片反码的向量的内积也是 0。任何一个码片向量和该码片向量自己的规格化内积都是 1。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230709160135.png"></li></ol></li></ul><h1 id="2-5-数字传输系统"><a href="#2-5-数字传输系统" class="headerlink" title="2.5 数字传输系统"></a>2.5 数字传输系统</h1><ul><li>早期的数字传输系统存在许多缺点，主要是以下两个：<ol><li><strong>速率标准不统一</strong>。多路复用的速率体系有两个互不兼容的国际标准，北美和日本的 T<sub>1</sub> 速率(1.544Mbit&#x2F;s) 和欧洲的 E<sub>1</sub> 速率 (2.048Mbit&#x2F;s)。</li><li><strong>不是同步传输</strong>。为了节约经费，各国的数字网主要采用<strong>准同步</strong>方式。在准同步系统中由于各支路信号的时钟频率有偏差，给时分复用和分用带来许多麻烦。当数据传输的速率很高时，收发双方的时钟同步就成大问题。</li></ol></li></ul><h1 id="2-6-宽带接入技术"><a href="#2-6-宽带接入技术" class="headerlink" title="2.6 宽带接入技术"></a>2.6 宽带接入技术</h1><h2 id="2-6-1-ADSL-技术"><a href="#2-6-1-ADSL-技术" class="headerlink" title="2.6.1 ADSL 技术"></a>2.6.1 ADSL 技术</h2><ul><li><strong>非对称数字用户线</strong> (ADSL) 技术是<strong>用数字技术对现有的模拟电话用户线进行改造</strong>，使它能承载宽带数字业务。    </li><li>ADSL 的传输距离取决于数据率和用户线的线径。ADSL 能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。<ol><li>用户线越细，信号传输时的衰减就越大。</li><li>传输速率越快，信号传输时的衰减就越大。</li></ol></li><li>基于ADSL 的接入网由三部分组成：<strong>数字用户线接入复用器</strong> DSLAM、用户线和用户家中的设施 (见图 2-20)。数字用户线接入复用器包括 ADSL 调制解调器。ADSL 调制解调器又称<strong>接入端接单元</strong> ATU。ADSL 调制解调器必须成对使用，因此把在电话端局 (或远端站) 和用户家中所用的 ADSL 调制解调器分别记为 ATU-C (C 代表<strong>端局</strong>) 和 ATU-R (R 代表<strong>远端</strong>)。用户电话通过电话<strong>分离器</strong>和 ATU-R 连在一起，经用户线到端局，并再经过电话分离器把电话连到本地电话交换机。电话分离器是无源的，它利用低通滤波器将电话信号与数字信号分开。将电话分离器做成无源的是为了在停电时不影响传统电话的使用。一个 DSLAM 可支持多达 500～1000 个用户。若按每户 6Mbit&#x2F;s 计算，则具有 1000 个端口的 DSLAM (这就需要用 1000 个 ATU-C) 应有高达 6Gbit&#x2F;s 的转发能力。ATU-C 要使用数字信号处理技术，因此 DSLAM 的价格较高。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230710170833.png"></li></ol></li><li>第二代 ADSL 改进的地方是：<ol><li>提高调制效率得到更高的数据率。</li><li>采用<strong>无缝速率自适应</strong>技术 (SRA)，可在运营中不中断通信和不产生误码的情况下，根据线路的实时状况，自适应地调整数据率。</li><li>改善线路质量评测和故障定位功能，对提高网络的运行维护水平具有重要意义。</li></ol></li></ul><h2 id="2-6-2-光纤同轴混合网-HFC-网"><a href="#2-6-2-光纤同轴混合网-HFC-网" class="headerlink" title="2.6.2 光纤同轴混合网 (HFC 网)"></a>2.6.2 光纤同轴混合网 (HFC 网)</h2><ul><li><strong>光纤同轴混合网</strong> (HFC 网) 是在目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还提供电话、数据和其他宽带交互型业务。</li><li>光纤同轴混合网 HFC 的特点：<ol><li>为提高传输的可靠性和电视信号的质量，HFC 网把原有线电视网中的同轴电缆主干部分改换为光纤 (图 2-23)。光纤从头端连接到<strong>光纤结点</strong>。在光纤结点光信号转换为电信号，然后通过同轴电缆传送到用户家庭。从头端到用户家庭所需的放大器数目减少到 4～5 个。连接到一个光纤结点的典型用户数是 500 左右，不超过 2000。</li><li>HFC 网具有双向传输功能，扩展了传输频带。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230710172306.png"></li></ol></li><li>使模拟电视机能接收数字电视信号，需要把<strong>机顶盒</strong>连接在同轴电缆和用户的电视机之间。为了使用户能够利用 HFC 网接入到互联网，以及在上行信道中传送交互数字电视所需的一些信息，还需要增加一个为 HFC 网使用的调制解调器，它又称为<strong>电缆调制解调器</strong>。</li></ul><h2 id="2-6-3-FTTx-技术"><a href="#2-6-3-FTTx-技术" class="headerlink" title="2.6.3 FTTx 技术"></a>2.6.3 FTTx 技术</h2><ul><li>为了更快地下载视频文件，更流畅地欣赏网上的高清视频节目，尽快地把用户的上网速率进行升级就成为 ISP 的重要任务，<strong>光纤到户</strong> (FTTH) 是最好的选择。</li><li>光纤到户 FTTH 有两个问题：<ol><li>价格不便宜</li><li>一般的家庭用户不需要过高的数据率的需求</li></ol></li><li>为了有效地利用光纤资源，在光纤干线和用户间，需要铺设一段中间的转换装置<strong>光配线网</strong> (ODN)，使数十个家庭用户能够共享一根光纤干线。</li><li>图 2-25 是广泛使用的无源光配线网的示意图。“无源”表明在光配线网中无须配备电源，基本上不用维护，其长期运营成本和管理成本很低。无源的光配线网常称为<strong>无源光网络</strong> (PON)。<ol><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network%7B419185F1-78FE-4077-9766-E3333D89BF52%7D.png"></li><li>在图 2-25 中，<strong>光线路终端</strong> OLT 是连接到光纤干线的终端设备。OLT 把收到的下行数据发往无源的 1：N <strong>光分路器</strong>，然后用广播方式向所有用户端的<strong>光网络单元</strong> ONU发送。</li><li>当 ONU 发送上行数据时，先把电信号转换为光信号，光分路器把各 ONU 发来的上行数据汇总后，以 TDMA 方式发往 OLT，而发送时间和长度都由 OLT 集中控制，以便有序地共享光纤主干。</li><li>无源光网络 PON 的种类很多，流行的有以下两种：<ul><li>以太网无源光网络 (EPON)，在链路层使用以太网协议，利用 PON 的拓扑结构实现了以太网的接入。EPON 的优点是：与现有以太网的兼容性好，并且成本低，扩展性强，管理方便。</li><li>吉比特无源光网络 (GPON)，GPON 采用<strong>通用封装方法</strong> (GEM)，可承载多业务，对各种业务类型都能够提供服务质量保证，是很有潜力的宽带光纤接入技术。</li></ul></li></ol></li><li>现在已有很多种不同的 FTTx。除了光纤到户 FTTH 外，还有<strong>光纤到路边</strong> FTTC (C 表示 Curb)、<strong>光纤到小区</strong> FTTZ (Z 表示 Zone)、<strong>光纤到大楼</strong> FTTB (B 表示 Building)、<strong>光纤到楼层</strong> FTTF (F 表示Floor)、<strong>光纤到办公室</strong> FTTO (O 表示 Office)、<strong>光纤到桌面</strong> FTTD (D 表示 Desk)，等等。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>物理层的任务是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。</p></li><li><p>一个数据通信系统可划分为三部分，即源系统、传输系统和目的系统。源系统包括源点 (或源站、信源) 和发送器，目的系统包括接收器和终点 (或目的站，或信宿)。</p></li><li><p>通信的目的是传送消息。如话音、文字、图像、视频等。数据是运送消息的实体。信号则是数据的电气或电磁的表现。</p></li><li><p>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号 (连续信号) 和数字信号 (离散信号)。代表数字信号不同离散数值的基本波形称为码元。</p></li><li><p>根据双方信息交互的方式，通信划分为单向通信 (单工通信)、双向交替通信 (半双工通信) 和双向同时通信 (全双工通信)。</p></li><li><p>来自信源的信号叫基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅、调频和调相。还有更复杂的调制方法，如正交振幅调制。</p></li><li><p>要提高数据在信道上的传输速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能被任意地提高。</p></li><li><p>传输媒体分为两类，即导引型传输媒体 (双绞线、同轴电缆或光纤) 和非导引型传输媒体 (无线或红外或大气激光)。</p></li><li><p>常用的信道复用技术有频分复用、时分复用、统计时分复用、码分复用和波分复用 (光的频分复用)。</p></li><li><p>最初在数字传输系统中使用的传输标准是脉冲编码调制 PCM。现在高速的数字传输系统使用同步光纤网 SONET (美国标准) 或同步数字系列 SDH (国际标准)。</p></li><li><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL (用数字技术对现有的模拟电话用户线进行改造)、光纤同轴混合网 HFC (在有线电视网的基础上开发的) 和 FTTx。</p></li><li><p>为了有效地利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无须配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</p></li><li><p>为什么要使用信道复用技术？常用的信道复用技术有哪些？</p><blockquote><p>许多用户通过复用技术就可以共同使用一个共享信道来进行通信。虽然复用要付出一定代价 (共享信道由于带宽较大因而费用也较高,再加上复用器和分用器也要增加成本) 但如果复用的信道数量较大，那么总的来看在经济上还是合算的。<br>常用的复用技术有: 频分复用、时分复用 (包括统计时分复用)、波分复用 (包括密集波分复用和稀疏波分复用) 和码分复用 (即码分多址)。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 概述</title>
      <link href="/2024/04/20/study/ji-suan-ji-wang-luo/di-1-zhang-gai-shu/"/>
      <url>/2024/04/20/study/ji-suan-ji-wang-luo/di-1-zhang-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-计算机网络在信息时代中的作用"><a href="#1-1-计算机网络在信息时代中的作用" class="headerlink" title="1.1 计算机网络在信息时代中的作用"></a>1.1 计算机网络在信息时代中的作用</h1><ul><li>互联网具有两个重要基本特点，<strong>连通性</strong>和<strong>共享</strong>。<ol><li>连通性：互联网使上网用户之间，不管相距多远，都可以非常便捷、非常经济地交换各种信息。</li><li>共享指<strong>资源共享</strong>。资源共享可以是信息共享、软件共享，也可以是硬件共享。</li></ol></li></ul><h1 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h1><h2 id="1-2-1-网络的网络"><a href="#1-2-1-网络的网络" class="headerlink" title="1.2.1 网络的网络"></a>1.2.1 网络的网络</h2><ul><li><strong>计算机网络</strong>（简称为<strong>网络</strong>）由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。网络中的结点可以是计算机、集线器、交换机或路由器等。图 1-1(a) 给出了一个具有四个结点和三条链路的网络。有三台计算机通过三条链路连接到一个集线器上，构成了一个简单的计算机网络。可以用一朵云表示一个网络。</li><li>网络之间通过路由器互连起来，构成覆盖范围更大的计算机网络。这样的网络称为<strong>互连网</strong>，如图 1-1(b) 所示。因此互连网是“<strong>网络的网络</strong>”。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630153611.png"></li><li><strong>网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机。</strong></li></ul><h2 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 <strong>互联网基础结构发展的三个阶段</strong></h2><ul><li>第一阶段是从单个网络 ARPANET 向互连网发展的过程。</li><li>第二阶段的特点是建成了<strong>三级结构的互联网</strong>。</li><li>第三阶段的特点是逐渐形成了<strong>多层次 ISP 结构的互联网</strong>。</li></ul><h2 id="1-2-3-互联网的标准化工作"><a href="#1-2-3-互联网的标准化工作" class="headerlink" title="1.2.3 互联网的标准化工作"></a>1.2.3 <strong>互联网的标准化工作</strong></h2><ul><li>国际性组织<strong>互联网协会</strong> (简称 ISOC)，对互联网进行全面管理以及在世界范围内促进其发展和使用。ISOC 下面有一个技术组织叫做<strong>互联网体系结构委员会</strong> (简称 IAB)，负责管理互联网有关协议的开发。IAB 下面又设有两个工程部：<ol><li><strong>互联网工程部</strong>（简称 IETF）</li><li><strong>互联网研究部</strong>（简称 IRTF）</li></ol></li><li>制定互联网的正式标准要经过以下三个阶段：<ol><li><strong>互联网草案</strong>——互联网草案的有效期只有六个月。在这个阶段还不能算是 RFC 文档。</li><li><strong>建议标准</strong>——从这个阶段开始就成为 RFC 文档。</li><li><strong>互联网标准</strong>——达到正式标准后，每个标准就分配到一个编号 STD xx。一个标准可以和多个RFC 文档关联。截止到 2016 年 7 月，互联网标准的最大编号是 STD 83。</li></ol></li></ul><h1 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h1><ul><li>互联网的拓扑结构非常复杂，并且覆盖了全球，从工作方式上看，划分为以下两大块：<ol><li><strong>边缘部分</strong>：由所有连接在互联网上的主机组成。<strong>用户直接使用</strong>，用来进行通信和资源共享。</li><li><strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。<strong>为边缘部分提供服务的</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630205219.png"></li></ol></li></ul><h2 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 <strong>互联网的边缘部分</strong></h2><ol><li><strong>计算机之间通信</strong>：<strong>主机 A 的某个进程和主机 B 上的另一个进程进行通信</strong></li><li><strong>客户——服务器方式</strong><ul><li><strong>客户</strong>和<strong>服务器</strong>是指通信中所涉及的两个应用进程。客户——服务器方式所描述的是进程之间服务和被服务的关系。</li><li><strong>客户是服务请求方，服务器是服务提供方。</strong></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630205735.png"></li><li><strong>客户程序：</strong><ol><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和复杂的操作系统。</li></ol></li><li><strong>服务器程序：</strong><ol><li>是一种用来提供某种服务的程序，<strong>可同时处理</strong>多个远地或本地客户的请求。</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。服务器程序不需要知道客户程序的地址。</li><li>需要有强大的硬件和高级的操作系统支持。</li></ol></li></ul></li><li><strong>对等连接方式</strong><ul><li><strong>对等连接</strong> (简称 P2P) 指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机运行了对等连接软件 (P2P 软件)，就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。因此这种工作方式也称为 <strong>P2P 方式</strong> 。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630223247.png"></li></ul></li></ol><h2 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2 互联网的核心部分"></a>1.3.2 互联网的核心部分</h2><ol><li>在网络核心部分起特殊作用的是<strong>路由器</strong>，是一种专用计算机。路由器是实现<strong>分组交换</strong>的关键构件，任务是<strong>转发收到的分组</strong>，是网络核心部分最重要的功能。</li><li><strong>电路交换的主要特点</strong><ul><li>从通信资源的分配角度来看，<strong>交换</strong>是按照某种方式动态地分配传输线路的资源</li><li>必须经过“<strong>建立连接</strong> (占用通信资源) →<strong>通话</strong> (一直占用通信资源) →<strong>释放连接</strong> (归还通信资源) ”三个步骤的交换方式称为<strong>电路交换</strong>。</li><li><strong>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</strong>。</li><li>使用电路交换来传送计算机数据时，<strong>线路的传输效率很低</strong>。因为计算机数据是突发式地出现在传输线路上的，因此线路上真正用来传送数据的时间很短。已被用户占用的通信线路资源在绝大部分时间里都是空闲的。</li></ul></li><li><strong>分组交换的主要特点</strong><ul><li>分组交换采用<strong>存储转发</strong>技术。</li><li>把要发送的整块数据称为一个<strong>报文</strong>。在发送报文前，把较长的报文划分成为一个个更小的等长数据段。在每一个数据段前，加上由必要的控制信息组成的<strong>首部</strong> (包头) 后，构成一个<strong>分组</strong> (包)。分组是在互联网中传送的数据单元。分组的首部包含目的地址和源地址等，使分组能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</li><li>位于网络边缘的主机和位于网络核心部分的路由器都是计算机，但作用不一样。<strong>主机是为用户进行信息处理的</strong>，并且可以和其他主机通过网络交换信息。<strong>路由器则是用来转发分组的，进行分组交换的</strong>。路由器收到一个分组，先暂时存储，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地以存储转发的方式，把分组交付最终的目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</li><li><strong>分组交换的优点</strong>：<ol><li>高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</li><li>灵活：为每一个分组选择合适的转发路由</li><li>迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性</li></ol></li><li><strong>分组交换的缺点</strong>：<ol><li>分组在各路由器存储转发时需要排队，会造成<strong>时延</strong>。由于分组交换不像电路交换那样通过建立连接来保证通信时所需的各种资源，因而无法确保通信时端到端所需的带宽。</li><li>各分组必须携带的控制信息造成了<strong>开销</strong>。分组交换网需要专门的管理和控制机制。</li></ol></li></ul></li></ol><ul><li>三种交换的比较<ol><li><strong>电路交换</strong>——整个报文的比特流连续地从源点直达终点</li><li><strong>报文交换</strong>——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li><li><strong>分组交换</strong>——单个分组 (这只是整个报文的一部分) 传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701111637.png"></li></ol></li></ul><h1 id="1-4-计算机网络在我国的发展"><a href="#1-4-计算机网络在我国的发展" class="headerlink" title="1.4 计算机网络在我国的发展"></a>1.4 计算机网络在我国的发展</h1><h1 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h1><h2 id="1-5-1-计算机网络的定义"><a href="#1-5-1-计算机网络的定义" class="headerlink" title="1.5.1 计算机网络的定义"></a>1.5.1 计算机网络的定义</h2><ul><li><strong>计算机网络的定义</strong><ol><li>计算机网络：计算机网络主要是由一些通用的、可编程的硬件互连而成的，这些硬件并非专门用来实现某一特定目的，它们能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，还包括了智能手机；计算机网络并非专门用来传送数据，还能支持很多种的应用。</li></ul></li></ol></li></ul><h2 id="1-5-2-几种不同类别的计算机网络"><a href="#1-5-2-几种不同类别的计算机网络" class="headerlink" title="1.5.2 几种不同类别的计算机网络"></a>1.5.2 几种不同类别的计算机网络</h2><ul><li><strong>几种不同类别的计算机网络</strong><ol><li><strong>按照网络的作用范围进行分类</strong><ul><li><strong>广域网</strong> (WAN) 作用范围通常为几十到几千公里，也称<strong>远程网</strong>。广域网是互联网的核心部分，任务是长距离运送主机所发送的数据。连接广域网各结点交换机的链路一般都是高速链路，具有较大的通信容量。</li><li><strong>城域网</strong> (MAN) 作用范围一般是城市，跨越几个街区甚至整个城市，作用距离约为 5～50km。城域网可以为一个或几个单位所拥有，也可以是一种公用设施，用来将多个局域网进行互连。目前很多城域网采用的是以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li><strong>局域网</strong> (LAN) 一般用微型计算机或工作站通过高速通信线路相连 (速率通常在10Mbit&#x2F;s 以上)，但地理上则局限在较小的范围 (如 1km 左右)。在局域网发展的初期，一个学校或工厂往往只拥有一个局域网，但现在局域网已非常广泛地使用，学校或企业大都拥有许多个互连的局域网 (这样的网络常称为<strong>校园网</strong>或<strong>企业网</strong>)。</li><li><strong>个人区域网</strong> (PAN) 在个人工作的地方把属于个人使用的电子设备 (如便携式电脑) 用无线技术连接起来的网络，因此也常称为<strong>无线个人区域网</strong> (WPAN)，其范围很小，大约在10m左右。</li></ul></li><li><strong>按照网络的使用者进行分类</strong><ul><li><strong>公用网</strong>：电信公司 (国有或私有) 出资建造的大型网络。“公用”的意思就是所有愿意按电信公司的规定交纳费用的人都可以使用这种网络。因此公用网也可称为<strong>公众网</strong>。</li><li><strong>专用网</strong>：某个部门为满足本单位的特殊业务工作的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如，军队、铁路、银行、电力等系统均有本系统的专用网。</li></ul></li><li><strong>用来把用户接入到互联网的网络</strong><ul><li><strong>接入网</strong> (AN)，又称为<strong>本地接入网</strong>或<strong>居民接入网</strong></li><li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。是从某个用户端系统到互联网中的第一个路由器之间的一种网络。</li></ul></li></ol></li></ul><h1 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h1><h2 id="1-6-1-计算机网络的性能"><a href="#1-6-1-计算机网络的性能" class="headerlink" title="1.6.1 计算机网络的性能"></a>1.6.1 计算机网络的性能</h2><ul><li><strong>计算机网络的性能指标</strong><ol><li>速率<ul><li><strong>比特</strong>来源于 binary digit，意思是一个“<strong>二进制数字</strong>”，因此一个比特就是二进制数字中的一个 1 或 0。</li><li>比特也是信息论中使用的<strong>信息量的单位</strong>。网络技术中的<strong>速率</strong>指的是<strong>数据的传送速率</strong>，它也称为<strong>数据率</strong>或<strong>比特率</strong>。</li></ul></li><li><strong>带宽</strong><ul><li>在计算机网络中，带宽用来表示网络中某<strong>通道</strong>传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“<strong>最高数据率</strong>”。这种意义的<strong>带宽的单位</strong>就是<strong>数据率的单位</strong> bit&#x2F;s，是<strong>比特每秒</strong>。</li><li>在“带宽”的上述两种表述中，前者为<strong>频域</strong>称谓，而后者为<strong>时域</strong>称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</li></ul></li><li><strong>吞吐量</strong><ul><li><strong>吞吐量</strong>表示在单位时间内通过某个网络的实际的数据量。</li><li>吞吐量受网络的带宽或网络的额定速率的限制。</li></ul></li><li><strong>时延</strong><ul><li><strong>时延</strong>指数据从网络的一端传送到另一端所需的时间。</li><li>时延是很重要的性能指标，有时也称为延迟或迟延。</li><li>时延由以下组成：<ol><li><strong>发送时延</strong>　发送时延是主机或路由器发送数据帧所需要的时间，从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。因此发送时延也叫做<strong>传输时延</strong>。发送时延的计算公式是：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701153549.png"></li><li>发送时延并非固定不变，而是与发送的帧长成正比，与发送速率成反比。</li></ul></li><li><strong>传播时延</strong>　传播时延是电磁波在信道中传播一定的距离需要花费的时间。传播时延的计算公式是：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701153757.png"></li><li>发送时延发生在机器内部的发送器中，<strong>与传输信道的长度 (或信号传送的距离) 没有关系</strong>。传播时延发生在机器外部的传输信道媒体上，<strong>与信号的发送速率无关</strong>。<strong>信号传送的距离越远，传播时延就越大</strong>。</li></ul></li><li><strong>处理时延</strong> 　主机或路由器在收到分组时要花费时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。</li><li><strong>排队时延</strong> 　分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。排队时延的长短往往取决于网络当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大。</li><li>数据在网络中经历的总时延就是四种时延之和：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702225623.png"></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702163416.png"></li><li><strong>对于高速网络链路，提高的仅是数据的发送速率而不是比特在链路上的传播速率</strong>。</li><li><strong>提高数据的发送速率减小了数据的发送时延</strong>。数据的发送速率的单位是每秒发送多少个比特，指在<strong>某个点</strong>或<strong>某个接口上</strong>的发送速率。而传播速率的单位是每秒传播多少公里，指在<strong>某一段传输线路上</strong>比特的传播速率。</li></ol></li></ul></li><li><strong>时延带宽积</strong><ul><li>把网络性能的两个度量——传播时延和带宽相乘，就得到另一个度量：传播<strong>时延带宽积</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702163707.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164122.png"></li></ol></li><li>若发送端连续发送数据，则在发送的第一个比特即将达到终点时，发送端就已经发送了20 万个比特，而这 20 万个比特都正在链路上向前移动。因此，链路的时延带宽积又称为<strong>以比特为单位的链路长度</strong>。</li></ul></li><li><strong>往返时间 RTT</strong><ul><li>互联网上的信息不是单向传输而是双向交互的。</li><li>A 向 B 发送数据。如果数据长度是 100MB，发送速率是 100Mbit&#x2F;s，那么<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164237.png"></li><li>如果 B 正确收完 100MB 的数据后，就立即向 A 发送确认。再假定 A 只有在收到 B 的确认信息后，才能继续向 B 发送数据。显然，这需要等待一个往返时间 RTT (这里假定确认信息很短，可忽略 B 发送确认的时间)。如果 RTT＝2s，那么可以算出 A 向 B 发送数据的有效数据率。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164313.png"></li></ol></li></ul></li><li><strong>利用率</strong><ul><li><strong>利用率</strong>有信道利用率和网络利用率两种。<ol><li>信道利用率指出某信道有百分之几的时间是被利用的。完全空闲的信道利用率是零。</li><li>网络利用率是全网络信道利用率的加权平均值。</li><li>信道利用率并非越高越好。根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也迅速增加。和高速公路的情况有些相似。当高速公路上的车流量很大时，由于在公路上的某些地方会出现堵塞，因此行车所需的时间就会变长。同样，当网络的通信量很少时，网络产生的时延并不大。但在网络通信量不断增大的情况下，由于分组在网络结点、进行处理时需要排队等候，因此网络引起的时延就会增大。</li></ol></li><li>如果令 <em>D<sub>0</sub></em> 表示网络空闲时的时延，<em>D</em> 表示网络当前的时延，用下面的公式来表示 <em>D</em>，<em>D<sub>0</sub></em> 和利用率 <em>U</em> 之间的关系：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702165329.png"></li><li><em>U</em> 是网络的利用率，数值在 0 到 1 之间。当网络的利用率达到其容量的 1&#x2F;2 时，时延就要加倍。</li><li>当网络的利用率接近最大值 1 时，网络的时延就趋于无穷大。</li><li><strong>信道或网络的利用率过高会产生非常大的时延</strong></li><li>一些拥有较大主干网的 ISP 通常控制信道利用率不超过 50％。如果超过了就要准备扩容，增大线路的带宽。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702205609.png"></li></ol></li></ul></li></ol></li></ul><h2 id="1-6-2-计算机网络的非性能特征"><a href="#1-6-2-计算机网络的非性能特征" class="headerlink" title="1.6.2 计算机网络的非性能特征"></a>1.6.2 计算机网络的非性能特征</h2><ul><li><strong>计算机网络的非性能特征</strong><ol><li><strong>费用</strong><ul><li>网络的性能与其价格密切相关。网络的速率越高，价格也越高。</li></ul></li><li><strong>质量</strong><ul><li>网络的质量取决于网络中所有构件的质量，以及这些构件是怎样组成网络的。网络的质量影响很多方面，如网络的可靠性、网络管理的简易性，以及网络的性能。但网络的性能与网络的质量并不一样。</li></ul></li><li><strong>标准化</strong><ul><li>网络的硬件和软件的设计既可以按照通用的国际标准，也可以遵循特定的专用网络标准。采用国际标准的设计，可以得到更好的互操作性，更易于升级换代和维修，也更容易得到技术上的支持。</li></ul></li><li><strong>可靠性</strong><ul><li>可靠性与网络的质量和性能密切相关。高速网络的可靠性不一定很差。但高速网络要可靠地运行，则往往更加困难，同时所需的费用也会较高。</li></ul></li><li><strong>可扩展性和可升级性</strong><ul><li>在构造网络时应当考虑到今后需要扩展和升级。网络的性能越高，其扩展费用往往也越高，难度也会相应增加。</li></ul></li><li><strong>易于管理和维护</strong><ul><li>网络如果没有良好的管理和维护，很难达到和保持所设计的性能。</li></ul></li></ol></li></ul><h1 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h1><ul><li>在计算机网络的基本概念中，分层次的体系结构是最基本的。</li></ul><h2 id="1-7-1-计算机网络体系结构的形成"><a href="#1-7-1-计算机网络体系结构的形成" class="headerlink" title="1.7.1 计算机网络体系结构的形成"></a>1.7.1 计算机网络体系结构的形成</h2><ul><li><strong>计算机网络体系结构的形成</strong><ol><li>计算机网络是个复杂的系统。、设想一种最简单的情况：连接在网络上的两台计算机要互相传送文件。在这两台计算机之间必须有一条传送数据的通路。但还有以下工作需要完成：<ul><li>发起通信的计算机必须将数据通信的通路进行<strong>激活</strong>，即发出一些信令，保证要传送的计算机数据能在这条通路上正确发送和接收。</li><li>要告诉网络如何识别接收数据的计算机。</li><li>发起通信的计算机必须查明对方计算机是否已开机，并且与网络连接正常。</li><li>发起通信的计算机中的应用程序必须清楚，在对方计算机中的文件管理程序是否已做好接收文件和存储文件的准备工作。</li><li>若计算机的文件格式不兼容，则至少其中一台计算机应完成格式转换功能。</li><li>对出现的各种差错和意外事故，如数据传送错误、重复或丢失，网络中某个结点交换机出现故障等，应当有可靠的措施保证对方计算机最终能够收到正确的文件。</li></ul></li></ol></li></ul><h2 id="1-7-2-协议与划分层次"><a href="#1-7-2-协议与划分层次" class="headerlink" title="1.7.2 协议与划分层次"></a>1.7.2 协议与划分层次</h2><ul><li><strong>协议与划分层次</strong><ol><li>在计算机网络中要做到有条不紊地交换数据，必须遵守一些事先约定好的规则。<strong>这些规则明确规定了所交换的数据的格式以及有关的同步问题</strong>。</li><li><strong>为进行网络中的数据交换而建立的规则、标准或约定</strong>称为<strong>网络协议</strong>。网络协议也可简称为<strong>协议</strong>，主要由以下三个要素组成：<ul><li>语法，即数据与控制信息的结构或格式；</li><li>语义，即需要发出何种控制信息，完成何种动作以及做出何种响应；</li><li>同步，即事件实现顺序的详细说明。</li></ul></li><li>协议通常有两种不同的形式。一种是使用便于人来阅读和理解的文字描述。另一种是使用让计算机能够理解的程序代码。这两种不同形式的协议都必须能够对网络上的信息交换过程做出精确的解释。</li><li>分层可以带来很多好处。如：<ul><li><strong>各层之间是独立的</strong>。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。整个问题的复杂程度就下降了。</li><li><strong>灵活性好</strong>。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某一层提供的服务还可进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。</li><li><strong>结构上可分割开</strong>。各层都可以采用最合适的技术来实现。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。</li><li><strong>能促进标准化工作</strong>。因为每一层的功能及其所提供的服务都已有了精确的说明。</li></ul></li><li>分层时应使每一层的功能非常明确。若层数太少，就会使每一层的协议太复杂。但层数太多又会在描述和综合各层功能的系统工程任务时遇到较多的困难。通常各层所要完成的功能主要有以下一些：<ul><li><strong>差错控制</strong> 　使相应层次对等方的通信更加可靠。</li><li><strong>流量控制</strong> 　发送端的发送速率必须使接收端来得及接收，不能太快。</li><li><strong>分段和重装</strong> 　发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><strong>复用和分用</strong> 　发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><strong>连接建立和释放</strong> 　交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li><li>分层也有一些缺点，例如，有些功能会在不同的层次中重复出现，产生额外开销。</li></ul></li><li><strong>计算机网络的各层及其协议的集合</strong>就是网络的<strong>体系结构</strong>。换种说法，<strong>计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义</strong>。</li><li><strong>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件</strong>。</li></ol></li></ul><h2 id="1-7-3-具有五层协议的体系结构"><a href="#1-7-3-具有五层协议的体系结构" class="headerlink" title="1.7.3 具有五层协议的体系结构"></a>1.7.3 具有五层协议的体系结构</h2><ul><li><strong>具有五层协议的体系结构</strong><ol><li><strong>应用层</strong><ul><li>应用层是体系结构中的最高层。</li><li>应用层的任务是<strong>通过应用进程间的交互来完成特定网络应用</strong>。</li><li>应用层协议定义的是<strong>应用进程间通信和交互的规则</strong>。<strong>进程</strong>指主机中<strong>正在运行的程序</strong>。</li><li>应用层交互的数据单元称为<strong>报文</strong>。</li></ul></li><li><strong>运输层</strong><ul><li>运输层的任务是负责向<strong>两台主机中进程之间的通信</strong>提供<strong>通用的数据传输</strong>服务。</li><li>运输层主要使用以下两种协议：<ol><li><strong>传输控制协议</strong> (TCP)——提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>。</li><li><strong>用户数据报协议</strong> (UDP)——提供无连接的、<strong>尽最大努力</strong>的数据传输服务，其数据传输的单位是<strong>用户数据报</strong>。</li></ol></li></ul></li><li><strong>网络层</strong><ul><li>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。</li><li>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成<strong>分组</strong>或<strong>包</strong>进行传送。</li><li>在 TCP&#x2F;IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 <strong>IP 数据报</strong>，简称<strong>数据报</strong>。</li><li><strong>无论在哪一层传送的数据单元，都可笼统地用“分组”来表示</strong>。</li><li>网络层的另一个任务是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</li><li>网络层中的“<strong>网络</strong>”，不是我们谈到的具体网络，而是在计算机网络体系结构模型中的第 3 层的名称。</li><li>互联网是由大量的<strong>异构</strong>网络通过<strong>路由器</strong>相互连接起来的，使用的网络层协议是无连接的<strong>网际协议</strong> (IP) 和许多种路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或 <strong>IP 层</strong>。</li></ul></li><li><strong>数据链路层</strong><ul><li>数据链路层简称<strong>链路层</strong>。</li><li>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报<strong>组装成帧</strong>，在两个相邻结点间的链路上传送<strong>帧</strong>。每一帧包括数据和<strong>控制信息</strong>。</li></ul></li><li><strong>物理层</strong><ul><li>在物理层上所传数据的单位是<strong>比特</strong>。</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703110014.png"></li><li>图1-19 说明应用进程的数据在各层之间的传递过程中所经历的变化。假定两台主机通过一台路由器连接起来。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703110122.png"></li><li>假定主机1的应用进程AP 1 向主机2的应用进程AP 2 传送数据。AP 1 先将其数据交给本主机的第5层（应用层）。第5层加上必要的控制信息H 5 就变成了下一层的数据单元。第4层（运输层）收到这个数据单元后，加上本层的控制信息H 4 ，再交给第3层（网络层），成为第3层的数据单元。依此类推。不过到了第2层（数据链路层）后，控制信息被分成两部分，分别加到本层数据单元的首部（H 2 ）和尾部（T 2 ）；而第1层（物理层）由于是比特流的传送，所以不再加上控制信息。请注意，传送比特流时应从首部开始传送。</li><li>OSI参考模型把对等层次之间传送的数据单位称为该层的<strong>协议数据单元</strong>（PDU）。这个名词现已被许多非OSI标准采用。</li><li>当这一串的比特流离开主机1经网络的物理媒体传送到路由器时，就从路由器的第1层依次上升到第3层。每一层都根据控制信息进行必要的操作，然后将控制信息剥去，将该层剩下的数据单元上交给更高的一层。当分组上升到了第3层时，就根据首部中的目的地址查找路由器中的转发表，找出转发分组的接口，然后往下传送到第2层，加上新的首部和尾部后，再到最下面的第1层，然后在物理媒体上把每一个比特发送出去。</li><li>当这一串的比特流离开路由器到达目的站主机2时，就从主机2的第1层按照上面讲过的方式，依次上升到第5层。最后，把应用进程AP 1 发送的数据交给目的站的应用进程AP 2 。</li><li>可以用一个简单例子来比喻上述过程。有一封信从最高层向下传。每经过一层就包上一个新的信封，写上必要的地址信息。包有多个信封的信件传送到目的站后，从第1层起，每层拆开一个信封后就把信封中的信交给它的上一层。传到最高层后，取出发信人所发的信交给收信人。</li><li>虽然应用进程数据要经过如图1-19所示的复杂过程才能送到终点的应用进程，但这些复杂过程对用户来说，却都被屏蔽掉了，以致应用进程AP 1 觉得好像是直接把数据交给了应用进程AP 2 。同理，任何两个同样的层次（例如在两个系统的第4层）之间，也好像如同图1-19中的水平虚线所示的那样，把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“<strong>对等层</strong> ”（peer layers）之间的通信。我们以前经常提到的各层协议，实际上就是在各个对等层之间传递数据时的各项规定。</li><li>在文献中也还可以见到术语“<strong>协议栈</strong>”。这是因为几个层次画在一起很像一个<strong>栈</strong>的结构。</li></ul></li></ol></li></ul><h2 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h2><ul><li><strong>实体、协议、服务和服务访问点</strong><ol><li>当研究开放系统中的信息交换时，使用<strong>实体</strong>这一抽象的名词表示<strong>任何可发送或接收信息的硬件或软件进程</strong>。</li><li><strong>协议是控制两个对等实体</strong> (或<strong>多个实体</strong>) <strong>进行通信的规则的集合</strong>。协议的语法方面规则定义了所交换信息的格式，协议的语义方面规则定义了发送者或接收者所要完成的操作，例如，在何种条件下，数据必须重传或丢弃。</li><li><strong>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</strong></li><li>协议和服务在概念上不一样：<ul><li>协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。下面的协议对上面的实体是透明的。</li><li><strong>协议是“水平的”</strong>，协议是控制对等实体之间通信的规则；但<strong>服务是“垂直的”</strong>，即服务是由下层向上层通过层间接口提供的。</li><li>并非在一个层内完成的全部功能都称为服务。只有能够被高一层实体“<strong>看得见</strong>”的功能才能称之为“服务”。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在 OSI 中称为<strong>服务原语</strong>。</li><li>在同一系统中相邻两层的实体进行交互的地方，通常称为<strong>服务访问点</strong> (SAP)。服务访问点 SAP 是一个抽象的概念，是一个逻辑接口，有点像邮政信箱 (可以把邮件放入信箱和从信箱中取走邮件)，但这种层间接口和两个设备之间的硬件接口并不一样。</li><li>在任何相邻两层之间的关系可概括为图 1-20 所示的那样。第 n 层的两个“实体 (n) ”之间通过“协议 (n) ”进行通信，而第 n＋1 层的两个“实体 (n＋1) ”之间则通过另外的“协议 (n＋1) ”进行通信 (每一层都使用不同的协议) 。第 n 层向上面的第 n＋1 层所提供的服务实际上已包括了在它以下各层所提供的服务。第 n 层的实体对第 n+1 层的实体就相当于一个服务提供者。在服务提供者的上一层的实体又称为“服务用户”，因为它使用下层服务提供者所提供的服务。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703113458.png"></li></ol></li></ul></li></ol></li></ul><h2 id="1-7-5-TCP-IP-的体系结构"><a href="#1-7-5-TCP-IP-的体系结构" class="headerlink" title="1.7.5 TCP&#x2F;IP 的体系结构"></a>1.7.5 TCP&#x2F;IP 的体系结构</h2><ul><li><strong>TCP&#x2F;IP 的体系结构</strong><ol><li>TCP&#x2F;IP 协议<strong>可以为应用提供服务</strong>，同时 TCP&#x2F;IP 协议也<strong>允许 IP 协议在网络构成的互联网上运行</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703152732.png"></li></ol></li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>计算机网络把计算机连接在一起，互连网把网络连接在一起，是网络的网络。</p></li><li><p>以小写字母 i 开始的 internet (互连网) 是通用名词，泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</p></li><li><p>以大写字母 I 开始的 Internet (互联网) 是专用名词，指当前全球最大的、开放的、由网络相互连接而成的特定互连网，并采用 TCP&#x2F;IP 协议族作为通信规则。</p></li><li><p>互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。</p></li><li><p>互联网按工作方式划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</p></li><li><p>计算机通信是计算机中进程之间的通信。计算机网络采用的通信方式是客户–服务器方式和对等连接方式 (P2P 方式)。</p></li><li><p>客户和服务器指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</p></li><li><p>按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和个人区域网 PAN。</p></li><li><p>计算机网络常用的性能指标是：速率、带宽、吞吐量、时延 (发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道 (或网络) 利用率。</p></li><li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p></li><li><p>五层协议的体系结构由应用层、运输层、网络层 (或网际层)、数据链路层和物理层组成。运输层最重要的协议是 TCP 和 UDP 协议，而网络层最重要的协议是 IP 协议。</p></li><li><p>叙述具有五层协议的网络体系结构的要点，包括各层的主要功能。</p><blockquote><p>(1) 物理层——在物理层上所传数据的单位是比特 (bit)。物理层的任务是透明地传送比特流。物理层还要确定连接电缆的插头应当有多少根引脚以及各条引脚应如何连接。当然，哪几个比特代表什么意思，则不是物理层所要管的。请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。因此也有人把物理媒体当作第 0 层。<br>(2) 数据链路层——常简称为链路层。在两个相邻结点之间 (主机和路由器之间或两个路由器之间) 传送数据是直接传送的 (即不需要经过转发的点对点通信)。这时就需要使用专门的链路层的协议。数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻结点间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息 (如同步信息、地址信息、差错控制等)。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如果需要改正错误，就由运输层的 TCP 协议来完成。<br>(3) 网络层——网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在 TCP&#x2F;IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 IP 数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。对于由广播信道构成的分组交换网，路由选择的问题很简单，因此这种网络的网络层非常简单，甚至可以没有。<br>(4) 运输层——运输层的任务是负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中的相应的进程运输层主要使用以下两种协议: 一个是传输控制协议 TCP，是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。另一个是用户数据报协议 UDP，是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能“尽最大努力交付”。<br>(5) 应用层——应用层是体系结构中的最高层。应用层直接为用户的应用进程提供服务这里的进程就是指正在运行的程序。在互联网中的应用层协议很多，如支持万维网应用的 HTTP 协议、支持电子邮件的 SMTP 协议、支持文件传送的 FTP 协议，等等。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;% tp.file.title %&gt;</title>
      <link href="/2024/04/20/study/mo-ban/temp/"/>
      <url>/2024/04/20/study/mo-ban/temp/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《外婆的道歉信》</title>
      <link href="/2024/04/20/read/yue-du/wai-po-de-dao-qian-xin/"/>
      <url>/2024/04/20/read/yue-du/wai-po-de-dao-qian-xin/</url>
      
        <content type="html"><![CDATA[<p>主角是一个七岁的孩子，她的名字叫爱莎。她的父母离婚并且分别再婚了，爱莎跟着母亲和后父生活。爱莎与众不同，她喜欢“咬文嚼字”（这是她从生父那里遗传的），比同龄人更加成熟，因此在学校经常被霸凌，但是她有一个很爱她的外婆。<br>外婆也是一个与众不同的老人，她抽烟、上厕所不关门、开车闯红灯、翻墙去动物园，但她真的很爱爱莎。外婆向爱莎讲述了自己搭建的世界，云兽、呜斯、狼心。<br>爱莎的父母虽然离婚又分别再婚，但无论是乔治还是莉丝特他们也都很爱爱莎。<br>爱莎住的公寓里有很多有趣的人，他们也有爱莎发生了妙趣横生的故事。<br>虽然小说前面会出现很多姓名，有些令人头昏脑花，但这些令人目眩的东西所埋下的伏笔，值得我们为后面的故事而等待<br>——2023.07.28（29补）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《棋王 树王 孩子王》</title>
      <link href="/2024/04/20/read/yue-du/qi-wang-shu-wang-hai-zi-wang/"/>
      <url>/2024/04/20/read/yue-du/qi-wang-shu-wang-hai-zi-wang/</url>
      
        <content type="html"><![CDATA[<p>分别是王一生、肖疙瘩、老杆儿<br>棋王在下乡的年代里借由象棋来充实自己的精神世界，并且将捡垃圾老人的箴言铭记于心，作为自己人生的指路标，承载着母亲疼爱的无字象棋也是棋王的精神寄托。生不可太盛，棋不可为生。<br>树王所率领的队伍在一次任务中犯错，后来就在一处山底生活，山顶有棵大树。响应号召的下乡青年伐木垦田，山顶大树自然也是目标之一。树王不希望大树被伐，但青年代表表示要“除旧迎新“旧的大树需得砍掉。树王沉默不语，看着青年代表将大树伐掉。大树倒后，肖疙瘩便郁郁寡终。<br>孩子王是老师，但主角是学生。青年们下乡，孩子们仍需学习，或因乡镇差距过大，九年级的学生识字却不如从前的五年级学生，熟虑之后孩子王不再照本宣科，每天教孩子们识字，让孩子们写些日常作文。最后因教学计划不达标开除归队。<br>——2023.07.25</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《罪与罚》</title>
      <link href="/2024/04/20/read/yue-du/zui-yu-fa/"/>
      <url>/2024/04/20/read/yue-du/zui-yu-fa/</url>
      
        <content type="html"><![CDATA[<p>优点：详细的心理描写、富有哲学意味的对话<br>缺点：翻译带来的文化差异</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《局外人》</title>
      <link href="/2024/04/20/read/yue-du/ju-wai-ren/"/>
      <url>/2024/04/20/read/yue-du/ju-wai-ren/</url>
      
        <content type="html"><![CDATA[<p>柳鸣九译本<br>优点：语言简练<br>缺点：<br>剧情平淡，局外人——身外之人</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《环界》系列</title>
      <link href="/2024/04/20/read/yue-du/huan-jie-xi-lie/"/>
      <url>/2024/04/20/read/yue-du/huan-jie-xi-lie/</url>
      
        <content type="html"><![CDATA[<ul><li>铃<br>优点：《午夜凶铃》原著、未知的诅咒、部分情节耐人寻味<br>缺点：部分翻译不恰当</li><li>螺旋<br>优点：第一部重要角色合理的死亡、奇怪的复活方式、解密</li><li>环<br>优点：复制环界人DNA，在现实世界克隆<br>缺点：不够科幻、不够悬疑</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《呼啸山庄》</title>
      <link href="/2024/04/20/read/yue-du/hu-xiao-shan-zhuang/"/>
      <url>/2024/04/20/read/yue-du/hu-xiao-shan-zhuang/</url>
      
        <content type="html"><![CDATA[<p>优点：<br>缺点：太夸张了<br>没看完，看到了林顿夫妻闹别扭后，林顿夫人第一次吃饭<br>——2023.11.7晚</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《超新星纪元》</title>
      <link href="/2024/04/20/read/yue-du/chao-xin-xing-ji-yuan/"/>
      <url>/2024/04/20/read/yue-du/chao-xin-xing-ji-yuan/</url>
      
        <content type="html"><![CDATA[<p>优点：想法有趣、前部分令人赞不绝口<br>缺点：剧情把控不足</p>]]></content>
      
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VA-11 Hall-A Cyberpunk Bartender Action</title>
      <link href="/2024/04/20/read/you-xi/va-11-hall-a-cyberpunk-bartender-action/"/>
      <url>/2024/04/20/read/you-xi/va-11-hall-a-cyberpunk-bartender-action/</url>
      
        <content type="html"><![CDATA[<p><strong>调制人生 改变饮料</strong></p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>ingram：看似放荡，实则比较富有学识<br>dorothy haze：开朗可爱的魅魔机器人<br>kim：<br>jamie：独眼杀手<br>kira miki：沉迷于扮演kira而迷失自我的歌星<br>alma：jill的好朋友，好像是黑客？推心置腹，互吐苦水的贝斯特 friend<br>sei：白骑士<br>stella：白骑士的朋友？可爱的富婆<br>art von delay：一名犀利的侦探<br>streaming-chan ：可怜的主动式楚门<br>betty：狗狗公司<br>deal：狗狗公司<br>taylor：一位大脑宅男？<br>virgilio armandio：像个外强中干的变态<br>brian：BTC老大<br>cass：<br>rad shiba：一条柴犬。<br>norma：被过于期待的未成年少女<br>mario：<br>gaby：jill前女友的妹妹<br>nacho：shiba的boss<br>vella：coser<br>essentia：lilim<br>anna：好像是心中的自我？</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Limbus Company（边狱巴士公司）</title>
      <link href="/2024/04/20/read/you-xi/limbus-company-bian-yu-ba-shi-gong-si/"/>
      <url>/2024/04/20/read/you-xi/limbus-company-bian-yu-ba-shi-gong-si/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><h2 id="李箱"><a href="#李箱" class="headerlink" title="李箱"></a>李箱</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="浮士德"><a href="#浮士德" class="headerlink" title="浮士德"></a>浮士德</h2><h2 id="堂吉河德"><a href="#堂吉河德" class="headerlink" title="堂吉河德"></a>堂吉河德</h2><h2 id="良秀"><a href="#良秀" class="headerlink" title="良秀"></a>良秀</h2><h2 id="默尔索"><a href="#默尔索" class="headerlink" title="默尔索"></a>默尔索</h2><h2 id="鸿璐"><a href="#鸿璐" class="headerlink" title="鸿璐"></a>鸿璐</h2><h2 id="希斯克利夫"><a href="#希斯克利夫" class="headerlink" title="希斯克利夫"></a>希斯克利夫</h2><h2 id="以实玛利"><a href="#以实玛利" class="headerlink" title="以实玛利"></a>以实玛利</h2><h2 id="罗佳"><a href="#罗佳" class="headerlink" title="罗佳"></a>罗佳</h2><h2 id="辛克莱"><a href="#辛克莱" class="headerlink" title="辛克莱"></a>辛克莱</h2><h2 id="奥提斯"><a href="#奥提斯" class="headerlink" title="奥提斯"></a>奥提斯</h2><h2 id="格里高尔"><a href="#格里高尔" class="headerlink" title="格里高尔"></a>格里高尔</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脑叶公司</title>
      <link href="/2024/04/20/read/you-xi/nao-xie-gong-si/"/>
      <url>/2024/04/20/read/you-xi/nao-xie-gong-si/</url>
      
        <content type="html"><![CDATA[<h1 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h1><p>我叫X，来脑叶公司工作。迎接我的人叫angela，是个被世界之翼所造的ai，被限制在脑叶公司。它说这家公司由很多ai共同管理，但它就像是主控中心，其它的ai要听它的吩咐，说自己才是我最值得信任的伙伴。</p><h1 id="chapter-2"><a href="#chapter-2" class="headerlink" title="chapter 2"></a>chapter 2</h1><p>“面对恐惧，创造未来”，angela说脑叶公司会成为拯救人类的希望。</p><h1 id="chapter-3"><a href="#chapter-3" class="headerlink" title="chapter 3"></a>chapter 3</h1><p>angela与我讨论是愿意兴盛公司，还是丰富自我。</p><h1 id="chapter-4"><a href="#chapter-4" class="headerlink" title="chapter 4"></a>chapter 4</h1><p>公司产能提升了百分之十几，但死了第一个员工</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《命运石之门0》</title>
      <link href="/2024/04/20/read/you-xi/2024-02/ming-yun-shi-zhi-men-0/"/>
      <url>/2024/04/20/read/you-xi/2024-02/ming-yun-shi-zhi-men-0/</url>
      
        <content type="html"><![CDATA[<p>优点：主角变好看了；对记忆更加深入地思考<br>缺点：部分情节高潮时尬住了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《影子工厂》</title>
      <link href="/2024/04/20/read/you-xi/2024-01/ying-zi-gong-han/"/>
      <url>/2024/04/20/read/you-xi/2024-01/ying-zi-gong-han/</url>
      
        <content type="html"><![CDATA[<p>优点：关于记忆思考；Quincy的表白方式<br>缺点：第一幕的谋杀是一个不错的能吸引兴趣的好点子，但结束的太仓促了<br>游戏讨论的主要有：记忆的提取与编辑、为人父母所面临的选择、对生活的态度</p><p>——01-30</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《亚托莉-我的挚爱时光》</title>
      <link href="/2024/04/20/read/you-xi/2024-01/ya-tuo-li-wo-de-zhi-ai-shi-guang/"/>
      <url>/2024/04/20/read/you-xi/2024-01/ya-tuo-li-wo-de-zhi-ai-shi-guang/</url>
      
        <content type="html"><![CDATA[<p>优点：喜闻乐见的机器人是否有心的概念；中间反转令人耳目一新；亚托莉很可爱<br>缺点：前面的剧情有些无聊；部分剧情有些尴尬<br>游戏讨论的主要有：水平线上升的末日、直面过去与未来的勇气、机器人伦理、光点亮的不仅是黑暗更是希望</p><p>——01-28</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《往日之影》</title>
      <link href="/2024/04/20/read/you-xi/2023-11/wang-ri-zhi-ying/"/>
      <url>/2024/04/20/read/you-xi/2023-11/wang-ri-zhi-ying/</url>
      
        <content type="html"><![CDATA[<p>优点：剧情精彩、玩法多样、人物对话有趣<br>缺点：高配置电脑、</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《邪恶铭刻》</title>
      <link href="/2024/04/20/read/you-xi/2023-10/xie-e-ming-ke/"/>
      <url>/2024/04/20/read/you-xi/2023-10/xie-e-ming-ke/</url>
      
        <content type="html"><![CDATA[<p>优点：独特的玩法<br>缺点：浮躁的心</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《武士零》</title>
      <link href="/2024/04/20/read/you-xi/2023-10/wu-shi-ling/"/>
      <url>/2024/04/20/read/you-xi/2023-10/wu-shi-ling/</url>
      
        <content type="html"><![CDATA[<p>优点：剧情引人、爽快<br>缺点：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑暗之魂3》</title>
      <link href="/2024/04/20/read/you-xi/2023-10/hei-an-zhi-hun-3/"/>
      <url>/2024/04/20/read/you-xi/2023-10/hei-an-zhi-hun-3/</url>
      
        <content type="html"><![CDATA[<p>优点：宫崎英高，绝美的风景，令人赞不绝口的地图设计，风格各异的建筑，拼接支离破碎剧情的乐趣<br>缺点：宫崎英高</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火山的女儿</title>
      <link href="/2024/04/20/read/you-xi/2023-09/huo-shan-de-nu-er/"/>
      <url>/2024/04/20/read/you-xi/2023-09/huo-shan-de-nu-er/</url>
      
        <content type="html"><![CDATA[<p>养成类国产游戏。<br>玩家将扮演一名父亲，目标是培养自己的女儿。<br>优点：精美的插画、悦耳的配音、养虚拟小人的成就感、有反转的剧情<br>缺点：缺乏引导的小游戏、一般的战斗<br>游戏与小说不同很重要的一点就是多结局的表现力，因此看着自己的女儿走向不同的结局难免想到以后自己为人父时又会怎样教导儿女。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>428 ～被封锁的涩谷～（428 Shibuya Scramble）</title>
      <link href="/2024/04/20/read/you-xi/2023-09/428-bei-feng-suo-de-se-gu-428-shibuya-scramble/"/>
      <url>/2024/04/20/read/you-xi/2023-09/428-bei-feng-suo-de-se-gu-428-shibuya-scramble/</url>
      
        <content type="html"><![CDATA[<p>优点：新颖的文字冒险模式、紧凑的剧情、不同角色相互关联的蝴蝶效应<br>缺点：有时很难找到正确的转折点、部分keep out必须通过坏结局才能找到</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《土豆兄弟》</title>
      <link href="/2024/04/20/read/you-xi/2023-09/tu-dou-xiong-di/"/>
      <url>/2024/04/20/read/you-xi/2023-09/tu-dou-xiong-di/</url>
      
        <content type="html"><![CDATA[<p>2023.9.9<br>（医疗，枪械）（道具）（辅助、元素）（元素）（独特的）（限制x）（精准）（虚灵）<br>类吸血鬼幸存者<br>一款杀时间的游戏，后期每分钟一回合，不知不觉之中就游玩很久。<br>我第三把游侠，四金武，差点过关，可惜血太少，最后被boss封走位杀死。<br>一直在玩远程，没玩过近战</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《极渊》</title>
      <link href="/2024/04/20/read/you-xi/2023-09/ji-yuan/"/>
      <url>/2024/04/20/read/you-xi/2023-09/ji-yuan/</url>
      
        <content type="html"><![CDATA[<p>优点：<br>缺点：有些枯燥、手感差<br>没玩完</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛奶袋中袋装牛奶（Milk inside a bag of milk inside a bag of milk）</title>
      <link href="/2024/04/20/read/you-xi/2023-08/niu-nai-dai-zhong-dai-zhuang-niu-nai-milk-inside-a-bag-of-milk-inside-a-bag-of-milk/"/>
      <url>/2024/04/20/read/you-xi/2023-08/niu-nai-dai-zhong-dai-zhuang-niu-nai-milk-inside-a-bag-of-milk-inside-a-bag-of-milk/</url>
      
        <content type="html"><![CDATA[<p>未成年精神疾病患者去买牛奶。<br>两个结局——买到牛奶和未能买到牛奶。<br>2023.8.16</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛奶袋外袋装牛奶（Milk outside a bag of milk outside a bag of milk）</title>
      <link href="/2024/04/20/read/you-xi/2023-08/niu-nai-dai-wai-dai-zhuang-niu-nai-milk-outside-a-bag-of-milk-outside-a-bag-of-milk/"/>
      <url>/2024/04/20/read/you-xi/2023-08/niu-nai-dai-wai-dai-zhuang-niu-nai-milk-outside-a-bag-of-milk-outside-a-bag-of-milk/</url>
      
        <content type="html"><![CDATA[<p>延续一作的剧情，女孩买到牛奶后，在回家的路上又看到了一些令人不舒服的场景。进房间之后又和“我”进行一系列的沟通和交流，为了不过分地激怒女孩，我选择了更加平缓的交流方式——尽量不探究内心，顺着女孩的话，缓慢地改善扭曲的内心，但从进入了探索深黯的结局来看，女孩似乎更加封闭自己的内心了，不愿意与外界接触。<br>“我”已经做了很多，但从结局来看，“我”似乎并没有对女孩的病情有什么帮助。那些光怪陆离的幻觉浮现在女孩面前，不知是什么感受。<br>2023.8.18（8.22补）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《只狼》</title>
      <link href="/2024/04/20/read/you-xi/2023-05/zhi-lang/"/>
      <url>/2024/04/20/read/you-xi/2023-05/zhi-lang/</url>
      
        <content type="html"><![CDATA[<p>优点：爽</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《一次机会》</title>
      <link href="/2024/04/20/read/you-xi/2023-05/yi-ci-ji-hui/"/>
      <url>/2024/04/20/read/you-xi/2023-05/yi-ci-ji-hui/</url>
      
        <content type="html"><![CDATA[<p>优点：<br>缺点：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《命运石之门》</title>
      <link href="/2024/04/20/read/you-xi/2023-04/ming-yun-shi-zhi-men/"/>
      <url>/2024/04/20/read/you-xi/2023-04/ming-yun-shi-zhi-men/</url>
      
        <content type="html"><![CDATA[<p>剧情还是很不错的，但前面略显中二的片段在很大程度上会劝退很多人。如果没有看过动漫，或者是对文字冒险游戏不感兴趣的人恐怕会放弃。<br>优点：逻辑较为自洽的时间旅行；世界线变动率探测器的设定；善解人意的助手<br>缺点：前面略显中二的片段；</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《再见绘梨》</title>
      <link href="/2024/04/20/read/man-hua/zai-jian-hui-li/"/>
      <url>/2024/04/20/read/man-hua/zai-jian-hui-li/</url>
      
        <content type="html"><![CDATA[<p>优点：蒙太奇复合使用，通过“现实”与“摄影”迷惑读者；<br>缺点：有点短；<br>2024-03-20</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漫画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《亚人酱有话要说》</title>
      <link href="/2024/04/20/read/man-hua/ya-ren-jiang-you-hua-yao-shuo/"/>
      <url>/2024/04/20/read/man-hua/ya-ren-jiang-you-hua-yao-shuo/</url>
      
        <content type="html"><![CDATA[<p>优点：无头骑士22表情、剧情合理<br>缺点：架空常识</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漫画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精武英雄</title>
      <link href="/2024/04/20/read/guan-ying/jing-wu-ying-xiong/"/>
      <url>/2024/04/20/read/guan-ying/jing-wu-ying-xiong/</url>
      
        <content type="html"><![CDATA[<p>优点：打斗<br>缺点：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悲惨世界</title>
      <link href="/2024/04/20/read/guan-ying/bei-can-shi-jie/"/>
      <url>/2024/04/20/read/guan-ying/bei-can-shi-jie/</url>
      
        <content type="html"><![CDATA[<p>优点：音乐剧<br>缺点：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《十二怒汉》</title>
      <link href="/2024/04/20/read/guan-ying/shi-er-nu-han/"/>
      <url>/2024/04/20/read/guan-ying/shi-er-nu-han/</url>
      
        <content type="html"><![CDATA[<p>优点：个性鲜明的人物性格、结局适当的留疑<br>缺点：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《控方证人》</title>
      <link href="/2024/04/20/read/guan-ying/kong-fang-zheng-ren/"/>
      <url>/2024/04/20/read/guan-ying/kong-fang-zheng-ren/</url>
      
        <content type="html"><![CDATA[<p>优点：超级反转、幽默风趣、剧情张驰有度、悬疑</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《金刚(2005)》</title>
      <link href="/2024/04/20/read/guan-ying/jin-gang-2005/"/>
      <url>/2024/04/20/read/guan-ying/jin-gang-2005/</url>
      
        <content type="html"><![CDATA[<p>优点：怪兽与人类角色塑造丰满、虫谷大战、<br>缺点：</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《谍影重重3》</title>
      <link href="/2024/04/20/read/guan-ying/die-ying-chong-chong-3/"/>
      <url>/2024/04/20/read/guan-ying/die-ying-chong-chong-3/</url>
      
        <content type="html"><![CDATA[<p>特工寻找自己记忆。<br>优点：紧凑的剧情，车戏、打戏精彩，追逐战与反跟踪令人赞叹不已<br>缺点：可能需要看前作</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《茶馆》</title>
      <link href="/2024/04/20/read/guan-ying/cha-guan/"/>
      <url>/2024/04/20/read/guan-ying/cha-guan/</url>
      
        <content type="html"><![CDATA[<p>优点：时代厚重感、无可奈何的悲哀、有心救国无力回天</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;% tp.file.title %&gt;</title>
      <link href="/2024/04/20/read/mo-ban/temp/"/>
      <url>/2024/04/20/read/mo-ban/temp/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-12/yi-ji-2/"/>
      <url>/2024/01/01/read/you-xi/2023-12/yi-ji-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-01/omori/"/>
      <url>/2024/01/01/read/you-xi/2023-01/omori/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-03/ao-ri-jing-ling-yu-ying-huo-yi-zhi/"/>
      <url>/2024/01/01/read/you-xi/2023-03/ao-ri-jing-ling-yu-ying-huo-yi-zhi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-08/yi-sa-de-jie-he/"/>
      <url>/2024/01/01/read/you-xi/2023-08/yi-sa-de-jie-he/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-08/chuan-song-men-2/"/>
      <url>/2024/01/01/read/you-xi/2023-08/chuan-song-men-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-08/di-yu-ba-mei-wang/"/>
      <url>/2024/01/01/read/you-xi/2023-08/di-yu-ba-mei-wang/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-11/dui-die-da-lu/"/>
      <url>/2024/01/01/read/you-xi/2023-11/dui-die-da-lu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-11/xiao-gu-ying-xiong-sha-shou-skul-the-hero-slayer/"/>
      <url>/2024/01/01/read/you-xi/2023-11/xiao-gu-ying-xiong-sha-shou-skul-the-hero-slayer/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-11/yu-zhong-mou-xian/"/>
      <url>/2024/01/01/read/you-xi/2023-11/yu-zhong-mou-xian/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-12/nuan-xue-warm-snow/"/>
      <url>/2024/01/01/read/you-xi/2023-12/nuan-xue-warm-snow/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/01/read/you-xi/2023-12/gu-fan-yuan-hang-far-lone-sails/"/>
      <url>/2024/01/01/read/you-xi/2023-12/gu-fan-yuan-hang-far-lone-sails/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="/2023/12/11/ying-yong-ceng/"/>
      <url>/2023/12/11/ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1-域名系统-DNS"><a href="#6-1-域名系统-DNS" class="headerlink" title="6.1 域名系统 DNS"></a>6.1 域名系统 DNS</h1><ul><li>应用层的具体内容是精确定义通信规则：<ol><li>应用进程交换的报文类型，如请求报文和响应报文。</li><li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li><li>字段的语义，即包含在字段中的信息的含义。</li><li>进程何时、如何发送报文，以及对报文进行响应的规则。</li></ol></li></ul><h2 id="6-1-1-域名系统概述"><a href="#6-1-1-域名系统概述" class="headerlink" title="6.1.1 域名系统概述"></a>6.1.1 域名系统概述</h2><ul><li><strong>域名系统</strong> DNS 是互联网使用的命名系统，把机器名字转换为 IP 地址。</li><li>许多应用层软件经常直接使用域名系统 DNS。虽然计算机的用户只是<strong>间接</strong>使用域名系统，但 DNS 却为互联网的各种网络应用提供了核心服务。</li><li>用户与互联网上某台主机通信时，必须要知道对方的 IP 地址。应用层为了便于用户记忆各种网络应用设置了主机名，通过域名系统 DNS 把互联网上的主机名字转换为 IP 地址。</li><li>从理论上讲，整个互联网可以只使用一个域名服务器，使它装入互联网上所有的主机名，并回答所有对 IP 地址的查询。但是因为互联网规模很大，这样的域名服务器会因过负荷而无法正常工作，而且一旦域名服务器出现故障，整个互联网就会瘫痪。因此采用层次树状结构的命名方法，并使用分布式的<strong>域名系统</strong> DNS。</li><li>互联网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行<strong>解析</strong>，仅少量解析需要在互联网上通信，因此 DNS 系统的效率很高。由于 DNS 是分布式系统，即使单个计算机出了故障，也不会妨碍整个 DNS 系统的正常运行。</li><li>域名到 IP 地址的解析是由分布在互联网上的许多<strong>域名服务器程序</strong>共同完成的。域名服务器程序在专设的结点上运行，把运行域名服务器程序的机器称为<strong>域名服务器</strong>。</li><li>域名到 IP 地址的解析过程的要点如下：当某一个应用进程需要把主机名解析为 IP 地址时，该应用进程就调用<strong>解析程序</strong>，成为 DNS 的一个客户，把待解析的域名放在 DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器 (使用 UDP 是为了减少开销)。本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。应用进程获得目的主机的 IP 地址后即可进行通信。</li></ul><h2 id="6-1-2-互联网的域名结构"><a href="#6-1-2-互联网的域名结构" class="headerlink" title="6.1.2 互联网的域名结构"></a>6.1.2 互联网的域名结构</h2><ul><li>DNS 规定，域名中的标号都由英文字母和数字组成，<strong>每一个标号不超过 63 个字符</strong> (为了记忆方便，最好不要超过 12 个字符)，<strong>也不区分大小写字母</strong> (例如，CCTV 或 cctv 在域名中是等效的)。标号中除连字符 (-) 外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的顶级域名则写在最右边。<strong>由多个标号组成的完整域名总共不超过 255 个字符</strong>。DNS 既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由 ICANN 进行管理。用这种方法可使每一个域名在整个互联网范围内是唯一的，并且也容易设计出一种查找域名的机制。</li><li>原先的顶级域名共分为三大类：<ol><li><strong>国家顶级域名</strong> nTLD</li><li><strong>通用顶级域名</strong> gTLD</li><li><strong>基础结构域名</strong></li></ol></li><li>我国把二级域名划分为“<strong>类别域名</strong>”和“<strong>行政区域名</strong>”两大类。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218153419.png"></li></ul><h2 id="6-1-3-域名服务器"><a href="#6-1-3-域名服务器" class="headerlink" title="6.1.3 域名服务器"></a>6.1.3 域名服务器</h2><ul><li>域名服务器划分为以下四种不同的类型：<ol><li><strong>根域名服务器</strong> (root name server)：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析 (即转换为 IP 地址)，只要自己无法解析，就首先要求助于根域名服务器。假定所有的根域名服务器都瘫痪了，那么整个互联网中的 DNS 系统就无法工作。</li><li><strong>顶级域名服务器</strong> (即 TLD <strong>服务器</strong>)：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答。</li><li><strong>权限域名服务器</strong>：当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</li><li><strong>本地域名服务器</strong> (local name server)：当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</li></ol></li><li>为了提高域名服务器的可靠性，DNS 域名服务器把数据复制到几个域名服务器来保存，其中的一个是<strong>主域名服务器</strong>，其他的是<strong>辅助域名服务器</strong>。当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行，保证数据的一致性。</li><li>域名的解析过程:<ol><li>主机向本地域名服务器的查询一般采用<strong>递归查询</strong>。递归查询是：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器发出查询请求报文，而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果是所要查询的 IP 地址，或报错。</li><li>本地域名服务器向根域名服务器的查询通常采用<strong>迭代查询</strong>。迭代查询的特点是：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询，而不是替本地域名服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询，本地域名服务器就这样进行迭代查询。最后，知道了所要解析的域名的 IP 地址，然后把这个结果返回给发起查询的主机。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218171321.png"></li></ol></li><li>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</li></ul><h1 id="6-2-文件传送协议"><a href="#6-2-文件传送协议" class="headerlink" title="6.2 文件传送协议"></a>6.2 文件传送协议</h1><h2 id="6-2-1-FTP-概述"><a href="#6-2-1-FTP-概述" class="headerlink" title="6.2.1 FTP 概述"></a>6.2.1 FTP 概述</h2><ul><li>文件传送协议 FTP 是互联网上使用得最广泛的文件传送协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。FTP 屏蔽了各计算机系统的细节，适合于在异构网络中任意计算机之间传送文件。</li><li>基于 TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP 都是文件共享协议中的一大类，即<strong>复制整个文件</strong>，特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。</li><li>文件共享协议中的另一大类是<strong>联机访问</strong>。联机访问意味着允许多个程序同时对一个文件进行存取。和数据库系统的不同之处是用户不需要调用一个特殊的客户进程，而是由操作系统提供对远地共享文件进行访问的服务。使用户可以用远地文件作为输入和输出来运行任何应用程序，而操作系统中的文件系统则提供对共享文件的<strong>透明存取</strong>。透明存取的优点是：将原来用于处理本地文件的应用程序用来处理远地文件时，不需要对该应用程序作明显的改动。属于文件共享协议的有网络文件系统 NFS。</li></ul><h2 id="6-2-2-FTP-的基本工作原理"><a href="#6-2-2-FTP-的基本工作原理" class="headerlink" title="6.2.2 FTP 的基本工作原理"></a>6.2.2 FTP 的基本工作原理</h2><ul><li>文件传输协议 FTP 只提供文件传输的一些基本的服务，它使用 TCP 可靠的运输服务。FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li><li>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个<strong>主进程</strong>，负责接受新的请求；另外有若干个<strong>从属进程</strong>，负责处理单个请求。</li><li>主进程的工作步骤如下：<ol><li>打开熟知端口 (端口号为21)，使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li><li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发进行的。</li></ol></li><li>在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：“<strong>控制连接</strong>”和“<strong>数据连接</strong>”。控制连接在整个会话期间一直保持打开，FTP 客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。<strong>实际用于传输文件的是“数据连接”</strong>。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“<strong>数据传送进程</strong>”和“<strong>数据连接</strong>”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。由于 FTP 使用了一个分离的控制连接，因此 FTP 的控制信息是<strong>带外</strong>传送的。</li><li>网络文件系统 <strong>NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据</strong>。</li></ul><h2 id="6-2-3-简单文件传送协议-TFTP"><a href="#6-2-3-简单文件传送协议-TFTP" class="headerlink" title="6.2.3 简单文件传送协议 TFTP"></a>6.2.3 简单文件传送协议 TFTP</h2><ul><li>TCP&#x2F;IP 协议族中有一个<strong>简单文件传送协议</strong> TFTP，它是一个很小且易于实现的文件传送协议。虽然 TFTP 也使用客户服务器方式，但它使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</li><li>TFTP 的主要优点有两个：<ol><li>TFTP 可用于 UDP 环境。例如，当需要将程序或文件同时向许多机器下载时就往往需要使用 TFTP。</li><li>TFTP 代码所占的内存较小。这对较小的计算机或某些特殊用途的设备是很重要的。</li></ol></li><li>TFTP 的主要特点是：<ol><li>每次传送的数据报文中有 512 字节的数据，但最后一次可不足 512 字节。</li><li>数据报文按序编号，从 1 开始。</li><li>支持 ASCII 码或二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部。</li></ol></li></ul><h1 id="6-3-远程终端协议-TELNET"><a href="#6-3-远程终端协议-TELNET" class="headerlink" title="6.3 远程终端协议 TELNET"></a>6.3 远程终端协议 TELNET</h1><ul><li>TELNET 是一个简单的远程终端协议。用户用 TELNET 可在其所在地通过 TCP 连接注册到远地的另一台主机上。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。因此，TELNET 又称为<strong>终端仿真协议</strong>。</li><li>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行TELNET 服务器进程。和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。</li><li><strong>网络虚拟终端</strong> NVT 的格式定义很简单。所有的通信都使用 8 位一个字节。在运转时，NVT 使用 7 位 ASCII 码传送数据，而当高位置 1 时用作控制命令。ASCII 码共有 95 个可打印字符 (如字母、数字、标点符号) 和 33 个控制字符。所有可打印字符在 NVT 中的意义和在 ASCII 码中一样。但 NVT 只使用了 ASCII 码的控制字符中的几个。</li></ul><h1 id="6-4-万维网-WWW"><a href="#6-4-万维网-WWW" class="headerlink" title="6.4 万维网 WWW"></a>6.4 万维网 WWW</h1><h2 id="6-4-1-万维网概述"><a href="#6-4-1-万维网概述" class="headerlink" title="6.4.1 万维网概述"></a>6.4.1 万维网概述</h2><ul><li><strong>万维网</strong> WWW 并非某种特殊的计算机网络，<strong>而是一个大规模的、联机式的信息储藏所</strong>，英文简称为 Web。</li><li>万维网是一个分布式的<strong>超媒体</strong>系统，它是<strong>超文本</strong>系统的扩充。</li><li>分布式的和非分布式的超媒体系统有很大区别。在非分布式系统中，各种信息都驻留在单个计算机的磁盘中。由于各种文档都可从本地获得，因此这些文档之间的链接可进行一致性检查。</li><li><strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>。</li><li>万维网必须解决以下几个问题：<ol><li>怎样标志分布在整个互联网上的万维网文档？——万维网使用<strong>统一资源定位符</strong> URL 来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</li><li>用什么样的协议来实现万维网上的各种链接？——万维网使用<strong>超文本传送协议</strong> HTTP 来实现万维网上的各种链接。HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li><li>怎样使不同作者创作的不同风格的万维网文档，都能在互联网上的各种主机上显示出来，同时使用户清楚地知道在什么地方存在着链接？——万维网使用<strong>超文本标记语言</strong> HTML，使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来。</li></ol></li></ul><h2 id="6-4-2-统一资源定位符-URL"><a href="#6-4-2-统一资源定位符-URL" class="headerlink" title="6.4.2 统一资源定位符 URL"></a>6.4.2 统一资源定位符 URL</h2><ul><li><strong>URL 的格式</strong><ol><li><strong>统一资源定位符</strong> URL 是用来从互联网上得到的资源位置和访问这些资源的方法。</li><li>URL 是与互联网相连的机器上的任何可访问对象的一个指针。由于访问不同对象所使用的协议不同，所以 URL 还指出读取某个对象时所使用的协议。URL 的一般形式由以下四个部分组成：&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</li><li>URL 的第一部分是最左边的&lt;协议&gt;。&lt;协议&gt;是指使用什么协议来获取该万维网文档。现在最常用的协议就是 http，其次是 ftp。在&lt;协议&gt;后面的“:&#x2F;&#x2F;”是规定的格式。它的右边是第二部分&lt;主机&gt;，指出这个万维网文档是在哪一台主机上。&lt;主机&gt;是指该主机在互联网上的域名。再后面是第三和第四部分&lt;端口&gt;和&lt;路径&gt;，有时可省略。</li></ol></li><li><strong>使用 HTTP 的 URL</strong><ol><li>对于万维网网点的访问要使用 HTTP 协议。HTTP 的 URL 的一般形式是：http:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</li><li>HTTP 的默认端口号是 80，通常可省略。若再省略文件的&lt;路径&gt;项，则 URL 就指到互联网上的某个<strong>主页</strong>。主页是个很重要的概念，它可以是以下几种情况之一：<ul><li>一个 WWW 服务器的最高级别的页面。</li><li>某一个组织或部门的一个定制的页面或目录。从这样的页面可链接到互联网上的与本组织或部门有关的其他站点。</li><li>由某一个人自己设计的描述他本人情况的 WWW 页面。</li></ul></li></ol></li></ul><h2 id="6-4-3-超文本传送协议-HTTP"><a href="#6-4-3-超文本传送协议-HTTP" class="headerlink" title="6.4.3 超文本传送协议 HTTP"></a>6.4.3 超文本传送协议 HTTP</h2><ul><li><strong>HTTP 的操作过程</strong><ol><li>HTTP 是<strong>面向事务的</strong>应用层协议是万维网上能够可靠地交换文件的重要基础。</li><li>用户浏览页面的方法有两种：<ul><li>键入 URL。</li><li>用鼠标点击一个可选部分所对应的链接。</li></ul></li><li>HTTP&#x2F;1.0 的主要缺点是：<ul><li>每请求一个文档要有两倍 RTT 开销。若一个主页上有很多链接的对象需要依次进行链接，每一次链接下载都导致 2×RTT 的开销。</li><li>万维网客户和服务器每一次建立新的 TCP 连接都要分配缓存和变量，特别是万维网服务器往往要同时服务于大量客户的请求，所以这种<strong>非持续连接</strong>会使万维网服务器的负担很重。</li></ul></li><li>HTTP&#x2F;1.1 协议使用<strong>持续连接</strong>较好地解决了这个问题。万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。</li><li>HTTP&#x2F;1.1 协议的持续连接有两种工作方式：<ul><li><strong>非流水线方式</strong><ol><li>特点：客户在收到前一个响应后才能发出下一个请求。因此，在 TCP 连接已建立后，客户每访问一次对象都要用去一个往返时间 RTT，这比非持续连接节省了建立 TCP 连接所需的一个 RTT 时间。</li><li>缺点：服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</li></ol></li><li><strong>流水线方式</strong><ol><li>特点：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用流水线方式时，客户访问<strong>所有的对象</strong>只需花费一个 RTT 时间。流水线工作方式使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li></ol></li></ul></li></ol></li><li><strong>代理服务器</strong><ol><li><strong>代理服务器</strong>是一种网络实体，又称<strong>万维网高速缓存</strong>。</li></ol></li><li><strong>HTTP 的报文结构</strong><ol><li>HTTP 有两类报文：<ul><li>请求报文——从客户向服务器发送请求报文，见图 6-12(a)。</li><li>响应报文——从服务器到客户的回答，见图 6-12(b)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812151126.png"></li></ul></li><li>由于 HTTP 是<strong>面向文本的</strong>，因此在报文中的每一个字段都是一些 ASCII 码串，各个字段的长度都是不确定的。</li><li>HTTP 请求报文和响应报文都是由三个部分组成：<ul><li><strong>开始行</strong>，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做<strong>请求行</strong>，而在响应报文中的开始行叫做<strong>状态行</strong>。在开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表“回车”和“换行”。</li><li><strong>首部行</strong>，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</li><li><strong>实体主体</strong>，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</li></ul></li><li>请求报文的第一行“请求行”有三个内容：<ul><li>方法</li><li>请求资源的 URL</li><li>HTTP 的版本。</li><li>HTTP 请求报文的一些方法：<img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218160354.png"></li></ul></li><li>HTTP 响应报文的主要特点：<ul><li>每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。</li><li>状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。</li><li><strong>状态码</strong>都是三位数字的，分为 5 大类，原先有 33 种，后来又增加了几种。这 5 大类的状态码都是以不同的数字开头的。<ol><li>1xx 表示通知信息，如请求收到了或正在进行处理。</li><li>2xx 表示成功，如接受或知道了。</li><li>3xx 表示重定向，如要完成请求还必须采取进一步的行动。</li><li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li></ol></li></ul></li></ol></li><li><strong>在服务器上存放用户的信息</strong></li></ul><h2 id="6-4-4-万维网的文档"><a href="#6-4-4-万维网的文档" class="headerlink" title="6.4.4 万维网的文档"></a>6.4.4 万维网的文档</h2><ul><li><strong>超文本标记语言 HTML</strong><ol><li><strong>超文本标记语言 HTML</strong>  是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍。但 HTML <strong>并不是应用层的协议</strong>，它只是万维网浏览器使用的一种语言。</li><li>HTML 允许在万维网页面中插入图像。</li><li>HTML 规定了链接的设置方法。</li><li>XML 是<strong>可扩展标记语言</strong>，与 HTML 很相似。但 XML 的设计宗旨是传输数据，而不是显示数据 (HTML 是为了在浏览器上显示数据)。更具体些，XML 用于标记电子文件，使其具有结构性的标记语言，可用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML 是一种简单、与平台无关并被广泛采用的标准。XML 相对于 HTML 的优点是它将用户界面与结构化数据分隔开来。</li><li>XHTML 是<strong>可扩展超文本标记语言</strong>，与 HTML 4.01 几乎是相同的。</li><li>CSS 是<strong>层叠样式表</strong>，它是一种样式表语言，用于为 HTML 文档定义布局。CSS 与 HTML 的区别是：HTML 用于结构化内容，而 CSS 则用于格式化结构化的内容。</li></ol></li><li><strong>动态万维网文档</strong><ol><li>静态文档的优点是简单。由于 HTML 是一种排版语言，因此静态文档可以由不懂程序设计的人员来创建。但静态文档的缺点是不够灵活。当信息变化时就要由文档的作者手工对文档进行修改。</li><li><strong>动态文档</strong>是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。当浏览器请求到达时，万维网服务器要运行另一个应用程序，并把控制转移到此应用程序。接着，该应用程序对浏览器发来的数据进行处理，并输出 HTTP 格式的文档，万维网服务器把应用程序的输出作为对浏览器的响应。由于对浏览器每次请求的响应都是临时生成的，因此用户通过动态文档所看到的内容是不断变化的。动态文档的主要优点是具有报告当前最新信息的能力。</li><li>动态文档和静态文档之间的主要差别体现在服务器一端，主要是<strong>文档内容的生成方法不同</strong>。而从浏览器的角度看，这两种文档并没有区别。</li><li>要实现动态文档就必须在以下两个方面对万维网服务器的功能进行扩充：<ul><li>增加另一个应用程序，处理浏览器发来的数据，并创建动态文档。</li><li>增加一个机制，使万维网服务器将浏览器发来的数据传送给这个应用程序，然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。</li></ul></li><li><strong>通用网关接口 CGI</strong> 是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。</li></ol></li><li><strong>活动万维网文档</strong><ol><li>有两种技术可用于浏览器屏幕显示的连续更新：<ul><li><strong>服务器推送</strong>，这种技术是将所有的工作都交给服务器。服务器不断地运行与动态文档相关联的应用程序，定期更新信息，并发送更新过的文档。<ol><li>缺点：为了满足很多客户的请求，服务器要运行很多服务器推送程序。这将造成过多的服务器开销。服务器推送技术要求服务器为每一个浏览器客户维持一个不释放的 TCP 连接。随着 TCP 连接的数目增加，每一个连接所能分配到的网络带宽就下降，这就导致网络传输时延的增大。</li></ol></li><li>另一种提供屏幕连续更新的技术是<strong>活动文档</strong>。<ol><li>这种技术是把所有的工作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段活动文档程序副本，使该程序副本在浏览器端运行。这时，活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。只要用户运行活动文档程序，活动文档的内容就可以连续地改变。由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。</li></ol></li></ul></li></ol></li></ul><h2 id="6-4-5-万维网的信息检索系统"><a href="#6-4-5-万维网的信息检索系统" class="headerlink" title="6.4.5 万维网的信息检索系统"></a>6.4.5 万维网的信息检索系统</h2><ul><li><strong>全文检索搜索与分类目录搜索</strong><ol><li>在万维网中用来进行搜索的工具叫做<strong>搜索引擎</strong>。搜索引擎的种类很多，但大体上可划分为两大类，<ul><li><strong>全文检索</strong>搜索引擎：全文检索搜索引擎是一种纯技术型的检索工具。<ol><li>优点：全文检索可以检索出大量的信息。</li><li>缺点：但缺点是查询结果不够准确，往往是罗列出了海量的信息，使用户无法迅速找到所需的信息。</li></ol></li><li><strong>分类目录</strong>搜索引擎：分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。因此，分类目录搜索也叫做分类网站搜索。<ol><li>优点：用户可根据网站设计好的目录有针对性地逐级查询所需要的信息，查询时不需要使用关键词，只需要按照分类 (先找大类，再找下面的小类)，因而查询的准确性较好。</li><li>缺点：分类目录查询的结果并不是具体的页面，而是被收录网站主页的 URL 地址，因而所得到的内容就比较有限。</li></ol></li></ul></li><li><strong>垂直搜索引擎</strong>针对某一特定领域、特定人群或某一特定需求提供搜索服务。</li><li><strong>元搜索引擎</strong>，把用户提交的检索请求发送到多个独立的搜索引擎上去搜索，并把检索结果集中统一处理，以统一的格式提供给用户，因此是搜索引擎之上的搜索引擎。它的主要精力放在提高搜索速度、智能化处理搜索结果、个性化搜索功能的设置和用户检索界面的友好性上。元搜索引擎的查全率和查准率都比较高。</li></ol></li><li><strong>Google 搜索技术的特点</strong></li></ul><h2 id="6-4-6-博客与微博"><a href="#6-4-6-博客与微博" class="headerlink" title="6.4.6 博客与微博"></a>6.4.6 博客与微博</h2><ul><li><strong>博客</strong></li><li><strong>微博</strong></li></ul><h2 id="6-4-7-社交网站"><a href="#6-4-7-社交网站" class="headerlink" title="6.4.7 社交网站"></a>6.4.7 社交网站</h2><h1 id="6-5-电子邮件"><a href="#6-5-电子邮件" class="headerlink" title="6.5 电子邮件"></a>6.5 电子邮件</h1><h2 id="6-5-1-电子邮件概述"><a href="#6-5-1-电子邮件概述" class="headerlink" title="6.5.1 电子邮件概述"></a>6.5.1 电子邮件概述</h2><ul><li>电子邮件的两个最重要的标准是：<strong>简单邮件传送协议</strong> SMTP 和<strong>互联网文本报文格式</strong> </li><li>由于互联网的 SMTP 只能传送可打印的 7 位 ASCII 码邮件，因此提出了<strong>通用互联网邮件扩充</strong> MIME 。MIME 在其邮件首部中说明了邮件的数据类型。在 MIME 邮件中可同时传送多种类型的数据。</li><li>一个电子邮件系统应具有图 6-17 所示的三个主要组成构件，即<strong>用户代理、邮件服务器</strong>，以及邮件发送协议 (如 SMTP) 和邮件读取协议 (如POP3)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812154053.png"></li></ol></li><li><strong>用户代理</strong> UA 是用户与电子邮件系统的接口，大多数情况下它是运行在用户电脑中的一个程序。因此用户代理又称为<strong>电子邮件客户端软件</strong>。用户代理向用户提供一个很友好的接口来发送和接收邮件。</li><li>用户代理至少应当具有以下四个功能：<ol><li><strong>撰写</strong>。给用户提供编辑信件的环境。例如，应让用户能创建便于使用的通讯录。回信时不仅能很方便地从来信中提取出对方地址，并自动地将此地址写入到邮件中合适的位置，而且还能方便地对来信提出的问题进行答复。</li><li><strong>显示</strong>。能方便地在计算机屏幕上显示出来信。</li><li><strong>处理</strong>。处理包括发送邮件和接收邮件。收件人应能根据情况按不同方式对来信进行处理。例如，阅读后删除、存盘、打印、转发等，以及自建目录对来信进行分类保存。有时还可在读取信件之前先查看一下邮件的发件人和长度等，对于不愿收的信件可直接在邮箱中删除。</li><li><strong>通信</strong>。发信人在撰写完邮件后，要利用邮件发送协议发送到用户所使用的邮件服务器。收件人在接收邮件时，要使用邮件读取协议从本地邮件服务器接收邮件。</li></ol></li><li>电子邮件由<strong>信封</strong>和**内容两部分组成。</li></ul><h2 id="6-5-2-简单邮件传送协议-SMTP"><a href="#6-5-2-简单邮件传送协议-SMTP" class="headerlink" title="6.5.2 简单邮件传送协议 SMTP"></a>6.5.2 简单邮件传送协议 SMTP</h2><ul><li>通过发送方和接收方的邮件服务器之间的 SMTP 通信的三个阶段介绍几个最主要的命令和响应信息：<ol><li><strong>连接建立</strong><ul><li>SMTP <strong>不使用中间的邮件服务器</strong>。</li></ul></li><li><strong>邮件传送</strong><ul><li>RCPT 命令的作用是：先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件。这样做是为了避免浪费通信资源，不至于发送了很长的邮件以后才知道地址错误。</li></ul></li><li><strong>连接释放</strong><ul><li>邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是“221 (服务关闭)”，表示 SMTP 同意释放 TCP 连接。邮件传送的全部过程即结束。</li></ul></li></ol></li></ul><h2 id="6-5-3-电子邮件的信息格式"><a href="#6-5-3-电子邮件的信息格式" class="headerlink" title="6.5.3 电子邮件的信息格式"></a>6.5.3 电子邮件的信息格式</h2><h2 id="6-5-4-邮件读取协议-POP3-和-IMAP"><a href="#6-5-4-邮件读取协议-POP3-和-IMAP" class="headerlink" title="6.5.4 邮件读取协议 POP3 和 IMAP"></a>6.5.4 邮件读取协议 POP3 和 IMAP</h2><ul><li>现在常用的邮件读取协议有两个：<ol><li>邮局协议第 3 个版本 POP3：<strong>邮局协议</strong> POP 是一个非常简单、但功能有限的邮件读取协议。</li><li><strong>网际报文存取协议</strong> IMAP：比 POP3 复杂。IMAP 和 POP 都按客户服务器方式工作，但它们有很大的差别。<ul><li>用户在自己的计算机上可以操纵邮件服务器的邮箱，就像在本地操纵一样，IMAP 是一个联机协议。当用户计算机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。用户可以根据需要为自己的邮箱创建便于分类管理的层次式的邮箱文件夹，并且能够将存放的邮件从某一个文件夹中移动到另一个文件夹中。用户也可按某种条件对邮件进行查找。在用户未发出删除邮件的命令之前，IMAP 服务器邮箱中的邮件一直保存着。</li><li>优点：用户可以在不同的地方使用不同的计算机，随时上网阅读和处理自己在邮件服务器中的邮件，IMAP 还允许收件人只读取邮件中的某一个部分。</li><li>缺点：如果用户没有将邮件复制到自己的计算机上，则邮件一直存放在 IMAP 服务器上。要想查阅自己的邮件，必须先上网。</li></ul></li></ol></li><li>表 6-2 给出了 IMAP 和 POP3 的主要功能的比较。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812161852.png"></li></ol></li></ul><h2 id="6-5-5-基于万维网的电子邮件"><a href="#6-5-5-基于万维网的电子邮件" class="headerlink" title="6.5.5 基于万维网的电子邮件"></a>6.5.5 基于万维网的电子邮件</h2><ul><li>万维网电子邮件的好处是：不管在什么地方，只要能够找到上网的计算机，在打开任何一种浏览器后，就可以非常方便地收发电子邮件。</li></ul><h2 id="6-5-6-通用互联网邮件扩充-MIME"><a href="#6-5-6-通用互联网邮件扩充-MIME" class="headerlink" title="6.5.6 通用互联网邮件扩充 MIME"></a>6.5.6 通用互联网邮件扩充 MIME</h2><ul><li><strong>MIME 概述</strong><ol><li>电子邮件协议 SMTP 有以下缺点：<ul><li>SMTP 不能传送可执行文件或其他的二进制对象。</li><li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字就无法传送。即使在 SMTP 网关将 EBCDIC 码 (即扩充的二&#x2F;十进制交换码) 转换为 ASCII 码，也会遇到一些麻烦。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li><li>某些 SMTP 的实现并没有完全按照 SMTP 的互联网标准。常见的问题如下：<ol><li>回车、换行的删除和增加；</li><li>超过 76 个字符时的处理：截断或自动换行；</li><li>后面多余空格的删除；</li><li>将制表符 tab 转换为若干个空格。</li></ol></li></ul></li><li><strong>通用互联网邮件扩充 MIME</strong> 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程序和协议下传送。图 6-18 表示 MIME 和 SMTP 的关系。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812180720.png"></li></ul></li><li>MIME 主要包括以下三部分内容：<ul><li>5 个新的邮件首部字段，它们可包含在原来的邮件首部中。这些字段提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ul></li><li>MIME 增加的 5 个新的邮件首部的名称及其意义：<ul><li>MIME-Version：标志 MIME 的版本。现在的版本号是 1.0。</li><li>Content-Description：可读字符串，说明此邮件主体是否是图像、音频或视频。</li><li>Content-Id：邮件的唯一标识符。</li><li>Content-Transfer-Encoding：在传送时邮件的主体是如何编码的。</li><li>Content-Type：说明邮件主体的数据类型和子类型。</li></ul></li></ol></li><li><strong>内容传送编码</strong><ol><li>介绍三种常用的<strong>内容传送编码</strong><ul><li>最简单的编码就是 7 位 ASCII 码，而每行不能超过 1000 个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。</li><li>另一种编码称为 quoted-printable，这种编码方法适用于所传送的数据中只有少量的非 ASCII 码，例如汉字。</li><li>对于任意的二进制文件，可用 base64 编码。</li></ul></li></ol></li><li><strong>内容类型</strong><ol><li>MIME 标准规定 Content-Type 说明必须含有两个标识符，即内容<strong>类型</strong>和<strong>子类型</strong>，中间用“&#x2F;”分开。</li><li>除了内容类型和子类型，MIME 允许发件人和收件人自己定义专用的内容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串 X- 开始。</li><li>表 6-3 列出了 MIME 的内容类型、子类型举例及其说明。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812181229.png"></li></ul></li><li>MIME 标准为 multipart 定义了四种可能的子类型，每个子类型都提供重要功能。<ul><li>mixed 子类型允许单个报文含有多个相互独立的子报文，每个子报文有自己的类型和编码。mixed 子类型报文使用户能够在单个报文中附上文本、图形和声音，或者用额外数据段发送一个备忘录。在 mixed 后面还要用到一个关键字，即 Boundary＝，此关键字定义了分隔报文各部分所用的字符串 (由邮件系统定义)，只要在邮件的内容中不会出现这样的字符串即可。当某一行以两个连字符“–”开始，后面紧跟上述的字符串，就表示下面开始了另一个子报文。</li><li>alternative 子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件和软件系统的收件人发送备忘录时，这种类型的 multipart 报文很有用。例如，用户可同时用普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在查看图形时选择格式化的形式。</li><li>parallel 子类型允许单个报文含有可同时显示的各个子部分。</li><li>digest 子类型允许单个报文含有一组其他报文。</li></ul></li></ol></li></ul><h1 id="6-6-动态主机配置协议DHCP"><a href="#6-6-动态主机配置协议DHCP" class="headerlink" title="6.6 动态主机配置协议DHCP"></a>6.6 动态主机配置协议DHCP</h1><ul><li>连接到互联网的计算机的协议软件需要配置的项目包括：<ol><li>IP 地址；</li><li>子网掩码；</li><li>默认路由器的 IP 地址；</li><li>域名服务器的 IP 地址。</li></ol></li><li>互联网现在广泛使用的是<strong>动态主机配置协议</strong> DHCP，它提供了一种机制，称为<strong>即插即用连网</strong>。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。</li><li>DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。DHCP 给运行服务器软件而位置固定的计算机指派一个永久地址，而当这计算机重新启动时其地址不改变。</li><li>DHCP 使用客户服务器方式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送<strong>发现报文</strong> (将目的 IP 地址置为全 1，即 255.255.255.255)，这时该主机就成为 DHCP 客户。发送广播报文是因为现在还不知道 DHCP 服务器在什么地方，因此要发现 (DISCOVER) DHCP服务器的 IP 地址。这台主机目前还没有自己的 IP 地址，因此它将 IP 数据报的源 IP 地址设为全 0。这样，在本地网络上的所有主机都能够收到这个广播报文，但只有 DHCP 服务器才对此广播报文进行回答。DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做<strong>提供报文</strong>，表示“提供”了 IP 地址等配置信息。</li><li>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>，但并没有具体规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。</li></ul><h1 id="6-7-简单网络管理协议-SNMP"><a href="#6-7-简单网络管理协议-SNMP" class="headerlink" title="6.7 简单网络管理协议 SNMP"></a>6.7 简单网络管理协议 SNMP</h1><h2 id="6-7-1-网络管理的基本概念"><a href="#6-7-1-网络管理的基本概念" class="headerlink" title="6.7.1 网络管理的基本概念"></a>6.7.1 网络管理的基本概念</h2><ul><li><strong>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等。网络管理常简称为网管。</strong></li><li>网络是一个非常复杂的分布式系统。因为网络上有很多不同厂家生产的、运行着多种协议的结点，而这些结点还在相互通信和交换信息。</li><li>网络管理的一般模型<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812181706.png"></li><li><strong>管理站</strong>又称为<strong>管理器</strong>，是整个网络管理系统的核心，它通常是个有着良好图形界面的高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理站发出的。管理站的所在部门也常称为<strong>网络运行中心</strong> NOC。管理站中的关键构件是<strong>管理程序</strong> (如图 6-21 中有字母 M 的椭圆形图标所示)。管理程序在运行时就成为<strong>管理进程</strong>。管理站 (硬件) 或管理程序 (软件) 都可称为<strong>管理者</strong>或<strong>管理器</strong>，所以这里的 manager 不是指人而是指机器或软件。网络管理员才是指人。大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的设备。</li><li>在被管网络中有很多的<strong>被管设备</strong> (包括设备中的软件)。被管设备可以是主机、路由器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多<strong>被管对象</strong>。被管对象可以是被管设备中的某个硬件，也可以是某些硬件或软件 (例如，路由选择协议) 的配置参数的集合。被管设备有时可称为网络<strong>元素</strong>或简称为<strong>网元</strong>。在被管设备中也会有一些<strong>不能被管的对象</strong>。</li><li><strong>简单网络管理协议</strong> SNMP 中的管理程序和代理程序按客户服务器方式工作。管理程序运行 SNMP <strong>客户程序</strong>，而代理程序运行 SNMP <strong>服务器程序</strong>。在被管对象上运行的 SNMP 服务器程序不停地监听来自管理站的 SNMP 客户程序的请求 (或命令)。一旦发现了，就立即返回管理站所需的信息，或执行某个动作。在网管系统中往往是一个 (或少数几个) 客户程序与很多的服务器程序进行交互。</li><li><strong>若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有对象的影响必须尽量小些。</strong></li></ol></li><li>SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。在网络正常工作时，SNMP 可实现统计、配置和测试等功能。当网络出故障时，可实现各种差错检测和恢复功能。</li><li>若网络元素使用的不是 SNMP 协议而是另一种网络管理协议，那么 SNMP 协议就无法控制该网络元素。这时可使用<strong>委托代理</strong>，委托代理能提供如协议转换和过滤操作等功能对被管对象进行管理。</li><li>SNMP 的网络管理由三个部分组成，SNMP 本身、<strong>管理信息结构</strong> SMI 和<strong>管理信息库</strong> MIB。<ol><li>SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象 (变量) 名及其状态 (值)。SNMP 负责读取和改变这些数值。</li><li>SMI 定义了命名对象和定义对象类型 (包括范围和长度) 的<strong>通用规则</strong>，以及把对象和对象的值进行<strong>编码的规则</strong>。这样做是为了确保网络管理数据的语法和语义无二义性。但从 SMI 的名称并不能看出它的功能。</li><li>MIB 在被管理的实体中创建了命名对象，并规定了其类型。</li></ol></li></ul><h2 id="6-7-2-管理信息结构-SMI"><a href="#6-7-2-管理信息结构-SMI" class="headerlink" title="6.7.2 管理信息结构 SMI"></a>6.7.2 管理信息结构 SMI</h2><ul><li><strong>管理信息结构</strong> SMI 是 SNMP 的重要组成部分，SMI 的功能应当有三个：<ol><li>被管对象应怎样命名；</li><li>用来存储被管对象的数据类型有哪些；</li><li>在网络上传送的管理数据应如何编码。</li></ol></li><li><strong>被管对象的命名</strong><ol><li>SMI 规定，所有的被管对象都必须处在<strong>对象命名树</strong>上。图 6-22 给出了对象命名树的一部分。对象命名树的根没有名字，它的下面有三个顶级对象，都是世界上著名的标准制定单位，即 ITU-T，ISO，以及这两个组织的联合体，它们的标号分别是 0 到 2。在 ISO 的下面的一个标号为 3 的节点是 ISO 认同的的组织成员 org。在其下面有一个美国国防部 dod 的子树 (标号为 6)，再下面就是 internet (标号为 1)。在 internet 节点下面的标号为 2 的节点是 mgmt。再下面只有一个节点，即管理信息库 mib-2，其对象标识符为 1.3.6.1.2.1。在 mib-2 下面包含了所有被 SNMP 管理的对象。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182130.png"></li></ul></li></ol></li><li><strong>被管对象的数据类型</strong><ol><li>SMI 使用基本的<strong>抽象语法记法</strong> 1 (即 ISO 制定的 ASN.1) 来定义数据类型，但又增加了一些新的定义。因此 SMI 既是 ASN.1 的子集，又是 ASN.1 的超集。ASN.1 的记法很严格，它使得数据的含义不存在任何可能的二义性。</li><li>SMI 把数据类型分为两大类：<strong>简单类型和结构化类型</strong>。简单类型是最基本的、直接使用 ASN.1 定义的类型。表 6-4 给出了最主要的几种简单类型。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182253.png"></li></ul></li><li>SMI 定义了两种结构化数据类型，即 sequence 和 sequence of。</li></ol></li><li><strong>编码方法</strong><ol><li>SMI 使用 ASN.1 制定的<strong>基本编码规则</strong> BER 进行数据的编码。BER 指明了每种数据的类型和值。在发送端用 BER 编码，可把用 ASN.1 所表述的报文转换成唯一的比特序列。在接收端用 BER 进行解码，就可得到该比特序列所表示的 ASN.1 报文。</li><li>ASN.1 把所有的数据元素都表示为 T-L-V 三个字段组成的序列 (见图 6-23)。T 字段 (Tag) <strong>定义数据的类型</strong> ，L 字段 (Length) 定义 V <strong>字段的长度</strong> ，而 V 字段 (Value) <strong>定义数据的值</strong>。<ul><li>T 字段又叫做<strong>标记字段</strong> ，占 1 字节。T 字段比较复杂，因为它要定义的数据类型较多。T 字段又再分为以下三个子字段：<ol><li><strong>类别</strong> (2 位) 共四种：通用类 (00)，即 ASN.1 定义的类型；应用类 (01)，即 SMI 定义的类型；上下文类 (10)，即上下文所定义的类型；专用类 (11)，保留为特定厂商定义的类型。</li><li><strong>格式</strong> (1 位) 共两种，指出数据类型的种类：简单数据类型 (0)，结构化数据类型 (1)。</li><li><strong>编号</strong> (5 位) 用来标志不同的数据类型。编号的范围一般为 0～30。当编号大于 30 时，T 字段就要扩展为多个字节。</li></ol></li><li>L 字段又叫做<strong>长度字段</strong> (单字节或多字节)。当 L 字段为单字节时，其最高位为 0，后面的 7 位定义 V 字段的长度。当 L 字段为多个字节时，其最高位为 1，而后面的 7 位定义后续字节的字节数 (用二进制整数表示)。这时，所有的后续字节并置起来的二进制整数定义 V 字段的长度。</li><li>V 字段又叫做<strong>值字段</strong>，用于定义数据元素的值。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182351.png"></li></ul></li></ol></li></ul><h2 id="6-7-3-管理信息库-MIB"><a href="#6-7-3-管理信息库-MIB" class="headerlink" title="6.7.3 管理信息库 MIB"></a>6.7.3 管理信息库 MIB</h2><ul><li><strong>管理信息</strong>就是指在互联网的网管框架中<strong>被管对象的集合</strong>。被管对象必须维持可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚拟的信息存储器，所以才称为<strong>管理信息库</strong> MIB。管理程序就使用 MIB 中这些信息的<strong>值</strong>对网络进行管理 (如读取或重新设置这些值)。只有在 MIB 中的对象才是 SNMP 所能够管理的。</li></ul><h2 id="6-7-4-SNMP-的协议数据单元和报文"><a href="#6-7-4-SNMP-的协议数据单元和报文" class="headerlink" title="6.7.4 SNMP 的协议数据单元和报文"></a>6.7.4 SNMP 的协议数据单元和报文</h2><ul><li>SNMP 的功能通过探询操作来实现，即 SNMP 管理进程定时向被管理设备周期性地发送探询信息。探询的好处是：<ol><li>使系统相对简单</li><li>能限制通过网络所产生的管理信息的通信量。但探询管理协议不够灵活，而且所能管理的设备数目不能太多。探询系统的开销也较大。</li></ol></li><li>SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为<strong>陷阱</strong>，表示它能够捕捉“事件”。但这种陷阱信息的参数是受限制的。</li><li>当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达到某些门限值的事件 (这就叫做<strong>过滤</strong>)。这种方法的好处是：<ol><li>仅在严重事件发生时才发送陷阱；</li><li>陷阱信息很简单且所需字节数很少。</li></ol></li><li>SNMP 使用无连接的 UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保证可靠交付的。</li><li>和大多数 TCP&#x2F;IP 协议不一样，SNMP 报文没有固定的字段。它们使用标准 ASN.1 编码。因此，SNMP 报文用人工进行编码和理解时都比较困难。</li><li>SNMP 的报文格式<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812213115.png"></li><li>一个SNMP 报文共由四个部分组成，即<strong>版本、首部、安全参数</strong>和 SNMP 报文的<strong>数据部分</strong>。首部包括报文标识、最大报文长度、报文标志。报文标志占 1 字节，其中的每一位定义安全类型或其他信息。安全参数用来产生报文摘要。</li><li>在 SNMP PDU 前面还有两个有关加密信息的字段。这是当数据部分需要加密时才使用的两个字段。与网络管理直接相关的是后面的 SNMP PDU 部分。由 PDU <strong>类型、请求</strong> ID、<strong>差错状态、差错索引</strong>以及<strong>变量绑定</strong>这几个字段组成。</li><li>简单介绍一下其他字段的作用：<ul><li><strong>请求标识符</strong>　由管理进程设置的 4 字节整数值。代理进程在发送响应报文时也要返回此请求标识符。由于管理进程可同时向许多代理发出请求读取变量值的报文，因此设置了请求标识符可使管理进程能够识别返回的响应是对应于哪一个请求报文。</li><li><strong>差错状态</strong>　在请求报文中，这个字段是零。当代理进程响应时，就填入 0～18 中的一个数字。例如 0 表示 noError，1 表示 tooBig，2 表示 noSuchName，3 表示badValue。</li><li><strong>差错索引</strong>　在请求报文中，这个字段是零。当代理进程响应时，若出现 noSuchName，badValue 或 readOnly 的差错，代理进程就设置一个整数，指明有差错的变量在变量列表中的偏移。</li><li><strong>变量绑定</strong>　指明一个或多个变量的名和对应的值。在请求报文中，变量的值应忽略 (类型是 NULL)。</li></ul></li></ol></li></ul><h1 id="6-8-应用进程跨越网络的通信"><a href="#6-8-应用进程跨越网络的通信" class="headerlink" title="6.8 应用进程跨越网络的通信"></a>6.8 应用进程跨越网络的通信</h1><h2 id="6-8-1-系统调用和应用编程接口"><a href="#6-8-1-系统调用和应用编程接口" class="headerlink" title="6.8.1 系统调用和应用编程接口"></a>6.8.1 系统调用和应用编程接口</h2><ul><li>当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口。此接口再把控制权传递给计算机的操作系统。操作系统把这个调用转给某个内部过程，并执行所请求的操作。内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程。总之，只要应用进程需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执行必要的操作后把控制权返回给应用进程。因此，系统调用接口实际上是应用进程的控制权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为<strong>应用编程接口</strong> API。API <strong>从程序设计的角度</strong>定义了许多标准的系统调用函数。应用进程只要使用标准的系统调用函数就可得到操作系统的服务。因此从程序设计的角度看，也可以把 API 看成是应用程序和操作系统之间的接口。</li><li>在套接字以上的进程是受应用程序控制的，而在套接字以下的运输层协议软件则是受计算机操作系统的控制。因此，只要应用程序使用 TCP&#x2F;IP 协议进行通信，它就必须通过套接字与操作系统交互 (这就要使用系统调用函数) 并请求其服务。</li></ul><h2 id="6-8-2-几种常用的系统调用"><a href="#6-8-2-几种常用的系统调用" class="headerlink" title="6.8.2 几种常用的系统调用"></a>6.8.2 几种常用的系统调用</h2><ul><li><strong>连接建立阶段</strong></li><li><strong>数据传送阶段</strong></li><li><strong>连接释放阶段</strong></li></ul><h1 id="6-9-P2P应用"><a href="#6-9-P2P应用" class="headerlink" title="6.9 P2P应用"></a>6.9 P2P应用</h1><h2 id="6-9-1-具有集中目录服务器-P2P-工作方式"><a href="#6-9-1-具有集中目录服务器-P2P-工作方式" class="headerlink" title="6.9.1 具有集中目录服务器 P2P 工作方式"></a>6.9.1 具有集中目录服务器 P2P 工作方式</h2><ul><li>集中式目录服务器的最大缺点就是可靠性差，而且会成为其性能的瓶颈 (尤其是在用户数非常多的情况下)。</li></ul><h2 id="6-9-2-具有全分布式结构的P2P文件共享程序"><a href="#6-9-2-具有全分布式结构的P2P文件共享程序" class="headerlink" title="6.9.2 具有全分布式结构的P2P文件共享程序"></a>6.9.2 具有全分布式结构的P2P文件共享程序</h2><h2 id="6-9-3-P2P文件分发的分析"><a href="#6-9-3-P2P文件分发的分析" class="headerlink" title="6.9.3 P2P文件分发的分析"></a>6.9.3 P2P文件分发的分析</h2><h2 id="6-9-4-在-P2P-对等方中搜索对象"><a href="#6-9-4-在-P2P-对等方中搜索对象" class="headerlink" title="6.9.4 在 P2P 对等方中搜索对象"></a>6.9.4 在 P2P 对等方中搜索对象</h2><ul><li>在 P2P 文件系统中，对等方用户的数量非常多，并且处于一种无序的状态。任何一个对等方可以随时加入进来或随时退出。在这种情况下，怎样有效地找到所需的文件，也就是怎样有效地定位对等方及其资源，是 P2P 系统中重要的问题。</li><li>现在广泛使用的索引和查找技术叫做<strong>分布式散列表</strong> DHT。DHT 也可译为分布式哈希表，它是由大量对等方共同维护的散列表。</li><li>分布式散列表 DHT 利用散列函数，把资源名 K 及其存放的结点 IP 地址 N 都分别映射为<strong>资源名标识符</strong> KID 和<strong>结点标识符</strong> NID。</li><li>为了加速查找，在 Chord 环上可以增加一些<strong>指针表</strong>，它又称为<strong>路由表</strong>或<strong>查找器表</strong>。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所遵循的协议。应用层的许多协议都是基于客户服务器方式的。客户是服务请求方，服务器是服务提供方。</p></li><li><p>域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。DNS 是一个联机分布式数据库系统，并采用客户服务器方式。</p></li><li><p>域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序 (即域名服务器) 共同完成的。</p></li><li><p>互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制 IP 地址中的点没有关系。</p></li><li><p>域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。</p></li><li><p>文件传送协议 FTP 使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接。实际用于传输文件的是数据连接。</p></li><li><p>万维网 WWW 是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网上的一个站点链接到另一个站点。</p></li><li><p>万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在客户程序主窗口上显示出的万维网文档称为页面。</p></li><li><p>万维网使用统一资源定位符 URL 来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</p></li><li><p>万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议 HTTP。HTTP 使用 TCP 连接进行可靠的传送。但 HTTP 协议本身是无连接、无状态的。HTTP&#x2F;1.1 协议使用了持续连接 (分为非流水线方式和流水线方式)。</p></li><li><p>万维网使用超文本标记语言 HTML 来显示各种万维网页面。</p></li><li><p>万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。</p></li><li><p>活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。</p></li><li><p>在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索搜索引擎和分类目录搜索引擎两大类。</p></li><li><p>电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取，相当于“电子信箱”。</p></li><li><p>一个电子邮件系统有三个主要组成构件，即：用户代理、邮件服务器，以及邮件协议 (包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP)。用户代理和邮件服务器都要运行这些协议。</p></li><li><p>电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的视窗界面来发送和接收邮件。</p></li><li><p>从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送，都要使用 SMTP 协议。但用户代理从邮件服务器读取邮件时，则要使用 POP3 (或 IMAP) 协议。</p></li><li><p>基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏览器和邮件服务器之间的邮件传送使用 HTTP 协议，而在邮件服务器之间邮件的传送仍然使用 SMTP 协议。</p></li><li><p>简单网络管理协议 SNMP 由三部分组成：</p><ol><li>SNMP 本身，负责读取和改变各代理中的对象名及其状态数值</li><li>管理信息结构 SMI，定义命名对象和定义对象类型 (包括范围和长度) 的通用规则，以及把对象和对象的值进行编码的基本编码规则 BER</li><li>管理信息库 MIB，在被管理的实体中创建了命名对象，并规定了其类型。</li></ol></li><li><p>系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称为应用编程接口 API。API 是应用程序和操作系统之间的接口。</p></li><li><p>套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。</p></li><li><p>目前 P2P 工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应用所占的比例大得多。</p></li><li><p>BT 是很流行的一种 P2P 应用。BT 采用“最稀有的优先”的技术，可以尽早把最稀有的文件块收集到。此外，凡有当前以最高数据率向某个对等方传送文件块的相邻对等方，该对等方就优先把所请求的文件块传送给这些相邻对等方。这样做的结果是，这些对等方相互之间都能够以令人满意的速率交换文件块。</p></li><li><p>当对等方的数量很大时，采用 P2P 方式下载大文件，要比传统的客户−服务器方式快得多。</p></li><li><p>在 P2P 应用中，广泛使用的索引和查找技术是分布式散列表 DHT。</p></li><li><p>域名系统的主要功能是什么？域名系统中的根域名服务器、顶级域名服务器、权限域名服务器以及本地域名服务器有何区别？</p><blockquote><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。根域名服务器是最重要的域名服务器，因为不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析 (即转换为 IP 地址)，只要自己无法解析，就首先要求助于根域名服务器。域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。在域名系统中使用了层次结构的许多域名服务器。<br>顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答 (可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址)。一个服务器所负责管辖的 (或有权限的) 范围叫做区。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。<br>因此，权限域名服务器是负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。<br>本地域名服务器离用户较近，一般不超过几个路由器的距离。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。当所要查询的主机也属于同一个本地 ISP 时，该本地域名服务器立即就能将所查询的主机名转换为它的 IP 地址，而不需要再去询问其他的域名服务器。</p></blockquote></li><li><p>简单文件传送协议 TFTP 与文件传送协议 FTP 的主要区别是什么？应用在什么场合？</p><blockquote><p>简单文件传送协议 TFTP是一个很小且易于实现的文件传送协议。虽然 TFTP 也使用客户服务器方式，但它使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。FTP 使用 TCP 传送数据，因而是很可靠的。但正因如此，FTP 比 TFTP 复杂得多。TFTP 只支持文件传输而不支持交互。TFTP 有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。<br>TFTP 的主要优点有两个: (1) TFTP 可用于 UDP 环境；(2) TFTP 代码所占的内存较小。<br>TFTP 的工作很像停止等待协议。发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。发完数据后在规定时间内收不到确认就要重发数据 PDU。发送确认 PDU 的一方，若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。当我们只需要复制一个文件而不需要 FTP 协议的功能时，就只需要一个能够迅速复制这些文件的协议，TFTP 就是一个很好的选择。<br><strong>复杂性</strong>：TFTP 是一种非常简单的文件传输协议，功能相对有限。它设计简单，只支持文件的读写操作，没有目录列表、权限管理等高级功能；FTP 是一个功能更为丰富和复杂的协议。它支持文件上传、下载、删除、重命名等操作，同时提供目录列表、权限管理、登录认证等多种功能。<br><strong>设计</strong>：TFTP 的设计目标是轻量级和简单，它使用 UDP 进行通信，没有建立连接的过程，因此具有低开销但也更容易受到网络中断等问题的影响；FTP 是一个基于 TCP 的协议，它建立连接后进行通信，具有更为可靠的传输机制，但相对来说会有更多的开销。<br><strong>安全性</strong>：TFTP 在安全性方面较为薄弱，没有提供加密和身份验证机制，传输的数据是明文的，容易受到中间人攻击；FTP 的安全性相对更强，支持加密和登录认证，可以更好地保护数据传输的隐私和完整性。<br><strong>TFTP</strong>：由于其简单性，TFTP 通常用于一些特定的场景，如在内部网络中进行配置文件的传输、嵌入式设备的固件升级等。<br><strong>FTP</strong>：FTP 适用于更复杂的文件传输需求，例如，Web 开发中文件上传、下载，或者在服务器之间进行文件的备份和同步等。<br>总体来说，TFTP 适用于简单的、对复杂性和安全性要求不高的文件传输场景，而 FTP 适用于更为复杂和安全要求较高的文件传输场景。</p></blockquote></li><li><p>DHCP 协议用在什么情况下？当一台计算机第一次运行引导程序时，其 ROM 中有没有该主机的 IP 地址、子网掩码，或某个域名服务器的 IP 地址？</p><blockquote><p>动态主机配置协议 DHCP 提供了即插即用连网机制。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。因此，每当一台计算机加入到一个新的网络时就需要运行 DHCP 协议来获取这台计算机的 IP 地址。<br>当一台计算机第一次运行引导程序时，ROM 中并没有该计算机的 IP 地址、子网掩码或某个域名服务器的 IP 地址的任何一个。</p></blockquote></li><li><p>SNMP 协议使用 UDP 传送报文，为什么不使用 TCP？</p><blockquote><p>SNMP 使用无连接的 UDP (要发送数据时不需要有连接建立过程，数据发送完毕后，也不需要连接释放过程)，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保证可靠交付的，有丢失的可能。好在 SNMP 使用周期性地发送探询报文段的方法，来对网络资源进行实时监视，如果丢失了一个探寻报文，则经过一段时间后，会再发送一个。这样就比使用 TCP 要快速得多。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2023/12/09/wang-luo-ceng/"/>
      <url>/2023/12/09/wang-luo-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h1><ul><li><strong>表4-1　虚电路服务与数据报服务的对比</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722192206.png"></li></ol></li></ul><h1 id="4-2-网际协议-IP"><a href="#4-2-网际协议-IP" class="headerlink" title="4.2 网际协议 IP"></a>4.2 网际协议 IP</h1><ul><li>网际协议 IP 是 TCP&#x2F;IP 体系中两个主要的协议之一，也是最重要的互联网标准协议之一。</li><li>与 IP 协议配套使用的还有三个协议：<ol><li><strong>地址解析协议 ARP</strong></li><li><strong>网际控制报文协议 ICMP</strong></li><li><strong>网际组管理协议 IGMP</strong></li></ol></li><li>图 4-2 画出了这三个协议和网际协议 IP 的关系。这一层中，ARP 画在最下面，因为 IP 经常使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722193402.png"></li></ol></li><li>网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP&#x2F;IP 体系中的网络层常常被称为<strong>网际层</strong>或 <strong>IP 层</strong>。</li></ul><h2 id="4-2-1-虚拟互连网络"><a href="#4-2-1-虚拟互连网络" class="headerlink" title="4.2.1 虚拟互连网络"></a>4.2.1 虚拟互连网络</h2><ul><li>用户的需求是多种多样的，<strong>没有一种单一的网络能够适应所有用户的需求</strong>。</li><li>将网络互相连接起来要使用<strong>中间设备</strong>。根据中间设备所在的层次，有以下不同的中间设备: <ol><li>物理层使用的中间设备叫做<strong>转发器</strong>。</li><li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>。</li><li>网络层使用的中间设备叫做<strong>路由器</strong>。</li><li>在网络层以上使用的中间设备叫做<strong>网关</strong>。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li></ol></li><li>图 4-3 (a) 表示有许多计算机网络通过路由器进行互连。由于参加互连的计算机网络都使用相同的<strong>网际协议</strong> IP，因此可以把互连以后的计算机网络看成如图 4-3 (b) 所示的一个<strong>虚拟互连网络</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722193637.png"></li></ol></li><li>利用 IP 协议可以使性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。</li><li>使用 IP 网的好处是: 当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节。</li><li>在图 4-4 所示的互联网中的源主机 H<sub>1</sub> 要把一个 IP 数据报发送给目的主机 H<sub>2</sub>。根据分组交换存储转发概念，主机 H<sub>1</sub> 先查找自己的路由表，看目的主机是否在本网络上。如在，则<strong>直接交付</strong>。如不在，则必须把 IP 数据报发送给某个路由器 (图中的 R<sub>1</sub>)。R<sub>1</sub> 在查找路由表后，知道应当把数据报转发给 R<sub>2</sub> 进行<strong>间接交付</strong>。这样一直转发下去，最后路由器 R<sub>5</sub> 和 H<sub>2</sub> 连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报<strong>直接交付</strong>目的主机 H<sub>2</sub>。图中画出了源主机、目的主机以及各路由器的协议栈。主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向 (用黑色粗线表示)。在 R<sub>4</sub> 和 R<sub>5</sub> 之间使用了卫星链路，R<sub>5</sub> 所连接的是个无线局域网。在 R<sub>1</sub> 到 R<sub>4</sub> 之间的三个网络则可以是任意类型的网络。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723110729.png"></li></ol></li><li><strong>互联网可以由多种异构网络互连组成</strong>。</li></ul><h2 id="4-2-2-分类的-IP-地址"><a href="#4-2-2-分类的-IP-地址" class="headerlink" title="4.2.2 分类的 IP 地址"></a>4.2.2 分类的 IP 地址</h2><ul><li><strong>IP 地址及其表示方法</strong><ol><li>互联网是一个<strong>单一的、抽象的网络</strong>。IP 地址是给互联网上的每台主机 (或路由器) 的每个接口分配一个在全世界范围唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上方便地进行寻址。</li><li>IP 地址的编址方法共经过了三个历史阶段：<ul><li><strong>分类的 IP 地址</strong>是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li><li><strong>子网的划分</strong>是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</li><li><strong>构成超网</strong>是比较新的无分类编址方法。1993年提出后很快就得到推广应用。</li></ul></li><li>“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成。第一个字段是<strong>网络号</strong>，它标志主机 (或路由器) 所连接到的网络，网络号是唯一的。第二个字段是<strong>主机号</strong>，它标志该主机 (或路由器)。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。一个 IP 地址<strong>在整个互联网范围内是唯一的</strong>。</li><li>这种两级的 IP 地址可以记为：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112010.png"></li><li>式 4-1 中的符号“::&#x3D;”表示“<strong>定义为</strong>”。图  4-5 给出了各种 IP 地址的网络号字段和主机号字段，A 类、B 类和 C 类地址都是<strong>单播地址</strong>，是最常用的。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112033.png"></li></ol></li><li>从图4-5 可以看出：<ol><li>A 类、B 类和 C 类地址的网络号字段分别为 1、2 和 3 个字节长，而在网络号字段的最前面有 1～3 位的<strong>类别位</strong> ，其数值分别规定为 0，10 和 110。</li><li>A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。</li><li>D 类地址 (前 4 位是 1110) 用于<strong>多播</strong>。</li><li>E 类地址 (前 4 位是 1111) 保留为以后用。</li></ol></li></ul></li><li>从 IP 地址的结构来看，<strong>IP</strong> 地址并不仅仅指明一台主机，还指明了主机所连接到的网络。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112436.png"></li></ol></li><li><strong>常用的三种类别的 IP 地址</strong><ol><li>A类地址<ul><li>A 类地址的网络号字段占 1 个字节，只有 7 位可供使用 (该字段的第一位固定为 0)，但可指派的网络号是 126 个 (即 2<sup>7</sup>–2)。减 2 的原因是：第一，IP 地址中的全 0 表示“<strong>这个</strong>”。网络号字段为全 0 的 IP 地址是个保留地址，意思是“<strong>本网络</strong>”；第二，网络号为 127 (即01111111) 保留作为本地软件<strong>环回测试</strong>本主机的进程之间的通信。若主机发送一个目的地址为环回地址 (例如127.0.0.1) 的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址不是网络地址。</li><li>A 类地址的主机号占 3 个字节，因此每一个 A 类网络中的最大主机数是 2<sup>24</sup>–2，即16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>单个网络地址</strong> (例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是5.0.0.0)，全 1 表示“<strong>所有的</strong>”，因此全 1 的主机号字段表示该网络上的所有主机。</li><li>IP 地址空间共有 2<sup>32</sup> (4294967296) 个地址。整个 A 类地址空间共有 2<sup>31</sup> 个地址，占整个IP地址空间的 50％。</li></ul></li><li>B 类地址<ul><li>B 类地址的网络号字段有 2 个字节，前面两位 (10) 已固定了，剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此不存在网络总数减 2 的问题。实际上 B 类网络地址 128.0.0.0 是不指派的，可以指派的 B 类最小网络地址是 128.1.0.0。因此 B 类地址可指派的网络数为 2<sup>14</sup>−1，即 16383。B 类地址的每一个网络上的最大主机数是 2<sup>16</sup>–2，即 65534。这里需要减2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 2<sup>30</sup> 个地址，占整个 IP地址空间的 25％。</li></ul></li><li>C 类地址<ul><li>C 类地址有 3 个字节的网络号字段，最前面的 3 位是 (110)，还有 21 位可以进行分配。C类网络地址 192.0.0.0 是不指派的，可指派的 C 类最小网络地址 192.0.1.0，因此 C 类地址可指派的网络总数是 2<sup>21</sup>−1，即 2097151。每一个 C 类地址的最大主机数是 2<sup>8</sup>–2，即254。整个 C 类地址空间共约有 2<sup>29</sup> 个地址，占整个 IP 地址的 12.5％。</li></ul></li><li>得出表 4-2 所示的 IP 地址的指派范围。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112931.png"></li></ul></li><li>表 4-3 给出了一般不使用的特殊 IP 地址，这些地址只能在特定的情况下使用。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112945.png"></li></ul></li><li>IP 地址具有以下一些重要特点：<ul><li>每个 IP 地址都由网络号和主机号两部分组成。IP 地址是一种<strong>分等级的地址结构</strong>。分两个等级的好处是：<ol><li>IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong> (第一级)，而剩下的主机号 (第二级) 由得到该网络号的单位自行分配。方便了 IP 地址的管理。</li><li>路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong> (不考虑目的主机号)，可以使路由表中的项目数大幅度减少，从而<strong>减小了路由表所占的存储空间以及查找路由表的时间</strong>。</li></ol></li><li>实际上 IP 地址是标志一台主机 (或路由器) 和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>。一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。</li><li>一个网络指具有相同网络号 net-id 的主机的集合，因此，<strong>用转发器或网桥连接的若干个局域网仍为一个网络</strong>，这些局域网具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li><li>在 IP 地址中，所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域)，互联网都会同等对待每一个 IP 地址。</li></ul></li><li><h2 id="图-4-7-画出了三个局域网-LAN1，LAN2-和-LAN3-通过三个路由器-R1，R2-和-R3-互连起来所构成的一个互联网-互联网用虚线圆角方框表示-。其中局域网-LAN2-是由两个网段通过网桥-B-互连的。图中的小圆圈表示需要有-IP-地址。"><a href="#图-4-7-画出了三个局域网-LAN1，LAN2-和-LAN3-通过三个路由器-R1，R2-和-R3-互连起来所构成的一个互联网-互联网用虚线圆角方框表示-。其中局域网-LAN2-是由两个网段通过网桥-B-互连的。图中的小圆圈表示需要有-IP-地址。" class="headerlink" title="图 4-7 画出了三个局域网 (LAN1，LAN2 和 LAN3) 通过三个路由器 (R1，R2 和 R3) 互连起来所构成的一个互联网 (互联网用虚线圆角方框表示)。其中局域网 LAN2 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有 IP 地址。 - "></a>图 4-7 画出了三个局域网 (LAN<sub>1</sub>，LAN<sub>2</sub> 和 LAN<sub>3</sub>) 通过三个路由器 (R<sub>1</sub>，R<sub>2</sub> 和 R<sub>3</sub>) 互连起来所构成的一个互联网 (互联网用虚线圆角方框表示)。其中局域网 LAN<sub>2</sub> 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有 IP 地址。<br> - <img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723113523.png"></h2><pre><code> 1. 在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。图中所示的网络号就是 IP 地址中的网络号字段的值。另一种表示方法是用主机号为全 0 的网络IP 地址。 2. 用网桥互连的网段仍然是一个局域网，只能有一个网络号。 3. 路由器总是具有两个或两个以上的 IP 地址。即路由器的每一个接口都有一个不同网络号的 IP 地址。 4. 当两个路由器直接相连时 (例如通过一条租用线路)，在连线两端的接口处，可以分配也可以不分配 IP 地址。如分配了 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” (如图中的 N&lt;sub&gt;1&lt;/sub&gt;，N&lt;sub&gt;2&lt;/sub&gt; 和 N&lt;sub&gt;3&lt;/sub&gt;)。之所以叫做“网络”是因为它有 IP 地址。但为了节省 IP 地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配 IP 地址。通常把这样的特殊网络叫做**无编号网络**或**无名网络**。</code></pre></li></ol></li></ul><h2 id="4-2-3-IP-地址与硬件地址"><a href="#4-2-3-IP-地址与硬件地址" class="headerlink" title="4.2.3 IP 地址与硬件地址"></a>4.2.3 IP 地址与硬件地址</h2><ul><li>图 4-8 说明了物理地址与 IP 地址的区别。从层次的角度看，<strong>物理地址是数据链路层和物理层使用的地址</strong>，IP <strong>地址是网络层和以上各层使用的地址，是一种逻辑地址</strong> (称 IP 地址为逻辑地址是因为 IP 地址是用软件实现的)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723113843.png"></li></ol></li><li>在发送数据时，数据从高层下到低层，然后到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中；连接在通信链路上的设备 (主机或路由器) 在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址；总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。</li><li>图 4-9 (a) 画的是三个局域网用两个路由器 R<sub>1</sub> 和 R<sub>2</sub> 互连起来。现在主机 H<sub>1</sub> 要和主机 H<sub>2</sub> 通信。这两台主机的 IP 地址分别是 IP<sub>1</sub> 和 IP<sub>2</sub>，而它们的硬件地址分别为 HA<sub>1</sub> 和 HA<sub>2</sub> (HA 表示 Hardware Address)。通信的路径是：H<sub>1</sub>→ 经过 R<sub>1</sub> 转发 → 再经过 R<sub>2</sub> 转发 →H<sub>2</sub>。路由器 R<sub>1</sub> 因同时连接到两个局域网上，因此它有两个硬件地址，即 HA<sub>3</sub> 和 HA<sub>4</sub>。同理，路由器 R<sub>2</sub> 也有两个硬件地址 HA<sub>5</sub> 和 HA<sub>6</sub>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723234703.png"></li><li>图 4-9 (b) 特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723234720.png"></li></ul></li></ol></li><li>强调指出以下几点：<ol><li><strong>在 IP 层抽象的互联网上只能看到 IP 数据报</strong>。虽然 IP 数据报要经过路由器 R<sub>1</sub> 和 R<sub>2</sub> 的两次转发，但源地址和目的地址始终是 IP<sub>1</sub> 和 IP<sub>2</sub>。图中的数据报上写的“从 IP<sub>1</sub> 到 IP<sub>2</sub>”表示前者是源地址，后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li><li>虽然在 IP 数据报首部有源站 IP 地址，但<strong>路由器只根据目的站的 IP 地址的网络号进行路由选择</strong>。</li><li><strong>在局域网的链路层，只能看见 MAC 帧</strong>。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图4-9 (b)。开始在 H<sub>1</sub> 到 R<sub>1</sub> 间传送时，MAC 帧首部中写的是从硬件地址 HA<sub>1</sub> 发送到硬件地址 HA<sub>3</sub>，路由器 R<sub>1</sub> 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新添加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 HA<sub>4</sub>和 HA<sub>5</sub>。路由器 R<sub>2</sub> 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变成为 HA<sub>6</sub> 和 HA<sub>2</sub>。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。</li><li>尽管互连在一起的网络的硬件地址体系各不相同，<strong>但 IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。在网络层上讨论问题时，能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信</strong>。</li></ol></li></ul><h2 id="4-2-4-地址解析协议-ARP"><a href="#4-2-4-地址解析协议-ARP" class="headerlink" title="4.2.4 地址解析协议 ARP"></a>4.2.4 地址解析协议 ARP</h2><ul><li>图 4-10 说明了 ARP 协议的作用。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724110352.png"></li></ol></li><li>在网络层中，数据包使用 IP 地址进行路由和传输。然而，在实际的网络链路上，数据帧必须使用该网络的硬件地址进行传输。</li><li><strong>地址解析协议</strong> ARP 是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新 (新增或超时删除)。</li><li>如果不使用 ARP 高速缓存，那么任何一台主机只要进行一次通信，就必须在网络上用广播方式发送 ARP 请求分组，使网络上的通信量增加。ARP 把已经得到的地址映射保存在高速缓存中，使该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。</li><li>ARP 对保存在高速缓存中的每一个映射地址项目设置<strong>生存时间</strong>，超过生存时间的项目就从高速缓存中删除掉。</li><li>ARP 解决<strong>同一个局域网上</strong>的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，就无法解析另一个局域网主机的硬件地址。</li><li>归纳出使用 ARP 的四种典型情况 (图 4-12)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724110844.png"></li><li>发送方是主机 (如 H<sub>1</sub>)，要把 IP 数据报发送到同一个网络上的另一台主机 (如 H<sub>2</sub>)。这时 H<sub>1</sub> 发送 ARP 请求分组 (在网 1 上广播)，找到目的主机 H<sub>2</sub> 的硬件地址。</li><li>发送方是主机 (如 H<sub>1</sub>），要把 IP 数据报发送到另一个网络上的一台主机 (如 H<sub>3</sub> 或 H<sub>4</sub>)。这时 H<sub>1</sub>发送 ARP 请求分组 (在网 1 上广播)，找到网 1 上的一个路由器 R<sub>1</sub> 的硬件地址。剩下的工作由路由器 R<sub>1</sub> 来完成。R<sub>1</sub> 要做的事情是下面的 (3) 或 (4)。</li><li>发送方是路由器 (如 R<sub>1</sub>)，要把 IP 数据报转发到与 R<sub>1</sub> 连接在同一个网络 (网 2) 上的主机 (如 H<sub>3</sub>)。这时 R<sub>1</sub> 发送 ARP 请求分组 (在网 2 上广播)，找到目的主机 H<sub>3</sub> 的硬件地址。</li><li>发送方是路由器 (如 R<sub>1</sub>)，要把 IP 数据报转发到网3上的一台主机 (如 H<sub>4</sub>)。H<sub>4</sub> 与 R<sub>1</sub> 不是连接在同一个网络上。这时 R<sub>1</sub> 发送 ARP 请求分组 (在网 2 上广播)，找到连接在网 2 上的一个路由器 R<sub>2</sub> 的硬件地址。剩下的工作由这个路由器 R<sub>2</sub> 来完成。</li></ol></li><li>存在着各式各样的网络，<strong>它们使用不同的硬件地址</strong>。要使这些异构网络能够互相通信就必须进行<strong>非常复杂的硬件地址转换工作</strong>，因此由用户或用户主机来完成这项工作几乎是不可能的事。</li></ul><h2 id="4-2-5-IP-数据报的格式"><a href="#4-2-5-IP-数据报的格式" class="headerlink" title="4.2.5 IP 数据报的格式"></a>4.2.5 IP 数据报的格式</h2><ul><li>图 4-13 是 IP 数据报的完整格式。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724111741.png"></li></ol></li><li>一个 IP 数据报由首部和数据两部分组成。首部的前一部分是<strong>固定长度</strong>，共 20 字节，所有 IP 数据报必须具有。在首部的固定部分的后面是一些<strong>可选字段</strong>，其长度可变。</li><li><strong>IP 数据报首部的固定部分中的各字段</strong><ol><li><strong>版本</strong>   占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4 (即 IPv4)。</li><li><strong>首部长度</strong>   占 4 位，可表示的最大十进制数值是 15。首部长度字段所表示数的单位是 32 位字长 (1 个 32 位字长是 4 字节)。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 0101。而当首部长度为最大值 1111 时，就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用，但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节 (即首部长度为 0101)，这时不使用任何选项。</li><li><strong>区分服务</strong>   占 8 位，用来获得更好的服务。只有在使用区分服务时，这个字段才起作用，在一般的情况下都不使用这个字段。</li><li><strong>总长度</strong>   总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 2<sup>16</sup>–1＝65535 字节。</li><li><strong>标识</strong>   占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li><li><strong>标志</strong>   占 3 位，目前只有两位有意义。<ul><li>标志字段中的最低位记为 <strong>MF</strong>。MF＝1 即表示后面“<strong>还有分片</strong>”的数据报。MF＝0 表示这已是若干数据报片中的最后一个。</li><li>标志字段中间的一位记为 <strong>DF</strong>，意思是“<strong>不能分片</strong>”。只有当 DF＝0 时才允许分片。</li></ul></li><li><strong>片偏移</strong>   占 13 位。片偏移指：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位，每个分片的长度是 8 字节 (64 位) 的整数倍。</li><li><strong>生存时间</strong> 　占 8 位。生存时间字段的英文缩写是 TTL，是数据报在网络中的<strong>寿命</strong>。由发出数据报的源点设置这个字段。目的是防止无法交付的数据报无限制地在互联网中兜圈子，消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。</li><li><strong>协议</strong>   占 8 位。协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP 层知道应将数据部分上交给哪个协议进行处理。</li><li><strong>首部检验和</strong>   占 16 位。这个字段<strong>只检验数据报的首部，但不包括数据部分</strong>。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和，但不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的 CRC 检验码而采用下面的简单计算方法：在发送方，先把 IP 数据报首部划分为许多 16 位字的序列，并把检验和字段置零。用反码算术运算把所有 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有 16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为 0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。图 4-15 说明了 IP 数据报首部检验和的计算过程。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230729164523.png"></li></ol></li><li><strong>源地址</strong> 　占 32 位。</li><li><strong>目的地址</strong> 　占 32 位。</li></ol></li><li><strong>IP 数据报首部的可变部分</strong><ol><li>IP 数据报首部的可变部分是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容丰富。</li><li>增加首部的可变部分是为了增加 IP 数据报的功能，同时也增加了每一个路由器处理数据报的开销。</li></ol></li></ul><h2 id="4-2-6-IP-层转发分组的流程"><a href="#4-2-6-IP-层转发分组的流程" class="headerlink" title="4.2.6 IP 层转发分组的流程"></a>4.2.6 IP 层转发分组的流程</h2><ul><li>若路由表指出到每一台主机应怎样转发，则所得出的路由表就会过于庞大，即<strong>每一行对应于一台主机</strong>；但若路由表指出到某个网络应如何转发，则每个路由器中的路由表就只包含 4 个项目，即<strong>每一行对应于一个网络</strong>。</li><li>在互联网上转发分组时，是<strong>从一个路由器转发到下一个路由器</strong>。</li><li>在路由表中，对每一条路由最主要的是以下两个信息：<strong>目的网络地址，下一跳地址</strong>。</li><li>根据目的网络地址来确定下一跳路由器，可得出以下的结果：<ol><li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ol></li><li>互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>。</li><li>采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，也可在需要考虑某种安全问题时采用这种特定主机路由。</li><li>路由器还可采用<strong>默认路由</strong>以减小路由表所占用的空间和搜索路由表所用的时间。</li><li><strong>分组转发算法</strong>如下：<ol><li>从数据报的首部提取目的主机的 IP 地址 <em>D</em>，得出目的网络地址为 <em>N</em>。</li><li>若 <em>N</em> 是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 <em>D</em> 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行 3。</li><li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。</li><li>若路由表中有到达网络 <em>N</em> 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 5。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。</li><li>报告转发分组出错。</li></ol></li></ul><h1 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3 划分子网和构造超网"></a>4.3 划分子网和构造超网</h1><h2 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1 划分子网"></a>4.3.1 划分子网</h2><ul><li><strong>从两级 IP 地址到三级 IP 地址</strong><ol><li>在 ARPANET 的早期，IP 地址的设计不够合理：<ul><li>IP <strong>地址空间的利用率有时很低</strong></li><li>给每一个物理网络分配一个网络号会<strong>使路由表变得太大</strong>因而使网络性能变坏</li><li><strong>两级 IP 地址不够灵活</strong></li></ul></li><li>为解决上述问题，在 IP 地址中增加了一个“<strong>子网号字段</strong>”，使两级 IP 地址变成为三级 IP地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做<strong>划分子网</strong>，或<strong>子网寻址</strong>或<strong>子网路由选择</strong>。划分子网已成为互联网的正式标准协议。</li><li>划分子网的基本思路如下：<ul><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个<strong>子网</strong>。划分子网是一个单位内部的事情。本单位以外的网络<strong>看不见</strong>这个网络是由多少个子网组成，因为这个单位<strong>对外仍然表现为一个网络</strong>。</li><li>划分子网的方法是从网络的主机号借用若干位作为子网号，主机号也就相应减少了同样的位数。于是两级 IP 地址在<strong>本单位内部</strong>就变为<strong>三级</strong> IP 地址：网络号、子网号和主机号。也可以用以下记法来表示：IP 地址 ::&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</li><li>凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。</li></ul></li></ol></li><li><strong>子网掩码</strong><ol><li>从 IP 数据报的首部<strong>无法看出</strong>源主机或目的主机所连接的网络是否进行了子网的划分。因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。必须使用<strong>子网掩码</strong>。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730151524.png"></li></ul></li><li>使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“与”运算，就立即得出网络地址来。</li><li>为了更便于查找路由表，即使在不划分子网时，还要使用子网掩码。</li><li>如果一个网络不划分子网，那么该网络的子网掩码就使用<strong>默认子网掩码</strong>。默认子网掩码中 1 的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相“与”，就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。<ul><li>A 类地址的默认子网掩码是 255.0.0.0，或 0xFF000000。</li><li>B 类地址的默认子网掩码是 255.255.0.0，或 0xFFFF0000。</li><li>C 类地址的默认子网掩码是 255.255.255.0，或 0xFFFFFF00。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730153614.png"></li></ul></li><li><strong>子网掩码是一个网络或一个子网的重要属性</strong>。</li><li>采用固定长度子网时，所划分的<strong>所有</strong>子网的子网掩码都是相同的<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730153818.png"></li><li>子网数是根据子网号 subnet-id 计算出来的。若 subnet-id 有 <em>n</em> 位，则共有 2<sup>n</sup> 种可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数。</li></ul></li><li>虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，<strong>现在全 1 和全 0 的子网号也可以使用了</strong>。</li><li><strong>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数</strong>。</li></ol></li></ul><h2 id="4-3-2-使用子网时分组的转发"><a href="#4-3-2-使用子网时分组的转发" class="headerlink" title="4.3.2 使用子网时分组的转发"></a>4.3.2 使用子网时分组的转发</h2><ul><li>使用子网划分后，路由表必须包含以下三项内容：<strong>目的网络地址、子网掩码和下一跳地址</strong>。</li><li>在划分子网的情况下，路由器转发分组的算法如下：<ol><li>从收到的数据报的首部提取目的 IP 地址 <em>D</em>。</li><li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 <em>D</em> 逐位相“<strong>与</strong>” (AND 操作)，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付)，转发任务结束。否则是间接交付，执行 3。</li><li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。</li><li>对路由表中的每一行 (目的网络地址，子网掩码，下一跳地址)，用其中的子网掩码和 <em>D</em> 逐位相“与” (AND操作)，其结果为 <em>N</em>。若 <em>N</em> 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行 5。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。</li><li>报告转发分组出错。</li></ol></li></ul><h2 id="4-3-3-无分类编址-CIDR-构造超网"><a href="#4-3-3-无分类编址-CIDR-构造超网" class="headerlink" title="4.3.3 无分类编址 CIDR (构造超网)"></a>4.3.3 无分类编址 CIDR (构造超网)</h2><ul><li><strong>网络前缀</strong><ol><li>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：<ul><li>B 类地址在 1992 年已分配了近一半，很快将分配完毕。</li><li>互联网主干网上的路由表中的项目数急剧增长。</li><li>整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽。</li></ul></li><li>早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用<strong>变长子网掩码</strong> VLSM 可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出<strong>无分类编址</strong>方法，它的正式名字是<strong>无分类域间路由选择</strong> CIDR。</li><li>CIDR 主要的特点有两个：<ul><li>CIDR <strong>消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念</strong>，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是“<strong>网络前缀</strong>” (简称“<strong>前缀</strong>”)，用来指明网络，后面部分则用来指明主机。因此 CIDR 使 IP 地址从三级编址 (使用子网掩码) 又回到了两级编址，但这已是<strong>无分类的两级编址</strong>。其记法是：IP 地址 ::&#x3D;{&lt;网络前缀&gt;,&lt;主机号&gt;}；CIDR 还使用“<strong>斜线记法</strong>”，或称为 <strong>CIDR 记法</strong> ，即在 IP 地址后面加上斜线“&#x2F;”，然后写上网络前缀所占的位数。</li><li>CIDR 把<strong>网络前缀都相同</strong>的连续的 IP 地址组成一个“CIDR <strong>地址块</strong>”。只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址 (即最小地址) 和最大地址，以及地址块中的地址数。</li></ul></li><li>为了更方便地进行路由选择，CIDR 使用 32 位的<strong>地址掩码</strong>。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为<strong>子网掩码</strong>。<strong>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数</strong>。</li><li>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong> (构成超网)，它使得路由表中的一个项目可以表示原来传统分类地址的很多个 (例如上千个) 路由。</li><li>路由聚合有利于减少路由器之间的路由选择信息的交换，提高了整个互联网的性能。</li><li>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。</li><li><strong>网络前缀越短，其地址块所包含的地址数就越多</strong>。</li></ol></li><li><strong>最长前缀匹配</strong><ol><li>在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要有相应的改变。每个项目由“<strong>网络前缀</strong>”和“<strong>下一跳地址</strong>”组成。在查找路由表时<strong>可能会得到不止一个匹配结果</strong>。</li><li><strong>最长前缀匹配</strong>是<strong>从匹配结果中选择具有最长网络前缀的路由</strong>，最长前缀匹配又称为<strong>最长匹配</strong>或<strong>最佳匹配</strong>。</li><li>网络前缀越长，地址块越小，路由越具体。</li></ol></li><li><strong>使用二叉线索查找路由表</strong><ol><li>使用 CIDR 后，由于要寻找最长前缀匹配，路由表的查找过程变得更加复杂了。</li><li>对无分类编址的路由表的最简单的查找算法是对所有可能的前缀进行循环查找，这种简单算法的缺点是查找的次数太多。最坏的情况是路由表中没有这个路由。</li><li>为了进行更加有效的查找，通常把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。最常用的就是<strong>二叉线索</strong>，它是一种特殊结构的树。IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。</li><li>为了提高二叉线索的查找速度，使用了各种<strong>压缩技术</strong>。</li></ol></li></ul><h1 id="4-4-网际控制报文协议-ICMP"><a href="#4-4-网际控制报文协议-ICMP" class="headerlink" title="4.4 网际控制报文协议 ICMP"></a>4.4 网际控制报文协议 ICMP</h1><ul><li>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了<strong>网际控制报文协议 ICMP</strong>。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议，但不是高层协议，而是 IP 层的协议。ICMP 报文作为 IP 层数据报的数据部分，加上数据报的首部，组成 IP 数据报发送出去。ICMP 报文格式如图 4-27 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230731164920.png"></li></ol></li></ul><h2 id="4-4-1-ICMP-报文的种类"><a href="#4-4-1-ICMP-报文的种类" class="headerlink" title="4.4.1 ICMP 报文的种类"></a>4.4.1 ICMP 报文的种类</h2><ul><li>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</li><li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段，其长度取决于 ICMP 的类型。表 4-8 给出了几种常用的 ICMP 报文类型。</li><li>ICMP 报文的代码字段能进一步区分某种类型中的几种不同情况。检验和字段用来检验整个 ICMP 报文。IP 数据报首部的检验和并不检验 IP 数据报的内容 (检验首部)，因此不能保证经过传输的 ICMP 报文不产生差错。</li><li>表 4-8 给出的 ICMP 差错报告报文共有四种：<ol><li><strong>终点不可达</strong> 　当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li><li><strong>时间超过</strong> 　当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li><strong>参数问题</strong> 　当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li><strong>改变路由 (重定向)</strong> 　路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器 (可通过更好的路由)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230802183434.png"></li></ol></li><li>对改变路由报文进行解释。在互联网的主机中要有一个路由表，当主机要发送数据报时，首先查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由 (通过和其他路由器交换路由信息)。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器 R (而不是默认路由器)。</li><li>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式 (图 4-28)。把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段。再加上相应的 ICMP 差错报告报文的前 8 个字节，就构成了 ICMP 差错报告报文。提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号 (对于 TCP 和 UDP) 以及运输层报文的发送序号 (对于 TCP)。这些信息对源点通知高层协议是有用的。整个 ICMP报文作为 IP 数据报的数据字段发送给源点。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230802184415.png"></li></ol></li><li>下面是不应发送 ICMP 差错报告报文的几种情况：<ol><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报，都不发送 ICMP 差错报告报文。</li><li>对具有特殊地址 (如 127.0.0.0 或 0.0.0.0) 的数据报，不发送 ICMP 差错报告报文。</li></ol></li><li>常用的 ICMP 询问报文有两种，即：<ol><li><strong>回送请求和回答</strong> 　ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</li><li><strong>时间戳请求和回答</strong> 　ICMP 时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。****</li></ol></li></ul><h2 id="4-4-2-ICMP的应用举例"><a href="#4-4-2-ICMP的应用举例" class="headerlink" title="4.4.2 ICMP的应用举例"></a>4.4.2 ICMP的应用举例</h2><ul><li>ICMP 的一个重要应用是分组网间探测 <strong>PING</strong>，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的一个例子，没有通过运输层的 TCP 或 UDP。</li><li>另一个非常有用的应用是 traceroute (这是 UNIX 操作系统中名字)，它用来跟踪一个分组从源点到终点的路径。在 Windows 操作系统中这个命令是 tracert。</li></ul><h1 id="4-5-互联网的路由选择协议"><a href="#4-5-互联网的路由选择协议" class="headerlink" title="4.5 互联网的路由选择协议"></a>4.5 互联网的路由选择协议</h1><h2 id="4-5-1-有关路由选择协议的几个基本概念"><a href="#4-5-1-有关路由选择协议的几个基本概念" class="headerlink" title="4.5.1 有关路由选择协议的几个基本概念"></a>4.5.1 有关路由选择协议的几个基本概念</h2><ul><li><strong>理想的路由算法</strong><ol><li>路由选择协议的核心是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点：<ul><li><strong>算法必须是正确的和完整的</strong>。“正确”是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li><li><strong>算法在计算上应简单</strong>。路由选择的计算不应使网络通信量增加太多的额外开销。</li><li><strong>算法应能适应通信量和网络拓扑的变化</strong>，要有<strong>自适应性</strong>。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“<strong>稳健性</strong>“。</li><li><strong>算法应具有稳定性</strong>。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li><li><strong>算法应是公平的</strong>。路由选择算法应对所有用户 (除对少数优先级高的用户) 都是平等的。</li><li><strong>算法应是最佳的</strong>。路由选择算法应当能找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li></ul></li><li>路由选择是个复杂的问题，因为它是网络中的所有结点共同协调工作的结果。其次，路由选择的环境是不断变化的，这种变化无法事先知道，此外，当网络发生拥塞时，需要有能缓解拥塞的路由选择策略。</li><li>从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，有两大类：<ul><li><strong>静态路由选择策略</strong>，也称<strong>非自适应路由选择</strong><ol><li>特点：简单、开销小，但不能及时适应网络状态的变化。对于很简单的小网络，采用静态路由选择，用人工配置每一条路由。</li></ol></li><li><strong>动态路由选择策略</strong>，也称<strong>自适应路由选择</strong><ol><li>特点：能较好地适应网络状态的变化，实现起来较复杂，开销也较大。因此，动态路由选择适用于较复杂的大网络。</li></ol></li></ul></li></ol></li><li><strong>分层次的路由选择协议</strong><ol><li>互联网采用的路由选择协议主要是自适应的 (即动态的)、分布式路由选择协议。由于以下两个原因，互联网采用分层次的路由选择协议：<ul><li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li><li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。</li></ul></li><li>可以把整个互联网划分为许多较小的<strong>自治系统</strong>，一般记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</li><li>在目前的互联网中，一个 ISP 就是一个自治系统。互联网就把路由选择协议划分为两大类：<ul><li><strong>内部网关协议</strong> IGP　在一个自治系统内部使用的路由选择协议，与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li><li><strong>外部网关协议</strong> EGP　若源主机和目的主机处在不同的自治系统中 (这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，需要使用协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4 (BGP-4)。</li></ul></li><li>自治系统之间的路由选择叫做<strong>域间路由选择</strong>，自治系统内部的路由选择叫做<strong>域内路由选择</strong>。</li><li>图 4-31 是两个自治系统互连在一起的示意图。每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议 (例如，可以是 RIP，也可以是 OSPF)，但每个自治系统都有一个或多个路由器 (图中的路由器 R<sub>1</sub> 和 R<sub>2</sub>) ,除运行本系统的内部路由选择协议外，还要运行自治系统间的路由选择协议 (BGP-4)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230803100909.png"></li></ul></li></ol></li></ul><h2 id="4-5-2-内部网关协议-RIP"><a href="#4-5-2-内部网关协议-RIP" class="headerlink" title="4.5.2 内部网关协议 RIP"></a>4.5.2 内部网关协议 RIP</h2><ul><li><strong>工作原理</strong><ol><li>RIP 是内部网关协议 IGP 中最先广泛使用的协议，是一种分布式的<strong>基于距离向量的路由选择协议</strong>，是互联网的标准协议，最大优点是简单。</li><li>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录 (因此，这是<strong>一组距离</strong>，即“<strong>距离向量</strong>”)。</li><li>RIP 认为好的路由通过的路由器的数目少，即“距离短”。它允许一条路径最多只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。<strong>RIP 只适用于小型互联网</strong>。</li><li>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由 (即最短路由)，哪怕还存在另一条高速 (低时延) 但路由器较多的路由。</li><li>RIP协议的特点是：<ul><li><strong>仅和相邻路由器交换信息</strong>。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。</li><li>路由器交换的信息是<strong>当前本路由器所知道的全部信息，即自己现在的路由表</strong>。即：“我到本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器”。</li><li><strong>按固定的时间间隔</strong>交换路由信息，然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ul></li><li>路由器在<strong>刚刚开始工作时</strong>，它的路由表是空的。然后路由器就得出直接相连的几个网络的距离 (这些距离定义为 1)。接着，每一个路由器只和<strong>数目非常有限的</strong>相邻路由器交换并更新路由信息。经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 </li><li>在一般情况下，RIP 协议可以<strong>收敛</strong>，且过程较快。“收敛”是在自治系统中所有的结点都得到正确的路由选择信息的过程。</li><li>路由表中主要的信息是：到某个网络的距离 (即最短距离)，以及应经过的下一跳地址。路由表更新的原则是找出到每个目的网络的<strong>最短距离</strong>。这种更新算法又称为<strong>距离向量算法</strong>。</li></ol></li><li><strong>距离向量算法</strong><ol><li>对<strong>每一个相邻路由器</strong>发送过来的 RIP 报文，进行以下步骤：<ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的<strong>所有项目</strong> ：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。每一个项目都有三个关键数据，即：到目的网络 N，距离是 d，下一跳路由器是 X。</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：若原来的路由表中没有目的网络 N，则把该项目添加到路由表中。否则（即在路由表中有目的网络 N，这时就再查看下一跳路由器地址）若下一跳路由器地址是 X，则把收到的项目替换原路由表中的项目。否则（即这个项目是：到目的网络 N，但下一跳路由器不是 X）若收到的项目中的距离 d 小于路由表中的距离，则进行更新，否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为 16（距离为 16 表示不可达）。</li><li>返回。</li></ul></li><li>RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从<strong>每一个路由器到每一个目的网络的路由都是最短的</strong>。</li><li>所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表也应当是不同的。</li></ol></li><li><strong>RIP 协议的报文格式</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230803131532.png"></li><li>RIP 协议使用运输层的用户数据报 UDP 进行传送。</li><li>RIP 报文由首部和路由部分组成。</li><li>RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1 表示请求路由信息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为 0”是为了 4 字节字的对齐。</li><li>RIP 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。<strong>地址族标识符</strong> (地址类别) 字段用来标志所使用的地址协议。如采用 IP 地址就令这个字段的值为 2。<strong>路由标记</strong>填入<strong>自治系统号</strong> ASN，因为 RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个<strong>网络地址</strong>、该网络的<strong>子网掩码</strong>、<strong>下一跳路由器地址</strong>以及<strong>到此网络的距离</strong>。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4＋20×25＝504 字节。如超过，必须再用一个 RIP 报文来传送。</li><li>RIP 具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息 (20 字节) 的位置用作鉴别。这时应将地址族标识符置为全 1 (即 0xFFFF)，而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，这时最多只能再放入 24 个路由信息。</li><li>RIP 的问题是<strong>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器</strong>。网络出故障的传播时间往往需要较长的时间。这是 RIP 的主要缺点。</li><li>RIP 协议的优点是<strong>实现简单，开销小</strong>。</li><li>RIP 有很多缺点：RIP 限制了网络的规模，它能使用的最大距离为 15 (16 表示不可达)。其次，路由器之间交换的路由信息是路由器中的完整路由表，随着网络规模的扩大，开销也增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用 OSPF 协议。在规模较小的网络中，使用 RIP 协议。</li></ol></li></ul><h2 id="4-5-3-内部网关协议-OSPF"><a href="#4-5-3-内部网关协议-OSPF" class="headerlink" title="4.5.3 内部网关协议 OSPF"></a>4.5.3 内部网关协议 OSPF</h2><ul><li><strong>OSPF 协议的基本特点</strong><ol><li>协议的名字是<strong>开放最短路径优先</strong> OSPF，是为克服 RIP 的缺点开发出来的。</li><li>OSPF 只是一个协议的名字，<strong>并不表示其他的路由选择协议不是“最短路径优先”</strong>。所有的在自治系统内部使用的路由选择协议 (包括 RIP 协议) 都要寻找一条最短的路径。</li><li>OSPF 主要的特征是使用分布式的<strong>链路状态协议</strong>，不像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样：<ul><li>向本自治系统中<strong>所有路由器</strong>发送信息。使用的方法是<strong>洪泛法</strong>，就是路由器通过所有输出端口向所有相邻的路由器发送信息。每一个相邻路由器又再将此信息发往其所有的相邻路由器 (但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。RIP 协议仅仅向自己相邻的几个路由器发送信息。</li><li>发送的信息是与本路由器<strong>相邻的所有路由器的链路状态</strong>，但这只是路由器知道的<strong>部分信息</strong>。所谓“链路状态”就是说明本路由器和哪些路由器相邻，以及该链路的“<strong>度量</strong>”。度量用来表示费用、距离、时延、带宽等等。这些由网络管理人员决定，较灵活。有时为了方便就称度量为“<strong>代价</strong>”。对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。</li><li>只有当链路状态<strong>发生变化时</strong>，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li></ul></li><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库</strong>，这个数据库实际上是全网的拓扑结构图。</li><li>RIP 协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却<strong>不知道全网的拓扑结构</strong>。</li><li>OSPF 的<strong>更新过程收敛得快</strong>是其重要优点。</li><li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统划分为若干个更小的范围，叫做<strong>区域</strong>。图 4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符 (用点分十进制表示)。一个区域不能太大，在一个区域内的路由器最好不超过 200 个。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804152244.png"></li></ul></li><li>划分区域的好处是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做<strong>主干区域</strong>。主干区域的标识符规定为 0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息由<strong>区域边界路由器</strong>进行概括。在图 4-34 中，路由器 R<sub>3</sub>，R<sub>4</sub> 和 R<sub>7</sub> 都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫做<strong>主干路由器</strong>，如 R<sub>3</sub>，R<sub>4</sub>，R<sub>5</sub>，R<sub>6</sub> 和 R<sub>7</sub>。一个主干路由器可以同时是区域边界路由器，如 R<sub>3</sub>，R<sub>4</sub> 和 R<sub>7</sub>。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong> (如图中的 R<sub>6</sub>)。</li><li>采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复杂。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议能够用于规模很大的自治系统中。</li><li>OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong> (其 IP 数据报首部的协议字段值为 89)。OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li><li>OSPF 分组使用 24 字节的固定长度首部 (见图 4-35)，分组的数据部分可以是五种类型分组中的一种：<ul><li><strong>版本</strong> 　当前的版本号是 2。</li><li><strong>类型</strong> 　可以是五种类型分组中的一种。</li><li><strong>分组长度</strong> 　包括 OSPF 首部在内的分组长度，以字节为单位。</li><li><strong>路由器标识符</strong> 　标志发送该分组的路由器的接口的 IP 地址。</li><li><strong>区域标识符</strong> 　分组属于的区域的标识符。</li><li><strong>检验和</strong> 　用来检测分组中的差错。</li><li><strong>鉴别类型</strong> 　只有两种，0 (不用) 和1 (口令)。</li><li><strong>鉴别</strong> 　鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字符的口令。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804152901.png"></li></ul></li><li>除了以上的几个基本特点外，OSPF 还具有下列的一些特点：<ul><li>OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF <strong>对于不同类型的业务可计算出不同的路由</strong>。链路的代价可以是 1 至 65535 中的任何一个无量纲的数，因此十分灵活。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的<strong>负载平衡</strong>。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。</li><li>所有在 OSPF 路由器之间交换的分组 (例如，链路状态更新分组) 都具有鉴别的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</li><li>OSPF 支持可变长度的子网划分和无分类的编址 CIDR。</li><li>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过每 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复号。</li></ul></li></ol></li><li><strong>OSPF 的五种分组类型</strong><ol><li>OSPF 有五种分组类型：<ul><li><strong>类型 1，问候</strong>分组，用来发现和维持邻站的可达性。</li><li><strong>类型 2，数据库描述</strong>分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li><strong>类型 3，链路状态请求</strong>分组，向对方请求发送某些链路状态项目的详细信息。</li><li><strong>类型 4，链路状态更新</strong>分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是 OSPF 协议的核心部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有五种不同的链路状态。</li><li><strong>类型 5，链路状态确认</strong>分组，对链路更新分组的确认。</li></ul></li><li>OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要是指出有哪些路由器的链路状态信息 (以及其序号) 已经写入了数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。图 4-36 给出了 OSPF 的基本操作，说明了两个路由器需要交换各种类型的分组。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804153513.png"></li></ul></li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，与整个互联网的规模无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</li><li>OSPF 协议对多点接入的局域网采用了<strong>指定的路由器</strong>的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</li></ol></li></ul><h2 id="4-5-4-外部网关协议-BGP"><a href="#4-5-4-外部网关协议-BGP" class="headerlink" title="4.5.4 外部网关协议 BGP"></a>4.5.4 外部网关协议 BGP</h2><ul><li>内部网关协议主要是设法使数据报在一个 AS 中尽可能有效地从源站传送到目的站。</li><li>BGP 使用的环境不同，主要是因为以下原因：<ol><li><strong>互联网的规模太大，使得自治系统 AS 之间路由选择非常困难</strong>。</li><li><strong>自治系统 AS 之间的路由选择必须考虑有关策略</strong>。</li></ol></li><li>边界网关协议 BGP 力求寻找一条能够到达目的网络且比较好的路由，<strong>并非要寻找一条最佳路由</strong>。BGP 采用了<strong>路径向量路由选择协议</strong> ，它与距离向量协议 (如 RIP) 和链路状态协议 (如 OSPF) 都有很大的区别。</li><li>BGP 协议交换路由信息的结点数量级是<strong>自治系统个数</strong>的量级，比自治系统中的<strong>网络数</strong>少。</li><li>在 RFC 4271 中规定了 BGP-4 的四种报文：<ol><li>OPEN (打开) 报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。</li><li>UPDATE (更新) 报文，用来通告某一路由的信息，以及列出要撤销的多条路由。</li><li>KEEPALIVE (保活) 报文，用来周期性地证实邻站的连通性。</li><li>NOTIFICATION (通知) 报文，用来发送检测到的差错。</li></ol></li><li>图 4-41 给出了 BGP 报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度为 19 字节。通用首部为三个字段。<strong>标记</strong>字段为 16 字节长，用来鉴别收到的 BGP 报文。当不使用鉴别时，标记字段要置为全 1。<strong>长度</strong>字段指出包括通用首部在内的整个 BGP 报文以字节为单位的长度，最小值是 19，最大值是 4096。<strong>类型</strong>字段的值为 1 到 4，分别对应于上述四种 BGP 报文中的一种。<ol><li>OPEN <strong>报文</strong>共有 6 个字段，即<strong>版本</strong> (1 字节，现在的值是 4)、<strong>本自治系统号</strong> (2 字节，使用全球唯一的 16 位自治系统号，由 ICANN 地区登记机构分配)、<strong>保持时间</strong> (2 字节，以秒计算的保持为邻站关系的时间)、<strong>BGP 标识符</strong> (4 字节，通常就是该路由器的 IP 地址)、<strong>可选参数长</strong>(1 字节) 和<strong>可选参数</strong>。</li><li>UPDATE <strong>报文</strong>共有 5 个字段，即<strong>不可行路由长度</strong> (2 字节，指明下一个字段的长度)、<strong>撤销的路由</strong> (列出所有要撤销的路由)、<strong>路径属性总长度</strong> (2 字节，指明下一个字段的长度)、<strong>路径属性</strong> (定义在这个报文中增加的路径的属性) 和<strong>网络层可达性信息 NLRI</strong>。最后这个字段定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀。</li><li>KEEPALIVE <strong>报文</strong>只有 BGP 的 19 字节长的通用首部。</li><li>NOTIFICATION <strong>报文</strong>有 3 个字段，即差错代码 (1 字节)、差错子代码 (1 字节) 和差错数据 (给出有关差错的诊断信息)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804161110.png"></li></ol></li></ul><h2 id="4-5-5-路由器的构成"><a href="#4-5-5-路由器的构成" class="headerlink" title="4.5.5 路由器的构成"></a>4.5.5 路由器的构成</h2><ul><li><strong>路由器的结构</strong><ol><li>路由器是一种具有多个输入端口和多个输出端口的专用计算机，任务是转发分组。</li><li>典型的路由器的结构<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170016.png"></li><li>从图 4-42 可以看出，路由器结构可划分为两部分：<strong>路由选择</strong>部分和<strong>分组转发部分</strong>。</li><li>路由选择部分也叫<strong>控制部分</strong>，其核心构件是路由选择处理机。</li><li>分组转发由三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>。</li><li>交换结构又称为<strong>交换组织</strong>，作用是根据<strong>转发表</strong>对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中的网络”。</li><li>在图 4-42 中，路由器的输入和输出端口里面都各有三个方框，用方框中的 1，2 和 3 分别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。若接收到的分组是路由器之间交换路由信息的分组 (如 RIP 或 OSPF 分组等)，则把这种分组送交路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得出的结果，分组经过交换结构到达合适的输出端口。一个路由器的输入端口和输出端口安装在路由器的<strong>线路接口卡上</strong>。</li><li>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中 (如图 4-42 中的虚线箭头所示)。路由选择处理机负责对各转发表的副本进行更新。这些副本常称为“<strong>影子副本</strong>”。分散化交换可以避免在路由器中的某一点上出现瓶颈。</li></ul></li><li>输入端口对线路上收到的分组的处理<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170325.png"></li><li>当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个后到的分组必须在队列中排队等待，产生了一定的时延。图 4-43 给出了在输入端口的队列中排队的分组的示意图。</li></ul></li><li>输出端口把交换结构传送过来的分组发送到线路上<ul><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_networkSnipaste_2023-12-04_11-02-43.png"></li><li>观察在输出端口上的情况 (图 4-44 )。输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上是一个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</li></ul></li><li>分组在路由器的输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</li></ol></li><li><strong>交换结构</strong><ol><li>三种常用的交换方法<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170614.png"></li><li>最早的路由器：当路由器的某个输入端口收到一个分组时，用中断方式通知路由选择处理机。然后分组从输入端口复制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。</li><li>图 4-45 (a) 的示意图表示分组通过存储器进行交换。与早期的路由器的区别是，目的地址的查找和分组在存储器中的缓存是在输入端口中进行的。</li><li>图 4-45 (b) 是通过总线进行交换的示意图。数据报从输入端口通过共享的总线直接传送到合适的输出端口，不需要路由选择处理机的干预。由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线忙，则被阻塞不能通过交换结构，并在输入端口排队等待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品都采用这种通过总线的交换方式。</li><li>图4-45 (c) 是通过纵横交换结构进行交换。这种交换机构称为<strong>互连网络</strong>，它有 2<em>N</em> 条总线，可以使 <em>N</em> 个输入端口和 <em>N</em> 个输出端口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。但若该垂直总线已被占用 (有另一个分组正在转发到同一个输出端口)，则后到达的分组就被阻塞，必须在输入端口排队。</li></ul></li></ol></li></ul><h1 id="4-6-IPv6"><a href="#4-6-IPv6" class="headerlink" title="4.6 IPv6"></a>4.6 IPv6</h1><h2 id="4-6-1-IPv6-的基本首部"><a href="#4-6-1-IPv6-的基本首部" class="headerlink" title="4.6.1 IPv6 的基本首部"></a>4.6.1 IPv6 的基本首部</h2><ul><li>IPv6 支持无连接的传送，但将协议数据单元 PDU 称为<strong>分组</strong>，而不是 IPv4 的数据报。</li><li>IPv6 所引进的主要变化如下：<ol><li><strong>更大的地址空间</strong>。IPv6 把地址从 IPv4 的 32 位增大 4 倍，即增大到 128 位，使地址空间增大了2<sup>96</sup> 倍。这样大的地址空间在可预见的将来是不会用完的。</li><li><strong>扩展的地址层次结构</strong>。IPv6 由于地址空间很大，因此可以划分为更多的层次。</li><li><strong>灵活的首部格式</strong>。IPv6 数据报的首部和 IPv4 的并不兼容。IPv6 定义了许多可选的扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路由器对扩展首部不进行处理 (除逐跳扩展首部外)。</li><li><strong>改进的选项</strong>。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选项。但 IPv6 的<strong>首部长度是固定的</strong>，其选项放在有效载荷中。IPv4 所规定的选项是固定不变的，其选项放在首部的可变部分。</li><li><strong>允许协议继续扩充</strong>。因为技术总是在不断地发展而新的应用也还会出现。</li><li>支持即插即用 (即自动配置)。因此 IPv6 不需要使用 DHCP。</li><li><strong>支持资源的预分配</strong>。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。</li><li>IPv6 首部改为 8 <strong>字节对齐</strong> (即首部长度必须是 8 字节的整数倍)。原来的 IPv4 首部是 4 字节对齐。</li></ol></li><li>IPv6 数据报由两大部分组成，即<strong>基本首部和后面的有效载荷</strong>。有效载荷也称为净负荷。有效载荷允许有零个或多个<strong>扩展首部</strong>，再后面是数据部分 (图 4-46)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804173631.png"></li><li>与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：<ul><li>取消了首部长度字段，因为它的首部长度是固定的 (40 字节)。</li><li>取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。</li><li>取消了总长度字段，改用有效载荷长度字段。</li><li>取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。</li><li>把 TTL 字段改称为跳数限制字段，但作用是一样的。</li><li>取消了协议字段，改用下一个首部字段。</li><li>取消了检验和字段，加快了路由器处理数据报的速度。在数据链路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确传送到目的进程为止。因此在网络层的差错检测可以精简掉。</li><li>取消了选项字段，而用扩展首部来实现选项功能。</li></ul></li></ol></li><li>解释 IPv6 基本首部中各字段的作用 (参见图 4-47)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804173739.png"></li></ul><ol><li><strong>版本</strong>　占 4 位。它指明了协议的版本，IPv6 字段是 6。</li><li><strong>通信量类</strong>　占 8 位。这是为了区分不同的 IPv6 数据报的类别或优先级。</li><li><strong>流标号</strong>　占 20 位。IPv6 的一个新的机制是支持资源预分配，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流的抽象概念。所谓“流“<strong>是互联网络上从特定源点到特定终点 (单播或多播) 的一系列数据报 (如实时音频或视频传输)，“流”所经过的路径上的路由器都保证指明的服务质量</strong>。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频&#x2F;视频数据的传送有用。对于传统的电子邮件或非实时数据，流标号则没用，把它置为 0 即可。</li><li><strong>有效载荷长度</strong>　占 16 位。它指明 IPv6 数据报除基本首部以外的字节数 (所有扩展首部都算在有效载荷之内)。这个字段的最大值是 64KB (65535字节)。</li><li><strong>下一个首部</strong>　占 8 位。相当于 IPv4 的协议字段或可选字段。<ul><li>当 IPv6 数据报没有扩展首部时，下一个首部字段的作用和 IPv4 的协议字段一样，它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议 (例如：6 或17 分别表示应交付运输层 TCP 或 UDP)。</li><li>当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。</li></ul></li><li><strong>跳数限制</strong>　占 8 位。用来防止数据报在网络中无限期地存在。源点在每个数据报发出时即设定某个跳数限制 (最大为 255 跳)。每个路由器在转发数据报时，要先把跳数限制字段中的值减 1。当跳数限制的值为零时，就要把这个数据报丢弃。</li><li><strong>源地址</strong> 　占 128 位。是数据报的发送端的 IP 地址。</li><li><strong>目的地址</strong> 　占 128 位。是数据报的接收端的 IP 地址。</li></ol></li><li>IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，降低了路由器处理数据报的速度。然而实际上很多的选项在途中的路由器上是不需要检查的 (因为不需要使用这些选项的信息)。IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理，数据报途中经过的<strong>路由器都不处理这些扩展首部</strong> (只有一个首部例外，即逐跳选项扩展首部)，<strong>大大提高了路由器的处理效率</strong>。</li><li>在 RFC 2460 中定义了以下六种扩展首部：<ol><li>逐跳选项</li><li>路由选择</li><li>分片</li><li>鉴别</li><li>封装安全有效载荷</li><li>目的站选项</li></ol></li></ul><h2 id="4-6-2-IPv6-的地址"><a href="#4-6-2-IPv6-的地址" class="headerlink" title="4.6.2 IPv6 的地址"></a>4.6.2 IPv6 的地址</h2><ul><li>一个 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：<ol><li><strong>单播</strong>　单播是传统的点对点通信。</li><li><strong>多播</strong>　多播是一对多的通信，数据报发送到一组计算机中的每一个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li><li><strong>任播</strong>　IPv6 增加的一种类型。任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。</li></ol></li><li>IPv6 把实现 IPv6 的主机和路由器均称为<strong>结点</strong>。由于一个结点可能会使用多条链路与其他的一些结点相连，因此一个结点可能有多个与链路相连的接口。IPv6 给结点的每一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当作到达该结点的目的地址。</li><li>为了使地址再稍简洁些，IPv6 使用<strong>冒号十六进制记法</strong>，它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。</li><li>IPv6 的地址分类见表 4-10 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805093424.png"></li></ol></li><li>对表 4-10 所列举的几种地址简单解释如下。<ol><li><strong>未指明地址</strong> 　这是 16 字节的全 0 地址，可缩写为两个冒号“::”。这个地址不能用作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的 IP 地址。这类地址仅此一个。</li><li><strong>环回地址</strong> 　IPv6 的环回地址是 0:0:0:0:0:0:0:1，可缩写为 ::1。它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。</li><li><strong>多播地址</strong> 　功能和 IPv4 的一样。这类地址占 IPv6 地址总数的 1&#x2F;256。</li><li><strong>本地链路单播地址</strong>　有些单位的网络使用 TCP&#x2F;IP 协议，但<strong>并没有连接到互联网上</strong> 。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。这类地址占 IPv6 地址总数的 1&#x2F;1024。</li><li><strong>全球单播地址</strong> 　使用得最多的一类。IPv6 单播地址的划分方法非常灵活，可以如图 4-48 所示的任何一种。可把整个的 128 比特都作为一个结点的地址。也可用 <em>n</em> 比特作为子网前缀，用剩下的 (128–<em>n</em>) 比特作为接口标识符 (相当于 IPv4 的主机号)。当然也可以划分为三级，用 <em>n</em> 比特作为全球路由选择前缀，用 <em>m</em> 比特作为子网前缀，而用剩下的 (128–<em>n</em>–<em>m</em>) 比特作为接口标识符。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805093530.png"></li></ul></li></ol></li></ul><h2 id="4-6-3-从-IPv4-向-IPv6-过渡"><a href="#4-6-3-从-IPv4-向-IPv6-过渡" class="headerlink" title="4.6.3 从 IPv4 向 IPv6 过渡"></a>4.6.3 从 IPv4 向 IPv6 过渡</h2><ul><li><strong>双协议栈</strong><ol><li><strong>双协议栈</strong>是指在完全过渡到 IPv6 之前，使一部分主机 (或路由器) 装有双协议栈：一个 IPv4 和一个 IPv6。因此双协议栈主机 (或路由器) 既能够和 IPv6 的系统通信，又能够和 IPv4 的系统通信。双协议栈的主机 (或路由器) 记为 IPv6&#x2F;IPv4，表明它同时具有两种 IP 地址：一个 IPv6 地址和一个 IPv4 地址。</li></ol></li><li><strong>隧道技术</strong><ol><li>向 IPv6 过渡的另一种方法是<strong>隧道技术</strong>， 这种方法的要点是在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报。</li><li>要使双协议栈的主机知道 IPv4 数据报里面封装的数据是一个 IPv6 数据报，就必须把 IPv4 首部的协议字段的值设置为 41 (41 表示数据报的数据部分是 IPv6 数据报)。</li></ol></li></ul><h2 id="4-6-4-ICMPv6"><a href="#4-6-4-ICMPv6" class="headerlink" title="4.6.4 ICMPv6"></a>4.6.4 ICMPv6</h2><ul><li>和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数据报。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。</li><li>ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为 ICMPv6 报文，而把另一些报文定义为<strong>邻站发现</strong> ND 报文或<strong>多播听众交付</strong> MLD 报文。其实所有这些报文都是 ICMPv6 报文，只是功能和作用不同而已。</li></ul><h1 id="4-7-IP-多播"><a href="#4-7-IP-多播" class="headerlink" title="4.7 IP 多播"></a>4.7 IP 多播</h1><h2 id="4-7-1-IP-多播的基本概念"><a href="#4-7-1-IP-多播的基本概念" class="headerlink" title="4.7.1 IP 多播的基本概念"></a>4.7.1 IP 多播的基本概念</h2><ul><li>与单播相比，在一对多的通信中，多播可大大节约网络资源。图 4-53(a) 是视频服务器用单播方式向 90 台主机传送同样的视频节目。为此，需要发送 90 个单播，即同一个视频分组要发送 90 个副本。图 4-53(b) 是视频服务器用多播方式向属于同一个多播组的 90 个成员传送节目。这时，视频服务器只需把视频分组当作多播数据报来发送，并且<strong>只需发送一次</strong>。路由器 R<sub>1</sub> 在转发分组时，需要把收到的分组<strong>复制</strong>成 3 个副本，分别向 R<sub>2</sub>、R<sub>3</sub> 和 R<sub>4</sub> 各转发 1个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此<strong>不需要复制分组</strong>，在局域网上的多播组成员都能收到这个视频分组。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805150914.png"></li></ol></li><li>当多播组的主机数很大时 (如成千上万个)，多播明显地减轻网络中各种资源的消耗。在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件。能够运行多播协议的路由器称为<strong>多播路由器</strong>。多播路由器当然也可以转发普通的单播 IP 数据报。</li><li>在互联网上进行多播叫做 <strong>IP 多播</strong>。IP 多播所传送的分组需要使用多播 IP 地址。</li><li>多播数据报的目的地址不能写入主机的 IP 地址。因为在同一时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入如此多的主机 IP 地址。目的地址写入的是多播组的标识符，然后设法让加入到这个多播组的主机 IP 地址与多播组的标识符关联起来。</li><li><strong>多播地址只能用于目的地址，不能用于源地址</strong>。此外，对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，永远不会收到响应。</li><li>IP 多播可以分为两种。一种是在本地局域网上进行硬件多播，另一种是在互联网上进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付多播组的所有成员。</li></ul><h2 id="4-7-2-在局域网上进行硬件多播"><a href="#4-7-2-在局域网上进行硬件多播" class="headerlink" title="4.7.2 在局域网上进行硬件多播"></a>4.7.2 在局域网上进行硬件多播</h2><h2 id="4-7-3-网际组管理协议-IGMP-和多播路由选择协议"><a href="#4-7-3-网际组管理协议-IGMP-和多播路由选择协议" class="headerlink" title="4.7.3 网际组管理协议 IGMP 和多播路由选择协议"></a>4.7.3 网际组管理协议 IGMP 和多播路由选择协议</h2><ul><li><strong>IP 多播需要两种协议</strong><ol><li>图 4-55 是在互联网上传送多播数据报的例子。图中标有 IP 地址的四台主机都参加了一个多播组，其组地址是 226.15.37.123。显然，多播数据报应传送到路由器 R<sub>1</sub>，R<sub>2</sub> 和 R<sub>3</sub>，而不应传送到路由器 R<sub>4</sub>，因为与 R<sub>4</sub> 连接的局域网上现在没有这个多播组的成员。路由器需要用<strong>网际组管理协议</strong> IGMP 来识别多播组的成员信息。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806153909.png"></li><li>图 4-55 强调了 IGMP 的<strong>本地使用范围</strong> 。IGMP 并非在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上等等。IGMP 协议是让<strong>连接在本地局域网</strong>上的多播路由器知道<strong>本局域网上</strong>是否有主机 (严格讲，是主机上的某个进程) 参加或退出了某个多播组。</li></ul></li><li>仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员，需要使用<strong>多播路由选择协议</strong>。</li><li>**多播转发必须动态地适应多播组成员的变化 (这时网络拓扑并未发生变化)**。</li><li><strong>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址</strong>。</li><li><strong>多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络</strong>。</li></ol></li><li><strong>网际组管理协议 IGMP</strong><ol><li>和网际控制报文协议 ICMP 相似，IGMP 使用 IP 数据报传递其报文 (即 IGMP 报文加上 IP 首部构成 IP 数据报)，但它也向 IP 提供服务。因此，IGMP 不是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。</li><li>从概念上讲，IGMP 的工作可分为两个阶段：<ul><li>第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li><li>第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续当组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍没有一台主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li></ul></li><li>IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些具体措施如下：<ul><li>在主机和多播路由器之间的所有通信都是使用 IP 多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加 IP 多播的主机不会收到 IGMP 报文。</li><li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，不需要对每一个组都发送询问报文。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。</li><li>在 IGMP 的询问报文中有一个数值 <em>N</em>，它指明一个最长响应时间。当收到询问时，主机在 0 到 <em>N</em> 之间随机选择发送响应所需经过的时延。因此，若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。</li><li>同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。</li></ul></li><li>多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据报使用硬件多播。多播路由器只需要知道网络上是否至少还有一台主机是本组成员即可。实际上，对询问报文每一个组只需有一台主机发送响应。</li><li>如果一台主机上有多个进程都加入了某个多播组，那么这台主机对发给这个多播组的每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。</li></ol></li><li><strong>多播路由选择协议</strong><ol><li>多播路由选择实际上就是要找出以源主机为根节点的<strong>多播转发树</strong>。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据报，但在多播转发树上的路由器不会收到重复的多播数据报。</li><li>已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：<ul><li><strong>洪泛与剪除</strong>。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。一开始，路由器转发多播数据报使用洪泛的方法 (广播)。为了避免兜圈子，采用了叫做<strong>反向路径广播 RPB</strong> 的策略。RPB 的要点是：每一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进行这种检查很容易，只要从本路由器寻找到源点的最短路径上 (之所以叫做反向路径，因为在计算最短路径时把源点当作终点) 的第一个路由器是否是刚才把多播数据报送来的路由器。若是，就向所有其他方向转发刚才收到的多播数据报 (进入的方向除外)，否则就丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上 (也就是说，存在几条同样长度的最短路径)，那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。图 4-57 的例子说明了这一概念。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806161532.png"></li></ol></li><li><strong>隧道技术</strong>。隧道技术适用于多播组的位置在地理上很分散的情况。例如在图 4-58中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R<sub>1</sub> 和 R<sub>2</sub> 之间的网络并不支持多播，因而 R<sub>1</sub> 和 R<sub>2</sub> 不能按多播地址转发数据报。为此，路由器 R<sub>1</sub> 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的<strong>单播</strong>数据报，然后通过“<strong>隧道</strong>”从 R<sub>1</sub> 发送到 R<sub>2</sub> 。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806161545.png"></li></ol></li><li><strong>基于核心的发现技术</strong>。这种方法对于多播组的大小在较大范围内变化时都适合。对每一个多播组 G 指定一个<strong>核心路由器</strong>，给出它的 IP 单播地址。核心路由器创建出对应于多播组 G 的转发树。如果有一个路由器 R<sub>1</sub> 向这个核心路由器发送数据报，在途中经过的每一个路由器都要检查其内容。当数据报到达参加了多播组 G 的路由器 R<sub>2</sub> 时，R<sub>2</sub> 就处理这个数据报。如果 R<sub>1</sub> 发出的是一个多播数据报，其目的地址是 G 的组地址，R<sub>2</sub> 就向多播组 G 的成员转发这个多播数据报。如果 R<sub>1</sub> 发出的数据报是一个请求加入多播组 G 的数据报，R<sub>2</sub> 就把这个信息加到它的路由中，并用隧道技术向 R<sub>1</sub> 转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。</li></ul></li><li>使用的多播路由选择协议：<ul><li><strong>距离向量多播路由选择协议</strong> DVMRP 是在互联网上使用的第一个多播路由选择协议。它使用 DVMRP 在路由器之间传播路由信息。</li><li><strong>基于核心的转发树 CBT</strong>。这个协议使用核心路由器作为转发树的根节点。一个大的自治系统 AS 可划分为几个区域，每一个区域选择一个核心路由器。</li><li><strong>开放最短通路优先的多播扩展 MOSPF</strong>。这个协议是单播路由选择协议 OSPF 的扩充，使用于一个机构内。MOSPF 使用多播链路状态路由选择创建出基于源点的多播转发树。</li><li><strong>协议无关多播-稀疏方式 PIM-SM</strong>。这个协议使用和 CBT 同样的方法构成多播转发树。“协议无关”强调：虽然在建立多播转发树时是使用单播数据报来和远程路由器联系的，但这并不要求使用特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。</li><li><strong>协议无关多播-密集方式 PIM-DM</strong>。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。PIM-DM 不使用核心路由器，而是使用洪泛方式转发数据报。</li></ul></li></ol></li></ul><h1 id="4-8-虚拟专用网-VPN-和网络地址转换-NAT"><a href="#4-8-虚拟专用网-VPN-和网络地址转换-NAT" class="headerlink" title="4.8 虚拟专用网 VPN 和网络地址转换 NAT"></a>4.8 虚拟专用网 VPN 和网络地址转换 NAT</h1><h2 id="4-8-1-虚拟专用网-VPN"><a href="#4-8-1-虚拟专用网-VPN" class="headerlink" title="4.8.1 虚拟专用网 VPN"></a>4.8.1 虚拟专用网 VPN</h2><ul><li><strong>在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</strong>。RFC 6890 全面地给出了所有特殊用途的 IPv4 地址，但三个专用地址块的指派并无变化，即：<ol><li>10.0.0.0 到 10.255.255.255 (或记为 10.0.0.0&#x2F;8，它又称为 24 位块)</li><li>172.16.0.0 到 172.31.255.255 (或记为 172.16.0.0&#x2F;12，它又称为 20 位块)</li><li>192.168.0.0 到 192.168.255.255 (或记为 192.168.0.0&#x2F;16，它又称为 16 位块)</li></ol></li><li>有时一个机构的许多部门分布的范围很广，这些部门要互相交换信息，有两种方法：<ol><li>租用电信公司的通信线路为本机构专用。这种方法简单方便，但线租金高，一般难于承受。</li><li>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为<strong>虚拟专用网</strong> VPN。</li></ol></li><li>“专用网”是指为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信的网络。如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么<strong>所有通过互联网传送的数据都必须加密</strong>。</li><li>VPN 只是<strong>在效果上</strong>和专用网一样。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</li><li>由场所 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为<strong>内联网</strong>，表示场所 A 和 B 都属于同一个机构。</li><li>有时一个机构的 VPN 需要有某些<strong>外部机构</strong> (通常就是合作伙伴) 参加进来。这样的 VPN 就称为<strong>外联网</strong>。</li><li>还有一种类型的 VPN，是<strong>远程接入</strong> VPN。</li></ul><h2 id="4-8-2-网络地址转换-NAT"><a href="#4-8-2-网络地址转换-NAT" class="headerlink" title="4.8.2 网络地址转换 NAT"></a>4.8.2 网络地址转换 NAT</h2><ul><li>装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个有效的外部全球 IP 地址。</li><li>图 4-60 给出了 NAT 路由器的工作原理。在图中，专用网 192.168.0.0 内所有主机的 IP 地址都是本地 IP 地址 192.168.x.x。NAT 路由器至少要有一个全球 IP 地址，才能和互联网相连。图 4-60 表示出 NAT 路由器有一个全球 IP 地址 172.38.1.5。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806174735.png"></li></ol></li><li>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和互联网上的不同主机进行通信。</li><li>使用端口号的 NAT 也叫做<strong>网络地址与端口号转换</strong> NAPT，而不使用端口号的 NAT 就叫做传统的 NAT。</li></ul><h1 id="4-9-多协议标记交换-MPLS"><a href="#4-9-多协议标记交换-MPLS" class="headerlink" title="4.9 多协议标记交换 MPLS"></a>4.9 多协议标记交换 MPLS</h1><ul><li>MPLS 利用面向连接技术，使每个分组携带一个叫做<strong>标记</strong>的小整数。当分组到达交换机 (即标记交换路由器) 时，交换机读取分组的标记，并用标记值来检索分组转发表，比查找路由表来转发分组要快得多。</li><li>MPLS 常与<strong>异步传递方式</strong> ATM 联系起来，因为它们都采用了面向连接的工作方式。</li><li>MPLS 具有以下三个方面的特点：<ol><li>支持面向连接的服务质量。</li><li>支持流量工程，平衡网络负载。</li><li>有效地支持虚拟专用网 VPN。</li></ol></li></ul><h2 id="4-9-1-MPLS-的工作原理"><a href="#4-9-1-MPLS-的工作原理" class="headerlink" title="4.9.1 MPLS 的工作原理"></a>4.9.1 MPLS 的工作原理</h2><ul><li><strong>基本工作过程</strong><ol><li>在传统的 IP 网络中，分组每到达一个路由器，都必须查找路由表，并按照“最长前缀匹配”的原则找到下一跳的 IP 地址。当网络很大时，查找含有大量项目的路由表要花费很多的时间。在出现突发性的通信量时，往往还会使缓存溢出，引起分组丢失、传输时延增大和服务质量下降。</li><li>MPLS 的一个重要特点是在 MPLS 域的入口处，给每一个 IP 数据报打上固定长度“标记”，<strong>然后对打上标记的 IP 数据报用硬件进行转发</strong>，使 IP 数据报转发的过程大大加快。采用硬件技术对打上标记的 IP 数据报进行转发就称为<strong>标记交换</strong> 。“交换”也表示在转发时不再上升到第三层查找转发表，而是<strong>根据标记在第二层 (链路层) 用硬件进行转发</strong>。MPLS 可使用多种链路层协议，如 PPP、以太网、ATM 以及帧中继等。图 4-61是 MPLS 协议的基本原理的示意图。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175138.png"></li></ul></li><li>MPLS 域是指该域中有许多彼此相邻的路由器，并且所有的路由器都是支持 MPLS 技术的<strong>标记交换路由器</strong> LSR。LSR 同时具有标记交换和路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择功能构造转发表。</li><li>MPLS 的基本工作过程如下：<ul><li>MPLS 域中的各 LSR 使用专门的<strong>标记分配协议 LDP</strong> 交换报文，并找出和特定标记相对应的路径，即<strong>标记交换路径</strong> LSP。例如在图中的路径 A→B→C→D。各 LSR 根据这些路径构造出转发表。这个过程和路由器构造自己的路由表相似。MPLS 是面向连接的，因为在标记交换路径 LSP上 的第一个 LSR 就根据 IP 数据报的初始标记确定了整个的标记交换路径，就像一条虚连接一样。</li><li>当一个 IP 数据报进入到 MPLS 域时，MPLS <strong>入口结点</strong>就给它打上标记，并按照转发表把它转发给下一个 LSR。以后的所有 LSR 都按照标记进行转发；给 IP 数据报打标记的过程叫做<strong>分类</strong>。严格的<strong>第三层 (网络层) 分类</strong>只使用了 IP 首部中的字段，如源 IP 地址和目的 IP 地址等。大多数运营商实现了<strong>第四层 (运输层) 分类</strong>，而有些运营商则实现了<strong>第五层 (应用层) 分类</strong>。</li><li>在全网内统一分配全局标记数值是非常困难的，因此<strong>一个标记仅仅在两个标记交换路由器 LSR 之间才有意义</strong>。分组每经过一个 LSR，LSR 做两件事：一是转发，二是更换新的标记，即把<strong>入标记</strong>更换成为<strong>出标记</strong>。这就叫做<strong>标记对换</strong>。做这两件事所需的数据需要写在转发表中。例如，图 4-61 中的标记交换路由器 B 从入接口 0 收到一个入标记为 3 的 IP 数据报，查找了如下的转发表：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175430.png"></li></ol></li><li>当 IP 数据报离开 MPLS 域时，MPLS <strong>出口结点</strong>就把 MPLS 的标记去除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。</li></ul></li></ol></li><li><strong>转发等价类 FEC</strong><ol><li>MPLS 有个很重要的概念是<strong>转发等价类</strong> FEC。所谓“转发等价类”就是路由器<strong>按照同样方式对待</strong>的 IP 数据报的集合。这里“按照同样方式对待”表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等。FEC 的例子是：<ul><li>目的 IP 地址与某一个特定 IP 地址的前缀匹配的 IP 数据报；</li><li>所有源地址与目的地址都相同的 IP 数据报；</li><li>具有某种服务质量需求的 IP 数据报。</li></ul></li></ol></li></ul><h2 id="4-9-2-MPLS-首部的位置与格式"><a href="#4-9-2-MPLS-首部的位置与格式" class="headerlink" title="4.9.2 MPLS 首部的位置与格式"></a>4.9.2 MPLS 首部的位置与格式</h2><ul><li>MPLS 不要求下层的网络都使用面向连接的技术。因此一对 MPLS 路由器之间的物理连接，既可以由一个专用电路组成，如 OC-48 线路，也可以使用像以太网这样的网络。但是这些网络并不提供打标记的手段，而 IPv4 数据报首部也没有多余的位置存放 MPLS 标记。需要使用一种封装技术：在把 IP 数据报封装成以太网帧之前，先要插入一个 MPLS 首部。从层次的角度看，MPLS 首部就处在第二层和第三层之间 (图 4-63)。在把加上 MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为 8847 16 ，在多播的情况下为 8848 16 。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的 IP 数据报。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175802.png"></li></ol></li><li>图 4-64 给出了 MPLS 首部的格式。给 IP 数据报打上标记其实就是在以太网的帧首部和 IP 数据报的首部之间插入一个 4 字节的 MPLS 首部。具体的标记在“标记值”这个字段中。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175822.png"></li><li>MPLS 首部共包括以下四个字段：<ul><li><strong>标记值</strong> 　占 20 位。由于一个 MPLS 标记占 20 位，因此从理论上讲，在设置 MPLS 时可以使用标记的所有 20 位，因而可以同时容纳高达 2<sup>20</sup> 个流 (即 1048576 个流)。但是，实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管理和设置每条交换路径。</li><li><strong>试验</strong> 　占 3 位，目前保留用于试验。</li><li><strong>栈</strong> S　占 1 位，在有“标记栈”时使用。</li><li><strong>生存时间</strong> TTL　占 8 位，用来防止 MPLS 分组在 MPLS 域中兜圈子。</li></ul></li></ol></li></ul><h1 id="本章重要概念"><a href="#本章重要概念" class="headerlink" title="本章重要概念"></a>本章重要概念</h1><ul><li><p>TCP&#x2F;IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。</p></li><li><p>IP 网是虚拟的，因为从网络层上看，IP 网是一个统一的、抽象的网络。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统一的、抽象的 IP 地址处理主机之间的通信问题。</p></li><li><p>在互联网上的交付有两种：</p><ol><li>在本网络上的直接交付 (不经过路由器) </li><li>到其他网络的间接交付 (经过至少一个路由器，但最后一次一定是直接交付)。</li></ol></li><li><p>一个 IP 地址在整个互联网范围内是唯一的。分类的 IP 地址包括 A 类、B 类和 C 类地址 (单播地址)，以及 D 类地址 (多播地址)。E 类地址未使用。</p></li><li><p>分类的 IP 地址由网络号字段 (指明网络) 和主机号字段 (指明主机) 组成。网络号字段最前面的类别位指明 IP 地址的类别。</p></li><li><p>IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。</p></li><li><p>IP 地址标志一台主机 (或路由器) 和一条链路的接口。多归属主机同时连接到两个或更多的网络上。这样的主机同时具有两个或更多的 IP 地址，其网络号必须是不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。</p></li><li><p>用转发器或网桥连接起来的若干个局域网仍为一个网络。所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网) 都是平等的。</p></li><li><p>物理地址 (硬件地址) 是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，在数据链路层看不见数据报的 IP 地址。</p></li><li><p>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。一些长度可变的可选字段放在固定首部的后面。</p></li><li><p>IP 首部中的生存时间字段给出了 IP 数据报在互联网中所能经过的最大路由器数，可防止 IP 数据报在互联网中兜圈子。</p></li><li><p>地址解析协议 ARP 把 IP 地址解析为硬件地址，它解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。ARP 的高速缓存大大减少网络上的通信量。</p></li><li><p>在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。</p></li><li><p>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线“&#x2F;”，然后写上前缀所占的位数。前缀 (或网络前缀) 用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的IP地址组成一个“CIDR 地址块”。IP 地址的分配都以 CIDR 地址块为单位。</p></li><li><p>CIDR 的 32 位地址掩码 (或子网掩码) 由一串 1 和一串 0 组成，而 1 的个数就是前缀的长度。只要把 IP 地址和地址掩码逐位进行“逻辑与 (AND) ”运算，就很容易得出网络地址。A 类地址的默认地址掩码是 255.0.0.0。B 类地址的默认地址掩码是 255.255.0.0。C 类地址的默认地址掩码是 255.255.255.0。</p></li><li><p>路由聚合 (把许多前缀相同的地址用一个来代替) 有利于减少路由表中的项目，减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p></li><li><p>“转发”和“路由选择”不同。“转发”是单个路由器的动作。“路由选择”是许多路由器共同协作的过程，这些路由器相互交换信息，目的是生成路由表，再从路由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使用路由表这一名词。</p></li><li><p>自治系统 (AS) 是在单一的技术管理下的一组路由器。一个自治系统对其他自治系统表现出的是一个单一的和一致的路由选择策略。</p></li><li><p>路由选择协议有两大类：</p><ol><li>内部网关协议 (或自治系统内部的路由选择协议)，如 RIP 和 OSPF；</li><li>外部网关协议 (或自治系统之间的路由选择协议)，如 BGP-4。</li></ol></li><li><p>RIP 是分布式的基于距离向量的路由选择协议，适用于小型互联网，按固定的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器。</p></li><li><p>OSPF 是分布式的链路状态协议，适用于大型互联网，只在链路状态发生变化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路的“度量”。“度量”可表示费用、距离、时延、带宽等，统称为“代价”。所有的路由器最终都能建立一个全网的拓扑结构图。</p></li><li><p>BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP力求寻找一条能够到达目的网络 (可达) 且比较好的路由 (不兜圈子)，而并非要寻找一条最佳路由。</p></li><li><p>网际控制报文协议 ICMP 是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 并非为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p></li><li><p>ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。</p></li><li><p>要解决 IP 地址耗尽的问题，根本的办法是采用有更大地址空间的新版本 IP 协议，即 IPv6。</p></li><li><p>IPv6 所带来的主要变化是：</p><ol><li>更大的地址空间 (采用 128 位的地址)；</li><li>灵活的首部格式；</li><li>改进的选项；</li><li>支持即插即用；</li><li>支持资源的预分配；</li><li>IPv6 首部改为 8 字节对齐。</li></ol></li><li><p>IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。</p></li><li><p>IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。</p></li><li><p>IPv6 的地址使用冒号十六进制记法。</p></li><li><p>向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的 IPv6 系统能够向后兼容。向 IPv6 过渡可以使用双协议栈或使用隧道技术。</p></li><li><p>与单播相比，在一对多的通信中，IP 多播可大大节约网络资源。IP 多播使用 D 类 IP 地址。IP 多播需要使用网际组管理协议 IGMP 和多播路由选择协议。</p></li><li><p>虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体。VPN 内部使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都必须加密。</p></li><li><p>使用网络地址转换 NAT 技术，可以在专用网络内部使用专用 IP 地址，而仅在连接到互联网的路由器使用全球 IP 地址。这样就大大节约了宝贵的 IP 地址。</p></li><li><p>MPLS 的特点：</p><ol><li>支持面向连接的服务质量；</li><li>支持流量工程，平衡网络负载；</li><li>有效地支持虚拟专用网 VPN。</li></ol></li><li><p>MPLS 在入口结点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层 (链路层) 用硬件进行转发 (在标记交换路由器中进行标记对换)，因而转发速率大大加快。</p></li><li><p>子网划分为什么全0全1子网号不能使用？</p><blockquote><p>看看 RFC950 提到的原因：<br>假设我们有一个网络：192.168.0.0&#x2F;24，我们现在需要两个子网，那么按照 RFC950，应该使用使用两位子网号，即 &#x2F;26，得到两个可以使用的子网 192.168.0.64&#x2F;26 和 192.168.0.128&#x2F;26<br>对于主网络 192.168.0.0&#x2F;24，网络地址是192.168.0.0，广播地址是 192.168.0.255<br>对于子网 192.168.0.0&#x2F;26 (子网号全 0)，网络地址是 192.168.0.0，广播地址是 192.168.0.63<br>对于子网 192.168.0.64&#x2F;26，网络地址是 192.168.0.64，广播地址是 192.168.0.127<br>对于子网 192.168.0.128&#x2F;26，网络地址是 192.168.0.128，广播地址是 192.168.0.191<br>对于子网 192.168.0.192&#x2F;26 (子网号全1)，网络地址是 192.168.0.192，广播地址是 192.168.0.255</p><p>可以看出，对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。这样的重叠将导致极大的混乱。比如，一个发往192.168.0.255 的广播是发给主网络的还是子网的？这就是为什么在当时不建议使用全 0 和全 1 子网。</p></blockquote></li><li><p>IP, ARP, RARP, ICMP 协议的作用：</p><blockquote><p>网际协议 IP: 使用 IP 协议就可以把互连以后的计算机网络看成是一个虚拟互连网络。所谓虚拟互连网络也就是逻辑互连网络，或称为互联网。我们知道，各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用 IP 协议的虚拟互连网络可简称为 IP 网。使用 IP 网的好处是: 当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节 (如具体的编址方案、路由选择协议，等等)。<br>地址解析协议 ARP: 用来把一个机器 (主机或路由器) 的 IP 地址转换为相应的物理地址或硬件地址)。<br>逆地址解析协议 RARP: 和 ARP 相反，用来把一个机器 (主机或路由器)的物理地址 (或硬件地址) 转换为相应的 IP 地址。<br>网际控制报文协议 ICMP: 用来使主机或路由器报告差错情况和提供有关异常情况的报告，这样就可以更有效地转发 IP 数据报和提高交付成功的机会。</p></blockquote></li><li><p>IP 地址分为几类？各如何表示？IP 地址的主要特点是什么？</p><blockquote><p>在 IPv4 的地址中，所有的地址都是 32 位，并且可记为: IP 地址 ::&#x3D;&lt;网络号&gt;,主机号&gt;<br>IP 地址共分为五类:<br>A 类地址: 网络号字段为 1 字节，最前面的 1 位是 0<br>B 类地址: 网络号字段为 2 字节，最前面的 2 位是 10。<br>C 类地址: 网络号字段为 3 字节，最前面的 3 位是 110<br>D 类地址: 用于多播，最前面的 4 位是 1110。<br>E 类地址: 保留今后使用，最前面的 4 位是 1111。<br>IP 地址具有以下一些重要特点:<br>(1) 每一个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种分等级的地址结构。<br>(2) 实际上 IP 地址是标志一个主机(或路由器)和一条链路的接口。换言之，IP 地址并不仅仅指明一个主机，同时还指明了主机所连接到的网络。<br>(3) 按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连<br>(4) 在 IP 地址中，所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网) 都是平等的。</p></blockquote></li><li><p>IP 地址与硬件地址的区别，为什么使用两种不同的地址？</p><blockquote><p>从层次的角度看，物理地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址 (称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的)。<br>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的 IP 地址把这个复杂问题解决了。连接到互联网的主机只需拥有统一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便。当需要把 IP 地址转换为物理地址时，调用 ARP 的复杂过程都由计算机软件自动进行，而用户是看不见这种调用过程的。因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来很大的方便。</p></blockquote></li><li><p>IGP 和 EGP 这两类协议的主要区别？</p><blockquote><p>IGP 是内部网关协议，即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。EGP 是外部网关协议。若源主机和目的主机处在不同的自治系统中 (这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4 (BGP-4)。</p></blockquote></li><li><p>试简述 RIP, OSPF 和 BGP 路由选择协议的主要特点。</p><blockquote><p>RIP 是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大优点就是简单。RIP 协议的特点是:<br>(1) 仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。<br>(2) 路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。也就是说，交换的信息是:“我到本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器”。<br>(3) 按固定的时间间隔交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。<br>OSPF 最主要的特征就是使用分布式的链路状态协议。OSPF 协议的特点是:<br>(1) 向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法，这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。<br>(2) 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。<br>(3) 只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。<br>BGP 是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议。BGP 协议的主要特点是:<br>(1) BGP 在自治系统之问交换“可达性”信息 (即“可到达”或“不可到达”)。例如，告诉相邻路由器:“到达目的网络 N 可经过 AS<sub>x</sub>”<br>(2) 自治系统之间的路由选择必须考虑有关策略。<br>(3) BGP 只能是力求寻找一条能够到达目的网络且比较好的路由 (不能兜圈子)，而并非要寻找一条最佳路由。</p></blockquote></li><li><p>IGMP 协议的要点是什么？隧道技术在多播中是怎样使用的？</p><blockquote><p>IGMP 是网际组管理协议，它不是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。IGMP 并非是在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上，等等。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机 (严格讲，是主机上的某个进程) 参加或退出了某个多播组。显然，仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。<br>从概念上讲，IGMP的工作可分为两个阶段。<br>第一阶段: 当某个主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器<br>第二阶段: 组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一个主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。隧道技术适用于多播组的位置在地理上很分散的情况。例如在图 T-4-43 中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R<sub>1</sub> 和 R<sub>2</sub> 之间的网络并不支持多播，因而 R<sub>1</sub> 和 R<sub>2</sub>不能按多播地址转发数据报。为此，路由器 R<sub>1</sub> 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的单播数据报，然后通过“隧道”从 R<sub>1</sub> 发送到 R<sub>2</sub>。<br><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network20231217162537.png"><br>单播数据报到达路由器 R 后，再由路由器 R 剥去其首部，使它又恢复成原来的多播数据报，继续向多个目的站转发。</p></blockquote></li><li><p>VPN 的优缺点：</p><blockquote><p>优点是比专用网造价便宜，缺点是技术复杂，并且当进行加密通信时，需要更加安全的加密措施。</p></blockquote></li><li><p>什么是 NAT ？NAPT 有哪些特点？NAT 的优缺点有哪些？</p><blockquote><p>NAT 是网络地址转换。NAPT 是网络地址与端口号转换，是使用端口号的 NAT。<br>NAP 的优点是可以通过使用 NAT 路由器使专用网用户与互联网用户连接。缺点是通过 NAT 路由器的通信必须由专用网内的主机发起，另一个缺点是当 NAT 路由器只有一个全球 IP 地址时，专用网内部只能有一个主机接入互联网。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2023/12/09/shu-ju-lian-lu-ceng/"/>
      <url>/2023/12/09/shu-ju-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h1><ul><li>数据链路层属于计算机网络的低层。数据链路层使用的信道有以下两种类型：<ol><li><strong>点对点信道</strong>。使用一对一的点对点通信方式。</li><li><strong>广播信道</strong>。使用一对多的广播通信方式，过程复杂。广播信道上连接的主机很多，必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ol></li><li>本章重要的内容：<ol><li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议 (PPP 协议以及 CSMA&#x2F;CD 协议) 的特点。</li><li>数据链路层的三个基本问题：封装成帧、透明传输和差错检测。</li><li>以太网 MAC 层的硬件地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。</li></ol></li></ul><h2 id="3-1-1-数据链路和帧"><a href="#3-1-1-数据链路和帧" class="headerlink" title="3.1.1 数据链路和帧"></a>3.1.1 数据链路和帧</h2><ul><li><strong>链路</strong>是从一个结点<strong>到相邻结点</strong>的一段物理线路，中间没有其他的交换结点。在进行数据通信时，两台计算机之间的通信路径要经过许多段链路。链路只是一条路径的组成部分。</li><li>当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些通信协议控制数据的传输。把实现这些协议的硬件和软件加到链路上，构成了数据链路。常用的方法是使用<strong>网络适配器</strong>来实现协议。一般适配器都包括了数据链路层和物理层这两层的功能。</li><li>数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是 IP 数据报 (或简称为<strong>数据报、分组</strong>或<strong>包</strong>)。</li><li>点对点信道的数据链路层在进行通信时的主要步骤如下：<ol><li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。</li><li>结点 A 把封装好的帧发送给结点 B 的数据链路层。</li><li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。</li></ol></li><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network%7BB2EB60AE-6404-40b9-9EEA-BE05ACDFE73D%7D.png"></li></ul><h2 id="3-1-2-三个基本问腿"><a href="#3-1-2-三个基本问腿" class="headerlink" title="3.1.2 三个基本问腿"></a>3.1.2 三个基本问腿</h2><ul><li>数据链路层协议有多种，但有三个基本问题是共同的：<strong>封装成帧、透明传输和差错检测</strong>：<ol><li><strong>封装成帧</strong><ul><li><strong>封装成帧</strong>是在一段数据的前后添加首部和尾部，构成了一个帧。</li><li>帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。</li><li>首部和尾部的作用是进行<strong>帧定界</strong> (即确定帧的界限)。首部和尾部还包括许多控制信息。</li><li>为了提高帧的传输效率，应当使帧的<strong>数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元</strong>(MTU)。</li><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_networkSnipaste_2023-11-20_16-00-59.png"></li></ul></li><li><strong>透明传输</strong><ul><li>由于帧的开始和结束的标记使用指明的控制字符，因此，所传输的数据中任何 8 比特的组合不允许和用作帧定界的控制字符的比特编码一样，否则会出现帧定界的错误。</li><li>当传送的帧是用文本文件组成的帧时 (文本文件中的字符都是从键盘上输入的)，其数据部分不会出现像 SOH 或 EOT 这样的帧定界控制字符。不管从键盘上输入什么字符都可以放在这样的帧中传输过去，这样的传输就是透明传输。</li><li>当数据部分是非 ASCII 码的文本文件时 (如二进制代码的计算机程序或图像等)。如果数据中的某个字节的二进制代码和 SOH 或 EOT 这种控制字符一样 (见图 3-6)，数据链路层会<strong>错误地</strong>找到帧的边界，把部分帧收下，而把剩下的那部分数据丢弃。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711095956.png"></li></ol></li><li>解决透明传输问题，必须使<strong>数据中</strong>可能出现的控制字符 SOH 和 EOT 在接收端不被解释为控制字符。方法是：发送端的数据链路层在数据中出现控制字符的前面插入一个<strong>转义字符</strong> ESC。在接收端的数据链路层，在把数据送往网络层之前删除插入的转义字符。这被称为<strong>字节填充</strong>或<strong>字符填充</strong>。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。图 3-7 表示用字节填充法解决透明传输的问题。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711100111.png"></li></ol></li></ul></li><li><strong>差错检测</strong><ul><li>现实的通信链路不是理想的。比特在传输过程中可能会产生差错：1 可能变成 0，而 0 可能变成 1。这就叫做<strong>比特差错</strong>。比特差错是传输差错中的一种。</li><li>一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong> (BER)。</li><li>为保证数据传输的可靠性，在数据链路层广泛使用<strong>循环冗余检验</strong> (CRC) 的检错技术。</li><li>通过例子说明循环冗余检验的原理。<ol><li>在发送端，把数据划分为组，假定每组 <em>k</em> 个比特。待传送的数据 <em>M</em>＝101001 (<em>k</em>＝6)。CRC 运算就是在数据 <em>M</em> 的后面添加供差错检测用的 <em>n</em> 位<strong>冗余码</strong>，构成一个帧发送出去，一共发送 (<em>k</em> ＋ <em>n</em>) 位。在所要发送的数据后面增加 <em>n</em> 位的冗余码，虽然增大了数据传输的开销，但可以进行差错检测。</li><li>这 <em>n</em> 位冗余码可用以下方法得出。用二进制的<strong>模 2 运算</strong>进行 2<sup>n</sup> 乘 <em>M</em> 的运算，这相当于在 <em>M</em> 后面添加 <em>n</em> 个 0。得到的 (<em>k</em>＋<em>n</em>) 位的数除以收发双方事先商定的长度为 (<em>n</em>＋1) 位的除数 <em>P</em>，得出商是 <em>Q</em> 而余数是 <em>R</em> (<em>n</em> 位，比 <em>P</em> 少一位)。在图 3-8 所示的例子中，<em>M</em>＝101001 (即 <em>k</em>＝6)。假定除数 <em>P</em>＝1101 (即 <em>n</em>＝3)。经模 2 除法运算后的结果是：商 <em>Q</em>＝110101 (这个商并没有什么用处)，余数 <em>R</em>＝001。余数 <em>R</em> 作为冗余码拼接在数据 <em>M</em> 的后面发送出去。这种为了进行检错而添加的冗余码常称为<strong>帧检验序列</strong> (FCS)。因此加上 FCS 后发送的帧是 101001001，共有 (<em>k</em>＋<em>n</em>) 位。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711102631.png"></li></ol></li><li>循环冗余检验 CRC 和帧检验序列 FCS 并不是同一个概念。CRC 是一种<strong>检错方法</strong>，而 FCS 是添加在数据后面的<strong>冗余码</strong>，在检错方法上可选用 CRC，也可不选用 CRC。</li><li>在接收端对收到的每一帧经过 CRC 检验后，有两种情况：<ol><li>得出的余数 <em>R</em>＝0，判定这个帧没有差错，接受。</li><li>余数 <em>R</em>≠0，这个帧有差错 (但无法确定究竟是哪一位或哪几位出现了差错)，丢弃。</li></ol></li><li>用多项式来表示循环冗余检验过程。用多项式 <em>P</em>(<em>X</em>) ＝<em>X</em><sup>3</sup> ＋<em>X</em><sup>2</sup>＋1表示上面的除数 <em>P</em>＝1101 (最高位对应于 <em>X</em><sup>3</sup>，最低位对应于 <em>X</em><sup>0</sup>)。多项式 <em>P</em>(<em>X</em>) 称为<strong>生成多项式</strong>。现在广泛使用的生成多项式 <em>P</em>(<em>X</em>) 有以下几种：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711104339.png"></li></ol></li><li>在数据链路层，发送端帧检验序列 FCS 的生成和接收端的 CRC 检验都是用硬件完成的，处理很迅速，不会延误数据的传输。</li><li>在数据链路层若<strong>仅仅</strong>使用循环冗余检验 CRC 差错检测技术，只能做到对帧的<strong>无差错接受</strong>，即：“<strong>凡是接收端数据链路层接受的帧均无差错</strong>”。</li><li>传输差错分为两大类：<ol><li>最基本的比特差错</li><li>收到的帧并没有出现比特差错，却出现了<strong>帧丢失、帧重复</strong>或<strong>帧失序</strong>。例如，发送方连续传送三个帧：1，2，3。假定接收端收到的每一个帧都没有比特差错，但却出现下面的几种情况：<ul><li><strong>帧丢失</strong> ：收到 1，3 (丢失 2)。</li><li><strong>帧重复</strong> ：收到1，2，2，3 (收到两个2)。</li><li><strong>帧失序</strong> ：收到1，3，2 (后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样)。</li></ul></li></ol></li><li>现在的通信线路的质量大大提高，由通信链路质量不好引起差错的概率大大降低。现在互联网采取了区别对待的方法：<ol><li>对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议来完成。</li><li>对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</li></ol></li></ul></li></ol></li></ul><h1 id="3-2-点对点协议-PPP"><a href="#3-2-点对点协议-PPP" class="headerlink" title="3.2 点对点协议 PPP"></a>3.2 点对点协议 PPP</h1><ul><li>在通信线路质量较差的年代，使用可靠传输协议是种好办法，能实现可靠传输的<strong>高级数据链路控制</strong> (HDLC) 成为流行的数据链路层协议。对于点对点的链路，简单的<strong>点对点协议</strong> (PPP) 是目前使用得最广泛的数据链路层协议。</li></ul><h2 id="3-2-1-PPP-协议的特点"><a href="#3-2-1-PPP-协议的特点" class="headerlink" title="3.2.1 PPP 协议的特点"></a>3.2.1 PPP 协议的特点</h2><ul><li>PPP 协议是用户计算机和 ISP 进行通信时使用的数据链路层协议。</li><li><strong>PPP 协议应满足的需求</strong><ol><li><strong>简单</strong> 　在设计互联网体系结构时复杂的部分在 TCP 协议中，而网际协议 IP 比较简单，它提供的是不可靠的数据报服务。在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。</li><li><strong>封装成帧</strong> 　PPP 协议规定特殊的字符作为<strong>帧定界符</strong>，以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</li><li><strong>透明性</strong> 　PPP 协议保证数据传输的透明性。如果数据中碰巧出现了和帧定界符一样的比特组合时，要采取有效的措施来解决问题。</li><li><strong>多种网络层协议</strong> 　PPP 协议能够在<strong>在同一条物理链路上同时支持多种网络层协议</strong> (如 IP 和 IPX 等) 的运行。当点对点链路所连接的是局域网或路由器时，PPP 协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。</li><li><strong>多种类型链路</strong> 　除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。</li><li><strong>差错检测</strong> 　PPP 协议必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong>。若在数据链路层不进行差错检测，那么出现差错的无用帧还要在网络中继续向前转发，白白浪费许多的网络资源。</li><li><strong>检测连接状态</strong> 　PPP 协议必须具有一种能够及时自动检测出链路是否处于正常工作状态的机制。当出现故障的链路隔了一段时间后又重新恢复正常工作时，就需要这种及时检测功能。</li><li><strong>最大传送单元</strong> 　PPP 协议必须对每种类型的点对点链路设置<strong>最大传送单元</strong> MTU 的标准默认值，目的是为了促进各种实现之间的互操作性。如果高层协议发送的分组过长并超过 MTU 的数值，PPP 就要丢弃这样的帧，并返回差错。MTU 是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，<strong>不是帧的总长度</strong>。</li><li><strong>网络层地址协商</strong> 　PPP 协议必须提供一种机制使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址。协商的算法应尽可能简单，并且能够在所有的情况下得出协商结果。</li><li><strong>数据压缩协商</strong> 　PPP 协议必须提供一种方法来协商使用数据压缩算法。但 PPP 协议并不要求将数据压缩算法进行标准化。</li></ol></li><li><strong>PPP 协议的组成</strong><ol><li>一个将 IP 数据报封装到串行链路的方法。PPP 既支持异步链路，也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。</li><li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议</strong> (LCP)。</li><li>一套<strong>网络控制协议</strong> (NCP)，其中的每一个协议支持不同的网络层协议。</li></ol></li></ul><h2 id="3-2-2-PPP-协议的帧格式"><a href="#3-2-2-PPP-协议的帧格式" class="headerlink" title="3.2.2 PPP 协议的帧格式"></a>3.2.2 PPP 协议的帧格式</h2><ul><li><strong>各字段的意义</strong><ol><li>PPP 的帧格式如图 3-10 所示。PPP 帧的首部和尾部分别为四个字段和两个字段。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714175950.png"></li><li>首部的第一个字段和尾部的第二个字段都是标志字段 F (Flag)，规定为 0x7E (符号“0x”表示它后面的字符是用十六进制表示的。十六进制的 7E 的二进制表示是 01111110)。标志字段表示一个帧的开始或结束。因此标志字段就是 PPP 帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃；首部中的地址字段 A 规定为 0xFF (即 11111111)，控制字段 C 规定为 0x03 (即 00000011)。这两个字段并没有携带 PPP 帧的信息；PPP 首部的第四个字段是 2 字节的协议字段。当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。若为 0xC021，则信息字段是 PPP 链路控制协议 LCP 的数据，而 0x8021 表示这是网络层的控制数据；信息字段的长度是可变的，不超过 1500 字节；尾部中的第一个字段 (2 字节) 是使用 CRC 的帧检验序列 FCS。</li></ol></li><li><strong>字节填充</strong><ol><li>PPP 使用异步传输时，把转义符定义为 0x7D (即 01111101)，并使用<strong>字节填充</strong>，RFC 1662 规定了如下所述的填充方法：<ul><li>把信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D，0x5E)。</li><li>若信息字段中出现一个 0x7D 的字节 (即出现了和转义字符一样的比特组合)，则把 0x7D 转变成为 2 字节序列 (0x7D，0x5D)。</li></ul></li></ol></li><li><strong>零比特填充</strong><ol><li>PPP 协议用在 SONET&#x2F;SDH 链路时，使用同步传输 (一连串的比特连续传送) 而不是异步传输 (逐个字符地传送)。在这种情况下，PPP 协议采用零比特填充方法来实现透明传输。</li><li>零比特填充的做法是：在发送端，扫描整个信息字段。只要发现有 5 个连续 1，则立即填入一个 0。因此经过这种零比特填充后的数据，可以保证在信息字段中不会出现 6 个连续 1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除，以还原成原来的信息比特流 (图 3-11)。这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714180243.png"></li></ol></li></ul><h2 id="3-2-3-PPP-协议的工作状态"><a href="#3-2-3-PPP-协议的工作状态" class="headerlink" title="3.2.3 PPP 协议的工作状态"></a>3.2.3 PPP 协议的工作状态</h2><ul><li>当用户拨号接入 ISP 后，建立了一条从用户个人电脑到 ISP 的物理连接。这时，用户个人电脑向 ISP 发送一系列的链路控制协议 LCP 分组 (封装成多个 PPP 帧)，以便建立 LCP 连接。这些分组及其响应选择了将要使用的一些 PPP 参数。接着进行网络层配置，网络控制协议 NCP 为新接入的用户个人电脑分配一个临时的 IP 地址。用户个人电脑成为互联网上的一个有 IP 地址的主机；当用户通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放物理层的连接。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_RR12G7EOJ~98TROOF1YPF_Y.png"></li><li>PPP 链路的起始和终止状态永远是图 3-12 中的“<strong>链路静止</strong>”状态，这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接。</li><li>当用户个人电脑通过调制解调器呼叫路由器时，路由器能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP 进入“<strong>链路建立</strong>”状态，目的是建立链路层的 LCP 连接。</li><li>这时 LCP 开始协商<strong>配置选项</strong>，即发送 LCP 的<strong>配置请求帧</strong>。这是个 PPP 帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：<ul><li><strong>配置确认帧</strong>　所有选项都接受</li><li><strong>配置否认帧</strong>　所有选项都理解但不能接受。</li><li><strong>配置拒绝帧</strong>　选项有的无法识别或不能接受，需要协商。</li></ul></li><li>LCP 配置选项包括链路上的最大帧长、所使用的<strong>鉴别协议</strong>的规约，以及不使用 PPP 帧中的地址和控制字段。</li><li>协商结束后双方就建立了 LCP 链路，接着就进入“<strong>鉴别</strong>”状态。在这一状态，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用<strong>口令鉴别协议</strong> (PAP)，发起通信的一方需要发送身份标识符和口令。系统允许用户重试若干次。如果需要有更好的安全性，可使用更加复杂的<strong>口令握手鉴别协议</strong> (CHAP)。若鉴别身份失败，则转到“<strong>链路终止</strong>”状态。若鉴别成功，则进入“<strong>网络层协议</strong>”状态。</li><li>在“<strong>网络层协议</strong>”状态，PPP 链路两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。现在的路由器能同时支持多种网络层协议。PPP 协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个 PPP 协议进行通信。</li><li>如果在 PPP 链路上运行的是 IP 协议，则对 PPP 链路的每一端配置 IP 协议模块时要使用 NCP 中支持 IP 的协议——IP <strong>控制协议</strong> (IPCP)。IPCP 分组也封装成 PPP 帧 (其中的协议字段为 0x8021) 在 PPP 链路上传送。在低速链路上运行时，双方可以协商使用压缩的 TCP 和 IP 首部，以减少在链路上发送的比特数。</li><li>网络层配置完毕后，链路进入可进行数据通信的“<strong>链路打开</strong>”状态。链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可发送<strong>回送请求</strong> LCP 分组和<strong>回送回答</strong> LCP 分组，以检查链路的状态。</li><li>数据传输结束后，可以由链路的一端发出<strong>终止请求</strong> LCP 分组请求终止链路连接，在收到对方发来的<strong>终止确认</strong> LCP 分组后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，会从“<strong>链路打开</strong>”状态转到“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”状态。</li></ol></li></ul><h1 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h1><h2 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h2><ul><li>局域网按网络拓扑进行分类。图 3-13(a) 是<strong>星形网</strong> 。由于<strong>集线器</strong>的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了广泛的应用。图 3-13(b) 是<strong>环形网</strong> ，图 3-13(c) 为<strong>总线网</strong>，各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。总线网以传统以太网最为著名。局域网经过了四十年的发展，以太网已经在局域网市场中占据了绝对优势。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714234326.png"></li></ol></li><li>共享信道要着重考虑的一个问题是如何使众多用户能够合理而方便地共享通信媒体资源。在技术上有两种方法：<ol><li><strong>静态划分信道</strong>，如频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价高，不适合局域网使用。</li><li><strong>动态媒体接入控制</strong> ，又称<strong>多点接入</strong>，特点是信道并非在用户通信时固定分配给用户。分为两类：<ul><li><strong>随机接入</strong> 　特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，在共享媒体上会产生<strong>碰撞</strong> (即发生了<strong>冲突</strong>)，使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</li><li><strong>受控接入</strong> 　特点是用户不能随机地发送信息，必须服从控制。典型代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询</strong>，或称为<strong>轮询</strong>。</li></ul></li></ol></li><li><strong>以太网的两个标准</strong><ol><li>为了使数据链路层能更好地适应多种局域网标准，局域网的数据链路层又拆成两个子层，即<strong>逻辑链路控制</strong> (LLC) 子层和<strong>媒体接入控制</strong> (MAC) 子层。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230715094124.png"></li></ol></li><li><strong>适配器的作用</strong><ol><li>适配器的一个功能是：进行数据串行传输和并行传输的转换。</li><li>适配器所实现的功能包含了数据链路层及物理层这两个层次的功能。</li><li>计算机的硬件地址在适配器的 ROM 中，而软件地址——IP 地址，在计算机的存储器中。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230715095506.png"></li></ol></li></ul><h2 id="3-3-2-CSMA-CD-协议"><a href="#3-3-2-CSMA-CD-协议" class="headerlink" title="3.3.2 CSMA&#x2F;CD 协议"></a>3.3.2 CSMA&#x2F;CD 协议</h2><ul><li>局域网上的计算机被称为“<strong>主机</strong>”、“<strong>工作站</strong>”、“<strong>站点</strong>”或“<strong>站</strong>”。</li><li>为了通信的简便，以太网采取两种措施：<ol><li>采用灵活的<strong>无连接</strong>的工作方式，不必先建立连接，可以直接发送数据。适配器对发送的数据帧<strong>不进行编号，也不要求对方发回确</strong>。<strong>以太网提供的服务是尽最大努力的交付</strong>，即<strong>不可靠的交付</strong>。当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。<strong>对有差错帧是否需要重传则由高层来决定</strong>。例如，如果高层使用 TCP 协议，那么 TCP 就会发现丢失了一些数据。于是经过一定的时间后，TCP 就把这些数据重新传递给以太网进行重传。<strong>但以太网并不知道这是重传帧，而是当作新的数据帧来发送</strong>。</li><li>以太网发送的数据使用<strong>曼彻斯特编码</strong>的信号。二进制基带数字信号通常是高、低电压交替出现的信号。使用这种信号的问题是当出现一长串的连 1 或连 0 时，接收端就无法从收到的比特流中提取位同步 (即比特同步) 信号。如图 3-16 所示，曼彻斯特编码的编码方法是把每一个码元分成两个相等的间隔。码元 1 是前一个间隔为低电压而后一个间隔为高电压。码元 0 则正好相反，从高电压变到低电压 (也可采用相反的约定，即 1 是“前高后低”而 0 是“前低后高”)，保证了在每一个码元的正中间出现一次电压的转换，接收端利用这种电压的转换很方便地把位同步信号提取出来。缺点是它所占的频带宽度比原始的基带信号增加了一倍 (因为每秒传送的码元数加倍了)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716104158.png"></li></ul></li></ol></li><li>CSMA&#x2F;CD 协议的要点：<ol><li><strong>多点接入</strong>　　总线型网络，计算机以多点接入的方式连接在一根总线上。实质是”载波监听”和”碰撞检测”。</li><li><strong>载波监听</strong>　　用电子技术检测总线上有没有其他计算机也在发送。载波监听是检测信道。<strong>不管在发送前，还是在发送中，每个站都必须不停地检测信道</strong>。在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则暂时不发送数据，等到信道变为空闲时才发送。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。</li><li><strong>碰撞检测</strong>　　<strong>边发送边监听</strong>，即适配器边发送数据边检测信道上的信号电压的变化情况，以判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度会增大 (互相叠加)。当适配器检测到信号电压变化幅度超过门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，总线上传输的信号严重失真，无法从中恢复出有用的信息来。任何一个正在发送数据的站，一旦发现总线上出现了碰撞，其适配器要停止发送。“碰撞检测”也称为“<strong>冲突检测</strong>”。</li><li>因为电磁波在总线上以有限的速率传播，所以即使每个站在发送数据之前已经监听到信道为“<strong>空闲</strong>”，还会出现数据在总线上的碰撞。这和开会相似，一听见会场安静，我们就立即发言，但偶尔也会发生几个人同时抢着发言而产生冲突的情况。</li><li>图 3-17 所示的例子可以说明这种情况。设图中的局域网两端的站 A 和 B 相距 1km，用同轴电缆相连。<strong>电磁波在</strong> 1km <strong>电缆的传播时延约为</strong> 5µs。因此，A 向 B 发出的数据，在约 5µs 后才能传送到 B。 若在 A 发送的数据到达 B 前，B 也发送，则在某个时间和 A 发送的帧会发生碰撞。碰撞的结果是两个帧都变得无用。在局域网的分析中，常把总线上的<strong>单程端到端传播时延</strong>记为 τ。A 发送数据后，<strong>最迟要两倍的总线端到端的传播时延</strong> (2τ)，或总线的端到端往返传播时延才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延  (这两个站之间的距离最大) 为端到端传播时延。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716104615.png"><ul><li>下面是图 3-17 中的一些重要的时刻。<br> 在 <em>t</em>＝0 时，A 发送数据。B 检测到信道为空闲。<br> 在 <em>t</em>＝<em>τ−δ</em> 时，A 发送的数据还没有到达 B 时，由于 B 检测到信道是空闲的，因此 B 发送数据。<br> 经过时间 <em>δ</em>&#x2F;2 后，即在 <em>t</em>＝<em>τ−δ</em>&#x2F;2 时，A 发送的数据和 B 发送的数据发生了碰撞。但这时 A 和 B 都不知道发生了碰撞。<br> 在 <em>t</em>＝<em>τ</em>  时，B 检测到发生了碰撞，于是停止发送数据。<br> 在 <em>t</em>＝2<em>τ−δ</em> 时，A 也检测到发生了碰撞，因而也停止发送数据。<br> A 和 B 发送数据均失败，它们都要推迟一段时间再重新发送。</li><li><strong>每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性</strong>。这一小段时间是<strong>不确定的</strong>，它取决于另一个发送数据的站到本站的距离。因此，以太网<strong>不能保证</strong>某一时间之内一定能够把自己的数据帧成功地发送出去。这一特点称为<strong>发送的不确定性</strong>。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</li><li>从图 3-17 可看出，最先发送数据帧的 A 站，在发送数据帧后<strong>至多</strong>经过时间 2<em>τ</em> 就可知道所发送的数据帧是否遭受了碰撞。这就是 <em>δ</em>→0 的情况。因此以太网的端到端往返时间 2<em>τ</em> 称为<strong>争用期</strong>。争用期又称为<strong>碰撞窗口</strong>。因为一个站在发送完数据后，只有通过争用期的“考验”，即<strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。这时，就可以放心把这一帧数据顺利发送完毕。</li></ul></li><li>在使用 CSMA&#x2F;CD 协议时，一个站<strong>不能同时进行发送和接收 (但必须边发送边监听信道</strong>)，以太网不能进行全双工通信而只能进行**双向交替通信 (半双工通信)**。</li><li>以太网使用<strong>截断二进制指数退避</strong>算法确定碰撞后重传的时机。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后立即再发送数据，而是<strong>推迟</strong> (即退避 ) 一个随机的时间。因为如果几个发生碰撞的站都在监听信道，那么都会同时发现信道变成了空闲。如果大家都同时再重新发送，那么肯定又会发生碰撞。为了使各站进行重传时再次发生冲突的概率减小，具体的退避算法如下：<ul><li>协议规定了基本退避时间为争用期 2<em>τ</em>，具体的<strong>争用期时间是</strong> 51.2µs。对于 10Mbit&#x2F;s 以太网，在争用期内可发送 512bit，即 64 字节。也可以<strong>直接使用比特作为争用期的单位</strong>，争用期是 512bit，即发送 512bit 所需的时间。</li><li>从离散的整数集合［0，1，…，(2<em>k</em> −1)］中随机取出一个数，记为 <em>r</em>。重传应推后的时间就是 <em>r</em> 倍的争用期。参数 <em>k</em> 按下面的公式 (3-1) 计算：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716154602.png"></li><li>可见当重传次数不超过 10 时，参数 <em>k</em> 等于重传次数；但当重传次数超过 10 时，<em>k</em> 就等于 10。</li></ol></li><li>当重传达 16 次仍不能成功时，则丢弃该帧，并向高层报告。</li></ul></li><li>以太网在发送数据时，如果在争用期 (共发送了 64 字节) 没有发生碰撞，那么后续发送的数据就一定不会发生冲突。如果发生碰撞，一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节，因此<strong>凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧</strong>。只要收到了这种无效帧，就应当立即将其丢弃。</li><li><strong>强化碰撞</strong>是当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送 32 比特或 48 比特的<strong>人为干扰信号</strong>，以便让所有用户都知道现在已经发生了碰撞。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716154825.png"></li><li>A 站从发送数据开始到发现碰撞并停止发送的时间间隔是 *T<sub>B</sub>*。A 站得知碰撞已经发生时所发送的强化碰撞的干扰信号的持续时间是 <em>T<sub>J</sub></em> 。图中的 B 站在得知发生碰撞后，也要发送人为干扰信号。发生碰撞使 A浪费时间 <em>T<sub>B</sub></em> ＋ <em>T<sub>J</sub><em>。可是整个信道被占用的时间还要增加一个单程端到端的传播时延 t。因此总线被占用的时间是 <em>T<sub>B</sub></em> ＋</em>T<sub>J</sub></em> ＋τ。</li></ul></li><li>CSMA&#x2F;CD 协议的要点如下：<ul><li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须<strong>先检测信道</strong>。</li><li>检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲 (保证了帧间最小间隔)，就发送这个帧。</li><li>在发送过程中仍不停地检测信道，即网络适配器要<strong>边发送边监听</strong>。有两种可能性：<ol><li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 (1)。</li><li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 <em>r</em> 倍 512 比特时间后，返回到步骤(2)，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。</li></ol></li></ul></li></ol></li></ul><h2 id="3-3-3-使用集线器的星形拓扑"><a href="#3-3-3-使用集线器的星形拓扑" class="headerlink" title="3.3.3 使用集线器的星形拓扑"></a>3.3.3 使用集线器的星形拓扑</h2><ul><li>10BASE-T <strong>双绞线以太网的出现，是局域网发展史上的一个重要的里程碑</strong>，从此以太网的拓扑就从总线型变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。双绞线比无源电缆可靠、价格便宜且使用方便。</li><li>使双绞线能够传送高速数据的措施是把双绞线的绞合度做得非常精确。这样不仅可使特性阻抗均匀以减少失真，而且减少了电磁波辐射和无线电频率的干扰。</li><li>集线器的特点如下：<ol><li>从表面上看，使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一个传统以太网那样运行。<strong>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是 CSMA&#x2F;CD 协议</strong>。网络中的各站必须竞争对传输媒体的控制，并且在<strong>同一时刻至多只允许一个站发送数据</strong>。</li><li>一个集线器有许多<strong>接口</strong>，用两对双绞线与一台计算机上的适配器相连，很像一个<strong>多接口的转发器</strong>。</li><li><strong>集线器工作在物理层</strong>，它的每个接口仅仅<strong>简单地转发比特</strong>——收到 1 就转发 1，收到 0 就转发 0，<strong>不进行碰撞检测</strong>。若两个接口同时有信号输入 (即发生碰撞)，那么所有的接口都将收不到正确的帧。图 3-20 是具有三个接口的集线器的示意图。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716163035.png"></li></ul></li><li>集线器采用专门的芯片，进行自适应串音回波抵消。可使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰 (这种干扰即近端串音)。每个比特在转发之前还要进行再生整形并重新定时。</li></ol></li></ul><h2 id="3-3-4-以太网的信道利用率"><a href="#3-3-4-以太网的信道利用率" class="headerlink" title="3.3.4 以太网的信道利用率"></a>3.3.4 以太网的信道利用率</h2><ul><li>一个站在发送帧时出现了碰撞。经过一个争用期 2<em>τ</em> 后，可能又出现了碰撞，经过若干个争用期后发送成功。假定发送帧需要的时间是 *T<sub>0</sub>*。它等于帧长 (bit) 除以发送速率 (10Mbit&#x2F;s)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716221408.png"></li><li>成功发送一个帧需要占用信道的时间是 <em>T<sub>0</sub></em>+<em>τ</em>，比这个帧的发送时间要多一个单程端到端时延 <em>τ</em>。这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。在极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是 <em>τ</em>。因此，必须在经过时间 <em>T<sub>0</sub></em>+<em>τ</em> 后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</li><li>要提高以太网的信道利用率，就必须减小 <em>τ</em> 与 <em>T<sub>0</sub></em> 之比。在以太网中定义了参数 <em>a</em>，它是以太网<strong>单程端到端时延</strong> <em>τ</em> 与<strong>帧的发送时间</strong> <em>T<sub>0</sub></em> 之比：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716222853.png"></li><li>当 <em>a</em>→0 时，表示只要发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常少。反之，表明争用期所占的比例越大，使得每发生一次碰撞就浪费了不少的信道资源，信道利用率明显降低。因此，以太网的<strong>参数</strong> <em>a</em> <strong>的值应当尽可能小些</strong> 。这就要求分子 <em>τ</em> 的数值要小些，分母 <em>T<sub>0</sub></em> 的数值要大些。当数据率一定时，<strong>以太网的连线的长度受到限制</strong>，同时<strong>以太网的帧长不能太短</strong>。</li></ul></li><li>考虑一种<strong>理想化</strong>的情况。假定以太网上的各站发送数据都不会产生碰撞，并且能够有效地利用网络的传输资源，即总线一旦空闲就有某一个站立即发送数据。这样，发送一帧占用线路的时间是 <em>T<sub>0</sub></em> ＋<em>τ</em>，而帧本身的发送时间是 *T<sub>0</sub>*。于是我们可计算出极限信道利用率 <em>S<sub>max</sub></em> 为：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716225325.png"></li><li>虽然实际的以太网不可能有这样高的极限信道利用率，<strong>只有当参数</strong> <em>a</em> <strong>远小于 1 才能得到尽可能高的极限信道利用率</strong>。若参数 <em>a</em> 远大于1，则极限信道利用率就远小于 1，实际的信道利用率就更小了。据统计，当以太网的利用率达到 30％ 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</li></ul></li></ol></li></ul><h2 id="3-3-5-以太网的-MAC-层"><a href="#3-3-5-以太网的-MAC-层" class="headerlink" title="3.3.5 以太网的 MAC 层"></a>3.3.5 以太网的 MAC 层</h2><ul><li><strong>MAC 层的硬件地址</strong><ol><li>在局域网中，<strong>硬件地址</strong>又称<strong>物理地址</strong>或 <strong>MAC 地址</strong> (因为这种地址用在 MAC 帧中)。</li><li>在所有计算机系统的设计中，<strong>标识系统</strong>都是一个核心问题。在标识系统中，地址是识别某个系统的标识符。<ul><li><strong>名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处</strong>。</li><li><strong>严格地讲，名字与系统的所在地无关</strong>。就像我们每一个人的名字一样，不随我们所处的地点而改变。但是 IEEE 802 标准为局域网规定了一种 48 位的全球地址，是指局域网上的每一台计算机中<strong>固化在适配器的 ROM 中的地址</strong>。<ol><li>假定连接在局域网上的一台计算机的适配器坏了，我们更换了一个新的适配器，那么这台计算机的局域网的“地址”就改变了。</li><li>假定我们把位于南京的某局域网上的一台笔记本电脑携带到北京，并连接在北京的某局域网上。虽然这台电脑的地理位置改变了，但只要电脑中的适配器不变，那么该电脑在北京的局域网中的“地址”仍然和它在南京的局域网中的“地址”一样。</li></ol></li></ul></li><li>在生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM 中。因此，MAC 地址也叫做<strong>硬件地址</strong>或<strong>物理地址</strong>，实际上就是<strong>适配器地址</strong>或<strong>适配器标识符</strong> EUI-48。当这块适配器插入(或嵌入) 到某台计算机后，适配器上的标识符 EUI-48 就成为这台计算机的 MAC 地址了。</li><li>地址记法中有两种标准：<ul><li>第一种记法是把每一字节的<strong>最低位</strong>写在最左边 (最左边的最低位是第一位)。</li><li>第二种记法是把每一字节的<strong>最高位</strong>写在最左边 (最左边的最高位是第一位)。</li><li>在发送数据时，两种记法都是按照字节的顺序发送，但每一个字节中先发送哪一位则不同：第一种记法先发送最低位，第二种记法先发送最高位。</li></ul></li><li>适配器有<strong>过滤功能</strong>。但适配器从网络上每收到一个 MAC 帧就先用硬件检查 MAC 帧中的目的地址。如果是发往本站的帧，则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。这里“发往本站的帧”包括以下三种帧：<ul><li><strong>单播帧</strong> (一对一)，即收到的帧的 MAC 地址与本站的硬件地址相同。</li><li><strong>广播帧</strong> (一对全体)，即发送给本局域网上所有站点的帧 (全 1 地址)。</li><li><strong>多播帧</strong> (一对多)，即发送给本局域网上一部分站点的帧。</li></ul></li></ol></li><li><strong>MAC 帧的格式</strong><ol><li>常用的以太网 MAC 帧格式有两种标准，一种是 DIX Ethernet V2 标准 (即以太网 V2 标准)，另一种是 IEEE 的 802.3 标准。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717111013.png"></li></ul></li><li>以太网 V2 的 MAC 帧较为简单，由五个字段组成。前两个字段分别为 6 字节长的<strong>目的地址</strong>和<strong>源地址</strong>字段。第三个字段是 2 字节的<strong>类型字段</strong>，用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。第四个字段是<strong>数据字段</strong>，其长度在 46 到 1500 字节之间 (46 字节是这样得出的：最小长度 64 字节减去 18 字节的首部和尾部就得出数据字段的最小长度)。最后一个字段是 4 字节的<strong>帧检验序列</strong> FCS (使用 CRC 检验)。当传输媒体的误码率为 1×10<sup>−8</sup> 时，MAC 子层可使未检测到的差错小于 1×10<sup>−14</sup>。</li><li>为了接收端实现位同步，从 MAC 子层向下传到物理层时要在帧的前面插入 8 字节 (由硬件生成)，它由两个字段构成：<ul><li>7 个字节的<strong>前同步码</strong> (1 和 0 交替码)，作用是使接收端的适配器在接收 MAC 帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现位同步”。</li><li><strong>帧开始定界符</strong>，定义为 10101011。它的前六位的作用和前同步码一样，最后的两个连续的 1 就是告诉接收端适配器：“MAC 帧的信息马上就要来了，请适配器注意接收”。</li></ul></li><li>IEEE 802.3 标准规定凡出现下列情况之一的即为无效的 MAC 帧：<ul><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>收到的帧的 MAC 客户数据字段的长度不在 46～1500 字节之间。考虑到 MAC 帧首部和尾部的长度共有 18 字节，可以得出有效的 MAC 帧长度为 64～1518 字节之间。</li></ul></li></ol></li></ul><h1 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h1><h2 id="3-4-1-在物理层扩展以太网"><a href="#3-4-1-在物理层扩展以太网" class="headerlink" title="3.4.1 在物理层扩展以太网"></a>3.4.1 在物理层扩展以太网</h2><ul><li>扩展主机和集线器之间距离的一种方法是使用一对光纤和一对光纤调制解调器，如图 3-23 所示：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717223544.png"></li></ol></li><li>光纤调制解调器的作用是进行电信号和光信号的转换。光纤的时延小，带宽宽，使用这种方法可以使主机和几公里以外的集线器相连接。</li><li>如果使用多个集线器，可以连接成覆盖更大范围的多级星形结构的以太网。例如，一个学院的三个系各有一个 10BASE-T 以太网 (a)，可通过一个主干集线器把各系的以太网连接起来，成为一个更大的以太网 (b)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717223829.png"></li><li>有以下好处：<ul><li>使这个学院不同系的以太网上的计算机能够进行跨系的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ul></li><li>但这种多级结构的集线器以太网也带来了一些缺点：<ul><li>如图 (a) 所示的例子，在三个系的以太网互连起来之前，每一个系的以太网是一个独立的<strong>碰撞域</strong> (冲突域)，在任一时刻，在每一个碰撞域中只能有一个站在发送数据。每一个系的以太网的最大吞吐量是 10Mbit&#x2F;s，因此三个系总的最大吞吐量共有 30Mbit&#x2F;s。在三个系的以太网通过集线器互连起来后就把三个碰撞域变成一个碰撞域 (范围扩大到三个系)，如图 (b) 所示，而这时的最大吞吐量仍然是一个系的吞吐量 10Mbit&#x2F;s。这就是说，当某个系的两个站在通信时所传送的数据会通过所有的集线器进行转发，使得其他系的内部在这时都不能通信 (一发送数据就会碰撞)。</li><li>如果不同的系使用不同的以太网技术 (如数据率不同)，那么就不可能用集线器将它们互连起来。如果在图 3-24 中，一个系使用 10Mbit&#x2F;s 的适配器，而另外两个系使用10&#x2F;100Mbit&#x2F;s 的适配器，那么用集线器连接起来后，大家都只能工作在 10Mbit&#x2F;s 的速率。集线器基本上是个多接口的转发器，不能把帧进行缓存。</li></ul></li></ol></li></ul><h2 id="3-4-2-在数据链路层扩展以太网"><a href="#3-4-2-在数据链路层扩展以太网" class="headerlink" title="3.4.2 在数据链路层扩展以太网"></a>3.4.2 在数据链路层扩展以太网</h2><ul><li>使用<strong>网桥</strong>扩展以太网的方法在数据链路层进行。网桥对收到的帧根据其 MAC 帧的目的地址进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是根据此帧的目的 MAC 地址，查找网桥中的地址表，然后确定将该帧转发到哪一个接口，或者是把它丢弃。</li><li><strong>交换式集线器</strong>淘汰了网桥。交换式集线器称为以太网<strong>交换机</strong>或<strong>第二层交换机</strong>，强调这种交换机<strong>工作在数据链路层</strong>。</li><li><strong>以太网交换机的特点：</strong><ol><li>以太网交换机实质上是一个<strong>多接口的网桥</strong>，通常都有十几个或更多的接口，和工作在物理层的转发器、集线器有很大的差别。以太网交换机的每个接口都直接与一个单台主机或另一个以太网交换机相连，一般都在全双工方式。以太网交换机还具有并行性，能同时连通多对接口，使多对主机能同时通信 (而网桥只能一次分析和转发一个帧)。相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong>。</li><li>以太网交换机的接口有存储器，能在输出端口繁忙时把到来的帧进行缓存。如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的接口繁忙时，发送帧的这两台主机的接口会把收到的帧暂存一下，以后再发送出去。</li><li>以太网交换机是一种即插即用设备，其内部的帧<strong>交换表</strong> (地址表) 是通过自学习算法自动地逐渐建立起来的。以太网交换机由于使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</li><li>以太网交换机的性能远超普通的集线器，而且价格不贵。</li><li>以太网交换机都具有多种速率的接口，方便了各种不同情况的用户。</li></ol></li><li><strong>以太网交换机的自学习功能</strong><ol><li>假定在图 3-25 中的以太网交换机有 4 个接口，各连接一台计算机，其 MAC 地址分别是 A，B，C 和 D。在一开始，以太网交换机里面的交换表是空的 (a)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718171025.png"></li><li>A 先向 B 发送一帧，从接口 1 进入到交换机。交换机收到帧后，先查找交换表，没有查到应从哪个接口转发这个帧 (在 MAC 地址这一列中，找不到目的地址为 B 的项目)。接着，交换机把这个帧的源地址 A 和接口 1 写入交换表中，并向除接口 1 以外的所有接口广播这个帧。</li><li>C 和 D 丢弃这个帧，因为目的地址不对。B 收下这个帧。也称<strong>过滤</strong>。</li><li>从新写入交换表的项目 (A，1) 可以看出，以后不管从哪一个接口收到帧，只要其目的地址是 A，就应当把收到的帧从接口 1 转发出去。依据是：既然 A 发出的帧是从接口 1 进入到交换机的，那么从交换机的接口 1 转发出的帧也应可以到达 A。</li><li>假定接下来 B 通过接口 3 向 A 发送一帧。交换机查找交换表，发现交换表中的 MAC 地址有 A。表明要发送给 A 的帧 (即目的地址为 A 的帧) 应从接口 1 转发。于是就把这个帧传送到接口 1 转发给 A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的项目 (B，3)，表明今后如有发送给 B 的帧，就应当从接口 3 转发出去。</li><li>经过一段时间后，只要主机 C 和 D 也向其他主机发送帧，以太网交换机中的交换表就会把转发到 C 或 D 应当经过的接口号 (2 或 4) 写入到交换表中。这样，交换表中的项目就齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口。</li></ul></li><li>考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。用这样的方法保证交换表中的数据符合当前网络的实际状况。</li><li>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，非常方便。</li><li>为了增加网络的可靠性，在使用以太网交换机组网时，会增加一些冗余的链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子。用图 3-26 的例子来说明这个问题。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718172449.png"></li><li>在图3-26 中，假定一开始主机 A 通过接口交换机 #1 向主机 B 发送一帧。交换机 #1 收到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向：离开交换机 #1 的接口 3→ 交换机 #2 的接口 1→ 接口 2→ 交换机 #1 的接口 4→ 接口 3→ 交换机 #2 的接口 1→……。无限制地循环兜圈子下去，消耗网络资源。</li><li>为了解决这种兜圈子问题，制定了一个<strong>生成树协议</strong> STP。要点是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</li></ul></li></ol></li><li><strong>从总线以太网到星形以太网</strong><ol><li>随着以太网上站点数目的增多，总线结构以太网的可靠性下降。与此同时，大规模集成电路以及专用芯片的发展，使得星形结构的以太网交换机既便宜又可靠。在这种情况下，采用以太网交换机的星形结构成为首选拓扑，而传统的总线以太网也很快从市场上消失了。</li><li>总线以太网使用 CSMA&#x2F;CD 协议，以半双工方式工作。但以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA&#x2F;CD 协议，而是以全双工方式工作。以太网交换机的帧结构未改变，<strong>仍然采用以太网的帧结构</strong>。</li></ol></li></ul><h2 id="3-4-3-虚拟局域网"><a href="#3-4-3-虚拟局域网" class="headerlink" title="3.4.3 虚拟局域网"></a>3.4.3 虚拟局域网</h2><ul><li>虚拟局域网 VLAN 这样定义：虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，这些网段具有某些共同的需求。每一个 VLAN 的帧都有明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN。</li><li>虚拟局域网其实是局域网给用户提供的一种服务，并不是新型局域网。</li><li>图 3-27 画的是使用了四个交换机的网络拓扑。设有 10 台计算机分配在三个楼层中，构成了三个局域网，即: LAN<sub>1</sub>:  (A<sub>1</sub>，A<sub>2</sub>，B<sub>1</sub>，C<sub>1</sub>)，LAN<sub>2</sub>: (A<sub>3</sub>，B<sub>2</sub>，C<sub>2</sub>)，LAN<sub>3</sub>: (A<sub>4</sub>，B<sub>3</sub>，C<sub>3</sub>)；这 10 个用户划分为三个工作组，也就是说划分为三个虚拟局域网 VLAN。即: VLAN<sub>1</sub>: (A<sub>1</sub>，A<sub>2</sub>，A<sub>3</sub>，A<sub>4</sub>)，VLAN<sub>2</sub>: (B<sub>1</sub>，B<sub>2</sub>，B<sub>3</sub>)；VLAN<sub>3</sub>：(C<sub>1</sub>，C<sub>2</sub>，C<sub>3</sub>)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718180349.png"></li><li>从图 3-27 可看出，每一个 VLAN 的计算机可处在不同的局域网中，也可以不在同一层楼中。</li></ol></li></ul><h1 id="3-5-高速以太网"><a href="#3-5-高速以太网" class="headerlink" title="3.5 高速以太网"></a>3.5 高速以太网</h1><h2 id="3-5-1-100BASE-T-以太网"><a href="#3-5-1-100BASE-T-以太网" class="headerlink" title="3.5.1 100BASE-T 以太网"></a>3.5.1 100BASE-T 以太网</h2><ul><li>100BASE-T 是在双绞线上传送 100Mbit&#x2F;s 基带信号的星形拓扑以太网，CSMA&#x2F;CD 协议，它又称为<strong>快速以太网</strong>。</li><li>100BASE-T 可使用以太网交换机提供很好的服务质量，可在全双工方式下工作而无冲突发生。因此，CSMA&#x2F;CD 协议对全双工方式工作的快速以太网是不起作用的 (但在半双工方式工作时则一定要使用 CSMA&#x2F;CD 协议)。快速以太网使用的 MAC 帧格式仍然是 IEEE 802.3标准规定的帧格式。</li><li><strong>从细缆以太网升级到快速以太网的用户必须重新布线</strong>。</li></ul><h2 id="3-5-2-吉比特以太网"><a href="#3-5-2-吉比特以太网" class="headerlink" title="3.5.2 吉比特以太网"></a>3.5.2 吉比特以太网</h2><ul><li>吉比特以太网的标准 IEEE 802.3z 有以下特点：<ol><li>允许在 1Gbit&#x2F;s 下以全双工和半双工两种方式工作。</li><li>使用 IEEE 802.3 协议规定的帧格式。</li><li>在半双工方式下使用 CSMA&#x2F;CD 协议，而在全双工方式不使用 CSMA&#x2F;CD 协议。</li><li>与 10BASE-T 和 100BASE-T 技术向后兼容。</li></ol></li><li>吉比特以太网的物理层使用两种成熟的技术：<ol><li>来自现有的以太网。</li><li>美国国家标准协会 ANSI 制定的<strong>光纤通道</strong>，采用成熟技术就能大大缩短吉比特以太网标准的开发时间。</li></ol></li><li>吉比特以太网工作在半双工方式时，必须进行碰撞检测。由于数据率提高了，因此只有减小最大电缆长度或增大帧的最小长度，才能使参数 <em>a</em> 保持为较小的数值。若将吉比特以太网最大电缆长度减小到 10m，网络的实际价值就大大减小。而若将最短帧长提高到 640 字节，则在发送短数据时开销太大。因此，吉比特以太网仍然保持一个网段的最大长度为 100m，采用了<strong>载波延伸</strong>的办法，使最短帧长仍为 64 字节，同时将争用期增大为 512 字节。凡发送的 MAC 帧长不足 512 字节时，就用一些特殊字符填充在帧的后面，使 MAC 帧的发送长度增大到 512 字节，这对有效载荷并无影响。接收端在收到以太网的 MAC 帧后，要把所填充的特殊字符删除后才向高层交付。当原来仅 64 字节长的短帧填充到 512 字节时，所填充的 448 字节就造成了很大的开销。为此，吉比特以太网还增加了一种功能称为<strong>分组突发</strong>。这就是当很多短帧要发送时，第一个短帧要采用上面所说的载波延伸的方法进行填充。但随后的一些短帧则可一个接一个地发送，它们之间只需留有必要的帧间最小间隔即可。这样就形成一串分组的突发，直到达到 1500 字节或稍多一些为止。当吉比特以太网工作在全双工方式时 (即通信双方可同时进行发送和接收数据)，不使用载波延伸和分组突发。</li></ul><h2 id="3-5-3-10-吉比特以太网"><a href="#3-5-3-10-吉比特以太网" class="headerlink" title="3.5.3 10 吉比特以太网"></a>3.5.3 10 吉比特以太网</h2><ul><li>10GE 的帧格式与 10Mbit&#x2F;s，100Mbit&#x2F;s 和 1Gbit&#x2F;s 以太网的<strong>帧格式完全相同</strong>，并保留了 802.3 标准规定的<strong>以太网最小帧长和最大帧长</strong>。使用户在将其已有的以太网进行升级时，仍能和较低速率的以太网很方便地通信。</li><li>10GE <strong>只工作在全双工方式，不存在争用问题，也不使用</strong> CSMA&#x2F;CD <strong>协议</strong>。使得 10GE 的传输距离大大提高了 (因为不再受必须进行碰撞检测的限制)。</li><li>现在以太网的工作范围已经从局域网 (校园网、企业网) 扩大到城域网和广域网，从而实现了端到端的以太网传输。这种工作方式的好处是：<ol><li>以太网是一种经过实践证明的成熟技术，无论是互联网服务提供者 ISP 还是端用户都愿意使用以太网。对 ISP 来说，使用以太网还需要在更大的范围进行试验。</li><li>以太网的互操作性很好，不同厂商生产的以太网都能可靠地进行互操作。</li><li>在广域网中使用以太网时，价格大约只有同步光纤网 SONET 的五分之一和异步传递方式 ATM 的十分之一。以太网还能够适应多种传输媒体，如铜缆、双绞线以及各种光缆。使具有不同传输媒体的用户在进行通信时不必重新布线。</li><li>端到端的以太网连接使帧的格式全都是以太网的格式，而不需要再进行帧的格式转换，简化了操作和管理。但是，以太网和现有的其他网络，如帧中继或 ATM 网络，仍然需要有相应的接口才能进行互连。</li></ol></li><li>以太网从 10Mbit&#x2F;s 到 10Gbit&#x2F;s 甚至到 100Gbit&#x2F;s 的演进，证明了以太网是：<ol><li>可扩展的 (速率从 10Mbit&#x2F;s 到 100Gbit&#x2F;s)。</li><li>灵活的 (多种媒体、全&#x2F;半双工、共享&#x2F;交换)。</li><li>易于安装。</li><li>稳健性好。</li></ol></li></ul><h2 id="3-5-4-使用以太网进行宽带接入"><a href="#3-5-4-使用以太网进行宽带接入" class="headerlink" title="3.5.4 使用以太网进行宽带接入"></a>3.5.4 使用以太网进行宽带接入</h2><ul><li>以太网接入的一个重要特点是它可以提供双向的宽带通信，并且可以根据用户对带宽的需求灵活地进行带宽升级。当城域网和广域网都采用吉比特以太网或 10 吉比特以太网时，采用以太网接入可以实现端到端的以太网传输，中间不需要再进行帧格式的转换。提高了数据的传输效率且降低了传输的成本。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>链路是从一个结点到相邻结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件 (如网络适配器) 和软件 (如协议的实现)。</p></li><li><p>数据链路层使用的信道有点对点信道和广播信道两种。</p></li><li><p>数据链路层传送的协议数据单元是帧。数据链路层的三个基本问题则是：封装成帧、透明传输和差错检测。</p></li><li><p>循环冗余检验 CRC 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码。</p></li><li><p>点对点协议 PPP 是数据链路层使用最多的一种协议，它的特点是: </p><ol><li>简单；</li><li>只检测差错，而不是纠正差错；</li><li>不使用序号，也不进行流量控制；</li><li>可同时支持多种网络层协议。</li></ol></li><li><p>PPPoE 是为宽带上网的主机使用的链路层协议。</p></li><li><p>局域网的优点是：</p><ol><li>具有广播功能，从一个站点可很方便地访问全网；</li><li>便于系统的扩展和逐渐演变；提高了系统的可靠性、可用性和生存性。</li></ol></li><li><p>共享通信媒体资源的方法有两种: </p><ol><li>静态划分信道 (各种复用技术)；</li><li>动态媒体接入控制，又称为多点接入 (随机接入或受控接入)。</li></ol></li><li><p>IEEE 802  委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制 (LLC) 子层 (与传输媒体无关) 和媒体接入控制 (MAC) 子层 (与传输媒体有关) 。但现在 LLC 子层已成为历史。</p></li><li><p>计算机与外界局域网的通信要通过通信适配器 (网络适配器)，它又称为网络接口卡或网卡。计算机的硬件地址就在适配器的 ROM 中。</p></li><li><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做。</p></li><li><p>以太网采用的协议是具有冲突检测的载波监听多点接入 CSMA&#x2F;CD。协议的要点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。因此，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上各站点都平等地争用以太网信道。</p></li><li><p>传统的总线以太网基本上都是使用集线器的双绞线以太网。这种以太网在物理上是星形网，但在逻辑上则是总线形网。集线器工作在物理层，它的每个接口仅仅简单地转发比特，不进行碰撞检测。</p></li><li><p>以太网的硬件地址，即 MAC 地址实际上就是适配器地址或适配器标识符，与主机所在的地点无关。源地址和目的地址都是 48 位长。</p></li><li><p>以太网的适配器有过滤功能，它只接收单播帧、广播帧或多播帧。</p></li><li><p>使用集线器可以在物理层扩展以太网 (扩展后的以太网仍然是一个网络)。</p></li><li><p>交换式集线器常称为以太网交换机或第二层交换机 (工作在数据链路层)，是一个多接口的网桥，每个接口都直接与某台单主机或另一个集线器相连，且工作在全双工方式。以太网交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。</p></li><li><p>高速以太网有 100Mbit&#x2F;s 的快速以太网、吉比特以太网和 10Gbit&#x2F;s 的 10 吉比特以太网。最近还发展到 100 吉比特以太网。在宽带接入技术中，也常使用高速以太网进行接入。</p></li><li><p>数据链路层的三个基本问题 (封装成帧、透明传输和差错检测) 为什么都必须加以解决？</p><blockquote><p>封装成帧就是在一段数据的前后分别添加首部和尾(在首部和尾部里面有许多必要的控制信息)，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<br>所谓“透明传输”就是上层交下来的数据，不管是什么形式的比特组合，都必须能够正确传送。由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何比特组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。数据链路层不应当对要传送的数据提出限制，即不应当规定某种形式的比特组合不能够传送。<br>如果数据链路层没有差错检测，那么当目的主机收到其他主机发送来的数据时，在交给高层后，如果应用程序要求收到的数据必须正确无误，那么目的主机的高层软件可以对收到的数据进行差错检测。如果发现数据中有差错，就可以请求源主机重传这些数据。这样做就可以达到正确接收数据的目的。但这种工作方式有一个很大的缺点，就是一些在传输过程中出现了错误的数据 (请注意，这些已经是没有用处的数据) 还会继续在网络中传送，这样就浪费了网络的资源。例如，源主机到目的主机的路径中共有 20 个结点。在传送数据时，第一个结点就检测出了差错。如果数据链路层有差错检测的功能，就可以把这个有差错的帧丢弃以后就不再传送了。否则这个没有用处的帧还要在网络上继续传送，还要陆续通过后面的 19 个结点，这就造成了网络资源的浪费。</p></blockquote></li><li><p>局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</p><blockquote><p>局域网最主要的特点是: 网络为一个单位所拥有，且地理范围和站点数目均有限在局域网刚刚出现时，局域网比广域网具有更高的数据率、更低的时延和更小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率局域网的地理范围较小，且为一个单位所拥有，采用广播通信方式十分简单方便。但广域网的地理范围很大，如果采用广播通信方式势必造成通信资源的极大浪费，因此广域网不采用广播通信方式。</p></blockquote></li><li><p>说明 10BASE-T中的“10”“BASE”和“T”所代表的意思。</p><blockquote><p>“10”代表这种以太网具有 10 Mbit&#x2F;s 的数据率，BASE 表示连接线上的信号是基带信号，T 代表双绞线 (Twisted-pair)。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层</title>
      <link href="/2023/12/09/wu-li-ceng/"/>
      <url>/2023/12/09/wu-li-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h1><ul><li>物理层的作用是屏蔽掉传输媒体和通信手段的差异，使数据链路层感觉不到这些差异，只考虑如何完成本层的协议和服务，不考虑网络具体的传输媒体和通信手段是什么。</li><li>用于物理层的协议也常称为物理层<strong>规程</strong>。</li><li>将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：<ol><li><strong>机械特性</strong> 　指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。</li><li><strong>电气特性</strong> 　指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong> 　指明某条线上出现的某一电平的电压的意义。</li><li><strong>过程特性</strong> 　指明对于不同功能的各种可能事件的出现顺序。</li></ol></li><li>数据在计算机内部多采用并行输出方式。但数据在通信线路上的传输方式一般是<strong>串行传输</strong>，即逐个比特按照时间顺序传输。物理层还要完成传输方式的转换。</li></ul><h1 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h1><h2 id="2-2-1-数据通信系统的模型"><a href="#2-2-1-数据通信系统的模型" class="headerlink" title="2.2.1  数据通信系统的模型"></a>2.2.1  数据通信系统的模型</h2><ul><li>如图 2-1 所示，数据通信系统可划分为三大部分，即<strong>源系统</strong>、<strong>传输系统</strong>和<strong>目的系统</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230704174305.png"></li></ol></li><li>源系统包括两个部分：<ol><li><strong>源点</strong> 　源点设备产生要传输的数据。源点又称为<strong>源站</strong>，或<strong>信源</strong>。</li><li><strong>发送器</strong> 　通常源点生成的数字比特流要通过发送器编码后才能在传输系统中进行传输。典型的发送器就是调制器。</li></ol></li><li>目的系统也包括两个部分：<ol><li><strong>接收器</strong> 　接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器是解调器，它把来自传输线路上的模拟信号进行解调，提取出在发送端置入的消息，还原出发送端产生的数字比特流。</li><li><strong>终点</strong> 　终点设备从接收器获取传送来的数字比特流，然后把信息输出。终点又称为<strong>目的站</strong>，或<strong>信宿</strong>。</li></ol></li><li>在源系统和目的系统之间的传输系统可以是简单的传输线，也可以是连接在源系统和目的系统之间的复杂网络系统。</li><li>通信的目的是传送<strong>消息</strong>。如话音、文字、图像、视频等都是消息。<strong>数据</strong>是运送消息的实体。根据RFC 4949 给出的定义，数据是使用特定方式表示的信息，是有意义的符号序列。这种信息的表示可用计算机或其他机器处理或产生。<strong>信号</strong>则是数据的电气或电磁的表现。</li><li>根据信号中代表消息的参数的取值方式不同，信号分为两大类：<ol><li><strong>模拟信号</strong>，或<strong>连续信号</strong>——代表消息的参数的取值是连续的。例如在图 2-1中，用户家中的调制解调器到电话端局之间的用户线上传送的就是模拟信号。</li><li><strong>数字信号</strong>，或<strong>离散信号</strong>——代表消息的参数的取值是离散的。例如在图 2-1中，用户家中的计算机到调制解调器之间，或在电话网中继线上传送的就是数字信号。在使用时间域 (或简称为时域) 的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表 0 状态而另一种代表 1 状态。</li></ol></li></ul><h2 id="2-2-2-有关信道的几个基本概念"><a href="#2-2-2-有关信道的几个基本概念" class="headerlink" title="2.2.2 有关信道的几个基本概念"></a>2.2.2 有关信道的几个基本概念</h2><ul><li>信道用来表示向某一个方向传送信息的媒体。一条通信电路包含一条发送信道和一条接收信道。</li><li>从通信的双方信息交互的方式来看，有三种基本方式：<ol><li><strong>单向通信</strong> 　又称为<strong>单工通信</strong>，只有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信</strong> 　又称为<strong>半双工通信</strong>，通信的双方都可以发送信息，但不能同时发送。这种通信方式是一方发送另一方接收，过一段时间后可以再反过来。</li><li><strong>双向同时通信</strong> 　又称为<strong>全双工通信</strong>，通信的双方可以同时发送和接收信息。</li></ol></li><li>单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道 (每个方向各一条)。双向同时通信的传输效率最高。</li><li>来自信源的信号称为<strong>基带信号</strong>。计算机输出的代表各种文字或图像文件的数据信号就属于基带信号。基带信号包含有低频成分，甚至有直流成分，许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行<strong>调制</strong>。</li><li>调制可分为两大类。一类是对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号，这类调制称为<strong>基带调制</strong>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此把这种过程称为<strong>编码</strong>。另一类调制需要使用<strong>载波</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>，使用载波的调制称为<strong>带通调制</strong>。<ol><li><strong>常用编码方式</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222731.png"></li><li><strong>不归零制</strong> 　正电平代表 1，负电平代表 0。</li><li><strong>归零制</strong> 　正脉冲代表 1，负脉冲代表 0。</li><li><strong>曼彻斯特编码</strong> 　位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。</li><li><strong>差分曼彻斯特编码</strong> 　在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。</li><li>从信号波形中可以看出，曼彻斯特编码产生的信号频率比不归零制高。从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率 (这叫做没有自同步能力)，而曼彻斯特编码具有自同步能力。</li></ul></li><li><strong>基本的带通调制方法</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222830.png"></li><li><strong>调幅</strong> (AM)　载波的振幅随基带数字信号而变化。0 或 1 分别对应于无载波或有载波输出。</li><li><strong>调频</strong> (FM)　载波的频率随基带数字信号而变化。0 或 1 分别对应于频率 <em>f<sub>1</sub></em> 或 <em>f<sub>2</sub>。</em></li><li><strong>调相</strong> (PM)　载波的初始相位随基带数字信号而变化。0 或 1 分别对应于相位 0 度或 180度。</li><li>为了达到更高的信息传输速率，必须采用更复杂的多元制的振幅相位混合调制方法。例如，<strong>正交振幅调制</strong> QAM。</li></ul></li></ol></li></ul><h2 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h2><ul><li>数字通信的优点是：虽然信号在信道上传输时会不可避免地产生失真，但在接收端只要从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就没有影响。例如图 2-4(a) 表示信号通过实际的信道传输后虽然有失真，但在接收端可识别并恢复出原来的码元。图 2-4(b)信号失真严重，在接收端无法识别码元是 1 还是 0。码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形的失真就越严重。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222925.png"></li></ol></li><li>限制码元在信道上的传输速率的因素下两个：<ol><li><strong>信道能够通过的频率范围</strong><ul><li>信道所能通过的频率范围是有限的，信号中的许多高频分量不能通过信道。像图 2-4 所示的发送信号是一种矩形脉冲信号，包含很丰富的高频分量。如果信号中的高频分量在传输时受到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，每一个码元所占的时间界限也不再是很明确的，而是前后都拖了“尾巴”。这样，在接收端收到的信号波形就失去了码元之间的清晰界限。这种现象叫做<strong>码间串扰</strong>。严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。<strong>在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的识别成为不可能</strong> 。</li><li>信道的频带越宽，能够通过的信号高频分量越多，就可以用更高的速率传送码元而不出现码间串扰。</li></ul></li><li><strong>信噪比</strong><ul><li>噪声存在于所有的电子设备和通信信道中。由于噪声是随机产生的，它的瞬时值有时会很大，因此噪声会使接收端对码元的识别产生错误 (1 误判为 0 或 0 误判为 1)。噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。因此，信噪比很重要。所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为 S&#x2F;N，并用分贝 (dB) 作为度量单位。即：</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705223051.png"></li><li>香农公式指出：<strong>信道的极限信息传输速率</strong> <em>C</em> 是</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705223107.png"></li><li><em>W</em> 为信道的带宽（以 Hz 为单位）；<em>S</em> 为信道内所传信号的平均功率；<em>N</em> 为信道内部的高斯噪声功率。</li><li>香农公式表明，<strong>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高</strong>。香农公式的意义在于：只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</li><li>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，可以用编码的方法<strong>让每一个码元携带更多比特的信息量</strong>来提高信息的传输速率。</li></ul></li></ol></li></ul><h1 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h1><ul><li><strong>传输媒体</strong>也称为传输介质或传输媒介，是数据传输系统中在发送器和接收器之间的物理通路。</li><li>传输媒体分为两大类，<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。在导引型传输媒体中，电磁波被导引沿着固体媒体 (铜线或光纤) 传播，而非导引型传输媒体是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。图 2-5 是电信领域使用的电磁波的频谱。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706092821.png"></li></ul><h2 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1 导引型传输媒体"></a>2.3.1 导引型传输媒体</h2><ol><li><strong>双绞线</strong><ul><li>双绞线也称双扭线，把两根互相绝缘的铜导线并排放在一起，然后用规则的方法<strong>绞合</strong>就构成了双绞线。绞合可减少对相邻导线的电磁干扰。几乎所有的电话都用双绞线连接到电话交换机。从用户电话机到交换机的双绞线称为<strong>用户线</strong>或<strong>用户环路</strong>。</li><li>模拟传输和数字传输可以使用双绞线，通信距离一般为几到十几公里。距离太长时就要加放大器将衰减的信号放大到合适的数值 (对于模拟传输)，或者加上中继器对失真的数字信号进行整形 (对于数字传输)。导线越粗，其通信距离就越远，价格也越高。在数字传输时，若传输速率为每秒几个兆比特，则传输距离可达几公里。由于双绞线的价格便宜且性能也不错，因此使用十分广泛。</li><li>为了提高双绞线抗电磁干扰的能力，可在双绞线的外面加上一层用金属丝编织成的屏蔽层。这就是<strong>屏蔽双绞线</strong>，简称为 STP。它的价格比<strong>无屏蔽双绞线</strong> UTP 要高。图 2-6 是无屏蔽双绞线和屏蔽双绞线的示意图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706095419.png"></li></ol></li></ul></li><li><strong>同轴电缆</strong><ul><li>同轴电缆由内导体铜质芯线、绝缘层、网状编织的外导体屏蔽层以及保护塑料外层所组成 (图2-7)。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706095526.png"></li></ol></li></ul></li><li><strong>光缆</strong><ul><li>光纤通信就是利用光导纤维传递光脉冲来进行通信。有光脉冲相当于 1，没有光脉冲相当于 0。由于可见光的频率非常高，约为10<sup>8</sup> MHz 的量级，因此一个光纤通信系统的传输带宽大于目前其他各种传输媒体的带宽。</li><li>光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</li><li>光纤不仅具有通信容量大的优点，而且还有其他特点：<ol><li>传输损耗小，中继距离长，远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。这在有大电流脉冲干扰的环境下尤为重要。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。这在电缆管道拥塞不堪的情况下特别有利。</li></ol></li></ul></li></ol><h2 id="2-3-2-非导引型传输媒体"><a href="#2-3-2-非导引型传输媒体" class="headerlink" title="2.3.2 非导引型传输媒体"></a>2.3.2 非导引型传输媒体</h2><ol><li>短波通信 (高频通信) 靠电离层的反射。电离层的不稳定所产生的衰落现象和电离层反射所产生的多径效应，使得短波信道的通信质量较差。当必须使用短波无线电台传送数据时，一般是低速传输，即速率为一个标准模拟话路传几十至几百比特&#x2F;秒</li><li>无线电微波通信在数据通信中占有重要地位。微波在空间是直线传播。由于微波会穿透电离层进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。传统的微波通信有两种，即<strong>地面微波接力通信</strong>和<strong>卫星通信</strong>。<ol><li>微波接力通信可传输电话、电报、图像、数据等信息。<ul><li>特点：<ol><li>微波波段频率高，频段范围宽，通信信道的容量大。</li><li>工业干扰和天电干扰的频谱成分比微波频率低得多，对微波通信的危害比对短波和米波 (即甚高频) 通信小，因而微波传输质量高。</li><li>与相同容量和长度的电缆载波通信比较，微波接力通信建设投资少，见效快，易于跨越山区、江河。</li></ol></li><li>缺点：<ol><li>相邻站之间必须直视 (常称为视距 LOS)，不能有障碍物。有时一个天线发射出的信号会分成几条略有差别的路径到达接收天线，因而造成失真。</li><li>微波的传播会受恶劣气候的影响。</li><li>与电缆通信系统比较，微波通信的隐蔽性和保密性差。</li><li>中继站的使用和维护要耗费较多的人力和物力。</li></ol></li></ul></li><li>卫星通信的特点是通信距离远，且通信费用与通信距离无关。<ul><li>和微波接力通信相似，卫星通信的频带宽，通信容量大，信号受到的干扰小，通信稳定。</li><li>卫星通信的另一特点是有<strong>较大的传播时延</strong> 。</li><li>“卫星信道的传播时延较大”不等于“用卫星信道传送数据的时延较大”。因为传送数据的总时延除了传播时延外，还有发送时延、处理时延和排队时延等。传播时延在总时延中所占的比例有多大，取决于具体情况。但利用卫星信道进行交互式的网上游戏显然是不合适的。</li><li>卫星通信适合于广播通信，因为它的覆盖面很广。从安全方面考虑，卫星通信系统的保密性则相对较差。</li><li>卫星通信的费用较高。</li></ul></li></ol></li></ol><h1 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h1><h2 id="2-4-1-频分复用、时分复用和统计时分复用"><a href="#2-4-1-频分复用、时分复用和统计时分复用" class="headerlink" title="2.4.1 频分复用、时分复用和统计时分复用"></a>2.4.1 频分复用、时分复用和统计时分复用</h2><ul><li>图 2-13(a) 表示 A<sub>1</sub>，B<sub>1</sub> 和 C<sub>1</sub> 分别使用一个单独的信道进行通信，总共需要三个信道。如果在发送端使用一个复用器，它们可以合起来使用一个共享信道进行通信。在接收端使用分用器，把合起来传输的信息分别送到相应的终点。图 2-13(b) 是复用的示意图。复用要付出代价。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707095902.png"></li></ol></li><li>最基本的复用就是<strong>频分复用</strong> (FDM) 和<strong>时分复用</strong> (TDM)。<ol><li><strong>频分复用</strong><ul><li>频分复用最简单，其特点如图 2-14(a) 所示。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽资源</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707100801.png"></li><li>使用频分复用时，若每一个用户占用的带宽不变，则当复用的用户数增加时，复用后的信道的总带宽就跟着变宽。</li></ul></li><li><strong>时分复用</strong><ul><li>时分复用是将时间划分为一段段等长的时分复用帧 (TDM 帧)。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。在图 2-14(b) 中画出了 4 个用户 A，B，C 和 D。每一个用户所占用的时隙周期性地出现 (周期是 TDM 帧的长度）。因此 TDM 信号也称<strong>等时</strong>信号。<strong>时分复用的所有用户是在不同的时间占用同样的频带宽度</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707100841.png"></li><li>使用时分复用时，每一个时分复用帧的长度是不变的，始终是 125µs。若有 1000 个用户进行时分复用，则每一个用户分配到的时隙宽度就是 125µs 的千分之一，即 0.125µs，时隙宽度变得非常窄。</li></ul></li><li>这两种复用方法的优点是技术成熟，缺点是不灵活。时分复用则更有利于数字信号的传输。</li></ol></li><li>在进行通信时，<strong>复用器</strong>总和<strong>分用器</strong>成对地使用。在复用器和分用器之间是用户共享的高速信道。分用器的作用和复用器相反，把高速信道传送过来的数据进行分用，分别送交到相应的用户。</li></ul><h2 id="2-4-2-波分复用"><a href="#2-4-2-波分复用" class="headerlink" title="2.4.2 波分复用"></a>2.4.2 波分复用</h2><ul><li><strong>波分复用</strong> (WDM) 就是<strong>光的频分复用</strong>。</li><li><strong>光复用器</strong>：波分复用的复用器又称为<strong>合波器</strong>。</li><li><strong>光分用器</strong>：波分复用的分用器又称为<strong>分波器</strong>。</li><li>光信号传输了一段距离后会衰减，对衰减了的光信号进行放大才能继续传输。</li><li><strong>掺铒光纤放大器</strong> (EDFA)。不需要进行光电转换直接对光信号进行放大。</li></ul><h2 id="2-4-3-码分复用"><a href="#2-4-3-码分复用" class="headerlink" title="2.4.3 码分复用"></a>2.4.3 码分复用</h2><ul><li><strong>码分复用</strong> (CDM) 是一种共享信道的方法。也叫作<strong>码分多址</strong> (CDMA)。每个用户可在同样的时间使用同样的频带进行通信。由于<strong>各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰</strong>。码分复用发送的信号有很强的抗干扰能力，<strong>其频谱类似于白噪声，不易被发现</strong>。采用 CDMA 可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率。</li><li>在 CDMA 中，每个比特时间划分为 m 个短的间隔，称为<strong>码片</strong>。</li><li>使用 CDMA 的每个站被指派一个唯一的 m bit <strong>码片序列</strong>。一个站如果要发送比特 1，则发送它自己的 m bit 码片序列。如果要发送比特 0，则发送该码片序列的二进制反码。<ol><li>例如指派给 S 站的 8 bit 码片序列是 0001 1011。当 S 发送比特 1 时，它就发送序列 0001 1011，而当 S 发送比特 0 时，就发送 1110 0100。将码片中的 0 写为 – 1，将 1 写为＋1。因此 S 站的码片序列是 (–1 –1 –1＋1＋1 –1＋1＋1)。</li></ol></li><li>假定 S 站要发送信息的数据率为 b bit&#x2F;s。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit&#x2F;s，S 站所占用的频带宽度也提高到原来数值的 m 倍。这种通信方式是<strong>扩频</strong>通信中的一种。扩频通信有两类。<ol><li>一种是<strong>直接序列扩频</strong> (DSSS)，如码片序列。</li><li>另一种是<strong>跳频扩频</strong> (FHSS)。</li></ol></li><li>CDMA 系统的特点是这种体制给每个站分配的码片序列不仅必须各不相同，还必须互相<strong>正交</strong>。在实用的系统中使用<strong>伪随机码序列</strong>。</li><li>数学公式可清楚地表示码片序列的正交关系。令向量 <em><strong>S</strong></em> 表示站 S 的码片向量，再令 <em><strong>T</strong></em> 表示其他任何站的码片向量。两个不同站的码片序列正交，就是向量 <em><strong>S</strong></em> 和 <em><strong>T</strong></em> 的规格化<strong>内积</strong>都是 0：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230709160115.png"></li></ol></li><li>向量 <em><strong>S</strong></em> 为 (–1 –1 –1＋1＋1 –1＋1＋1)，同时设向量 <em><strong>T</strong></em> 为 (–1 –1＋1 –1＋1＋1＋1 –1)，相当于 T 站的码片序列为 00101110。将向量 <em><strong>S</strong></em> 和 <em><strong>T</strong></em> 的各分量值代入 (2-3) 式就可看出这两个码片序列是正交的。向量 <em><strong>S</strong></em> 和各站码片反码的向量的内积也是 0。任何一个码片向量和该码片向量自己的规格化内积都是 1。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230709160135.png"></li></ol></li></ul><h1 id="2-5-数字传输系统"><a href="#2-5-数字传输系统" class="headerlink" title="2.5 数字传输系统"></a>2.5 数字传输系统</h1><ul><li>早期的数字传输系统存在许多缺点，主要是以下两个：<ol><li><strong>速率标准不统一</strong>。多路复用的速率体系有两个互不兼容的国际标准，北美和日本的 T<sub>1</sub> 速率(1.544Mbit&#x2F;s) 和欧洲的 E<sub>1</sub> 速率 (2.048Mbit&#x2F;s)。</li><li><strong>不是同步传输</strong>。为了节约经费，各国的数字网主要采用<strong>准同步</strong>方式。在准同步系统中由于各支路信号的时钟频率有偏差，给时分复用和分用带来许多麻烦。当数据传输的速率很高时，收发双方的时钟同步就成大问题。</li></ol></li></ul><h1 id="2-6-宽带接入技术"><a href="#2-6-宽带接入技术" class="headerlink" title="2.6 宽带接入技术"></a>2.6 宽带接入技术</h1><h2 id="2-6-1-ADSL-技术"><a href="#2-6-1-ADSL-技术" class="headerlink" title="2.6.1 ADSL 技术"></a>2.6.1 ADSL 技术</h2><ul><li><strong>非对称数字用户线</strong> (ADSL) 技术是<strong>用数字技术对现有的模拟电话用户线进行改造</strong>，使它能承载宽带数字业务。    </li><li>ADSL 的传输距离取决于数据率和用户线的线径。ADSL 能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。<ol><li>用户线越细，信号传输时的衰减就越大。</li><li>传输速率越快，信号传输时的衰减就越大。</li></ol></li><li>基于ADSL 的接入网由三部分组成：<strong>数字用户线接入复用器</strong> DSLAM、用户线和用户家中的设施 (见图 2-20)。数字用户线接入复用器包括 ADSL 调制解调器。ADSL 调制解调器又称<strong>接入端接单元</strong> ATU。ADSL 调制解调器必须成对使用，因此把在电话端局 (或远端站) 和用户家中所用的 ADSL 调制解调器分别记为 ATU-C (C 代表<strong>端局</strong>) 和 ATU-R (R 代表<strong>远端</strong>)。用户电话通过电话<strong>分离器</strong>和 ATU-R 连在一起，经用户线到端局，并再经过电话分离器把电话连到本地电话交换机。电话分离器是无源的，它利用低通滤波器将电话信号与数字信号分开。将电话分离器做成无源的是为了在停电时不影响传统电话的使用。一个 DSLAM 可支持多达 500～1000 个用户。若按每户 6Mbit&#x2F;s 计算，则具有 1000 个端口的 DSLAM (这就需要用 1000 个 ATU-C) 应有高达 6Gbit&#x2F;s 的转发能力。ATU-C 要使用数字信号处理技术，因此 DSLAM 的价格较高。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230710170833.png"></li></ol></li><li>第二代 ADSL 改进的地方是：<ol><li>提高调制效率得到更高的数据率。</li><li>采用<strong>无缝速率自适应</strong>技术 (SRA)，可在运营中不中断通信和不产生误码的情况下，根据线路的实时状况，自适应地调整数据率。</li><li>改善线路质量评测和故障定位功能，对提高网络的运行维护水平具有重要意义。</li></ol></li></ul><h2 id="2-6-2-光纤同轴混合网-HFC-网"><a href="#2-6-2-光纤同轴混合网-HFC-网" class="headerlink" title="2.6.2 光纤同轴混合网 (HFC 网)"></a>2.6.2 光纤同轴混合网 (HFC 网)</h2><ul><li><strong>光纤同轴混合网</strong> (HFC 网) 是在目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还提供电话、数据和其他宽带交互型业务。</li><li>光纤同轴混合网 HFC 的特点：<ol><li>为提高传输的可靠性和电视信号的质量，HFC 网把原有线电视网中的同轴电缆主干部分改换为光纤 (图 2-23)。光纤从头端连接到<strong>光纤结点</strong>。在光纤结点光信号转换为电信号，然后通过同轴电缆传送到用户家庭。从头端到用户家庭所需的放大器数目减少到 4～5 个。连接到一个光纤结点的典型用户数是 500 左右，不超过 2000。</li><li>HFC 网具有双向传输功能，扩展了传输频带。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230710172306.png"></li></ol></li><li>使模拟电视机能接收数字电视信号，需要把<strong>机顶盒</strong>连接在同轴电缆和用户的电视机之间。为了使用户能够利用 HFC 网接入到互联网，以及在上行信道中传送交互数字电视所需的一些信息，还需要增加一个为 HFC 网使用的调制解调器，它又称为<strong>电缆调制解调器</strong>。</li></ul><h2 id="2-6-3-FTTx-技术"><a href="#2-6-3-FTTx-技术" class="headerlink" title="2.6.3 FTTx 技术"></a>2.6.3 FTTx 技术</h2><ul><li>为了更快地下载视频文件，更流畅地欣赏网上的高清视频节目，尽快地把用户的上网速率进行升级就成为 ISP 的重要任务，<strong>光纤到户</strong> (FTTH) 是最好的选择。</li><li>光纤到户 FTTH 有两个问题：<ol><li>价格不便宜</li><li>一般的家庭用户不需要过高的数据率的需求</li></ol></li><li>为了有效地利用光纤资源，在光纤干线和用户间，需要铺设一段中间的转换装置<strong>光配线网</strong> (ODN)，使数十个家庭用户能够共享一根光纤干线。</li><li>图 2-25 是广泛使用的无源光配线网的示意图。“无源”表明在光配线网中无须配备电源，基本上不用维护，其长期运营成本和管理成本很低。无源的光配线网常称为<strong>无源光网络</strong> (PON)。<ol><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network%7B419185F1-78FE-4077-9766-E3333D89BF52%7D.png"></li><li>在图 2-25 中，<strong>光线路终端</strong> OLT 是连接到光纤干线的终端设备。OLT 把收到的下行数据发往无源的 1：N <strong>光分路器</strong>，然后用广播方式向所有用户端的<strong>光网络单元</strong> ONU发送。</li><li>当 ONU 发送上行数据时，先把电信号转换为光信号，光分路器把各 ONU 发来的上行数据汇总后，以 TDMA 方式发往 OLT，而发送时间和长度都由 OLT 集中控制，以便有序地共享光纤主干。</li><li>无源光网络 PON 的种类很多，流行的有以下两种：<ul><li>以太网无源光网络 (EPON)，在链路层使用以太网协议，利用 PON 的拓扑结构实现了以太网的接入。EPON 的优点是：与现有以太网的兼容性好，并且成本低，扩展性强，管理方便。</li><li>吉比特无源光网络 (GPON)，GPON 采用<strong>通用封装方法</strong> (GEM)，可承载多业务，对各种业务类型都能够提供服务质量保证，是很有潜力的宽带光纤接入技术。</li></ul></li></ol></li><li>现在已有很多种不同的 FTTx。除了光纤到户 FTTH 外，还有<strong>光纤到路边</strong> FTTC (C 表示 Curb)、<strong>光纤到小区</strong> FTTZ (Z 表示 Zone)、<strong>光纤到大楼</strong> FTTB (B 表示 Building)、<strong>光纤到楼层</strong> FTTF (F 表示Floor)、<strong>光纤到办公室</strong> FTTO (O 表示 Office)、<strong>光纤到桌面</strong> FTTD (D 表示 Desk)，等等。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>物理层的任务是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。</p></li><li><p>一个数据通信系统可划分为三部分，即源系统、传输系统和目的系统。源系统包括源点 (或源站、信源) 和发送器，目的系统包括接收器和终点 (或目的站，或信宿)。</p></li><li><p>通信的目的是传送消息。如话音、文字、图像、视频等。数据是运送消息的实体。信号则是数据的电气或电磁的表现。</p></li><li><p>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号 (连续信号) 和数字信号 (离散信号)。代表数字信号不同离散数值的基本波形称为码元。</p></li><li><p>根据双方信息交互的方式，通信划分为单向通信 (单工通信)、双向交替通信 (半双工通信) 和双向同时通信 (全双工通信)。</p></li><li><p>来自信源的信号叫基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅、调频和调相。还有更复杂的调制方法，如正交振幅调制。</p></li><li><p>要提高数据在信道上的传输速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能被任意地提高。</p></li><li><p>传输媒体分为两类，即导引型传输媒体 (双绞线、同轴电缆或光纤) 和非导引型传输媒体 (无线或红外或大气激光)。</p></li><li><p>常用的信道复用技术有频分复用、时分复用、统计时分复用、码分复用和波分复用 (光的频分复用)。</p></li><li><p>最初在数字传输系统中使用的传输标准是脉冲编码调制 PCM。现在高速的数字传输系统使用同步光纤网 SONET (美国标准) 或同步数字系列 SDH (国际标准)。</p></li><li><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL (用数字技术对现有的模拟电话用户线进行改造)、光纤同轴混合网 HFC (在有线电视网的基础上开发的) 和 FTTx。</p></li><li><p>为了有效地利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无须配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</p></li><li><p>为什么要使用信道复用技术?常用的信道复用技术有哪些？</p><blockquote><p>许多用户通过复用技术就可以共同使用一个共享信道来进行通信。虽然复用要付出一定代价 (共享信道由于带宽较大因而费用也较高,再加上复用器和分用器也要增加成本) 但如果复用的信道数量较大，那么总的来看在经济上还是合算的。<br>常用的复用技术有: 频分复用、时分复用 (包括统计时分复用)、波分复用 (包括密集波分复用和稀疏波分复用) 和码分复用 (即码分多址)。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运输层</title>
      <link href="/2023/12/09/yun-shu-ceng/"/>
      <url>/2023/12/09/yun-shu-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-运输层协议概述"><a href="#5-1-运输层协议概述" class="headerlink" title="5.1 运输层协议概述"></a>5.1 运输层协议概述</h1><h2 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1 进程之间的通信"></a>5.1.1 进程之间的通信</h2><ul><li><strong>运输层向应用层提供通信服务</strong>，属于面向通信部分的最高层、用户功能中的最低层。当网络边缘部分中的两台主机使用网络核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时只用到下三层的功能。</li><li>进行通信的实体是主机中的进程，是主机中的一个<strong>进程</strong>和另一台主机中的一个<strong>进程</strong>交换数据。两台主机进行通信就是两台主机中的<strong>应用进程互相通信</strong>。IP 协议虽然能把分组送到目的主机，但是分组还停留在主机的网络层，没有交付主机中的应用进程。从运输层的角度看，<strong>通信的真正端点不是主机，而是主机中的进程</strong>。<strong>端到端的通信</strong>是应用进程之间的通信。</li><li>运输层有个重要功能：<strong>复用</strong>和<strong>分用</strong>。复用指在<strong>发送方</strong>不同的应用进程可以使用同一个运输层协议传送数据，分用指<strong>接收方</strong>的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</li><li><strong>运输层提供应用进程间的逻辑通信</strong>。逻辑通信的意思是：从应用层来看，只要把应用层报文交给运输层，运输层就可以把这报文传送到对方的运输层，<strong>好像这种通信就是沿水平方向直接传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接</strong>。</li><li><strong>网络层为主机之间提供逻辑通信，运输层为应用进程之间提供端到端的逻辑通信</strong>。</li><li>根据应用程序的不同需求，运输层有不同的运输协议，即<strong>面向连接的 TCP</strong> 和<strong>无连接的 UDP</strong>。</li><li><strong>运输层向高层用户屏蔽了下面网络核心的细节，使应用进程看见的是，好像在两个运输层实体之间有一条端到端的逻辑通信信道</strong>。当运输层<strong>采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的</strong>，但这种逻辑通信信道就相当于<strong>一条全双工的可靠信道</strong>。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条<strong>不可靠信道</strong>。</li></ul><h2 id="5-1-2-运输层的两个主要协议"><a href="#5-1-2-运输层的两个主要协议" class="headerlink" title="5.1.2 运输层的两个主要协议"></a>5.1.2 运输层的两个主要协议</h2><ul><li>TCP&#x2F;IP 运输层的两个主要协议即：<ol><li><strong>用户数据报协议</strong> UDP</li><li><strong>传输控制协议</strong> TCP</li></ol></li><li>图 5-3 给出了这两种协议在协议栈中的位置。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807163232.png"></li></ol></li><li>在 TCP&#x2F;IP 体系中，根据所使用的协议是 TCP 或 UDP，分别称之为 <strong>TCP 报文段</strong>或 <strong>UDP 用户数据报</strong></li><li>UDP 在传送数据之前<strong>不需要先建立连接</strong>。远地主机的运输层在收到 UDP 报文后，不需要回复。即使不提供可靠交付，但在某些情况下 UDP 仍是一种有效的工作方式。</li><li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此增加许多开销。使得协议数据单元的首部增大很多，占用许多的处理机资源。</li><li>表 5-1 给出了一些应用和应用层协议主要使用的运输层协议 (UDP 或 TCP)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807163339.png"></li></ol></li></ul><h2 id="5-1-3-运输层的端口"><a href="#5-1-3-运输层的端口" class="headerlink" title="5.1.3 运输层的端口"></a>5.1.3 运输层的端口</h2><ul><li><strong>复用</strong>：应用层的应用进程数据可以通过运输层再传送到网络层 (IP 层)。<strong>分用</strong>：运输层从网络层收到发送给各应用进程的数据后，必须分别交付指明的各应用进程。</li><li>进程的创建和撤销是动态的，通信的一方几乎无法识别对方机器上的进程。需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程是哪一个。</li><li>通信的终点是应用进程，只要把需要传送的报文交到目的主机某个合适的目的端口，剩下的工作就由 TCP 或 UDP 来完成。</li><li><strong>在协议栈层间的抽象的协议端口是软件端口</strong>。硬件端口是<strong>不同硬件设备</strong>进行交互的接口，而<strong>软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址</strong>。</li><li>当运输层收到 IP 层交上来的运输层报文时，能够根据首部中的目的端口号把数据交付应用层的目的应用进程。</li><li><strong>端口号只具有本地意义</strong>，是为了标志<strong>本计算机</strong>应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是<strong>没有关联</strong>的。</li><li>两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址 (为了找到对方的计算机)，而且要知道对方的端口号 (为了找到对方计算机中的应用进程)。</li><li>运输层的端口号分为下面的两大类：<ol><li><strong>服务器端使用的端口号</strong> 　<ul><li>最重要的一类叫<strong>熟知端口号</strong>或<strong>系统端口号</strong>。IANA 把这些端口号指派给了 TCP&#x2F;IP 最重要的一些应用程序，让所有的用户都知道。当一种新的应用程序出现后，IANA 必须为它指派一个熟知端口，否则互联网上的其他应用进程就无法和它进行通信；</li><li>另一类叫做<strong>登记端口</strong>号。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在 IANA 按照规定的手续登记，以防止重复。</li></ul></li><li><strong>客户端使用的端口号</strong> 　这类端口号仅在客户进程运行时才动态选择，又叫<strong>短暂端口号</strong>。这类端口号留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已使用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。</li></ol></li></ul><h1 id="5-2-用户数据报协议-UDP"><a href="#5-2-用户数据报协议-UDP" class="headerlink" title="5.2 用户数据报协议 UDP"></a>5.2 用户数据报协议 UDP</h1><h2 id="5-2-1-UDP-概述"><a href="#5-2-1-UDP-概述" class="headerlink" title="5.2.1 UDP 概述"></a>5.2.1 UDP 概述</h2><ul><li>用户数据报协议 UDP 在 IP 的数据报服务之上增加了复用、分用以及差错检测的功能。UDP 的主要特点是：<ol><li>UDP 是<strong>无连接的</strong>，即发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。</li><li>UDP 使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li><li>UDP <strong>面向报文</strong>。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文，如图 5-4 所示。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。UDP 一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，会降低 IP 层的效率。若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，降低了 IP 层的效率。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181018.png"></li></ul></li><li>UDP <strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用 (如 IP 电话、实时视频会议等) 要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但不允许数据有太大的时延。</li><li>UDP <strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li>UDP <strong>的首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li></ol></li></ul><h2 id="5-2-2-UDP-的首部格式"><a href="#5-2-2-UDP-的首部格式" class="headerlink" title="5.2.2 UDP 的首部格式"></a>5.2.2 UDP 的首部格式</h2><ul><li>用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段很简单，只有 8 个字节 (图 5-5)，由四个字段组成，<strong>每个字段的长度都是两字节</strong> 。各字段意义如下：<ol><li><strong>源端口</strong> 　源端口号。在需要对方回信时选用。不需要时可用全 0。</li><li><strong>目的端口</strong> 　目的端口号。这在终点交付报文时必须使用。</li><li><strong>长度</strong> 　UDP 用户数据报的长度，其最小值是 8 (仅有首部)。</li><li><strong>检验和</strong> 　检测 UDP 用户数据报在传输中是否有错。有错就丢弃。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181355.png"></li></ol></li><li>当运输层从 IP 层收到 UDP 数据报时，根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程。图 5-6 是 UDP 基于端口分用的示意图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181414.png"></li></ol></li><li>如果接收方 UDP 发现收到的报文中的目的端口号不正确，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。</li><li>虽然在 UDP 之间的通信要用到端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字 (TCP 之间的通信必须要在两个套接字之间建立连接)。</li><li>UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。但 IP 数据报的检验和只检验 IP 数据报的首部，UDP 的检验和是<strong>把首部和数据部分一起都检验</strong>。在发送方，首先把全零放入检验和字段。再把伪首部以及 UDP 用户数据报看成是由许多 16 位的字串接起来的。若 UDP 用户数据报的数据部分不是偶数个字节，则要填入一个全零字节 (但此字节不发送)。然后按二进制反码计算出这些 16 位字的和。将此和的二进制反码写入检验和字段后，就发送这样的 UDP 用户数据报。在接收方，把收到的 UDP 用户数据报连同伪首部 (以及可能的填充全零字节) 一起，按二进制反码求这些 16 位字的和。当无差错时其结果应为全 1。否则就表明有差错出现，接收方就应丢弃这个 UDP 用户数据报 (也可以上交给应用层，但附上出现了差错的警告)。图 5-7 给出了一个计算 UDP 检验和的例子。这里假定用户数据报的长度是 15 字节，因此要添加一个全 0 的字节。这种简单的差错检验方法的检错能力并不强，但它的好处是简单，处理起来较快。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181600.png"></li></ol></li></ul><h1 id="5-3-传输控制协议-TCP-概述"><a href="#5-3-传输控制协议-TCP-概述" class="headerlink" title="5.3 传输控制协议 TCP 概述"></a>5.3 传输控制协议 TCP 概述</h1><h2 id="5-3-1-TCP-最主要的特点"><a href="#5-3-1-TCP-最主要的特点" class="headerlink" title="5.3.1 TCP 最主要的特点"></a>5.3.1 TCP 最主要的特点</h2><ul><li>TCP 的主要特点：<ol><li>TCP 是<strong>面向连接的运输层协议</strong>。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。</li><li>每一条 TCP 连接只能有两个端点，只能是点对点的 (一对一)。</li><li>TCP 提供<strong>可靠交付</strong>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li><li>TCP 提供<strong>全双工通信</strong>。允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序只需要把数据传送给 TCP 的缓存，TCP 把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层的应用进程读取缓存中的数据。</li><li><strong>面向字节流</strong>。TCP 中的“流”指的是<strong>流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块 (大小不等)，但 TCP 把应用程序交下来的数据仅仅看成一连串的<strong>无结构的字节流</strong>。并不知道所传送的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。</li></ol></li><li>TCP 和 UDP 在发送报文时采用的方式不同。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段包含多少个字节 (UDP 发送的报文长度是应用进程给出的)。如果应用进程传送到 TCP 缓存的数据块太长，TCP 就把它划分短一些再传送。如果应用进程一次只发来一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li></ul><h2 id="5-3-2-TCP-的连接"><a href="#5-3-2-TCP-的连接" class="headerlink" title="5.3.2 TCP 的连接"></a>5.3.2 TCP 的连接</h2><ul><li>TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是运输层的协议端口，而是<strong>套接字</strong>或<strong>插口</strong>。</li><li><strong>每一条 TCP 连接唯一地被通信两端的两个端点 (即两个套接字) 所确定</strong>。即：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807210504.png"></li><li>IP<sub>1</sub> 和 IP<sub>2</sub> 分别是两个端点主机的 IP 地址，而 port<sub>1</sub> 和 port<sub>2</sub> 分别是两个端点主机中的端口号。TCP 连接的两个套接字就是 socket<sub>1</sub> 和 socket<sub>2</sub>。</li></ol></li><li><strong>TCP 连接的端点是个抽象的套接字</strong>，即 (<strong>IP地址：端口号</strong> )。同一个 IP 地址可以有多个不同的 TCP 连接，同一个端口号也可以出现在多个不同的 TCP 连接中。</li><li><strong>socket 表示多种不同的意思</strong>。例如：<ol><li>允许应用程序访问连网协议的应<strong>用编程接口 API</strong>，即运输层和应用层之间的一种接口，称为 socket API，并简称为 socket。</li><li>在 socket API 中使用的一个<strong>函数名</strong>也叫做 socket。</li><li>调用 socket 函数的<strong>端点</strong>称为 socket，如“创建一个数据报 socket”。</li><li>调用 socket 函数时，其<strong>返回值</strong>称为 socket 描述符，可简称为 socket。</li><li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket <strong>实现</strong>。</li></ol></li></ul><h1 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4 可靠传输的工作原理"></a>5.4 可靠传输的工作原理</h1><ul><li>理想的传输条件有以下特点：<ol><li>传输信道不产生差错。</li><li>接收方总是来得及处理收到的数据。</li></ol></li></ul><h2 id="5-4-1-停止等待协议"><a href="#5-4-1-停止等待协议" class="headerlink" title="5.4.1 停止等待协议"></a>5.4.1 停止等待协议</h2><ul><li><strong>无差错情况</strong><ol><li>停止等待协议可用图 5-9 来说明。图 5-9(a) 是最简单的无差错情况。A 发送分组 M<sub>1</sub> ，发完暂停，等待 B 确认。B 收到了 M<sub>1</sub> 就向 A 发送确认。A 在收到了对确认后，就再发送下一个分组 M<sub>2</sub>。同样，在收到 B 确认后，再发送M<sub>3</sub>。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808145722.png"></li></ul></li></ol></li><li><strong>出现差错</strong><ol><li>图 5-9(b) 是分组在传输过程中出现差错的情况。B 接收 M<sub>1</sub> 时检测出了差错，丢弃 M<sub>1</sub>，其他什么也不做。这种情况下，B 不会发送任何信息。可靠传输协议是这样设计的：A 只要超过了一段时间没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</li><li>注意以下三点。<ul><li>A 在发送完一个分组后，<strong>必须保留已发送的分组的副本</strong>。只有在收到相应的确认后才能清除保留的分组副本。</li><li>分组和确认分组都必须进行**编号。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li><li>超时计时器设置的重传时间<strong>应当比数据在分组传输的平均往返时间更长一些</strong>。图 5-9(b) 中的一段虚线表示如果 M<sub>1</sub> 正确到达 B 同时 A 也正确收到确认的过程。重传时间应设定为比平均往返时间更长一些。如果重传时间设定得很长，那么通信的效率会很低。但如果重传时间设定得太短，以致产生不必要的重传，就浪费了网络资源。然而，在运输层重传时间的准确设定是非常复杂的，这是因为已发送出的分组到底会<strong>经过哪些网络</strong>，以及这些网络将会<strong>产生多大的时延</strong> (这取决于这些网络<strong>当时的拥塞情况</strong>)，这些都是<strong>不确定因素</strong>。</li></ul></li></ol></li><li><strong>确认丢失和确认迟到</strong><ol><li>图 5-10(a) 说明的是另一种情况。B 所发送的对 M<sub>1</sub> 的确认丢失了。A 在设定的超时重传时间内没有收到确认，无法知道是自己发送的分组出错、丢失，或者是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M<sub>1</sub>。假定 B 又收到了重传的分组 M<sub>1</sub><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150213.png"></li></ul></li><li>这时应采取两个行动：<ul><li><strong>丢弃这个重复的分组</strong> M<sub>1</sub>，不向上层交付。</li><li><strong>向 A 发送确认</strong>。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M<sub>1</sub> 就表示 A 没有收到对 M<sub>1</sub> 的确认。</li></ul></li><li>图 5-10(b) 也是一种可能出现的情况。传输过程中没有出现差错，但 B 对分组 M<sub>1</sub> 的确认迟到了。A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。B 仍然会收到重复的 M<sub>1</sub> ，并且同样要丢弃重复的 M<sub>1</sub>，并重传确认分组。</li></ol></li><li><strong>信道利用率</strong><ol><li>停止等待协议的优点是简单，缺点是信道利用率太低。可以用图 5-11 来说明这个问题。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150800.png"></li></ul></li><li>假定 A 发送分组需要的时间是 T<sub>D</sub>。T<sub>D</sub> 等于分组长度除以数据率。再假定分组正确到达 B 后，B 处理分组的时间忽略不计，同时立即发回确认。假定 B 发送确认分组需要时间 T<sub>A</sub>。如果 A 处理确认分组的时间也忽略不计，那么 A 在经过时间 (T<sub>D</sub>＋RTT＋T<sub>A</sub>) 后就可以再发送下一个分组，这里的 RTT 是往返时间。因为仅仅是在时间 T<sub>D</sub> 内才用来传送有用的数据 (包括分组的首部)，因此信道的利用率 U 可用下式计算：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150820.png"></li></ul></li><li>为了提高传输效率，发送方不使用低效率的停止等待协议，采用<strong>流水线传输</strong> (如图 5-12 所示)。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。这种传输方式可以获得很高的信道利用率。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151106.png"></li></ul></li></ol></li></ul><h2 id="5-4-2-连续-ARQ-协议"><a href="#5-4-2-连续-ARQ-协议" class="headerlink" title="5.4.2 连续 ARQ 协议"></a>5.4.2 连续 ARQ 协议</h2><ul><li>图 5-13(a) 表示发送方维持的<strong>发送窗口</strong>，表示位于发送窗口内的 5 个分组可连续发送出去，不需要等待对方的确认。提高了信道利用率。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151146.png"></li></ol></li><li>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。图 5-13(b) 表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。</li><li>接收方采用<strong>累积确认</strong>的方式，<strong>对按序到达的最后一个分组发送确认</strong>。</li><li>累积确认有优点也有缺点：<ol><li>优点是容易实现，即使确认丢失也不必重传。</li><li>缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。</li></ol></li></ul><h1 id="5-5-TCP-报文段的首部格式"><a href="#5-5-TCP-报文段的首部格式" class="headerlink" title="5.5 TCP 报文段的首部格式"></a>5.5 TCP 报文段的首部格式</h1><ul><li>TCP 面向字节流，但 TCP 传送的数据单元却是报文段。</li><li>一个 TCP 报文段分为首部和数据两部分。</li><li>TCP 报文段首部的前 20 个字节是固定的 (图 5-14)，后面有 4<em>n</em> 字节是根据需要而增加的选项。因此 TCP 首部的最小长度是 20 字节。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151426.png"></li></ol></li><li>首部固定部分各字段的意义如下：<ol><li><strong>源端口和目的端口</strong> 　各占 2 个字节，分别写入源端口号和目的端口号。</li><li><strong>序号</strong> 　占 4 字节。序号范围是［0，2<sup>32</sup>–1］，共 2<sup>32</sup> (即4 294 967 296) 个序号。序号增加到 2<sup>32</sup>–1 后，下一个序号就又回到 0。使用 mod 2<sup>32</sup> 运算。在一个 TCP 连接中传送的字节流中的<strong>每一个字节都按顺序编号</strong>。整个要传送的字节流的起始序号在连接建立时设置。首部中的序号字段值则指的是<strong>本报文段</strong>所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是 301，而携带的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。字段的名称也叫做“<strong>报文段序号</strong>”。</li><li><strong>确认号</strong> 　占 4 字节，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。例如，B 收到 A 发来的一个报文段，其序号字段值是 501，而数据长度是 200 字节 (序号 501～700)，这表明 B 收到到序号 700 为止的数据。因此，B 期望收到的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。若确认号＝<em>N</em>，则表明：到序号 <em>N</em>–1 为止的所有数据都已正确收到。</li><li><strong>数据偏移</strong> 　占 4 位，指出 TCP 报文段的首部长度。“数据偏移”的单位是 4 字节 (即以 32 位字为计算单位)。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度 (即选项长度不能超过 40 字节)。</li><li><strong>保留</strong> 　占 6 位，保留为今后使用，但目前应置为 0。</li><li><strong>紧急</strong> URG　当 URG＝1 时，紧急指针字段有效，发送应用进程告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。这时要与首部中<strong>紧急指针</strong>字段配合使用。</li><li><strong>确认</strong> ACK　当 ACK＝1 时确认号字段有效。当 ACK＝0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li>(x) <strong>推送</strong> PSH　当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 使用推送操作。这时，发送方 TCP 把 PSH 置 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH＝1 的报文段，就尽快地交付接收应用进程，不再等到整个缓存都填满了后再向上交付。</li><li><strong>复位</strong> RST　当 RST＝1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接。RST 置 1 还用来拒绝一个非法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位。</li><li><strong>同步</strong> SYN　在连接建立时用来同步序号。当 SYN＝1 而 ACK＝0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使  SYN＝1 和 ACK＝1。因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。</li><li><strong>终止</strong> FIN　用来释放一个连接。当 FIN＝1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li><li><strong>窗口</strong> 　占 2 字节。窗口值是［0，2<sup>16</sup>–1］之间的整数。窗口指的是发送本报文段的一方的<strong>接收窗口</strong>。窗口值<strong>告诉对方</strong> ：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量 (以字节为单位)。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<strong>窗口值作为接收方让发送方设置其发送窗口的依据</strong>。窗口字段明确指出了现在允许对方发送的数据量，经常动态变化。</li><li>(x) <strong>检验和</strong> 　占 2 字节。检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式与图 5-5 中 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的17 改为 6（TCP 的协议号是 6），把第 5 字段中的 UDP 长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。</li><li>(x) <strong>紧急指针</strong> 　占 2 字节。紧急指针仅在 URG＝1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。</li><li><strong>选项</strong> 　长度可变，最长可达 40 字节。</li></ol></li><li>TCP 最初只规定了一种选项，即<strong>最大报文段长度</strong> MSS。MSS 是每一个 TCP 报文段中的<strong>数据字段的最大长度</strong>。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以 MSS 并不是整个 TCP 报文段的最大长度，而是“TCP 报文段长度减去 TCP 首部长度”。</li><li>随着互联网的发展，又增加了<strong>窗口扩大</strong>选项、<strong>时间戳</strong>选项、<strong>选择确认</strong>选项。<ol><li>窗口扩大选项<ul><li>窗口扩大选项是为了扩大窗口。TCP 首部中窗口字段长度是 16 位，因此最大的窗口大小为 64K 字节。</li><li>窗口扩大选项占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数从 16 增大到 (16＋S) 。移位值允许使用的最大值是 14，相当于窗口最大值增大到 2<sup>(16+14)</sup>–1＝2<sup>30</sup> –1。</li><li>窗口扩大选项可以在双方初始建立 TCP 连接时进行协商。如果接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送 S＝0 的选项，使窗口大小回到 16。</li></ul></li><li>时间戳选项<ul><li><strong>时间戳</strong>选项占 10 字节，最主要的字段是<strong>时间戳</strong>值字段 (4 字节) 和<strong>时间戳回送回答</strong>字段 (4 字节)。时间戳选项有以下两个功能：<ol><li>用来计算往返时间 RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出 RTT 来。</li><li>用于处理 TCP 序号超过 2<sup>32</sup> 的情况，又称<strong>防止序号绕回</strong> PAWS。TCP 报文段的序号只有 32 位，而每增加 2<sup>32</sup> 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次 TCP 连接的数据传送中序号很可能会被重复使用。</li></ol></li></ul></li></ol></li></ul><h1 id="5-6-TCP-可靠传输的实现"><a href="#5-6-TCP-可靠传输的实现" class="headerlink" title="5.6 TCP 可靠传输的实现"></a>5.6 TCP 可靠传输的实现</h1><h2 id="5-6-1-以字节为单位的滑动窗口"><a href="#5-6-1-以字节为单位的滑动窗口" class="headerlink" title="5.6.1 以字节为单位的滑动窗口"></a>5.6.1 以字节为单位的滑动窗口</h2><ul><li>TCP 的滑动窗口以字节为单位。假定 A 收到了 B <strong>发来</strong>的确认报文段，其中窗口是 20 字节，而确认号是 31 (这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了)。根据这两个数据，A 就构造出自己的发送窗口，如图 5-15 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808160923.png"></li></ol></li><li>A 发送窗口表示：在没有收到 B 的确认的情况下，A 可以把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。</li><li>发送窗口里面的序号表示允许发送的序号。窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，获得更高的传输效率。接收方会把自己的接收窗口数值放在窗口字段中发送给对方，A 的发送窗口一定不能超过 B 的接收窗口数值。</li><li>发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据不需要保留。而发送窗口前沿的前面部分表示不允许发送的，因为接收方没有为这部分数据保留临时存放的缓存空间。</li><li>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动 (没有收到新的确认) 和前移 (收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：一是没有收到新的确认，对方通知的窗口大小也不变；二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。</li><li>发送窗口前沿也有可能<strong>向后收缩</strong>。这发生在接收方的接收窗口缩小了。但 TCP 的标准<strong>强烈不赞成这样做</strong>。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。</li><li>发送方的应用进程把字节流写入 TCP 的发送缓存，接收方的应用进程从 TCP 的接收缓存中读取字节流。图 5-19 画出了发送方维持的发送缓存和发送窗口，以及接收方维持的接收缓存和接收窗口。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808161130.png"></li><li>图 5-19(a) 所示的发送方的情况，发送缓存用来暂时存放：<ul><li>发送应用程序传送给发送方 TCP 准备发送的数据</li><li>TCP 已发送出但尚未收到确认的数据</li></ul></li><li>图 5-19(b) 所示的接收方的情况，接收缓存用来暂时存放：<ul><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>未按序到达的数据。</li></ul></li></ol></li><li>强调以下三点：<ol><li>虽然 A 的发送窗口是根据 B 的接收窗口设置的，但在同一时刻，A 的发送窗口并不总是和 B 的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后。</li><li>对于不按序到达的数据如何处理，TCP 标准并无明确规定。如果接收方把不按序到达的数据丢弃，那么接收窗口的管理会比较简单，但这样做对网络资源的利用不利。因此 TCP 通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<strong>按序交付上层的应用进程</strong>。</li><li>TCP 要求接收方必须有累积确认的功能，减小传输开销。接收方可以在合适时发送确认，也可以在自己有数据要发送时把确认信息顺便<strong>捎带</strong>上。注意两点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认。二是捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ol></li><li>TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。</li></ul><h2 id="5-6-2-超时重传时间的选择"><a href="#5-6-2-超时重传时间的选择" class="headerlink" title="5.6.2 超时重传时间的选择"></a>5.6.2 超时重传时间的选择</h2><ul><li>由于 TCP 的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个 IP 数据报所选择的路由可能不同。如果把超时重传时间设置得太短，会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则使网络的空闲时间增大，降低了传输效率。</li><li>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。两个时间之差就是<strong>报文段的往返时间 RTT</strong>。TCP 保留了 RTT 的一个<strong>加权平均往返时间</strong> RTT<sub>S</sub> (又称为平滑的往返时间，S 表示 Smoothed)。每当第一次测量到 RTT 样本时，RTT<sub>S</sub> 值就取为所测量到的 RTT 样本值。但以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTT<sub>S</sub>：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162046.png"></li></ol></li><li>在上式中，0≤α&lt;1。若 α 很接近于零，表示新的 RTT<sub>S</sub> 值和旧的 RTT<sub>S</sub> 值相比变化不大，而对新的 RTT 样本影响不大 (RTT 值更新较慢)。若选择 α 接近于 1，则表示新的 RTT<sub>S</sub> 值受新的 RTT 样本的影响较大 (RTT 值更新较快)。</li><li>超时计时器设置的<strong>超时重传时间</strong> RTO 应略大于上面得出的加权平均往返时间 RTT<sub>S</sub> 。RFC 6298 建议使用下式计算 RTO：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162104.png"></li></ol></li><li>RTT<sub>D</sub> 是 RTT 的<strong>偏差</strong>的加权平均值，它与 RTT<sub>S</sub> 和新的 RTT 样本之差有关。RFC 6298 建议这样计算 RTT<sub>D</sub>。当第一次测量时，RTT<sub>D</sub> 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTT<sub>D</sub>：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162116.png"></li></ol></li><li>如图 5-20 所示，发送出一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段。经过了一段时间后，收到了确认报文段。现在的问题是：<strong>如何判定此确认报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认</strong>。由于重传的报文段和原来的报文段完全一样，因此源主机在收到确认后，就无法做出正确的判断，而正确的判断对确定加权平均 RTT<sub>S</sub> 的值关系很大。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162135.png"></li><li>若收到的确认是对重传报文段的确认，却被源主机当成是对原来的报文段的确认，则这样计算出的 RTT<sub>S</sub> 和超时重传时间 RTO 就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间 RTO 就越来越长；同样，若收到的确认是对原来的报文段的确认，但被当成是对重传报文段的确认，则由此计算出的RTT<sub>S</sub> 和 RTO 都会偏小。这就必然导致报文段过多地重传使，RTO 越来越短。</li><li>Karn 提出了一个算法：<strong>在计算加权平均 RTT<sub>S</sub> 时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均 RTT<sub>S</sub> 和 RTO 就较准确</strong>。</li><li>但是，这又引起新的问题：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</li><li>因此要对 Karn 算法进行修正。方法是：报文段每重传一次，就把超时重传时间 RTO 增大一些。典型的做法是取新的重传时间为旧的重传时间的 2 倍。当不再发生报文段的重传时，才根据上面给出的 (5-5) 式计算超时重传时间。</li><li>Karn 算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返时间的估测，使计算结果更加合理。</li></ol></li></ul><h2 id="5-6-3-选择确认-SACK"><a href="#5-6-3-选择确认-SACK" class="headerlink" title="5.6.3 选择确认 SACK"></a>5.6.3 选择确认 SACK</h2><ul><li><strong>选择确认</strong>的工作原理。TCP 的接收方在接收对方发送过来的数据字节流的序号不连续时会形成一些不连续的字节块 (如图 5-21 所示)。序号 1～1000 收到了，但序号 1001～1500 没有收到。接下来的字节流又收到了，缺少了 3001～3500。再后面从序号 4501 起又没有收到。接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162315.png"></li><li>从图 5-21 可看出，与前后字节不连续的每一个字节块都有两个边界：左边界和右边界。因此在图中用四个指针标记这些边界。第一个字节块的左边界 L<sub>1</sub> ＝1501，右边界 R<sub>1</sub> ＝3001 而不是 3000。左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。同理，第二个字节块的左边界 L<sub>2</sub> ＝3501，而右边界 R<sub>2</sub> ＝4501。</li></ol></li></ul><h1 id="5-7-TCP-的流量控制"><a href="#5-7-TCP-的流量控制" class="headerlink" title="5.7 TCP 的流量控制"></a>5.7 TCP 的流量控制</h1><h2 id="5-7-1-利用滑动窗口实现流量控制"><a href="#5-7-1-利用滑动窗口实现流量控制" class="headerlink" title="5.7.1 利用滑动窗口实现流量控制"></a>5.7.1 利用滑动窗口实现流量控制</h2><ul><li><strong>流量控制</strong>就是<strong>让发送方的发送速率不要太快，让接收方来得及接收</strong>。</li><li><strong>发送方的发送窗口不能超过接收方给出的接收窗口的数值</strong>。</li><li>TCP 的<strong>窗口单位是字节，不是报文段</strong>。</li><li>TCP 为每一个连接设有一个<strong>持续计时器</strong>。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</li></ul><h2 id="5-7-2-TCP-的传输效率"><a href="#5-7-2-TCP-的传输效率" class="headerlink" title="5.7.2 TCP 的传输效率"></a>5.7.2 TCP 的传输效率</h2><ul><li>用不同的机制来控制 TCP 报文段的发送时机：<ol><li>TCP 维持一个等于<strong>最大报文段长度</strong> MSS 的变量。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即 TCP 支持的<strong>推送</strong>操作。</li><li>发送方的一个计时器期限到了时，就把当前已有的缓存数据装入报文段 (但长度不能超过MSS) 发送出去。</li></ol></li><li>在 TCP 的实现中广泛使用 Nagle 算法。算法如下：<ol><li>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。</li><li>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。</li><li>只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，可明显地减少所用的网络带宽。</li><li>当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段，可以有效地提高网络的吞吐量。</li></ol></li><li><strong>糊涂窗口综合征</strong>，有时会使 TCP 的性能变坏。当 TCP 接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取 1 个字节 (这样就使接收缓存空间仅腾出 1 个字节)，然后向发送方发送确认，并把窗口设置为 1 个字节 (但发送的数据报是 40 字节长)。接着，发送方又发来 1 个字节的数据 (请注意，发送方发送的 IP 数据报是 41 字节长)。接收方发回确认，仍然将窗口设置为 1 个字节。这样进行下去，使网络的效率很低。</li><li>解决糊涂窗口综合征需要<strong>让接收方等待一段时间</strong>，使得接收缓存已有足够空间容纳一个最长的报文段，或者<strong>等到接收缓存已有一半空闲的空间</strong>。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</li></ul><h1 id="5-8-TCP-的拥塞控制"><a href="#5-8-TCP-的拥塞控制" class="headerlink" title="5.8 TCP 的拥塞控制"></a>5.8 TCP 的拥塞控制</h1><h2 id="5-8-1-拥塞控制的一般原理"><a href="#5-8-1-拥塞控制的一般原理" class="headerlink" title="5.8.1 拥塞控制的一般原理"></a>5.8.1 拥塞控制的一般原理</h2><ul><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>。可以把出现网络拥塞的条件写成如下的关系式：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809093124.png"></li></ol></li><li>若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</li><li>网络拥塞由许多因素引起：<ol><li>当某个结点缓存的容量太小时，到达该结点的分组因无存储空间暂存而不得不被丢弃。</li><li>由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数分组的排队等待时间将会大大增加，上层软件只能重传。</li><li>处理机处理的速率太慢可能引起网络的拥塞。</li><li>拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次，导致更多的分组流入网络和被网络中的路由器丢弃。</li></ol></li><li><strong>拥塞控制防止过多的数据注入到网络中，使网络中的路由器或链路不致过载</strong>。拥塞控制要做的有一个前提，就是<strong>网络能够承受现有的网络负荷</strong>。拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。但 TCP 连接的端点只要迟迟不能收到对方的确认信息，就猜想在当前网络中的某处很可能发生了拥塞，但无法知道拥塞到底发生在网络的何处，也无法知道发生拥塞的具体原因。</li><li><strong>流量控制往往指点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题 (接收端控制发送端)。流量控制所要做的就是抑制发送端发送数据的速率，使接收端来得及接收。</li><li>进行拥塞控制需要付出代价。首先需要获得网络内部流量分布的信息。在实施拥塞控制时，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制，产生了额外开销。拥塞控制有时需要将一些资源 (如缓存、带宽等) 分配给个别用户单独使用，使得网络资源不能更好地实现共享。</li><li>拥塞控制所起的作用<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809093722.png"></li></ul><ol><li>在图 5-23 中的横坐标是<strong>提供的负载</strong>，代表单位时间内输入给网络的分组数目。因此提供的负载也称为<strong>输入负载</strong>或<strong>网络负载</strong>。纵坐标是<strong>吞吐量</strong>，代表单位时间内从网络输出的分组数目。</li><li>具有理想拥塞控制的网络，在吞吐量饱和之前，网络吞吐量应等于提供的负载，故吞吐量曲线是 45° 的斜线。但当提供的负载超过某一限度时，由于网络资源受限，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了。</li><li>实际网络的情况就很不相同了。从图 5-23 可看出，随着提供的负载的增大，网络吞吐量的增长速率逐渐减小。也就是说，在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了。当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了<strong>轻度拥塞</strong>的状态。更值得注意的是，当提供的负载达到某一数值时，网络的吞吐量反而随提供的负载的增大而下降，这时<strong>网络就进入了拥塞状态</strong>。当提供的负载继续增大到某一数值时，网络的吞吐量就下降到零，网络已无法工作，这就是所谓的<strong>死锁</strong>。</li></ol></li><li>从原理上讲，寻找拥塞控制的方案是寻找使不等式 (5-7) 不再成立的条件。或者是增大网络的某些可用资源，或减少一些用户对某些资源的需求。</li><li>开环控制是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正。</li><li>闭环控制是基于反馈环路的概念，主要有以下几种措施：<ol><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>把拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ol></li><li>过于频繁地采取行动以缓和网络的拥塞，会使系统产生不稳定的振荡。但过于迟缓地采取行动又不具有任何实用价值。</li></ul><h2 id="5-8-2-TCP-的拥塞控制方法"><a href="#5-8-2-TCP-的拥塞控制方法" class="headerlink" title="5.8.2 TCP 的拥塞控制方法"></a>5.8.2 TCP 的拥塞控制方法</h2><ul><li>TCP 进行拥塞控制的算法有四种，<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。</li><li>发送方维持一个叫<strong>拥塞窗口</strong> cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。</li><li>发送方<strong>控制拥塞窗口</strong>的原则：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</li><li><strong>慢开始</strong>算法的思路：当主机开始发送数据时，由于并不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，可能引起网络发生拥塞。应该<strong>由小到大逐渐增大发送窗口，由小到大逐渐增大拥塞窗口数值</strong>。</li><li>旧的规定是这样的：在刚刚开始发送报文段时，先把初始拥塞窗口 cwnd 设置为 1 至 2 个发送方的最大报文段 SMSS 的数值，但新的 RFC 5681 把初始拥塞窗口 cwnd 设置为不超过 2 至 4 个 SMSS 的数值。具体的规定如下：<ol><li>若 SMSS&gt;2190 字节，则设置初始拥塞窗口 cwnd＝2×SMSS 字节，且<strong>不得超过 2 个报文段。</strong></li><li>若 SMSS&gt;1095 字节 且 SMSS≤2190 字节，则设置初始拥塞窗口 cwnd＝3×SMSS 字节，且<strong>不得超过</strong> 3 个报文段。</li><li>若 SMSS≤1095 字节，则设置初始拥塞窗口 cwnd＝4×SMSS 字节，且<strong>不得超过</strong> 4 个报文段。</li></ol></li><li>慢开始规定，在每收到一个<strong>对新的报文段的确认</strong>后，可以把拥塞窗口增加最多一个 SMSS 的数值。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102613.png"></li><li>其中 <em>N</em> 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。</li></ol></li><li>在一开始发送方先设置 cwnd＝1，发送第一个报文段 M<sub>1</sub>，接收方收到后确认 M<sub>1</sub>。发送方收到对 M<sub>1</sub> 的确认后，把 cwnd 从 1 增大到 2，于是发送方接着发送 M<sub>2</sub> 和 M<sub>3</sub> 两个报文段。接收方收到后发回对 M<sub>2</sub> 和 M<sub>3</sub> 的确认。发送方每收到一个<strong>对新报文段的确认</strong>就使发送方的拥塞窗口加 1，因此发送方在收到两个确认后，cwnd 就从 2 增大到 4，并可发送 M<sub>4</sub>～M<sub>7</sub> 共 4 个报文段 (见图 5-24)。因此使用慢开始算法后，<strong>每经过一个传输轮次</strong>，<strong>拥塞窗口</strong> cwnd <strong>就加倍</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102703.png"></li></ol></li><li>传输<strong>轮次</strong>。从图 5-24 可以看出，一个传输轮次所经历的时间就是往返时间 RTT。使用“传输轮次”是强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。例如，拥塞窗口 cwnd 的大小是 4 个报文段，那么这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这4个报文段的确认，总共经历的时间。</li><li>为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限</strong> ssthresh 状态变量。慢开始门限 ssthresh 的用法如下：<ol><li>当 cwnd&lt;ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd&gt;ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd&#x3D;ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ol></li><li><strong>拥塞避免</strong>算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“<strong>加法增大</strong>”AI 的特点。这表明在拥塞避免阶段，拥塞窗口 cwnd <strong>按线性规律缓慢增长</strong>，比慢开始算法的拥塞窗口增长速率缓慢得多。</li><li>采用快重传算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>。快重传算法要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了<strong>失序的报文段</strong>也要立即发出对已收到的报文段的重复确认。</li><li>快重传算法规定，发送方只要<strong>一连收到 3 个重复确认</strong>，就知道接收方确实没有收到报文段 M<sub>3</sub>，因而应当<strong>立即进行重传</strong> (即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约 20％。</li><li>TCP 的拥塞控制可以归纳为图 5-27 的流程图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102925.png"></li></ol></li><li>接收方的缓存空间有限，根据自己的接收能力设定了接收方窗口 rwnd，并把这个窗口值写入 TCP 首部中的窗口字段，传送给发送方。因此，<strong>接收方窗口</strong>又称为<strong>通知窗口</strong>。因此，从接收方对发送方的流量控制的角度考虑，<strong>发送方的发送窗口一定不能超过对方给出的接收方窗口值</strong> rwnd。</li><li>如果把拥塞控制和接收方对发送方的流量控制一起考虑，那么发送方的窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，也就是说：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809103014.png"></li><li>当 rwnd&lt;cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</li><li>当 cwnd&lt;rwnd 时，则是网络的拥塞程度限制发送方窗口的最大值。</li><li>rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。</li></ol></li></ul><h2 id="5-8-3-主动队列管理-AQM"><a href="#5-8-3-主动队列管理-AQM" class="headerlink" title="5.8.3 主动队列管理 AQM"></a>5.8.3 主动队列管理 AQM</h2><ul><li>网络层的策略对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。在最简单的情况下，路由器的队列通常都是按照“<strong>先进先出</strong>” FIFO 的规则处理到来的分组。由于队列长度有限，因此当队列已满时，以后再到达的所有分组将都被丢弃，这叫<strong>尾部丢弃策略</strong>。</li><li>路由器的尾部丢弃会导致一连串分组的丢失，使发送方出现超时重传、TCP 进入拥塞控制的慢开始状态，使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。更为严重的是，在网络中通常有很多的 TCP 连接，这些连接中的报文段通常是复用在网络层的 IP 数据报中传送。在这种情况下，若发生了路由器中的尾部丢弃，可能会同时影响到很多条 TCP 连接，使许多 TCP 连接<strong>在同一时间</strong>突然都进入到慢开始状态。这在 TCP 的术语中称为<strong>全局同步</strong>。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</li><li>为了避免发生网络中的全局同步现象，提出了<strong>主动队列管理</strong> AQM。所谓“主动”是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。应当在队列长度达到某个值得警惕的数值时 (即当网络拥塞有了某些拥塞征兆时)，就主动丢弃到达的分组。这样就提醒了发送方放慢发送的速率，可能使网络拥塞的程度减轻，甚至不出现网络拥塞。</li><li>实现<strong>随机早期检测</strong> RED 时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED 就按照规定的算法先计算当前的平均队列长度。<ol><li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。</li><li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li><li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率 <em>p</em> 把新到达的分组丢弃 (这就体现了丢弃分组的随机性)。</li></ol></li><li>RED 不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，而是在检测到网络拥塞的<strong>早期征兆</strong>时 (即路由器的平均队列长度达到一定数值时)，就以概率 <em>p</em> 丢弃个别的分组，让拥塞控制只在个别的 TCP 连接上进行，因而避免发生全局性的拥塞控制。</li></ul><h1 id="5-9-TCP-的运输连接管理"><a href="#5-9-TCP-的运输连接管理" class="headerlink" title="5.9 TCP 的运输连接管理"></a>5.9 TCP 的运输连接管理</h1><ul><li>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此，运输连接就有三个阶段，即：<strong>连接建立、数据传送和连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</li><li>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做<strong>客户</strong>，而被动等待连接建立的应用进程叫做<strong>服务器</strong>。</li></ul><h2 id="5-9-1-TCP-的连接建立"><a href="#5-9-1-TCP-的连接建立" class="headerlink" title="5.9.1 TCP 的连接建立"></a>5.9.1 TCP 的连接建立</h2><ul><li>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。图 5-28 画出了三报文握手建立 TCP 连接的过程。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809153847.png"></li><li>A 的 TCP 客户进程也是首先创建<strong>传输控制模块</strong> TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN＝1，同时选择一个初始序号 seq＝x。TCP 规定，SYN 报文段(即 SYN＝1 的报文段) 不能携带数据，但要<strong>消耗掉一个序号</strong>。这时，TCP 客户进程进入 SYN-SENT (同步已发送) 状态。</li><li>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack＝x＋1，同时也为自己选择一个初始序号 seq＝y。请注意，这个报文段也不能携带数据，但同样<strong>要消耗掉一个序号</strong>。这时 TCP 服务器进程进入 SYN-RCVD (同步收到) 状态。</li><li>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack＝y＋1，而自己的序号 seq＝x＋1。TCP 的标准规定，ACK 报文段可以携带数据。但<strong>如果不携带数据则不消耗序号</strong>，在这种情况下，下一个数据报文段的序号仍是 seq＝x＋1。这时，TCP 连接已经建立，A 进入 ESTABLISHED (已建立连接) 状态。</li><li>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。</li></ol></li></ul><h2 id="5-9-2-TCP-的链接释放"><a href="#5-9-2-TCP-的链接释放" class="headerlink" title="5.9.2 TCP 的链接释放"></a>5.9.2 TCP 的链接释放</h2><ul><li>数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于 ESTABLISHED 状态 (图 5-29)。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq＝u，它等于前面已传送过的数据的最后一个字节的序号加 1。这时 A 进入 FIN-WAIT-1 (终止等待 1)状态，等待 B 的确认。TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_%7B5BE8DB9C-8B4F-4d08-93E2-9B2367E7A0F0%7D.png">图 5-29</li><li>B 收到连接释放报文段后即发出确认，确认号是 ack＝u＋1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。然后 B 就进入 CLOSE-WAIT (关闭等待) 状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于<strong>半关闭</strong>状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。</li><li>A 收到来自 B 的确认后，就进入 FIN-WAIT-2 (终止等待2) 状态，等待 B 发出的连接释放报文段。</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN＝1。假定 B 的序号为 w (在半关闭状态 B 可能又发送了一些数据)。B 还必须重复上次已发送过的确认号 ack＝u＋1。这时 B 就进入 LAST-ACK (最后确认) 状态，等待 A 的确认。</li><li>A 在收到 B 的连接释放报文段后，对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack＝w＋1，而自己的序号是 seq＝u＋1 (根据 TCP 标准，前面发送过的 FIN 报文段要消耗一个序号)。然后进入到 TIME-WAIT (时间等待) 状态。现在 TCP 连接还没有释放掉。必须经过<strong>时间等待计时器</strong>设置的时间 2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做<strong>最长报文段寿命</strong>。从 A 进入到 TIME-WAIT 状态后，要经过 4 分钟才能进入到 CLOSED 状态，才能开始建立下一个新的连接。当 A 撤销相应的传输控制块 TCB 后，就结束了 TCP 连接。</li></ol></li></ul><h2 id="5-9-3-TCP-的有限状态机"><a href="#5-9-3-TCP-的有限状态机" class="headerlink" title="5.9.3 TCP 的有限状态机"></a>5.9.3 TCP 的有限状态机</h2><ul><li>为了更清晰地看出 TCP 连接的各种状态之间的关系，图 5-30 给出了 TCP 的有限状态机。图中每一个方框即 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。图中有三种不同的箭头，粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，另一种细线箭头表示异常变迁。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_%7B4FCAAF4F-C6ED-46fa-ADF1-31A8D0D139AF%7D.png"></li></ol></li></ul><h1 id="本章重要概念"><a href="#本章重要概念" class="headerlink" title="本章重要概念"></a>本章重要概念</h1><ul><li><p>运输层提供应用进程间的逻辑通信，运输层之间的通信并不是真正在两个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节 (如网络拓扑、所采用的路由选择协议等)，使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p></li><li><p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</p></li><li><p>运输层有两个主要的协议：TCP 和 UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的 (只提供尽最大努力服务)，但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。</p></li><li><p>运输层用一个 16 位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。</p></li><li><p>两台计算机中的进程要互相通信，不仅要知道对方的 IP 地址 (为了找到对方的计算机)，而且还要知道对方的端口号 (为了找到对方计算机中的应用进程)。</p></li><li><p>运输层的端口号分为服务器端使用的端口号 (0～1023 指派给熟知端口，1024～49151 是登记端口号) 和客户端暂时使用的端口号 (49152～65535)。</p></li><li><p>UDP 的主要特点是：</p><ol><li>无连接；</li><li>尽最大努力交付；</li><li>面向报文；</li><li>无拥塞控制；</li><li>支持一对一、一对多、多对一和多对多的交互通信；</li><li>首部开销小 (只有四个字段：源端口、目的端口、长度、检验和)。</li></ol></li><li><p>TCP 的主要特点是：</p><ol><li>面向连接；</li><li>每一条 TCP 连接只能是点对点的 (一对一)；</li><li>提供可靠交付的服务；</li><li>提供全双工通信；</li><li>面向字节流。</li></ol></li><li><p>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字 (socket) 或插口。套接字用 (IP地址：端口号) 来表示。</p></li><li><p>停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组，分组需要进行编号。</p></li><li><p>超时重传指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p></li><li><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，同时还要发送确认。</p></li><li><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已正确收到了。</p></li><li><p>TCP 报文段首部的前 20 个字节是固定的，后面有 4<em>N</em> 字节是根据需要而增加的选项。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。</p></li><li><p>TCP 首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 <em>N</em>，则表明：到序号 <em>N</em>-1 为止的所有数据都已正确收到。</p></li><li><p>TCP 首部中的窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着的。</p></li><li><p>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动 (没有收到新的确认) 和前移 (收到了新的确认)。发送窗口前沿通常是不断向前移动的。</p></li><li><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p></li><li><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</p></li><li><p>流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p></li><li><p>为了进行拥塞控制，TCP 的发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p></li><li><p>TCP 的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网络层，也可以使路由器采用适当的分组丢弃策略 (如主动队列管理 AQM)，以减少网络拥塞的发生。</p></li><li><p>运输连接有三个阶段，即连接建立、数据传送和连接释放。</p></li><li><p>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 的连接建立采用三报文握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。</p></li><li><p>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后就进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接。</p></li><li><p>为什么说 UDP 面向报文，TCP 面向字节流？</p><blockquote><p>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP 一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。反之，若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。<br>(1) UDP 被称为”面向报文”的协议，因为它将数据视为独立的报文，而不是连续的字节流。每个UDP 报文都是一个独立的数据包，UDP 对报文的处理是原封不动地发送和接收，不保证它们的顺序，也不提供重传机制。每个 UDP 报文都是一个独立的实体，它们之间没有关联。<br>UDP 适用于一些实时性要求高、可以容忍一些数据丢失的应用场景，比如实时音视频传输、在线游戏等。<br>(2) TCP 则被称为”面向字节流”的协议，因为它将数据视为一个连续的字节流，而不是离散的报文。TCP 负责将应用层的数据划分为合适的数据块，然后将这些数据块封装为 TCP 报文段进行传输。在接收端，TCP 会负责重组这些字节流，确保按顺序交付给应用层。<br>TCP 提供了可靠的、面向连接的服务，通过序列号和确认机制保证数据的可靠传输，并能够处理数据的重传、流量控制和拥塞控制等问题。<br>TCP 适用于对数据可靠性和顺序性要求较高的应用，比如文件传输、网页访问等。</p></blockquote></li><li><p>为什么 UDP 首部中没有首部长度字段，而 TCP 首部中却有？</p><blockquote><p>UDP 数据报首部长度是固定的，不需要这个字段。<br>TCP 报文段除了固定长度的首部之外，还有选项字段，因此 TCP 报文段的首部长度是可变的。(TCP 报文段的首部长度字段就是“数据偏移”)</p></blockquote></li><li><p>流量控制与拥塞控制的主要区别是什么？发送窗口的大小取决于流量控制还是拥塞控制</p><blockquote><p>简单地说，流量控制是在一条 TCP 连接中的接收端采用的措施，用来限制对方 (发送端) 发送报文段的速率，以免在接收端来不及接收。流量控制只控制一个发送端。<br>拥塞控制是用来控制 TCP 连接中发送端发送报文段的速率，以免使互联网中的某处产生过载。拥寒控制可能会同时控制许多个发送端，限制它们的发送速率。不过每一个发送端只知道自己应当怎样调整发送速率，而不知道在互联网中还有哪些主机被限制了发送速率。<br>发送窗口的上限值是 Min[rwnd,cwnd]，即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个。接收窗口的大小体现了接收端对发送端施加的流量控制，而拥寨窗口的大小则是整个互联网的负载情况对发送端施加的拥寒控制。因此，当接收窗口小于拥塞窗口时，发送窗口的大小取决于流量控制，即取决于接收端的接收能力。但当拥塞窗口小于接收窗口时，则发送窗口的大小取决于拥塞控制，即取决于整个网络的拥塞状况。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概述</title>
      <link href="/2023/11/27/gai-shu/"/>
      <url>/2023/11/27/gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-计算机网络在信息时代中的作用"><a href="#1-1-计算机网络在信息时代中的作用" class="headerlink" title="1.1 计算机网络在信息时代中的作用"></a>1.1 计算机网络在信息时代中的作用</h1><ul><li>互联网具有两个重要基本特点，<strong>连通性</strong>和<strong>共享</strong>。<ol><li>连通性：互联网使上网用户之间，不管相距多远，都可以非常便捷、非常经济地交换各种信息。</li><li>共享指<strong>资源共享</strong>。资源共享可以是信息共享、软件共享，也可以是硬件共享。</li></ol></li></ul><h1 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h1><h2 id="1-2-1-网络的网络"><a href="#1-2-1-网络的网络" class="headerlink" title="1.2.1 网络的网络"></a>1.2.1 网络的网络</h2><ul><li><strong>计算机网络</strong>（简称为<strong>网络</strong>）由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。网络中的结点可以是计算机、集线器、交换机或路由器等。图 1-1(a) 给出了一个具有四个结点和三条链路的网络。有三台计算机通过三条链路连接到一个集线器上，构成了一个简单的计算机网络。可以用一朵云表示一个网络。</li><li>网络之间通过路由器互连起来，构成覆盖范围更大的计算机网络。这样的网络称为<strong>互连网</strong>，如图1-1(b) 所示。因此互连网是“<strong>网络的网络</strong>”。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630153611.png"></li><li><strong>网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机。</strong></li></ul><h2 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 <strong>互联网基础结构发展的三个阶段</strong></h2><ul><li>第一阶段是从单个网络 ARPANET 向互连网发展的过程。</li><li>第二阶段的特点是建成了<strong>三级结构的互联网</strong>。</li><li>第三阶段的特点是逐渐形成了<strong>多层次 ISP 结构的互联网</strong>。</li></ul><h2 id="1-2-3-互联网的标准化工作"><a href="#1-2-3-互联网的标准化工作" class="headerlink" title="1.2.3 互联网的标准化工作"></a>1.2.3 <strong>互联网的标准化工作</strong></h2><ul><li>国际性组织<strong>互联网协会</strong> (简称 ISOC)，对互联网进行全面管理以及在世界范围内促进其发展和使用。ISOC 下面有一个技术组织叫做<strong>互联网体系结构委员会</strong> (简称 IAB)，负责管理互联网有关协议的开发。IAB 下面又设有两个工程部：<ol><li><strong>互联网工程部</strong>（简称 IETF）</li><li><strong>互联网研究部</strong>（简称 IRTF）</li></ol></li><li>制定互联网的正式标准要经过以下三个阶段：<ol><li><strong>互联网草案</strong>——互联网草案的有效期只有六个月。在这个阶段还不能算是 RFC 文档。</li><li><strong>建议标准</strong>——从这个阶段开始就成为 RFC 文档。</li><li><strong>互联网标准</strong>——达到正式标准后，每个标准就分配到一个编号 STD xx。一个标准可以和多个RFC 文档关联。截止到 2016 年 7 月，互联网标准的最大编号是 STD 83。</li></ol></li></ul><h1 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h1><ul><li>互联网的拓扑结构非常复杂，并且覆盖了全球，从工作方式上看，划分为以下两大块：<ol><li><strong>边缘部分</strong>：由所有连接在互联网上的主机组成。<strong>用户直接使用</strong>，用来进行通信和资源共享。</li><li><strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。<strong>为边缘部分提供服务的</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630205219.png"></li></ol></li></ul><h2 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 <strong>互联网的边缘部分</strong></h2><ol><li><strong>计算机之间通信</strong>：<strong>主机 A 的某个进程和主机 B 上的另一个进程进行通信</strong></li><li><strong>客户——服务器方式</strong><ul><li><strong>客户</strong>和<strong>服务器</strong>是指通信中所涉及的两个应用进程。客户——服务器方式所描述的是进程之间服务和被服务的关系。</li><li><strong>客户是服务请求方，服务器是服务提供方。</strong></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630205735.png"></li><li><strong>客户程序：</strong><ol><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和复杂的操作系统。</li></ol></li><li><strong>服务器程序：</strong><ol><li>是一种用来提供某种服务的程序，<strong>可同时处理</strong>多个远地或本地客户的请求。</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。服务器程序不需要知道客户程序的地址。</li><li>需要有强大的硬件和高级的操作系统支持。</li></ol></li></ul></li><li><strong>对等连接方式</strong><ul><li><strong>对等连接</strong> (简称 P2P) 指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机运行了对等连接软件 (P2P 软件)，就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。因此这种工作方式也称为 <strong>P2P 方式</strong> 。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630223247.png"></li></ul></li></ol><h2 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2 互联网的核心部分"></a>1.3.2 互联网的核心部分</h2><ol><li>在网络核心部分起特殊作用的是<strong>路由器</strong>，是一种专用计算机。路由器是实现<strong>分组交换</strong>的关键构件，任务是<strong>转发收到的分组</strong>，是网络核心部分最重要的功能。</li><li><strong>电路交换的主要特点</strong><ul><li>从通信资源的分配角度来看，<strong>交换</strong>是按照某种方式动态地分配传输线路的资源</li><li>必须经过“<strong>建立连接</strong> (占用通信资源) →<strong>通话</strong> (一直占用通信资源) →<strong>释放连接</strong> (归还通信资源) ”三个步骤的交换方式称为<strong>电路交换</strong>。</li><li><strong>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</strong>。</li><li>使用电路交换来传送计算机数据时，<strong>线路的传输效率很低</strong>。因为计算机数据是突发式地出现在传输线路上的，因此线路上真正用来传送数据的时间很短。已被用户占用的通信线路资源在绝大部分时间里都是空闲的。</li></ul></li><li><strong>分组交换的主要特点</strong><ul><li>分组交换采用<strong>存储转发</strong>技术。</li><li>把要发送的整块数据称为一个<strong>报文</strong>。在发送报文前，把较长的报文划分成为一个个更小的等长数据段。在每一个数据段前，加上由必要的控制信息组成的<strong>首部</strong> (包头) 后，构成一个<strong>分组</strong> (包)。分组是在互联网中传送的数据单元。分组的首部包含目的地址和源地址等，使分组能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</li><li>位于网络边缘的主机和位于网络核心部分的路由器都是计算机，但作用不一样。<strong>主机是为用户进行信息处理的</strong>，并且可以和其他主机通过网络交换信息。<strong>路由器则是用来转发分组的，进行分组交换的</strong>。路由器收到一个分组，先暂时存储，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地以存储转发的方式，把分组交付最终的目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</li><li><strong>分组交换的优点</strong>：<ol><li>高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</li><li>灵活：为每一个分组选择合适的转发路由</li><li>迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性</li></ol></li><li><strong>分组交换的缺点</strong>：<ol><li>分组在各路由器存储转发时需要排队，会造成<strong>时延</strong>。由于分组交换不像电路交换那样通过建立连接来保证通信时所需的各种资源，因而无法确保通信时端到端所需的带宽。</li><li>各分组必须携带的控制信息造成了<strong>开销</strong>。分组交换网需要专门的管理和控制机制。</li></ol></li></ul></li></ol><ul><li>三种交换的比较<ol><li><strong>电路交换</strong>——整个报文的比特流连续地从源点直达终点</li><li><strong>报文交换</strong>——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li><li><strong>分组交换</strong>——单个分组 (这只是整个报文的一部分) 传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701111637.png"></li></ol></li></ul><h1 id="1-4-计算机网络在我国的发展"><a href="#1-4-计算机网络在我国的发展" class="headerlink" title="1.4 计算机网络在我国的发展"></a>1.4 计算机网络在我国的发展</h1><h1 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h1><h2 id="1-5-1-计算机网络的定义"><a href="#1-5-1-计算机网络的定义" class="headerlink" title="1.5.1 计算机网络的定义"></a>1.5.1 计算机网络的定义</h2><ul><li><strong>计算机网络的定义</strong><ol><li>计算机网络：计算机网络主要是由一些通用的、可编程的硬件互连而成的，这些硬件并非专门用来实现某一特定目的，它们能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，还包括了智能手机；计算机网络并非专门用来传送数据，还能支持很多种的应用。</li></ul></li></ol></li></ul><h2 id="1-5-2-几种不同类别的计算机网络"><a href="#1-5-2-几种不同类别的计算机网络" class="headerlink" title="1.5.2 几种不同类别的计算机网络"></a>1.5.2 几种不同类别的计算机网络</h2><ul><li><strong>几种不同类别的计算机网络</strong><ol><li><strong>按照网络的作用范围进行分类</strong><ul><li><strong>广域网</strong> (WAN) 作用范围通常为几十到几千公里，也称<strong>远程网</strong>。广域网是互联网的核心部分，任务是长距离运送主机所发送的数据。连接广域网各结点交换机的链路一般都是高速链路，具有较大的通信容量。</li><li><strong>城域网</strong> (MAN) 作用范围一般是城市，跨越几个街区甚至整个城市，作用距离约为 5～50km。城域网可以为一个或几个单位所拥有，也可以是一种公用设施，用来将多个局域网进行互连。目前很多城域网采用的是以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li><strong>局域网</strong> (LAN) 一般用微型计算机或工作站通过高速通信线路相连 (速率通常在10Mbit&#x2F;s 以上)，但地理上则局限在较小的范围 (如 1km 左右)。在局域网发展的初期，一个学校或工厂往往只拥有一个局域网，但现在局域网已非常广泛地使用，学校或企业大都拥有许多个互连的局域网 (这样的网络常称为<strong>校园网</strong>或<strong>企业网</strong>)。</li><li><strong>个人区域网</strong> (PAN) 在个人工作的地方把属于个人使用的电子设备 (如便携式电脑) 用无线技术连接起来的网络，因此也常称为<strong>无线个人区域网</strong> (WPAN)，其范围很小，大约在10m左右。</li></ul></li><li><strong>按照网络的使用者进行分类</strong><ul><li><strong>公用网</strong>：电信公司 (国有或私有) 出资建造的大型网络。“公用”的意思就是所有愿意按电信公司的规定交纳费用的人都可以使用这种网络。因此公用网也可称为<strong>公众网</strong>。</li><li><strong>专用网</strong>：某个部门为满足本单位的特殊业务工作的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如，军队、铁路、银行、电力等系统均有本系统的专用网。</li></ul></li><li><strong>用来把用户接入到互联网的网络</strong><ul><li><strong>接入网</strong> (AN)，又称为<strong>本地接入网</strong>或<strong>居民接入网</strong></li><li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。是从某个用户端系统到互联网中的第一个路由器之间的一种网络。</li></ul></li></ol></li></ul><h1 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h1><h2 id="1-6-1-计算机网络的性能"><a href="#1-6-1-计算机网络的性能" class="headerlink" title="1.6.1 计算机网络的性能"></a>1.6.1 计算机网络的性能</h2><ul><li><strong>计算机网络的性能指标</strong><ol><li>速率<ul><li><strong>比特</strong>来源于 binary digit，意思是一个“<strong>二进制数字</strong>”，因此一个比特就是二进制数字中的一个 1 或 0。</li><li>比特也是信息论中使用的<strong>信息量的单位</strong>。网络技术中的<strong>速率</strong>指的是<strong>数据的传送速率</strong>，它也称为<strong>数据率</strong>或<strong>比特率</strong>。</li></ul></li><li><strong>带宽</strong><ul><li>带宽本指某个<strong>信号具有的频带宽度</strong>。信号的带宽指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的<strong>带宽的单位</strong>是<strong>赫</strong> (或<strong>千赫、兆赫、吉赫</strong>等)。表示某信道允许通过的信号频带范围称为该信道的<strong>带宽</strong> (<strong>通频带</strong>)。</li><li>在计算机网络中，带宽用来表示网络中某<strong>通道</strong>传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“<strong>最高数据率</strong>”。这种意义的<strong>带宽的单位</strong>就是<strong>数据率的单位</strong> bit&#x2F;s，是<strong>比特每秒</strong>。</li><li>在“带宽”的上述两种表述中，前者为<strong>频域</strong>称谓，而后者为<strong>时域</strong>称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</li></ul></li><li><strong>吞吐量</strong><ul><li><strong>吞吐量</strong>表示在单位时间内通过某个网络的实际的数据量。</li><li>吞吐量受网络的带宽或网络的额定速率的限制。</li></ul></li><li><strong>时延</strong><ul><li><strong>时延</strong>指数据从网络的一端传送到另一端所需的时间。</li><li>时延是很重要的性能指标，有时也称为延迟或迟延。</li><li>时延由以下组成：<ol><li><strong>发送时延</strong>　发送时延是主机或路由器发送数据帧所需要的时间，从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。因此发送时延也叫做<strong>传输时延</strong>。发送时延的计算公式是：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701153549.png"></li><li>发送时延并非固定不变，而是与发送的帧长成正比，与发送速率成反比。</li></ul></li><li><strong>传播时延</strong>　传播时延是电磁波在信道中传播一定的距离需要花费的时间。传播时延的计算公式是：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701153757.png"></li><li>发送时延发生在机器内部的发送器中，<strong>与传输信道的长度 (或信号传送的距离) 没有关系</strong>。传播时延发生在机器外部的传输信道媒体上，<strong>与信号的发送速率无关</strong>。<strong>信号传送的距离越远，传播时延就越大</strong>。</li></ul></li><li><strong>处理时延</strong> 　主机或路由器在收到分组时要花费时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。</li><li><strong>排队时延</strong> 　分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。排队时延的长短往往取决于网络当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大。</li><li>数据在网络中经历的总时延就是四种时延之和：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702225623.png"></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702163416.png"></li><li><strong>对于高速网络链路，提高的仅是数据的发送速率而不是比特在链路上的传播速率</strong>。</li><li><strong>提高数据的发送速率减小了数据的发送时延</strong>。数据的发送速率的单位是每秒发送多少个比特，指在<strong>某个点</strong>或<strong>某个接口上</strong>的发送速率。而传播速率的单位是每秒传播多少公里，指在<strong>某一段传输线路上</strong>比特的传播速率。</li></ol></li></ul></li><li><strong>时延带宽积</strong><ul><li>把网络性能的两个度量——传播时延和带宽相乘，就得到另一个度量：传播<strong>时延带宽积</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702163707.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164122.png"></li></ol></li><li>若发送端连续发送数据，则在发送的第一个比特即将达到终点时，发送端就已经发送了20 万个比特，而这 20 万个比特都正在链路上向前移动。因此，链路的时延带宽积又称为<strong>以比特为单位的链路长度</strong>。</li></ul></li><li><strong>往返时间 RTT</strong><ul><li>互联网上的信息不是单向传输而是双向交互的。</li><li>A 向 B 发送数据。如果数据长度是 100MB，发送速率是 100Mbit&#x2F;s，那么<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164237.png"></li><li>如果 B 正确收完 100MB 的数据后，就立即向 A 发送确认。再假定 A 只有在收到 B 的确认信息后，才能继续向 B 发送数据。显然，这需要等待一个往返时间 RTT (这里假定确认信息很短，可忽略 B 发送确认的时间)。如果 RTT＝2s，那么可以算出 A 向 B 发送数据的有效数据率。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164313.png"></li></ol></li></ul></li><li><strong>利用率</strong><ul><li><strong>利用率</strong>有信道利用率和网络利用率两种。<ol><li>信道利用率指出某信道有百分之几的时间是被利用的。完全空闲的信道利用率是零。</li><li>网络利用率是全网络信道利用率的加权平均值。</li><li>信道利用率并非越高越好。根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也迅速增加。和高速公路的情况有些相似。当高速公路上的车流量很大时，由于在公路上的某些地方会出现堵塞，因此行车所需的时间就会变长。同样，当网络的通信量很少时，网络产生的时延并不大。但在网络通信量不断增大的情况下，由于分组在网络结点、进行处理时需要排队等候，因此网络引起的时延就会增大。</li></ol></li><li>如果令 <em>D<sub>0</sub></em> 表示网络空闲时的时延，<em>D</em> 表示网络当前的时延，用下面的公式来表示 <em>D</em>，<em>D<sub>0</sub></em> 和利用率 <em>U</em> 之间的关系：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702165329.png"></li><li><em>U</em> 是网络的利用率，数值在 0 到 1 之间。当网络的利用率达到其容量的 1&#x2F;2 时，时延就要加倍。</li><li>当网络的利用率接近最大值 1 时，网络的时延就趋于无穷大。</li><li><strong>信道或网络的利用率过高会产生非常大的时延</strong></li><li>一些拥有较大主干网的 ISP 通常控制信道利用率不超过 50％。如果超过了就要准备扩容，增大线路的带宽。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702205609.png"></li></ol></li></ul></li></ol></li></ul><h2 id="1-6-2-计算机网络的非性能特征"><a href="#1-6-2-计算机网络的非性能特征" class="headerlink" title="1.6.2 计算机网络的非性能特征"></a>1.6.2 计算机网络的非性能特征</h2><ul><li><strong>计算机网络的非性能特征</strong><ol><li><strong>费用</strong><ul><li>网络的性能与其价格密切相关。网络的速率越高，价格也越高。</li></ul></li><li><strong>质量</strong><ul><li>网络的质量取决于网络中所有构件的质量，以及这些构件是怎样组成网络的。网络的质量影响很多方面，如网络的可靠性、网络管理的简易性，以及网络的性能。但网络的性能与网络的质量并不一样。</li></ul></li><li><strong>标准化</strong><ul><li>网络的硬件和软件的设计既可以按照通用的国际标准，也可以遵循特定的专用网络标准。采用国际标准的设计，可以得到更好的互操作性，更易于升级换代和维修，也更容易得到技术上的支持。</li></ul></li><li><strong>可靠性</strong><ul><li>可靠性与网络的质量和性能密切相关。高速网络的可靠性不一定很差。但高速网络要可靠地运行，则往往更加困难，同时所需的费用也会较高。</li></ul></li><li><strong>可扩展性和可升级性</strong><ul><li>在构造网络时应当考虑到今后需要扩展和升级。网络的性能越高，其扩展费用往往也越高，难度也会相应增加。</li></ul></li><li><strong>易于管理和维护</strong><ul><li>网络如果没有良好的管理和维护，很难达到和保持所设计的性能。</li></ul></li></ol></li></ul><h1 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h1><ul><li>在计算机网络的基本概念中，分层次的体系结构是最基本的。</li></ul><h2 id="1-7-1-计算机网络体系结构的形成"><a href="#1-7-1-计算机网络体系结构的形成" class="headerlink" title="1.7.1 计算机网络体系结构的形成"></a>1.7.1 计算机网络体系结构的形成</h2><ul><li><strong>计算机网络体系结构的形成</strong><ol><li>计算机网络是个复杂的系统。、设想一种最简单的情况：连接在网络上的两台计算机要互相传送文件。在这两台计算机之间必须有一条传送数据的通路。但还有以下工作需要完成：<ul><li>发起通信的计算机必须将数据通信的通路进行<strong>激活</strong>，即发出一些信令，保证要传送的计算机数据能在这条通路上正确发送和接收。</li><li>要告诉网络如何识别接收数据的计算机。</li><li>发起通信的计算机必须查明对方计算机是否已开机，并且与网络连接正常。</li><li>发起通信的计算机中的应用程序必须清楚，在对方计算机中的文件管理程序是否已做好接收文件和存储文件的准备工作。</li><li>若计算机的文件格式不兼容，则至少其中一台计算机应完成格式转换功能。</li><li>对出现的各种差错和意外事故，如数据传送错误、重复或丢失，网络中某个结点交换机出现故障等，应当有可靠的措施保证对方计算机最终能够收到正确的文件。</li></ul></li></ol></li></ul><h2 id="1-7-2-协议与划分层次"><a href="#1-7-2-协议与划分层次" class="headerlink" title="1.7.2 协议与划分层次"></a>1.7.2 协议与划分层次</h2><ul><li><strong>协议与划分层次</strong><ol><li>在计算机网络中要做到有条不紊地交换数据，必须遵守一些事先约定好的规则。<strong>这些规则明确规定了所交换的数据的格式以及有关的同步问题</strong>。</li><li><strong>为进行网络中的数据交换而建立的规则、标准或约定</strong>称为<strong>网络协议</strong>。网络协议也可简称为<strong>协议</strong>，主要由以下三个要素组成：<ul><li>语法，即数据与控制信息的结构或格式；</li><li>语义，即需要发出何种控制信息，完成何种动作以及做出何种响应；</li><li>同步，即事件实现顺序的详细说明。</li></ul></li><li>协议通常有两种不同的形式。一种是使用便于人来阅读和理解的文字描述。另一种是使用让计算机能够理解的程序代码。这两种不同形式的协议都必须能够对网络上的信息交换过程做出精确的解释。</li><li>分层可以带来很多好处。如：<ul><li><strong>各层之间是独立的</strong>。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。整个问题的复杂程度就下降了。</li><li><strong>灵活性好</strong>。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某一层提供的服务还可进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。</li><li><strong>结构上可分割开</strong>。各层都可以采用最合适的技术来实现。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。</li><li><strong>能促进标准化工作</strong>。因为每一层的功能及其所提供的服务都已有了精确的说明。</li></ul></li><li>分层时应使每一层的功能非常明确。若层数太少，就会使每一层的协议太复杂。但层数太多又会在描述和综合各层功能的系统工程任务时遇到较多的困难。通常各层所要完成的功能主要有以下一些：<ul><li><strong>差错控制</strong> 　使相应层次对等方的通信更加可靠。</li><li><strong>流量控制</strong> 　发送端的发送速率必须使接收端来得及接收，不能太快。</li><li><strong>分段和重装</strong> 　发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><strong>复用和分用</strong> 　发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><strong>连接建立和释放</strong> 　交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li><li>分层也有一些缺点，例如，有些功能会在不同的层次中重复出现，产生额外开销。</li></ul></li><li><strong>计算机网络的各层及其协议的集合</strong>就是网络的<strong>体系结构</strong>。换种说法，<strong>计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义</strong>。</li><li><strong>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件</strong>。</li></ol></li></ul><h2 id="1-7-3-具有五层协议的体系结构"><a href="#1-7-3-具有五层协议的体系结构" class="headerlink" title="1.7.3 具有五层协议的体系结构"></a>1.7.3 具有五层协议的体系结构</h2><ul><li><strong>具有五层协议的体系结构</strong><ol><li><strong>应用层</strong><ul><li>应用层是体系结构中的最高层。</li><li>应用层的任务是<strong>通过应用进程间的交互来完成特定网络应用</strong>。</li><li>应用层协议定义的是<strong>应用进程间通信和交互的规则</strong>。<strong>进程</strong>指主机中<strong>正在运行的程序</strong>。</li><li>应用层交互的数据单元称为<strong>报文</strong>。</li></ul></li><li><strong>运输层</strong><ul><li>运输层的任务是负责向<strong>两台主机中进程之间的通信</strong>提供<strong>通用的数据传输</strong>服务。</li><li>运输层主要使用以下两种协议：<ol><li><strong>传输控制协议</strong> (TCP)——提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>。</li><li><strong>用户数据报协议</strong> (UDP)——提供无连接的、<strong>尽最大努力</strong>的数据传输服务，其数据传输的单位是<strong>用户数据报</strong>。</li></ol></li></ul></li><li><strong>网络层</strong><ul><li>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。</li><li>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成<strong>分组</strong>或<strong>包</strong>进行传送。</li><li>在 TCP&#x2F;IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 <strong>IP 数据报</strong>，简称<strong>数据报</strong>。</li><li><strong>无论在哪一层传送的数据单元，都可笼统地用“分组”来表示</strong>。</li><li>网络层的另一个任务是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</li><li>网络层中的“<strong>网络</strong>”，不是我们谈到的具体网络，而是在计算机网络体系结构模型中的第 3 层的名称。</li><li>互联网是由大量的<strong>异构</strong>网络通过<strong>路由器</strong>相互连接起来的，使用的网络层协议是无连接的<strong>网际协议</strong> (IP) 和许多种路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或 <strong>IP 层</strong>。</li></ul></li><li><strong>数据链路层</strong><ul><li>数据链路层简称<strong>链路层</strong>。</li><li>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报<strong>组装成帧</strong>，在两个相邻结点间的链路上传送<strong>帧</strong>。每一帧包括数据和<strong>控制信息</strong>。</li></ul></li><li><strong>物理层</strong><ul><li>在物理层上所传数据的单位是<strong>比特</strong>。</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703110014.png"></li><li>图1-19 说明应用进程的数据在各层之间的传递过程中所经历的变化。假定两台主机通过一台路由器连接起来。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703110122.png"></li><li>假定主机1的应用进程AP 1 向主机2的应用进程AP 2 传送数据。AP 1 先将其数据交给本主机的第5层（应用层）。第5层加上必要的控制信息H 5 就变成了下一层的数据单元。第4层（运输层）收到这个数据单元后，加上本层的控制信息H 4 ，再交给第3层（网络层），成为第3层的数据单元。依此类推。不过到了第2层（数据链路层）后，控制信息被分成两部分，分别加到本层数据单元的首部（H 2 ）和尾部（T 2 ）；而第1层（物理层）由于是比特流的传送，所以不再加上控制信息。请注意，传送比特流时应从首部开始传送。</li><li>OSI参考模型把对等层次之间传送的数据单位称为该层的<strong>协议数据单元</strong>（PDU）。这个名词现已被许多非OSI标准采用。</li><li>当这一串的比特流离开主机1经网络的物理媒体传送到路由器时，就从路由器的第1层依次上升到第3层。每一层都根据控制信息进行必要的操作，然后将控制信息剥去，将该层剩下的数据单元上交给更高的一层。当分组上升到了第3层时，就根据首部中的目的地址查找路由器中的转发表，找出转发分组的接口，然后往下传送到第2层，加上新的首部和尾部后，再到最下面的第1层，然后在物理媒体上把每一个比特发送出去。</li><li>当这一串的比特流离开路由器到达目的站主机2时，就从主机2的第1层按照上面讲过的方式，依次上升到第5层。最后，把应用进程AP 1 发送的数据交给目的站的应用进程AP 2 。</li><li>可以用一个简单例子来比喻上述过程。有一封信从最高层向下传。每经过一层就包上一个新的信封，写上必要的地址信息。包有多个信封的信件传送到目的站后，从第1层起，每层拆开一个信封后就把信封中的信交给它的上一层。传到最高层后，取出发信人所发的信交给收信人。</li><li>虽然应用进程数据要经过如图1-19所示的复杂过程才能送到终点的应用进程，但这些复杂过程对用户来说，却都被屏蔽掉了，以致应用进程AP 1 觉得好像是直接把数据交给了应用进程AP 2 。同理，任何两个同样的层次（例如在两个系统的第4层）之间，也好像如同图1-19中的水平虚线所示的那样，把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“<strong>对等层</strong> ”（peer layers）之间的通信。我们以前经常提到的各层协议，实际上就是在各个对等层之间传递数据时的各项规定。</li><li>在文献中也还可以见到术语“<strong>协议栈</strong>”。这是因为几个层次画在一起很像一个<strong>栈</strong>的结构。</li></ul></li></ol></li></ul><h2 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h2><ul><li><strong>实体、协议、服务和服务访问点</strong><ol><li>当研究开放系统中的信息交换时，使用<strong>实体</strong>这一抽象的名词表示<strong>任何可发送或接收信息的硬件或软件进程</strong>。</li><li><strong>协议是控制两个对等实体</strong> (或<strong>多个实体</strong>) <strong>进行通信的规则的集合</strong>。协议的语法方面规则定义了所交换信息的格式，协议的语义方面规则定义了发送者或接收者所要完成的操作，例如，在何种条件下，数据必须重传或丢弃。</li><li><strong>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</strong></li><li>协议和服务在概念上不一样：<ul><li>协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。下面的协议对上面的实体是透明的。</li><li><strong>协议是“水平的”</strong>，协议是控制对等实体之间通信的规则；但<strong>服务是“垂直的”</strong>，即服务是由下层向上层通过层间接口提供的。</li><li>并非在一个层内完成的全部功能都称为服务。只有能够被高一层实体“<strong>看得见</strong>”的功能才能称之为“服务”。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在 OSI 中称为<strong>服务原语</strong>。</li><li>在同一系统中相邻两层的实体进行交互的地方，通常称为<strong>服务访问点</strong> (SAP)。服务访问点 SAP 是一个抽象的概念，是一个逻辑接口，有点像邮政信箱 (可以把邮件放入信箱和从信箱中取走邮件)，但这种层间接口和两个设备之间的硬件接口并不一样。</li><li>在任何相邻两层之间的关系可概括为图 1-20 所示的那样。第 n 层的两个“实体 (n) ”之间通过“协议 (n) ”进行通信，而第 n＋1 层的两个“实体 (n＋1) ”之间则通过另外的“协议 (n＋1) ”进行通信 (每一层都使用不同的协议) 。第 n 层向上面的第 n＋1 层所提供的服务实际上已包括了在它以下各层所提供的服务。第 n 层的实体对第 n+1 层的实体就相当于一个服务提供者。在服务提供者的上一层的实体又称为“服务用户”，因为它使用下层服务提供者所提供的服务。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703113458.png"></li></ol></li></ul></li></ol></li></ul><h2 id="1-7-5-TCP-IP-的体系结构"><a href="#1-7-5-TCP-IP-的体系结构" class="headerlink" title="1.7.5 TCP&#x2F;IP 的体系结构"></a>1.7.5 TCP&#x2F;IP 的体系结构</h2><ul><li><strong>TCP&#x2F;IP 的体系结构</strong><ol><li>TCP&#x2F;IP 协议<strong>可以为应用提供服务</strong>，同时 TCP&#x2F;IP 协议也<strong>允许 IP 协议在网络构成的互联网上运行</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703152732.png"></li></ol></li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>计算机网络把计算机连接在一起，互连网把网络连接在一起，是网络的网络。</p></li><li><p>以小写字母 i 开始的 internet (互连网) 是通用名词，泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</p></li><li><p>以大写字母 I 开始的 Internet (互联网) 是专用名词，指当前全球最大的、开放的、由网络相互连接而成的特定互连网，并采用 TCP&#x2F;IP 协议族作为通信规则。</p></li><li><p>互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。</p></li><li><p>互联网按工作方式划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</p></li><li><p>计算机通信是计算机中进程之间的通信。计算机网络采用的通信方式是客户–服务器方式和对等连接方式 (P2P 方式)。</p></li><li><p>客户和服务器指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</p></li><li><p>按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和个人区域网 PAN。</p></li><li><p>计算机网络常用的性能指标是：速率、带宽、吞吐量、时延 (发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道 (或网络) 利用率。</p></li><li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p></li><li><p>五层协议的体系结构由应用层、运输层、网络层 (或网际层)、数据链路层和物理层组成。运输层最重要的协议是 TCP 和 UDP 协议，而网络层最重要的协议是 IP 协议。</p></li><li><p>叙述具有五层协议的网络体系结构的要点，包括各层的主要功能。</p><blockquote><p>(1) 物理层一在物理层上所传数据的单位是比特bit)。物理层的任务就是透明地传送比特流。物理层还要确定连接电缆的插头应当有多少根引脚以及各条引脚应如何连接。当然，哪几个比特代表什么意思，则不是物理层所要管的。请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。因此也有人把物理媒体当作第 0 层。<br>(2) 数据链路层一一常简称为链路层。在两个相邻结点之间 (主机和路由器之间或两个路由器之间)传送数据是直接传送的 (即不需要经过转发的点对点通信)。这时就需要使用专门的链路层的协议。数据链路层将网络层交下来的 IP 数据报组装成，在两个相邻结点间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息 (如同步信息、地址信息、差错控制等)。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如果需要改正错误，就由运输层的 TCP 协议来完成。<br>(3) 网络层一网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在 TCP&#x2F;IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 IP 数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。对于由广播信道构成的分组交换网，路由选择的问题很简单，因此这种网络的网络层非常简单，甚至可以没有。<br>(4) 运输层一一运输层的任务就是负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务,分用则是运输层把收到的信息分别交付上面应用层中的相应的进程运输层主要使用以下两种协议: 一个是传输控制协议 TCP，是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。另一个是用户数据报协议 UDP，是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能“尽最大努力交付”。<br>(5) 应用层一一应用层是体系结构中的最高层。应用层直接为用户的应用进程提供服务这里的进程就是指正在运行的程序。在百联网中的应用层协议很多，如支持万维网应用的 HTTP 协议、支持电子邮件的 SMTP 协议、支持文件传送的 FTP 协议，等等。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/18/read/guan-ying/lu-li-qi-ji/"/>
      <url>/2023/11/18/read/guan-ying/lu-li-qi-ji/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/09/read/you-xi/pa-te-li-ke-wu-qiong-xiang-zi-qi-yu-patrick-s-parabox/"/>
      <url>/2023/09/09/read/you-xi/pa-te-li-ke-wu-qiong-xiang-zi-qi-yu-patrick-s-parabox/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/09/read/you-xi/2023-01/guai-wu-xi-ren-shi-jie/"/>
      <url>/2023/09/09/read/you-xi/2023-01/guai-wu-xi-ren-shi-jie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/09/read/you-xi/2023-01/kong-dong-qi-shi/"/>
      <url>/2023/09/09/read/you-xi/2023-01/kong-dong-qi-shi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/09/read/you-xi/xiao-shi-de-guang-mang/"/>
      <url>/2023/09/09/read/you-xi/xiao-shi-de-guang-mang/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hall-A：赛博朋克酒保行动</title>
      <link href="/2023/09/08/hall-a-sai-bo-peng-ke-jiu-bao-xing-dong/"/>
      <url>/2023/09/08/hall-a-sai-bo-peng-ke-jiu-bao-xing-dong/</url>
      
        <content type="html"><![CDATA[<p><strong>调制人生 改变饮料</strong></p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>ingram：看似放荡，实则比较富有学识<br>dorothy haze：开朗可爱的魅魔机器人<br>kim：<br>jamie：独眼杀手<br>kira miki：沉迷于扮演kira而迷失自我的歌星<br>alma：jill的好朋友，好像是黑客？推心置腹，互吐苦水的贝斯特 friend<br>sei：白骑士<br>stella：白骑士的朋友？可爱的富婆<br>art von delay：一名犀利的侦探<br>streaming-chan ：可怜的主动式楚门<br>betty：狗狗公司<br>deal：狗狗公司<br>taylor：一位大脑宅男？<br>virgilio armandio：像个外强中干的变态<br>brian：BTC老大<br>cass：<br>rad shiba：一条柴犬。<br>norma：被过于期待的未成年少女<br>mario：<br>gaby：jill前女友的妹妹<br>nacho：shiba的boss<br>vella：coser<br>essentia：lilim<br>anna：好像是心中的自我？</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>random</title>
      <link href="/2023/09/08/random/"/>
      <url>/2023/09/08/random/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">random.seed(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置完种子后，每次生成的随机数相同</li></ul><pre class="line-numbers language-none"><code class="language-none">random.random()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成0-1的随机浮点数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.randint(strat, stop)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成某一区间的随机整数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.randrange(strat, stop[, step])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成一个在<code>start</code>与<code>stop</code>之间的随机整数，<code>step</code>是随机数之间的不长，<code>step</code>默认为 1 。</li><li><code>random.randrange(0, 10, 2)</code>只能生成0、2、4、6、8中的一个。</li></ul><pre class="line-numbers language-none"><code class="language-none">random.uniform(strat, stop)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成随机浮点数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.choice(seq)random.choice(seq, k)random.sample(seq, k)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>random.choice(seq)</code>用于从序列中获取一个随机元素，并返回一个（列表，元组或字符串中的）随机项，其中参数 <code>seq</code> 是一个非空序列。</li><li><code>random.choice(seq, k)</code>&#x3D;<code>random.sample(seq, k)</code>，表示随机生成<code>k</code>个元素。</li></ul><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>obsidian</title>
      <link href="/2023/09/08/obsidian/"/>
      <url>/2023/09/08/obsidian/</url>
      
        <content type="html"><![CDATA[<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><ul><li>输入<code>[[</code>后，会自动弹出列表对话框，其中包含了笔记名、图片名，选中想要链接的笔记。之后输入<code>^</code>，再次选择笔记中的文本，找到自己想要链接的具体内容；输入<code>|</code>显示链接的名字。在<code>[[]]</code>前加上<code>!</code>会显示出链接的内容。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy</title>
      <link href="/2023/09/08/numpy/"/>
      <url>/2023/09/08/numpy/</url>
      
        <content type="html"><![CDATA[<h5 id="生成数组或序"><a href="#生成数组或序" class="headerlink" title="生成数组或序"></a>生成数组或序</h5><pre class="line-numbers language-none"><code class="language-none">numpy.zeros(shape, dtype&#x3D;float, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>shape</code>：这是一个表示所需数组形状的元组或整数。例如，要创建一个2行3列的零数组，可以使用<code>shape=(2, 3)</code>。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。</li><li>行主序，横为行；列主序，竖为行。<pre class="line-numbers language-none"><code class="language-none">numpy.ones(shape, dtype&#x3D;None, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>shape</code>：这是一个表示所需数组形状的元组或整数。例如，要创建一个2行3列的全1数组，可以使用<code>shape=(2, 3)</code>。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。<pre class="line-numbers language-none"><code class="language-none">numpy.eye(N, M&#x3D;None, k&#x3D;0, dtype&#x3D;float, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>N</code>：矩阵的行数（以及列数，因为单位矩阵是方阵）。这是必需的参数。</li><li><code>M</code>（可选）：矩阵的列数。默认情况下，它等于 <code>N</code>，因此创建的是一个 <code>N x N</code> 的方阵。</li><li><code>k</code>（可选）：对角线的偏移。默认为0，表示主对角线上的元素为1。如果将其设置为正数或负数，将在主对角线上偏离 <code>k</code> 步的位置放置1。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。<pre class="line-numbers language-none"><code class="language-none">numpy.arange([start, ]stop, [step, ]dtype&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>start</code>（可选）：序列的起始值。如果不提供，默认为0。</li><li><code>stop</code>：序列的终止值（不包括该值）。</li><li><code>step</code>（可选）：序列中的值之间的间隔（步长）。如果不提供，默认为1。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下为<code>None</code>，它会自动推断为适当的数据类型。<pre class="line-numbers language-none"><code class="language-none">numpy.linspace(start, stop, num&#x3D;50, endpoint&#x3D;True, retstep&#x3D;False, dtype&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>start</code>：生成的范围的起始值。</li><li><code>stop</code>：生成的范围的结束值。生成的数组将包括此值。</li><li><code>num</code>（可选）：要生成的样本数量，默认为50。</li><li><code>endpoint</code>（可选）：如果为True（默认值），则生成的数组包括<code>stop</code>值；如果为False，生成的数组不包括<code>stop</code>值。</li><li><code>retstep</code>（可选）：如果为True，函数将返回一个元组，其中包括生成的数组和生成的步长值。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>None</code>，这意味着数据类型将根据输入的参数来确定。</li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">numpy.frombuffer(buffer, dtype&#x3D;float, count&#x3D;-1, offset&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>buffer</code>：要从中创建数组的缓冲区对象，通常是字节数组或字节对象。</li><li><code>dtype</code>：可选参数，指定数组的数据类型，默认为 <code>float</code>。你可以指定其他的数据类型，如 <code>int</code>、<code>str</code> 等。</li><li><code>count</code>：可选参数，要从缓冲区中读取的元素数量，默认为 -1，表示读取整个缓冲区的内容。</li><li><code>offset</code>：可选参数，指定从缓冲区的哪个位置开始读取数据，默认为 0，表示从缓冲区的开头开始读取。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pyautogui</title>
      <link href="/2023/09/07/pyautogui/"/>
      <url>/2023/09/07/pyautogui/</url>
      
        <content type="html"><![CDATA[<h5 id="屏幕的分辨率"><a href="#屏幕的分辨率" class="headerlink" title="屏幕的分辨率"></a>屏幕的分辨率</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui  width, height &#x3D; pyautogui.size()  x, y &#x3D; pyautogui.position()    result &#x3D; pyautogui.onScreen(2000, 2222) print(f&quot;宽度：&#123;width&#125;, 高度：&#123;height&#125;&quot;)print(f&quot;&#123;x&#125;, &#123;y&#125;&quot;)print(f&quot;&#123;result&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>print(f&quot;宽度：&#123;width&#125;, 高度：&#123;height&#125;&quot;)</code>中的<code>f</code>将<code>width</code>和<code>height</code>替换成了获取的值，可以将其当成<code>%s</code>的作用。详情见<a href="https://realpython.com/python-f-strings/">f字符串</a></p><h5 id="鼠标的移动"><a href="#鼠标的移动" class="headerlink" title="鼠标的移动"></a>鼠标的移动</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(800, 800, duration&#x3D;2)  pyautogui.move(0, -200, duration&#x3D;0.1)  pyautogui.move(-200, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>duration</code>表示移动持续的时间，不设置<code>duration</code>则默认为0.1。</p><h5 id="拖动鼠标"><a href="#拖动鼠标" class="headerlink" title="拖动鼠标"></a>拖动鼠标</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(700, 530, duration&#x3D;2)  pyautogui.dragTo(1, 1, button&#x3D;&#39;left&#39;, duration&#x3D;2)  pyautogui.drag(100, 400, button&#x3D;&#39;right&#39;, duration&#x3D;2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dragTo</code>是拖动到某个点，<code>drag</code>是向某个方向拖动多少像素。</p><h5 id="鼠标的点击"><a href="#鼠标的点击" class="headerlink" title="鼠标的点击"></a>鼠标的点击</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    x, y &#x3D; pyautogui.position()    pyautogui.click(button&#x3D;&#39;left&#39;)  pyautogui.click(x, y, button&#x3D;&#39;left&#39;, clicks&#x3D;2, interval&#x3D;0.1, duration&#x3D;2)  pyautogui.doubleClick(x, y, button&#x3D;&#39;left&#39;)  pyautogui.tripleClick(x, y, button&#x3D;&#39;left&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="鼠标的按压和释放"><a href="#鼠标的按压和释放" class="headerlink" title="鼠标的按压和释放"></a>鼠标的按压和释放</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.click(328, 190)  pyautogui.moveTo(220, 480)  pyautogui.mouseDown(button&#x3D;&#39;left&#39;)  pyautogui.move(500, 0)  pyautogui.mouseUp(button&#x3D;&#39;left&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="鼠标的滚动"><a href="#鼠标的滚动" class="headerlink" title="鼠标的滚动&#96;&#96;"></a>鼠标的滚动&#96;&#96;</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(220, 480)  pyautogui.scroll(-10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="键盘的输入"><a href="#键盘的输入" class="headerlink" title="键盘的输入"></a>键盘的输入</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.click(960, 460)  pyautogui.write(&#39;This is a test!&#39;, interval&#x3D;0.5)  This is a test!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="键盘的按压"><a href="#键盘的按压" class="headerlink" title="键盘的按压"></a>键盘的按压</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.press(&#39;x&#39;)  pyautogui.press(&#39;crtl&#39;)  pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)    pyautogui.keyDown(&#39;crtl&#39;)  pyautogui.keyUp(&#39;ctrl&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV入门</title>
      <link href="/2023/09/03/opencv-ru-men/"/>
      <url>/2023/09/03/opencv-ru-men/</url>
      
        <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><ol><li>3.4.1之后的一些命令、函数被申请了专利</li></ol><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><pre class="line-numbers language-none"><code class="language-none">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple opencv-python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)    cv2.imshow(&quot;blue&quot;, image[:, :, 0])  cv2.imshow(&quot;green&quot;, image[:, :, 1])  cv2.imshow(&quot;red&quot;, image[:, :, 2])    gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  cv2.imshow(&quot;gray&quot;, gray)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="图像的裁剪"><a href="#图像的裁剪" class="headerlink" title="图像的裁剪"></a>图像的裁剪</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)    crop &#x3D; image[10:170, 40:200]    cv2.imshow(&quot;crop&quot;, crop)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    image &#x3D; np.zeros([300, 300, 3], dtype&#x3D;np.uint8)    cv2.line(image, (100, 200), (250, 250), (255, 255, 0), 2)  cv2.rectangle(image, (30, 100), (60, 150), (0, 255, 255), 4)  cv2.circle(image, (150, 100), 20, (255, 0, 255), 5)  cv2.putText(image, &quot;hello&quot;, (100, 50), 0, 1, (255, 255, 255), 1)    cv2.imshow(&quot;image&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="噪点去除"><a href="#噪点去除" class="headerlink" title="噪点去除"></a>噪点去除</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;plane.jpg&quot;)    gauss &#x3D; cv2.GaussianBlur(image, (5, 5), 0)  median &#x3D; cv2.medianBlur(image, 5)    cv2.imshow(&quot;image&quot;, image)  cv2.imshow(&quot;gauss&quot;, gauss)  cv2.imshow(&quot;median&quot;, median)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取转角"><a href="#获取转角" class="headerlink" title="获取转角"></a>获取转角</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)  gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    corners &#x3D; cv2.goodFeaturesToTrack(gray, 500, 0.1, 10)  for corner in corners:      x, y &#x3D; corner.ravel()      cv2.circle(image, (int(x), int(y)), 3, (255, 0, 255), -1)    cv2.imshow(&quot;corners&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="匹配菱形框"><a href="#匹配菱形框" class="headerlink" title="匹配菱形框"></a>匹配菱形框</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    image &#x3D; cv2.imread(&quot;poker.jpg&quot;)  gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    template &#x3D; gray[75:105, 235:265]    match &#x3D; cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)  location &#x3D; np.where(match &gt;&#x3D; 0.9)    w, h &#x3D; template.shape[0:2]  for p in zip(*location[::-1]):      x1, y1 &#x3D; p[0], p[1]      x2, y2 &#x3D; x1 + w, y1 + h      cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)    cv2.imshow(&quot;image&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="图像明暗变化梯度图"><a href="#图像明暗变化梯度图" class="headerlink" title="图像明暗变化梯度图"></a>图像明暗变化梯度图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    gray &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;, cv2.IMREAD_GRAYSCALE)    laplacian &#x3D; cv2.Laplacian(gray, cv2.CV_64F)  canny &#x3D; cv2.Canny(gray, 100, 200)    cv2.imshow(&quot;gray&quot;, gray)  cv2.imshow(&quot;laplacian&quot;, laplacian)  cv2.imshow(&quot;canny&quot;, canny)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="阈值处理"><a href="#阈值处理" class="headerlink" title="阈值处理"></a>阈值处理</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    gray &#x3D; cv2.imread(&quot;bookpage.jpg&quot;, cv2.IMREAD_GRAYSCALE)  ret, binary &#x3D; cv2.threshold(gray, 10, 255, cv2.THRESH_BINARY)  binary_adaptive &#x3D; cv2.adaptiveThreshold(      gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 155, 1)  ret1, binary_otsu &#x3D; cv2.threshold(gray, 0 ,255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)    cv2.imshow(&quot;gray&quot;, gray)  cv2.imshow(&quot;binary&quot;, binary)  cv2.imshow(&quot;adaptive&quot;, binary_adaptive)  cv2.imshow(&quot;otsu&quot;, binary_otsu)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="形态学算法（腐蚀、膨胀）"><a href="#形态学算法（腐蚀、膨胀）" class="headerlink" title="形态学算法（腐蚀、膨胀）"></a>形态学算法（腐蚀、膨胀）</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    gray &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;, cv2.IMREAD_GRAYSCALE)    _, binary &#x3D; cv2.threshold(gray, 200, 255, cv2. THRESH_BINARY_INV)  kernel &#x3D; np.ones((5, 5), np.uint8)    erosion &#x3D; cv2.erode(binary, kernel)  dilation &#x3D; cv2.dilate(binary, kernel)    cv2.imshow(&quot;binary&quot;, binary)  cv2.imshow(&quot;erosion&quot;, erosion)  cv2.imshow(&quot;dilation&quot;, dilation)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">cv2.cvtColor(src, code[, dst[, dstCn]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>src</code>：需要转换颜色空间的图像。</li><li><code>code</code>：颜色空间转换代码。</li><li><code>dst</code>（可选）：与源图像大小和深度相同的输出图像。</li><li><code>dstCn</code>（可选）：目标图像中的通道数。如果该参数为 0，则根据 <code>src</code> 和 <code>code</code> 自动推导通道数。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.destoryAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>窗口保持打开：如果不调用<code>cv2.destroyAllWindows()</code>，OpenCV创建的窗口将保持打开状态，直到用户手动关闭它们或程序终止。</li><li>可能导致资源泄漏：不关闭窗口可能会导致资源泄漏，特别是在循环中使用<code>cv2.imshow()</code>时，每次迭代都会创建新窗口，而不关闭旧窗口。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.imwrite(filename, image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>filename</code>可以指明路径，如果该路径不存在，则创建。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.imread(filename, image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>filename</code>为读出图片的名字 。</p><pre class="line-numbers language-none"><code class="language-none">cv2.IMREAD_COLORcv2.IMREAD_GRAYSCALEcv2.IMREAD_ANYCOLORcv2.IMREAD_UNCHANGEDcv2.IMREAD_ANYDEPTHcv2.IMREAD_ANYDEPTH|cv2.IMREAD_COLORcv2.IMREAD_REDUCED_GRAYSCALE_2cv2.IMREAD_REDUCED_COLOR_2cv2.IMREAD_REDUCED_GRAYSCALE_4cv2.IMREAD_REDUCED_COLOR_4cv2.IMREAD_REDUCED_GRAYSCALE_8cv2.IMREAD_REDUCED_COLOR_8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cv2.IMREAD_COLOR</code>：以彩色模式加载图像。这是默认选项，为每个通道提供 3 通道 BGR 图像，每个图像具有 8 位值（0-255）。</li><li><code>cv2.IMREAD_GRAYSCALE</code>：以灰度模式加载图像。这提供了一个 8 位灰度图像。</li><li><code>cv2.IMREAD_ANYCOLOR</code>：尝试加载图像，但不关心颜色格式，如果图象是彩色的，它将以彩色模式加载，否则以灰度模式加载。根据文件中的元数据，它提供每通道 8 位的 BGR 图像或 8 位的灰度图像。</li><li><code>cv2.IMREAD_UNCHANGED</code>：加载图像，包括[[杂项#^025801|图像的阿尔法通道]]，不进行任何修改。读取所有图像数据，包括 alpha 或透明通道（如果有）作为第四通道。</li><li><code>cv2.IMREAD_ANYDEPTH</code>：尝试加载图像，不关心位深度，图像的位深度是指每个像素的颜色通道的位数。这将以原始位深度加载灰度图像。 例如，如果文件表示此格式的图像，它将提供每通道 16 位的灰度图像。</li><li><code>cv2.IMREAD_ANYDEPTH | cv2.IMREAD_COLOR</code>：尝试加载图像，不关心位深度，以彩色模式加载。此组合以原始位深度加载 BGR 颜色的图像。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_2</code>：这会以原始分辨率的一半加载灰度图像。 例如，如果文件包含<code>640 x 480</code>的图像，则它将作为<code>640 x 480</code>的图像加载。</li><li><code>cv2.IMREAD_REDUCED_COLOR_2</code>：这将以每通道 8 位 BGR 的颜色加载图像，其分辨率为原始分辨率的一半。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_4</code>：这会以原始分辨率的四分之一加载灰度图像。</li><li><code>cv2.IMREAD_REDUCED_COLOR_4</code>：这将以每通道 8 位的颜色加载原始分辨率的四分之一的图像。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_8</code>：这会以原始分辨率的八分之一以灰度加载图像。</li><li><code>cv2.IMREAD_REDUCED_COLOR_8</code>：这将以每通道 8 位的颜色加载图像，其分辨率为原始分辨率的八分之一。<br>以不同的降采样级别加载图像。这些常量用于加载具有不同降采样级别的图像。数字表示降采样的级别，例如，”2”表示图像宽度和高度减小到原始大小的1&#x2F;2。</li></ul><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="使用numpy-array访问图像数据并显示图像"><a href="#使用numpy-array访问图像数据并显示图像" class="headerlink" title="使用numpy.array访问图像数据并显示图像"></a>使用<code>numpy.array</code>访问图像数据并显示图像</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  img[150, 120] &#x3D; [255, 255, 255]    cv2.imshow(&#39;1&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>操作 BGR 图像中坐标<code>(150, 120)</code>处的像素并将其变成白色像素，</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)    cv2.imshow(&#39;1&#39;, img)    img.itemset((150, 120, 0), 255)    print(img.item(150, 120, 0))      cv2.imshow(&#39;2&#39;, img)cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更改特定像素的蓝色值，例如坐标<code>(150, 120)</code>处的像素。 <code>numpy.array</code>类型提供了一种方便的方法<code>item</code>，它采用三个参数：<code>x</code>（或左侧）位置，<code>y</code>（或顶部）位置以及索引 （<code>x</code>，<code>y</code>）位置处的数组内（请记住，在 BGR 图像中，特定位置的数据是包含 B，G 和 R 值按此顺序排列），并在索引位置返回该值。 另一种方法<code>itemset</code>将特定像素的特定通道的值设置为指定值。 <code>itemset</code>接受两个参数：一个三元素元组（<code>x</code>，<code>y</code>和索引）和新值。</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  img[:, :, 1] &#x3D; 0    cv2.imshow(&#39;1&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>它基本上指示程序从所有行和列中获取所有像素，并将绿色值（三元素 BGR 数组的索引之一）设置为<code>0</code>。 如果显示此图像，您会注意到完全没有绿色。</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)    cv2.imshow(&#39;1&#39;, img)    my_roi &#x3D; img[0:100, 0:100]  img[300:400, 300:400] &#x3D; my_roi    cv2.imshow(&#39;2&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们可以通过使用 NumPy 的数组切片访问原始像素来做几件有趣的事情。 其中之一是定义<strong>兴趣区域</strong>（<strong>ROI</strong>）。 定义区域后，我们可以执行许多操作。 例如，我们可以将此区域绑定到变量，定义第二个区域，并将第一个区域的值分配给第二个区域（因此，将图像的一部分复制到图像中的另一个位置）</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  print(img.shape)  print(img.size)  print(img.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>shape</code>：这是一个描述数组形状的元组。 对于图像，它包含（按顺序）高度，宽度和（如果图像是彩色的）通道数。 <code>shape</code>元组的长度是确定图像是灰度还是彩色的有用方法。 对于灰度图像，我们有<code>len(shape) == 2</code>，对于彩色图像，我们有<code>len(shape) == 3</code>。</li><li><code>size</code>：这是数组中元素的数量。 在灰度图像的情况下，这与像素数相同。 在 BGR 图像的情况下，它是像素数的三倍，因为每个像素都由三个元素（B，G 和 R）表示。</li><li><code>dtype</code>：这是数组元素的数据类型。 对于每通道 8 位图像，数据类型为<code>numpy.uint8</code>。</li></ul><h5 id="读-写视频文件"><a href="#读-写视频文件" class="headerlink" title="读&#x2F;写视频文件"></a>读&#x2F;写视频文件</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    videoCapture &#x3D; cv2.VideoCapture(&#39;MyInputVid.mp4&#39;)  fps &#x3D; videoCapture.get(cv2.CAP_PROP_FPS)  size &#x3D; (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),          int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))  videoWriter &#x3D; cv2.VideoWriter(      &#39;MyOutputVid.mp4&#39;, cv2.VideoWriter_fourcc(*&#39;mp4v&#39;),      fps, size)    success, frame &#x3D; videoCapture.read()  while success:  # Loop until there are no more frames.      videoWriter.write(frame)      success, frame &#x3D; videoCapture.read()    videoCapture.release()  videoWriter.release()  cv2.destroyAllWindows()# 参考书代码import cv2videoCapture &#x3D; cv2.VideoCapture(&#39;MyInputVid.avi&#39;)fps &#x3D; videoCapture.get(cv2.CAP_PROP_FPS)size &#x3D; (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),        int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))videoWriter &#x3D; cv2.VideoWriter(    &#39;MyOutputVid.avi&#39;, cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),    fps, size)success, frame &#x3D; videoCapture.read()while success:  # Loop until there are no more frames.    videoWriter.write(frame)    success, frame &#x3D; videoCapture.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>注意</strong>参考书中适用的视频格式为<code>avi</code>，我将代码略加修改，适配了更常见的<code>mp4</code>格式。</li><li><code>VideoWriter</code>类的构造器的参数值得特别注意。 必须指定视频的文件名。 具有该名称的任何先前存在的文件都将被覆盖。 还必须指定视频编解码器。 可用的编解码器可能因系统而异。 支持的选项可能包括以下内容：<ol><li><code>0</code>：此选项是未压缩的原始视频文件。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;)</code>：此选项是未压缩的 YUV 编码，4:2:0 色度被二次采样。 这种编码具有广泛的兼容性，但会产生大文件。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;P&#39;,&#39;I&#39;,&#39;M&#39;,&#39;1&#39;)</code>：此选项是 MPEG-1。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;V&#39;,&#39;I&#39;,&#39;D&#39;)</code>：此选项是相对较旧的 MPEG-4 编码。 如果要限制生成的视频的大小，这是一个不错的选择。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;P&#39;,&#39;4&#39;,&#39;V&#39;)</code>：此选项是另一种相对较旧的 MPEG-4 编码。 如果要限制生成的视频的大小，这是一个不错的选择。 文件扩展名应为<code>.mp4</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;2&#39;,&#39;6&#39;,&#39;4&#39;)</code>：此选项是相对较新的 MPEG-4 编码。 如果您想限制最终视频的大小，这可能是最好的选择。 文件扩展名应为<code>.mp4</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;T&#39;,&#39;H&#39;,&#39;E&#39;,&#39;O&#39;)</code>：此选项为 <strong>Ogg Vorbis</strong>。 文件扩展名应为<code>.ogv</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;F&#39;,&#39;L&#39;,&#39;V&#39;,&#39;1&#39;)</code>：此选项是 Flash 视频。 文件扩展名应为<code>.flv</code>。</li></ol></li><li>但仍可能会遇见一些问题吗，下面是一些解决方案：<ol><li><strong>重新编译OpenCV</strong>：如果使用的是自定义构建的OpenCV，尝试重新编译OpenCV时确保启用了FFmpeg支持。在CMake配置时，启用相应的选项，以便OpenCV可以使用FFmpeg。然后重新构建OpenCV。</li><li><strong>使用不同的FourCC代码</strong>：尝试使用其他编解码器</li><li><strong>下载并安装对应的库</strong> </li><li><strong>检查OpenCV版本</strong>：如果 OpenCV 版本较旧，可能会存在问题。尝试更新到最新版本的 OpenCV，以获得更好的支持。</li></ol></li><li>还必须指定帧速率和帧大小。 由于我们正在从另一个视频复制，因此可以从<code>VideoCapture</code>类的<code>get</code>方法读取这些属性。</li></ul><h5 id="捕捉相机帧并输出相机"><a href="#捕捉相机帧并输出相机" class="headerlink" title="捕捉相机帧并输出相机"></a>捕捉相机帧并输出相机</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    cameraCapture &#x3D; cv2.VideoCapture(0)  fps &#x3D; 30  # An assumption  size &#x3D; (int(cameraCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),          int(cameraCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))  videoWriter &#x3D; cv2.VideoWriter(      &#39;MyOutputVid.avi&#39;, cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),      fps, size)    success, frame &#x3D; cameraCapture.read()  numFramesRemaining &#x3D; 10 * fps - 1 # 10 seconds of frames  while success and numFramesRemaining &gt; 0:      videoWriter.write(frame)      success, frame &#x3D; cameraCapture.read()      numFramesRemaining -&#x3D; 1    cameraCapture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在窗口中显示摄像机帧"><a href="#在窗口中显示摄像机帧" class="headerlink" title="在窗口中显示摄像机帧"></a>在窗口中显示摄像机帧</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    capture &#x3D; cv2.VideoCapture(0)    while True:      ret, frame &#x3D; capture.read()      cv2.imshow(&quot;camera&quot;, frame)      key &#x3D; cv2.waitKey(1)      if key !&#x3D; -1:          break    capture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>capture.read()</code> 是 OpenCV 中用于从视频捕获设备（例如摄像头）中读取一帧视频的函数。它返回两个值，第一个是布尔值（通常命名为 <code>ret</code>），表示是否成功读取帧，第二个是视频帧本身，通常是一个NumPy数组。</li><li><code>cv2.VideoCapture()</code> 是 OpenCV 中用于创建视频捕获对象的函数，可以用于从摄像头、视频文件或其他视频源中捕获视频帧。它接受一个参数，该参数可以是以下三种类型之一：<ol><li>整数（通常为0、1、2等）：表示要使用的摄像头的索引。通常情况下，0表示默认摄像头，1表示第二个摄像头（如果有多个摄像头）。  <pre class="line-numbers language-none"><code class="language-none">import cv2# 创建一个视频捕获对象，0表示默认摄像头capture &#x3D; cv2.VideoCapture(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>字符串：表示视频文件的路径，可以是本地文件路径或网络视频流的URL。</li><li>IP摄像头地址：如果您有网络摄像头，可以将其IP地址作为字符串传递给 <code>cv2.VideoCapture()</code>，以便从网络摄像头捕获视频。</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2clicked &#x3D; Falsedef onMouse(event, x, y, flags, param):    global clicked    if event &#x3D;&#x3D; cv2.EVENT_LBUTTONUP:        clicked &#x3D; TruecameraCapture &#x3D; cv2.VideoCapture(0)cv2.namedWindow(&#39;MyWindow&#39;)cv2.setMouseCallback(&#39;MyWindow&#39;, onMouse)print(&#39;Showing camera feed. Click window or press any key to stop.&#39;)success, frame &#x3D; cameraCapture.read()while success and cv2.waitKey(1) &#x3D;&#x3D; -1 and not clicked:    cv2.imshow(&#39;MyWindow&#39;, frame)    success, frame &#x3D; cameraCapture.read() cv2.destroyWindow(&#39;MyWindow&#39;)cameraCapture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>def onMouse(event, x, y, flags, param)</code>: 定义一个鼠标事件处理函数<code>onMouse</code>，该函数会在鼠标事件发生时被调用。它接受五个参数：<code>event</code>表示触发的事件类型，<code>x</code>和<code>y</code>表示鼠标事件发生的坐标，<code>flags</code>表示鼠标事件的附加标志，<code>param</code>表示可选参数。<ol><li>在<code>onMouse</code>函数中，当鼠标左键被释放（<code>cv2.EVENT_LBUTTONUP</code>事件）时，将全局变量<code>clicked</code>设置为True，表示用户点击了窗口。</li><li><code>event</code>参数表示触发的鼠标事件类型。在这个函数中，我们检查是否是左键释放事件 (<code>cv2.EVENT_LBUTTONUP</code>)。</li><li><code>x</code>和<code>y</code>参数表示鼠标事件发生的坐标，即鼠标指针在窗口上的位置。</li><li><code>flags</code>参数包含了与事件相关的附加标志，但在这个代码中没有使用。</li><li><code>param</code>参数是可选参数，通常用于传递额外的数据，但在这个代码中也没有使用。</li></ol></li><li><code>cv2.namedWindow(&#39;MyWindow&#39;)</code>: 创建一个名为”MyWindow”的窗口，用于显示摄像头捕获的视频。<ol><li><code>cv2.namedWindow()</code> 是OpenCV库中的一个函数，用于创建一个窗口以显示图像、视频或其他视觉数据。它的一般语法如下：&#96;cv2.namedWindow(winname, flags&#x3D;cv2.WINDOW_AUTOSIZE)</li><li><code>winname</code>: 表示要创建的窗口的名称或标识符。您可以自定义窗口的名称，以便在后续的操作中引用该窗口。</li><li><code>flags</code>（可选参数）: 指定窗口的标志。这是一个可选参数，默认值为<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口的大小会自动根据显示内容调整。您也可以将其设置为<code>cv2.WINDOW_NORMAL</code>，以允许手动调整窗口大小。</li></ol></li><li><code>cv2.setMouseCallback(&#39;MyWindow&#39;, onMouse)</code>: 在窗口”MyWindow”上设置鼠标事件回调函数，以便捕获鼠标事件。<ol><li><code>cv2.setMouseCallback()</code> 是OpenCV中的一个函数，用于设置鼠标事件的回调函数，以便在指定的窗口上捕获和处理鼠标事件。它的一般语法如下：<code>cv2.setMouseCallback(windowName, onMouse, param=None)</code></li><li><code>windowName</code>: 表示要在其上设置鼠标事件回调的窗口的名称。通常，您在使用<code>cv2.namedWindow()</code>创建窗口时指定的窗口名称。</li><li><code>onMouse</code>: 是一个回调函数，用于处理鼠标事件。当鼠标事件发生时，OpenCV将调用此函数并传递相关的事件信息。</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2023/08/31/markdown-yu-fa/"/>
      <url>/2023/08/31/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h5 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h5><ul><li>在一行中用三个以上的星号*、减号-、底线_来建立一个分隔线，行内不能有其他东西，但可以在星号或减号蹭插入空格。<pre class="line-numbers language-none"><code class="language-none">********** * * <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><ul><li>如果段落上的文字要添加删除线，在文字的两端加上两个波浪线~~<pre class="line-numbers language-none"><code class="language-none">~~需要添加删除线的文本~~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h5><ul><li>下划线通过 HTML 的标签来实现<pre class="line-numbers language-none"><code class="language-none">&lt;u&gt;需要添加下划线的文本&lt;&#x2F;u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h5><ul><li>脚注是对文本的补充说明。<pre class="line-numbers language-none"><code class="language-none">[^需要注明的文本]：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h5><ul><li>Markdown 区块引用是在段落开头使用 &gt; 符号，然后后面紧跟一个空格符号。区块可以嵌套使用。<pre class="line-numbers language-none"><code class="language-none">&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; &gt;&gt; &gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h5><ul><li>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，在特殊符号前使用反斜杠” \ “转义特殊字符<pre class="line-numbers language-none"><code class="language-none">*文本斜体*\*正常文本\*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客优化</title>
      <link href="/2023/08/31/bo-ke-you-hua/"/>
      <url>/2023/08/31/bo-ke-you-hua/</url>
      
        <content type="html"><![CDATA[<h5 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h5><ul><li>目录下配置文件<code>_config.yml</code>配置:<pre class="line-numbers language-none"><code class="language-none">theme: hexo-theme-matery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="博客站点相关信息"><a href="#博客站点相关信息" class="headerlink" title="博客站点相关信息"></a>博客站点相关信息</h5><pre class="line-numbers language-none"><code class="language-none">title: 七破风的博客 # 网站标题subtitle: &#39;&#39; # 网站副标题description: &#39;&#39; #keywords: # 关键字author: Chipforn # 博客作者姓名language: zh-CN # 博客使用的语言timezone: &#39;&#39; # 时区，默认电脑时区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码高亮设置"><a href="#代码高亮设置" class="headerlink" title="代码高亮设置"></a>代码高亮设置</h5><ul><li>安装hexo代码高亮插件<pre class="line-numbers language-none"><code class="language-none">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置：<pre class="line-numbers language-none"><code class="language-none">highlight:  enable: falseprism_plugin:  mode: &#39;preprocess&#39;      theme: &#39;tomorrow&#39;  line_number: false      custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h5><ul><li>安装 hexo-generator-search 搜索插件<pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：<pre class="line-numbers language-none"><code class="language-none">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="文章字数统计插件"><a href="#文章字数统计插件" class="headerlink" title="文章字数统计插件"></a>文章字数统计插件</h5><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。</p><pre class="line-numbers language-none"><code class="language-none">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class="line-numbers language-none"><code class="language-none">postInfo:  date: true # 发布日期  update: true # 更新日期  wordCount: true # 文章字数统计  totalCount: true # 站点总文章字数  min2read: true # 文章阅读时长  readCount: true # 文章阅读次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nonebot learning</title>
      <link href="/2023/08/28/nonebot-learning/"/>
      <url>/2023/08/28/nonebot-learning/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/25/read/guan-ying/meng-shang-ni-de-yan/"/>
      <url>/2023/06/25/read/guan-ying/meng-shang-ni-de-yan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
