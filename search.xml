<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>应用层</title>
      <link href="/2023/12/11/ying-yong-ceng/"/>
      <url>/2023/12/11/ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1-域名系统-DNS"><a href="#6-1-域名系统-DNS" class="headerlink" title="6.1 域名系统 DNS"></a>6.1 域名系统 DNS</h1><ul><li>应用层的具体内容是精确定义通信规则：<ol><li>应用进程交换的报文类型，如请求报文和响应报文。</li><li>各种报文类型的语法，如报文中的各个字段及其详细描述。</li><li>字段的语义，即包含在字段中的信息的含义。</li><li>进程何时、如何发送报文，以及对报文进行响应的规则。</li></ol></li></ul><h2 id="6-1-1-域名系统概述"><a href="#6-1-1-域名系统概述" class="headerlink" title="6.1.1 域名系统概述"></a>6.1.1 域名系统概述</h2><ul><li><strong>域名系统</strong> DNS 是互联网使用的命名系统，把机器名字转换为 IP 地址。</li><li>许多应用层软件经常直接使用域名系统 DNS。虽然计算机的用户只是<strong>间接</strong>使用域名系统，但 DNS 却为互联网的各种网络应用提供了核心服务。</li><li>用户与互联网上某台主机通信时，必须要知道对方的 IP 地址。应用层为了便于用户记忆各种网络应用设置了主机名，通过域名系统 DNS 把互联网上的主机名字转换为 IP 地址。</li><li>从理论上讲，整个互联网可以只使用一个域名服务器，使它装入互联网上所有的主机名，并回答所有对 IP 地址的查询。但是因为互联网规模很大，这样的域名服务器会因过负荷而无法正常工作，而且一旦域名服务器出现故障，整个互联网就会瘫痪。因此采用层次树状结构的命名方法，并使用分布式的<strong>域名系统</strong> DNS。</li><li>互联网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS 使大多数名字都在本地进行<strong>解析</strong>，仅少量解析需要在互联网上通信，因此 DNS 系统的效率很高。由于 DNS 是分布式系统，即使单个计算机出了故障，也不会妨碍整个 DNS 系统的正常运行。</li><li>域名到 IP 地址的解析是由分布在互联网上的许多<strong>域名服务器程序</strong>共同完成的。域名服务器程序在专设的结点上运行，把运行域名服务器程序的机器称为<strong>域名服务器</strong>。</li><li>域名到 IP 地址的解析过程的要点如下：当某一个应用进程需要把主机名解析为 IP 地址时，该应用进程就调用<strong>解析程序</strong>，成为 DNS 的一个客户，把待解析的域名放在 DNS 请求报文中，以 UDP 用户数据报方式发给本地域名服务器 (使用 UDP 是为了减少开销)。本地域名服务器在查找域名后，把对应的 IP 地址放在回答报文中返回。应用进程获得目的主机的 IP 地址后即可进行通信。</li></ul><h2 id="6-1-2-互联网的域名结构"><a href="#6-1-2-互联网的域名结构" class="headerlink" title="6.1.2 互联网的域名结构"></a>6.1.2 互联网的域名结构</h2><ul><li>DNS 规定，域名中的标号都由英文字母和数字组成，<strong>每一个标号不超过 63 个字符</strong> (为了记忆方便，最好不要超过 12 个字符)，<strong>也不区分大小写字母</strong> (例如，CCTV 或 cctv 在域名中是等效的)。标号中除连字符 (-) 外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的顶级域名则写在最右边。<strong>由多个标号组成的完整域名总共不超过 255 个字符</strong>。DNS 既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由 ICANN 进行管理。用这种方法可使每一个域名在整个互联网范围内是唯一的，并且也容易设计出一种查找域名的机制。</li><li>原先的顶级域名共分为三大类：<ol><li><strong>国家顶级域名</strong> nTLD</li><li><strong>通用顶级域名</strong> gTLD</li><li><strong>基础结构域名</strong></li></ol></li><li>我国把二级域名划分为“<strong>类别域名</strong>”和“<strong>行政区域名</strong>”两大类。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218153419.png"></li></ul><h2 id="6-1-3-域名服务器"><a href="#6-1-3-域名服务器" class="headerlink" title="6.1.3 域名服务器"></a>6.1.3 域名服务器</h2><ul><li>域名服务器划分为以下四种不同的类型：<ol><li><strong>根域名服务器</strong> (root name server)：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析 (即转换为 IP 地址)，只要自己无法解析，就首先要求助于根域名服务器。假定所有的根域名服务器都瘫痪了，那么整个互联网中的 DNS 系统就无法工作。</li><li><strong>顶级域名服务器</strong> (即 TLD <strong>服务器</strong>)：这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答。</li><li><strong>权限域名服务器</strong>：当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</li><li><strong>本地域名服务器</strong> (local name server)：当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</li></ol></li><li>为了提高域名服务器的可靠性，DNS 域名服务器把数据复制到几个域名服务器来保存，其中的一个是<strong>主域名服务器</strong>，其他的是<strong>辅助域名服务器</strong>。当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行，保证数据的一致性。</li><li>域名的解析过程:<ol><li>主机向本地域名服务器的查询一般采用<strong>递归查询</strong>。递归查询是：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器发出查询请求报文，而不是让该主机自己进行下一步的查询。因此，递归查询返回的查询结果是所要查询的 IP 地址，或报错。</li><li>本地域名服务器向根域名服务器的查询通常采用<strong>迭代查询</strong>。迭代查询的特点是：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询，而不是替本地域名服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询，本地域名服务器就这样进行迭代查询。最后，知道了所要解析的域名的 IP 地址，然后把这个结果返回给发起查询的主机。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218171321.png"></li></ol></li><li>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</li></ul><h1 id="6-2-文件传送协议"><a href="#6-2-文件传送协议" class="headerlink" title="6.2 文件传送协议"></a>6.2 文件传送协议</h1><h2 id="6-2-1-FTP-概述"><a href="#6-2-1-FTP-概述" class="headerlink" title="6.2.1 FTP 概述"></a>6.2.1 FTP 概述</h2><ul><li>文件传送协议 FTP 是互联网上使用得最广泛的文件传送协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。FTP 屏蔽了各计算机系统的细节，适合于在异构网络中任意计算机之间传送文件。</li><li>基于 TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP 都是文件共享协议中的一大类，即<strong>复制整个文件</strong>，特点是：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。</li><li>文件共享协议中的另一大类是<strong>联机访问</strong>。联机访问意味着允许多个程序同时对一个文件进行存取。和数据库系统的不同之处是用户不需要调用一个特殊的客户进程，而是由操作系统提供对远地共享文件进行访问的服务。使用户可以用远地文件作为输入和输出来运行任何应用程序，而操作系统中的文件系统则提供对共享文件的<strong>透明存取</strong>。透明存取的优点是：将原来用于处理本地文件的应用程序用来处理远地文件时，不需要对该应用程序作明显的改动。属于文件共享协议的有网络文件系统 NFS。</li></ul><h2 id="6-2-2-FTP-的基本工作原理"><a href="#6-2-2-FTP-的基本工作原理" class="headerlink" title="6.2.2 FTP 的基本工作原理"></a>6.2.2 FTP 的基本工作原理</h2><ul><li>文件传输协议 FTP 只提供文件传输的一些基本的服务，它使用 TCP 可靠的运输服务。FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li><li>FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个<strong>主进程</strong>，负责接受新的请求；另外有若干个<strong>从属进程</strong>，负责处理单个请求。</li><li>主进程的工作步骤如下：<ol><li>打开熟知端口 (端口号为21)，使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li><li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发进行的。</li></ol></li><li>在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：“<strong>控制连接</strong>”和“<strong>数据连接</strong>”。控制连接在整个会话期间一直保持打开，FTP 客户所发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。<strong>实际用于传输文件的是“数据连接”</strong>。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“<strong>数据传送进程</strong>”和“<strong>数据连接</strong>”，用来连接客户端和服务器端的数据传送进程。数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。由于 FTP 使用了一个分离的控制连接，因此 FTP 的控制信息是<strong>带外</strong>传送的。</li><li>网络文件系统 <strong>NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据</strong>。</li></ul><h2 id="6-2-3-简单文件传送协议-TFTP"><a href="#6-2-3-简单文件传送协议-TFTP" class="headerlink" title="6.2.3 简单文件传送协议 TFTP"></a>6.2.3 简单文件传送协议 TFTP</h2><ul><li>TCP&#x2F;IP 协议族中有一个<strong>简单文件传送协议</strong> TFTP，它是一个很小且易于实现的文件传送协议。虽然 TFTP 也使用客户服务器方式，但它使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。TFTP 只支持文件传输而不支持交互。TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</li><li>TFTP 的主要优点有两个：<ol><li>TFTP 可用于 UDP 环境。例如，当需要将程序或文件同时向许多机器下载时就往往需要使用 TFTP。</li><li>TFTP 代码所占的内存较小。这对较小的计算机或某些特殊用途的设备是很重要的。</li></ol></li><li>TFTP 的主要特点是：<ol><li>每次传送的数据报文中有 512 字节的数据，但最后一次可不足 512 字节。</li><li>数据报文按序编号，从 1 开始。</li><li>支持 ASCII 码或二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部。</li></ol></li></ul><h1 id="6-3-远程终端协议-TELNET"><a href="#6-3-远程终端协议-TELNET" class="headerlink" title="6.3 远程终端协议 TELNET"></a>6.3 远程终端协议 TELNET</h1><ul><li>TELNET 是一个简单的远程终端协议。用户用 TELNET 可在其所在地通过 TCP 连接注册到远地的另一台主机上。TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。因此，TELNET 又称为<strong>终端仿真协议</strong>。</li><li>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行TELNET 服务器进程。和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。</li><li><strong>网络虚拟终端</strong> NVT 的格式定义很简单。所有的通信都使用 8 位一个字节。在运转时，NVT 使用 7 位 ASCII 码传送数据，而当高位置 1 时用作控制命令。ASCII 码共有 95 个可打印字符 (如字母、数字、标点符号) 和 33 个控制字符。所有可打印字符在 NVT 中的意义和在 ASCII 码中一样。但 NVT 只使用了 ASCII 码的控制字符中的几个。</li></ul><h1 id="6-4-万维网-WWW"><a href="#6-4-万维网-WWW" class="headerlink" title="6.4 万维网 WWW"></a>6.4 万维网 WWW</h1><h2 id="6-4-1-万维网概述"><a href="#6-4-1-万维网概述" class="headerlink" title="6.4.1 万维网概述"></a>6.4.1 万维网概述</h2><ul><li><strong>万维网</strong> WWW 并非某种特殊的计算机网络，<strong>而是一个大规模的、联机式的信息储藏所</strong>，英文简称为 Web。</li><li>万维网是一个分布式的<strong>超媒体</strong>系统，它是<strong>超文本</strong>系统的扩充。</li><li>分布式的和非分布式的超媒体系统有很大区别。在非分布式系统中，各种信息都驻留在单个计算机的磁盘中。由于各种文档都可从本地获得，因此这些文档之间的链接可进行一致性检查。</li><li><strong>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</strong>。</li><li>万维网必须解决以下几个问题：<ol><li>怎样标志分布在整个互联网上的万维网文档？——万维网使用<strong>统一资源定位符</strong> URL 来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</li><li>用什么样的协议来实现万维网上的各种链接？——万维网使用<strong>超文本传送协议</strong> HTTP 来实现万维网上的各种链接。HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li><li>怎样使不同作者创作的不同风格的万维网文档，都能在互联网上的各种主机上显示出来，同时使用户清楚地知道在什么地方存在着链接？——万维网使用<strong>超文本标记语言</strong> HTML，使得万维网页面的设计者可以很方便地用链接从本页面的某处链接到互联网上的任何一个万维网页面，并且能够在自己的主机屏幕上将这些页面显示出来。</li></ol></li></ul><h2 id="6-4-2-统一资源定位符-URL"><a href="#6-4-2-统一资源定位符-URL" class="headerlink" title="6.4.2 统一资源定位符 URL"></a>6.4.2 统一资源定位符 URL</h2><ul><li><strong>URL 的格式</strong><ol><li><strong>统一资源定位符</strong> URL 是用来从互联网上得到的资源位置和访问这些资源的方法。</li><li>URL 是与互联网相连的机器上的任何可访问对象的一个指针。由于访问不同对象所使用的协议不同，所以 URL 还指出读取某个对象时所使用的协议。URL 的一般形式由以下四个部分组成：&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</li><li>URL 的第一部分是最左边的&lt;协议&gt;。&lt;协议&gt;是指使用什么协议来获取该万维网文档。现在最常用的协议就是 http，其次是 ftp。在&lt;协议&gt;后面的“:&#x2F;&#x2F;”是规定的格式。它的右边是第二部分&lt;主机&gt;，指出这个万维网文档是在哪一台主机上。&lt;主机&gt;是指该主机在互联网上的域名。再后面是第三和第四部分&lt;端口&gt;和&lt;路径&gt;，有时可省略。</li></ol></li><li><strong>使用 HTTP 的 URL</strong><ol><li>对于万维网网点的访问要使用 HTTP 协议。HTTP 的 URL 的一般形式是：http:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</li><li>HTTP 的默认端口号是 80，通常可省略。若再省略文件的&lt;路径&gt;项，则 URL 就指到互联网上的某个<strong>主页</strong>。主页是个很重要的概念，它可以是以下几种情况之一：<ul><li>一个 WWW 服务器的最高级别的页面。</li><li>某一个组织或部门的一个定制的页面或目录。从这样的页面可链接到互联网上的与本组织或部门有关的其他站点。</li><li>由某一个人自己设计的描述他本人情况的 WWW 页面。</li></ul></li></ol></li></ul><h2 id="6-4-3-超文本传送协议-HTTP"><a href="#6-4-3-超文本传送协议-HTTP" class="headerlink" title="6.4.3 超文本传送协议 HTTP"></a>6.4.3 超文本传送协议 HTTP</h2><ul><li><strong>HTTP 的操作过程</strong><ol><li>HTTP 是<strong>面向事务的</strong>应用层协议是万维网上能够可靠地交换文件的重要基础。</li><li>用户浏览页面的方法有两种：<ul><li>键入 URL。</li><li>用鼠标点击一个可选部分所对应的链接。</li></ul></li><li>HTTP&#x2F;1.0 的主要缺点是：<ul><li>每请求一个文档要有两倍 RTT 开销。若一个主页上有很多链接的对象需要依次进行链接，每一次链接下载都导致 2×RTT 的开销。</li><li>万维网客户和服务器每一次建立新的 TCP 连接都要分配缓存和变量，特别是万维网服务器往往要同时服务于大量客户的请求，所以这种<strong>非持续连接</strong>会使万维网服务器的负担很重。</li></ul></li><li>HTTP&#x2F;1.1 协议使用<strong>持续连接</strong>较好地解决了这个问题。万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。</li><li>HTTP&#x2F;1.1 协议的持续连接有两种工作方式：<ul><li><strong>非流水线方式</strong><ol><li>特点：客户在收到前一个响应后才能发出下一个请求。因此，在 TCP 连接已建立后，客户每访问一次对象都要用去一个往返时间 RTT，这比非持续连接节省了建立 TCP 连接所需的一个 RTT 时间。</li><li>缺点：服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</li></ol></li><li><strong>流水线方式</strong><ol><li>特点：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用流水线方式时，客户访问<strong>所有的对象</strong>只需花费一个 RTT 时间。流水线工作方式使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li></ol></li></ul></li></ol></li><li><strong>代理服务器</strong><ol><li><strong>代理服务器</strong>是一种网络实体，又称<strong>万维网高速缓存</strong>。</li></ol></li><li><strong>HTTP 的报文结构</strong><ol><li>HTTP 有两类报文：<ul><li>请求报文——从客户向服务器发送请求报文，见图 6-12(a)。</li><li>响应报文——从服务器到客户的回答，见图 6-12(b)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812151126.png"></li></ul></li><li>由于 HTTP 是<strong>面向文本的</strong>，因此在报文中的每一个字段都是一些 ASCII 码串，各个字段的长度都是不确定的。</li><li>HTTP 请求报文和响应报文都是由三个部分组成：<ul><li><strong>开始行</strong>，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做<strong>请求行</strong>，而在响应报文中的开始行叫做<strong>状态行</strong>。在开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表“回车”和“换行”。</li><li><strong>首部行</strong>，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</li><li><strong>实体主体</strong>，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</li></ul></li><li>请求报文的第一行“请求行”有三个内容：<ul><li>方法</li><li>请求资源的 URL</li><li>HTTP 的版本。</li><li>HTTP 请求报文的一些方法：<img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/computer_network20231218160354.png"></li></ul></li><li>HTTP 响应报文的主要特点：<ul><li>每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。</li><li>状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。</li><li><strong>状态码</strong>都是三位数字的，分为 5 大类，原先有 33 种，后来又增加了几种。这 5 大类的状态码都是以不同的数字开头的。<ol><li>1xx 表示通知信息，如请求收到了或正在进行处理。</li><li>2xx 表示成功，如接受或知道了。</li><li>3xx 表示重定向，如要完成请求还必须采取进一步的行动。</li><li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li></ol></li></ul></li></ol></li><li><strong>在服务器上存放用户的信息</strong></li></ul><h2 id="6-4-4-万维网的文档"><a href="#6-4-4-万维网的文档" class="headerlink" title="6.4.4 万维网的文档"></a>6.4.4 万维网的文档</h2><ul><li><strong>超文本标记语言 HTML</strong><ol><li><strong>超文本标记语言 HTML</strong>  是一种制作万维网页面的标准语言，它消除了不同计算机之间信息交流的障碍。但 HTML <strong>并不是应用层的协议</strong>，它只是万维网浏览器使用的一种语言。</li><li>HTML 允许在万维网页面中插入图像。</li><li>HTML 规定了链接的设置方法。</li><li>XML 是<strong>可扩展标记语言</strong>，与 HTML 很相似。但 XML 的设计宗旨是传输数据，而不是显示数据 (HTML 是为了在浏览器上显示数据)。更具体些，XML 用于标记电子文件，使其具有结构性的标记语言，可用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML 是一种简单、与平台无关并被广泛采用的标准。XML 相对于 HTML 的优点是它将用户界面与结构化数据分隔开来。</li><li>XHTML 是<strong>可扩展超文本标记语言</strong>，与 HTML 4.01 几乎是相同的。</li><li>CSS 是<strong>层叠样式表</strong>，它是一种样式表语言，用于为 HTML 文档定义布局。CSS 与 HTML 的区别是：HTML 用于结构化内容，而 CSS 则用于格式化结构化的内容。</li></ol></li><li><strong>动态万维网文档</strong><ol><li>静态文档的优点是简单。由于 HTML 是一种排版语言，因此静态文档可以由不懂程序设计的人员来创建。但静态文档的缺点是不够灵活。当信息变化时就要由文档的作者手工对文档进行修改。</li><li><strong>动态文档</strong>是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。当浏览器请求到达时，万维网服务器要运行另一个应用程序，并把控制转移到此应用程序。接着，该应用程序对浏览器发来的数据进行处理，并输出 HTTP 格式的文档，万维网服务器把应用程序的输出作为对浏览器的响应。由于对浏览器每次请求的响应都是临时生成的，因此用户通过动态文档所看到的内容是不断变化的。动态文档的主要优点是具有报告当前最新信息的能力。</li><li>动态文档和静态文档之间的主要差别体现在服务器一端，主要是<strong>文档内容的生成方法不同</strong>。而从浏览器的角度看，这两种文档并没有区别。</li><li>要实现动态文档就必须在以下两个方面对万维网服务器的功能进行扩充：<ul><li>增加另一个应用程序，处理浏览器发来的数据，并创建动态文档。</li><li>增加一个机制，使万维网服务器将浏览器发来的数据传送给这个应用程序，然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。</li></ul></li><li><strong>通用网关接口 CGI</strong> 是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。</li></ol></li><li><strong>活动万维网文档</strong><ol><li>有两种技术可用于浏览器屏幕显示的连续更新：<ul><li><strong>服务器推送</strong>，这种技术是将所有的工作都交给服务器。服务器不断地运行与动态文档相关联的应用程序，定期更新信息，并发送更新过的文档。<ol><li>缺点：为了满足很多客户的请求，服务器要运行很多服务器推送程序。这将造成过多的服务器开销。服务器推送技术要求服务器为每一个浏览器客户维持一个不释放的 TCP 连接。随着 TCP 连接的数目增加，每一个连接所能分配到的网络带宽就下降，这就导致网络传输时延的增大。</li></ol></li><li>另一种提供屏幕连续更新的技术是<strong>活动文档</strong>。<ol><li>这种技术是把所有的工作都转移给浏览器端。每当浏览器请求一个活动文档时，服务器就返回一段活动文档程序副本，使该程序副本在浏览器端运行。这时，活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。只要用户运行活动文档程序，活动文档的内容就可以连续地改变。由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。</li></ol></li></ul></li></ol></li></ul><h2 id="6-4-5-万维网的信息检索系统"><a href="#6-4-5-万维网的信息检索系统" class="headerlink" title="6.4.5 万维网的信息检索系统"></a>6.4.5 万维网的信息检索系统</h2><ul><li><strong>全文检索搜索与分类目录搜索</strong><ol><li>在万维网中用来进行搜索的工具叫做<strong>搜索引擎</strong>。搜索引擎的种类很多，但大体上可划分为两大类，<ul><li><strong>全文检索</strong>搜索引擎：全文检索搜索引擎是一种纯技术型的检索工具。<ol><li>优点：全文检索可以检索出大量的信息。</li><li>缺点：但缺点是查询结果不够准确，往往是罗列出了海量的信息，使用户无法迅速找到所需的信息。</li></ol></li><li><strong>分类目录</strong>搜索引擎：分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。因此，分类目录搜索也叫做分类网站搜索。<ol><li>优点：用户可根据网站设计好的目录有针对性地逐级查询所需要的信息，查询时不需要使用关键词，只需要按照分类 (先找大类，再找下面的小类)，因而查询的准确性较好。</li><li>缺点：分类目录查询的结果并不是具体的页面，而是被收录网站主页的 URL 地址，因而所得到的内容就比较有限。</li></ol></li></ul></li><li><strong>垂直搜索引擎</strong>针对某一特定领域、特定人群或某一特定需求提供搜索服务。</li><li><strong>元搜索引擎</strong>，把用户提交的检索请求发送到多个独立的搜索引擎上去搜索，并把检索结果集中统一处理，以统一的格式提供给用户，因此是搜索引擎之上的搜索引擎。它的主要精力放在提高搜索速度、智能化处理搜索结果、个性化搜索功能的设置和用户检索界面的友好性上。元搜索引擎的查全率和查准率都比较高。</li></ol></li><li><strong>Google 搜索技术的特点</strong></li></ul><h2 id="6-4-6-博客与微博"><a href="#6-4-6-博客与微博" class="headerlink" title="6.4.6 博客与微博"></a>6.4.6 博客与微博</h2><ul><li><strong>博客</strong></li><li><strong>微博</strong></li></ul><h2 id="6-4-7-社交网站"><a href="#6-4-7-社交网站" class="headerlink" title="6.4.7 社交网站"></a>6.4.7 社交网站</h2><h1 id="6-5-电子邮件"><a href="#6-5-电子邮件" class="headerlink" title="6.5 电子邮件"></a>6.5 电子邮件</h1><h2 id="6-5-1-电子邮件概述"><a href="#6-5-1-电子邮件概述" class="headerlink" title="6.5.1 电子邮件概述"></a>6.5.1 电子邮件概述</h2><ul><li>电子邮件的两个最重要的标准是：<strong>简单邮件传送协议</strong> SMTP 和<strong>互联网文本报文格式</strong> </li><li>由于互联网的 SMTP 只能传送可打印的 7 位 ASCII 码邮件，因此提出了<strong>通用互联网邮件扩充</strong> MIME 。MIME 在其邮件首部中说明了邮件的数据类型。在 MIME 邮件中可同时传送多种类型的数据。</li><li>一个电子邮件系统应具有图 6-17 所示的三个主要组成构件，即<strong>用户代理、邮件服务器</strong>，以及邮件发送协议 (如 SMTP) 和邮件读取协议 (如POP3)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812154053.png"></li></ol></li><li><strong>用户代理</strong> UA 是用户与电子邮件系统的接口，大多数情况下它是运行在用户电脑中的一个程序。因此用户代理又称为<strong>电子邮件客户端软件</strong>。用户代理向用户提供一个很友好的接口来发送和接收邮件。</li><li>用户代理至少应当具有以下四个功能：<ol><li><strong>撰写</strong>。给用户提供编辑信件的环境。例如，应让用户能创建便于使用的通讯录。回信时不仅能很方便地从来信中提取出对方地址，并自动地将此地址写入到邮件中合适的位置，而且还能方便地对来信提出的问题进行答复。</li><li><strong>显示</strong>。能方便地在计算机屏幕上显示出来信。</li><li><strong>处理</strong>。处理包括发送邮件和接收邮件。收件人应能根据情况按不同方式对来信进行处理。例如，阅读后删除、存盘、打印、转发等，以及自建目录对来信进行分类保存。有时还可在读取信件之前先查看一下邮件的发件人和长度等，对于不愿收的信件可直接在邮箱中删除。</li><li><strong>通信</strong>。发信人在撰写完邮件后，要利用邮件发送协议发送到用户所使用的邮件服务器。收件人在接收邮件时，要使用邮件读取协议从本地邮件服务器接收邮件。</li></ol></li><li>电子邮件由<strong>信封</strong>和**内容两部分组成。</li></ul><h2 id="6-5-2-简单邮件传送协议-SMTP"><a href="#6-5-2-简单邮件传送协议-SMTP" class="headerlink" title="6.5.2 简单邮件传送协议 SMTP"></a>6.5.2 简单邮件传送协议 SMTP</h2><ul><li>通过发送方和接收方的邮件服务器之间的 SMTP 通信的三个阶段介绍几个最主要的命令和响应信息：<ol><li><strong>连接建立</strong><ul><li>SMTP <strong>不使用中间的邮件服务器</strong>。</li></ul></li><li><strong>邮件传送</strong><ul><li>RCPT 命令的作用是：先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件。这样做是为了避免浪费通信资源，不至于发送了很长的邮件以后才知道地址错误。</li></ul></li><li><strong>连接释放</strong><ul><li>邮件发送完毕后，SMTP 客户应发送 QUIT 命令。SMTP 服务器返回的信息是“221 (服务关闭)”，表示 SMTP 同意释放 TCP 连接。邮件传送的全部过程即结束。</li></ul></li></ol></li></ul><h2 id="6-5-3-电子邮件的信息格式"><a href="#6-5-3-电子邮件的信息格式" class="headerlink" title="6.5.3 电子邮件的信息格式"></a>6.5.3 电子邮件的信息格式</h2><h2 id="6-5-4-邮件读取协议-POP3-和-IMAP"><a href="#6-5-4-邮件读取协议-POP3-和-IMAP" class="headerlink" title="6.5.4 邮件读取协议 POP3 和 IMAP"></a>6.5.4 邮件读取协议 POP3 和 IMAP</h2><ul><li>现在常用的邮件读取协议有两个：<ol><li>邮局协议第 3 个版本 POP3：<strong>邮局协议</strong> POP 是一个非常简单、但功能有限的邮件读取协议。</li><li><strong>网际报文存取协议</strong> IMAP：比 POP3 复杂。IMAP 和 POP 都按客户服务器方式工作，但它们有很大的差别。<ul><li>用户在自己的计算机上可以操纵邮件服务器的邮箱，就像在本地操纵一样，IMAP 是一个联机协议。当用户计算机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。用户可以根据需要为自己的邮箱创建便于分类管理的层次式的邮箱文件夹，并且能够将存放的邮件从某一个文件夹中移动到另一个文件夹中。用户也可按某种条件对邮件进行查找。在用户未发出删除邮件的命令之前，IMAP 服务器邮箱中的邮件一直保存着。</li><li>优点：用户可以在不同的地方使用不同的计算机，随时上网阅读和处理自己在邮件服务器中的邮件，IMAP 还允许收件人只读取邮件中的某一个部分。</li><li>缺点：如果用户没有将邮件复制到自己的计算机上，则邮件一直存放在 IMAP 服务器上。要想查阅自己的邮件，必须先上网。</li></ul></li></ol></li><li>表 6-2 给出了 IMAP 和 POP3 的主要功能的比较。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812161852.png"></li></ol></li></ul><h2 id="6-5-5-基于万维网的电子邮件"><a href="#6-5-5-基于万维网的电子邮件" class="headerlink" title="6.5.5 基于万维网的电子邮件"></a>6.5.5 基于万维网的电子邮件</h2><ul><li>万维网电子邮件的好处是：不管在什么地方，只要能够找到上网的计算机，在打开任何一种浏览器后，就可以非常方便地收发电子邮件。</li></ul><h2 id="6-5-6-通用互联网邮件扩充-MIME"><a href="#6-5-6-通用互联网邮件扩充-MIME" class="headerlink" title="6.5.6 通用互联网邮件扩充 MIME"></a>6.5.6 通用互联网邮件扩充 MIME</h2><ul><li><strong>MIME 概述</strong><ol><li>电子邮件协议 SMTP 有以下缺点：<ul><li>SMTP 不能传送可执行文件或其他的二进制对象。</li><li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字就无法传送。即使在 SMTP 网关将 EBCDIC 码 (即扩充的二&#x2F;十进制交换码) 转换为 ASCII 码，也会遇到一些麻烦。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li><li>某些 SMTP 的实现并没有完全按照 SMTP 的互联网标准。常见的问题如下：<ol><li>回车、换行的删除和增加；</li><li>超过 76 个字符时的处理：截断或自动换行；</li><li>后面多余空格的删除；</li><li>将制表符 tab 转换为若干个空格。</li></ol></li></ul></li><li><strong>通用互联网邮件扩充 MIME</strong> 的意图是继续使用原来的邮件格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。也就是说，MIME 邮件可在现有的电子邮件程序和协议下传送。图 6-18 表示 MIME 和 SMTP 的关系。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812180720.png"></li></ul></li><li>MIME 主要包括以下三部分内容：<ul><li>5 个新的邮件首部字段，它们可包含在原来的邮件首部中。这些字段提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ul></li><li>MIME 增加的 5 个新的邮件首部的名称及其意义：<ul><li>MIME-Version：标志 MIME 的版本。现在的版本号是 1.0。</li><li>Content-Description：可读字符串，说明此邮件主体是否是图像、音频或视频。</li><li>Content-Id：邮件的唯一标识符。</li><li>Content-Transfer-Encoding：在传送时邮件的主体是如何编码的。</li><li>Content-Type：说明邮件主体的数据类型和子类型。</li></ul></li></ol></li><li><strong>内容传送编码</strong><ol><li>介绍三种常用的<strong>内容传送编码</strong><ul><li>最简单的编码就是 7 位 ASCII 码，而每行不能超过 1000 个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。</li><li>另一种编码称为 quoted-printable，这种编码方法适用于所传送的数据中只有少量的非 ASCII 码，例如汉字。</li><li>对于任意的二进制文件，可用 base64 编码。</li></ul></li></ol></li><li><strong>内容类型</strong><ol><li>MIME 标准规定 Content-Type 说明必须含有两个标识符，即内容<strong>类型</strong>和<strong>子类型</strong>，中间用“&#x2F;”分开。</li><li>除了内容类型和子类型，MIME 允许发件人和收件人自己定义专用的内容类型。但为避免可能出现名字冲突，标准要求为专用的内容类型选择的名字要以字符串 X- 开始。</li><li>表 6-3 列出了 MIME 的内容类型、子类型举例及其说明。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812181229.png"></li></ul></li><li>MIME 标准为 multipart 定义了四种可能的子类型，每个子类型都提供重要功能。<ul><li>mixed 子类型允许单个报文含有多个相互独立的子报文，每个子报文有自己的类型和编码。mixed 子类型报文使用户能够在单个报文中附上文本、图形和声音，或者用额外数据段发送一个备忘录。在 mixed 后面还要用到一个关键字，即 Boundary＝，此关键字定义了分隔报文各部分所用的字符串 (由邮件系统定义)，只要在邮件的内容中不会出现这样的字符串即可。当某一行以两个连字符“–”开始，后面紧跟上述的字符串，就表示下面开始了另一个子报文。</li><li>alternative 子类型允许单个报文含有同一数据的多种表示。当给多个使用不同硬件和软件系统的收件人发送备忘录时，这种类型的 multipart 报文很有用。例如，用户可同时用普通的 ASCII 文本和格式化的形式发送文本，从而允许拥有图形功能的计算机用户在查看图形时选择格式化的形式。</li><li>parallel 子类型允许单个报文含有可同时显示的各个子部分。</li><li>digest 子类型允许单个报文含有一组其他报文。</li></ul></li></ol></li></ul><h1 id="6-6-动态主机配置协议DHCP"><a href="#6-6-动态主机配置协议DHCP" class="headerlink" title="6.6 动态主机配置协议DHCP"></a>6.6 动态主机配置协议DHCP</h1><ul><li>连接到互联网的计算机的协议软件需要配置的项目包括：<ol><li>IP 地址；</li><li>子网掩码；</li><li>默认路由器的 IP 地址；</li><li>域名服务器的 IP 地址。</li></ol></li><li>互联网现在广泛使用的是<strong>动态主机配置协议</strong> DHCP，它提供了一种机制，称为<strong>即插即用连网</strong>。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。</li><li>DHCP 对运行客户软件和服务器软件的计算机都适用。当运行客户软件的计算机移至一个新的网络时，就可使用 DHCP 获取其配置信息而不需要手工干预。DHCP 给运行服务器软件而位置固定的计算机指派一个永久地址，而当这计算机重新启动时其地址不改变。</li><li>DHCP 使用客户服务器方式。需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送<strong>发现报文</strong> (将目的 IP 地址置为全 1，即 255.255.255.255)，这时该主机就成为 DHCP 客户。发送广播报文是因为现在还不知道 DHCP 服务器在什么地方，因此要发现 (DISCOVER) DHCP服务器的 IP 地址。这台主机目前还没有自己的 IP 地址，因此它将 IP 数据报的源 IP 地址设为全 0。这样，在本地网络上的所有主机都能够收到这个广播报文，但只有 DHCP 服务器才对此广播报文进行回答。DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做<strong>提供报文</strong>，表示“提供”了 IP 地址等配置信息。</li><li>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>，但并没有具体规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。</li></ul><h1 id="6-7-简单网络管理协议-SNMP"><a href="#6-7-简单网络管理协议-SNMP" class="headerlink" title="6.7 简单网络管理协议 SNMP"></a>6.7 简单网络管理协议 SNMP</h1><h2 id="6-7-1-网络管理的基本概念"><a href="#6-7-1-网络管理的基本概念" class="headerlink" title="6.7.1 网络管理的基本概念"></a>6.7.1 网络管理的基本概念</h2><ul><li><strong>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能、服务质量等。网络管理常简称为网管。</strong></li><li>网络是一个非常复杂的分布式系统。因为网络上有很多不同厂家生产的、运行着多种协议的结点，而这些结点还在相互通信和交换信息。</li><li>网络管理的一般模型<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812181706.png"></li><li><strong>管理站</strong>又称为<strong>管理器</strong>，是整个网络管理系统的核心，它通常是个有着良好图形界面的高性能的工作站，并由网络管理员直接操作和控制。所有向被管设备发送的命令都是从管理站发出的。管理站的所在部门也常称为<strong>网络运行中心</strong> NOC。管理站中的关键构件是<strong>管理程序</strong> (如图 6-21 中有字母 M 的椭圆形图标所示)。管理程序在运行时就成为<strong>管理进程</strong>。管理站 (硬件) 或管理程序 (软件) 都可称为<strong>管理者</strong>或<strong>管理器</strong>，所以这里的 manager 不是指人而是指机器或软件。网络管理员才是指人。大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的设备。</li><li>在被管网络中有很多的<strong>被管设备</strong> (包括设备中的软件)。被管设备可以是主机、路由器、打印机、集线器、网桥或调制解调器等。在每一个被管设备中可能有许多<strong>被管对象</strong>。被管对象可以是被管设备中的某个硬件，也可以是某些硬件或软件 (例如，路由选择协议) 的配置参数的集合。被管设备有时可称为网络<strong>元素</strong>或简称为<strong>网元</strong>。在被管设备中也会有一些<strong>不能被管的对象</strong>。</li><li><strong>简单网络管理协议</strong> SNMP 中的管理程序和代理程序按客户服务器方式工作。管理程序运行 SNMP <strong>客户程序</strong>，而代理程序运行 SNMP <strong>服务器程序</strong>。在被管对象上运行的 SNMP 服务器程序不停地监听来自管理站的 SNMP 客户程序的请求 (或命令)。一旦发现了，就立即返回管理站所需的信息，或执行某个动作。在网管系统中往往是一个 (或少数几个) 客户程序与很多的服务器程序进行交互。</li><li><strong>若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有对象的影响必须尽量小些。</strong></li></ol></li><li>SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。在网络正常工作时，SNMP 可实现统计、配置和测试等功能。当网络出故障时，可实现各种差错检测和恢复功能。</li><li>若网络元素使用的不是 SNMP 协议而是另一种网络管理协议，那么 SNMP 协议就无法控制该网络元素。这时可使用<strong>委托代理</strong>，委托代理能提供如协议转换和过滤操作等功能对被管对象进行管理。</li><li>SNMP 的网络管理由三个部分组成，SNMP 本身、<strong>管理信息结构</strong> SMI 和<strong>管理信息库</strong> MIB。<ol><li>SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象 (变量) 名及其状态 (值)。SNMP 负责读取和改变这些数值。</li><li>SMI 定义了命名对象和定义对象类型 (包括范围和长度) 的<strong>通用规则</strong>，以及把对象和对象的值进行<strong>编码的规则</strong>。这样做是为了确保网络管理数据的语法和语义无二义性。但从 SMI 的名称并不能看出它的功能。</li><li>MIB 在被管理的实体中创建了命名对象，并规定了其类型。</li></ol></li></ul><h2 id="6-7-2-管理信息结构-SMI"><a href="#6-7-2-管理信息结构-SMI" class="headerlink" title="6.7.2 管理信息结构 SMI"></a>6.7.2 管理信息结构 SMI</h2><ul><li><strong>管理信息结构</strong> SMI 是 SNMP 的重要组成部分，SMI 的功能应当有三个：<ol><li>被管对象应怎样命名；</li><li>用来存储被管对象的数据类型有哪些；</li><li>在网络上传送的管理数据应如何编码。</li></ol></li><li><strong>被管对象的命名</strong><ol><li>SMI 规定，所有的被管对象都必须处在<strong>对象命名树</strong>上。图 6-22 给出了对象命名树的一部分。对象命名树的根没有名字，它的下面有三个顶级对象，都是世界上著名的标准制定单位，即 ITU-T，ISO，以及这两个组织的联合体，它们的标号分别是 0 到 2。在 ISO 的下面的一个标号为 3 的节点是 ISO 认同的的组织成员 org。在其下面有一个美国国防部 dod 的子树 (标号为 6)，再下面就是 internet (标号为 1)。在 internet 节点下面的标号为 2 的节点是 mgmt。再下面只有一个节点，即管理信息库 mib-2，其对象标识符为 1.3.6.1.2.1。在 mib-2 下面包含了所有被 SNMP 管理的对象。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182130.png"></li></ul></li></ol></li><li><strong>被管对象的数据类型</strong><ol><li>SMI 使用基本的<strong>抽象语法记法</strong> 1 (即 ISO 制定的 ASN.1) 来定义数据类型，但又增加了一些新的定义。因此 SMI 既是 ASN.1 的子集，又是 ASN.1 的超集。ASN.1 的记法很严格，它使得数据的含义不存在任何可能的二义性。</li><li>SMI 把数据类型分为两大类：<strong>简单类型和结构化类型</strong>。简单类型是最基本的、直接使用 ASN.1 定义的类型。表 6-4 给出了最主要的几种简单类型。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182253.png"></li></ul></li><li>SMI 定义了两种结构化数据类型，即 sequence 和 sequence of。</li></ol></li><li><strong>编码方法</strong><ol><li>SMI 使用 ASN.1 制定的<strong>基本编码规则</strong> BER 进行数据的编码。BER 指明了每种数据的类型和值。在发送端用 BER 编码，可把用 ASN.1 所表述的报文转换成唯一的比特序列。在接收端用 BER 进行解码，就可得到该比特序列所表示的 ASN.1 报文。</li><li>ASN.1 把所有的数据元素都表示为 T-L-V 三个字段组成的序列 (见图 6-23)。T 字段 (Tag) <strong>定义数据的类型</strong> ，L 字段 (Length) 定义 V <strong>字段的长度</strong> ，而 V 字段 (Value) <strong>定义数据的值</strong>。<ul><li>T 字段又叫做<strong>标记字段</strong> ，占 1 字节。T 字段比较复杂，因为它要定义的数据类型较多。T 字段又再分为以下三个子字段：<ol><li><strong>类别</strong> (2 位) 共四种：通用类 (00)，即 ASN.1 定义的类型；应用类 (01)，即 SMI 定义的类型；上下文类 (10)，即上下文所定义的类型；专用类 (11)，保留为特定厂商定义的类型。</li><li><strong>格式</strong> (1 位) 共两种，指出数据类型的种类：简单数据类型 (0)，结构化数据类型 (1)。</li><li><strong>编号</strong> (5 位) 用来标志不同的数据类型。编号的范围一般为 0～30。当编号大于 30 时，T 字段就要扩展为多个字节。</li></ol></li><li>L 字段又叫做<strong>长度字段</strong> (单字节或多字节)。当 L 字段为单字节时，其最高位为 0，后面的 7 位定义 V 字段的长度。当 L 字段为多个字节时，其最高位为 1，而后面的 7 位定义后续字节的字节数 (用二进制整数表示)。这时，所有的后续字节并置起来的二进制整数定义 V 字段的长度。</li><li>V 字段又叫做<strong>值字段</strong>，用于定义数据元素的值。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812182351.png"></li></ul></li></ol></li></ul><h2 id="6-7-3-管理信息库-MIB"><a href="#6-7-3-管理信息库-MIB" class="headerlink" title="6.7.3 管理信息库 MIB"></a>6.7.3 管理信息库 MIB</h2><ul><li><strong>管理信息</strong>就是指在互联网的网管框架中<strong>被管对象的集合</strong>。被管对象必须维持可供管理程序读写的若干控制和状态信息。这些被管对象构成了一个虚拟的信息存储器，所以才称为<strong>管理信息库</strong> MIB。管理程序就使用 MIB 中这些信息的<strong>值</strong>对网络进行管理 (如读取或重新设置这些值)。只有在 MIB 中的对象才是 SNMP 所能够管理的。</li></ul><h2 id="6-7-4-SNMP-的协议数据单元和报文"><a href="#6-7-4-SNMP-的协议数据单元和报文" class="headerlink" title="6.7.4 SNMP 的协议数据单元和报文"></a>6.7.4 SNMP 的协议数据单元和报文</h2><ul><li>SNMP 的功能通过探询操作来实现，即 SNMP 管理进程定时向被管理设备周期性地发送探询信息。探询的好处是：<ol><li>使系统相对简单</li><li>能限制通过网络所产生的管理信息的通信量。但探询管理协议不够灵活，而且所能管理的设备数目不能太多。探询系统的开销也较大。</li></ol></li><li>SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为<strong>陷阱</strong>，表示它能够捕捉“事件”。但这种陷阱信息的参数是受限制的。</li><li>当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达到某些门限值的事件 (这就叫做<strong>过滤</strong>)。这种方法的好处是：<ol><li>仅在严重事件发生时才发送陷阱；</li><li>陷阱信息很简单且所需字节数很少。</li></ol></li><li>SNMP 使用无连接的 UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保证可靠交付的。</li><li>和大多数 TCP&#x2F;IP 协议不一样，SNMP 报文没有固定的字段。它们使用标准 ASN.1 编码。因此，SNMP 报文用人工进行编码和理解时都比较困难。</li><li>SNMP 的报文格式<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230812213115.png"></li><li>一个SNMP 报文共由四个部分组成，即<strong>版本、首部、安全参数</strong>和 SNMP 报文的<strong>数据部分</strong>。首部包括报文标识、最大报文长度、报文标志。报文标志占 1 字节，其中的每一位定义安全类型或其他信息。安全参数用来产生报文摘要。</li><li>在 SNMP PDU 前面还有两个有关加密信息的字段。这是当数据部分需要加密时才使用的两个字段。与网络管理直接相关的是后面的 SNMP PDU 部分。由 PDU <strong>类型、请求</strong> ID、<strong>差错状态、差错索引</strong>以及<strong>变量绑定</strong>这几个字段组成。</li><li>简单介绍一下其他字段的作用：<ul><li><strong>请求标识符</strong>　由管理进程设置的 4 字节整数值。代理进程在发送响应报文时也要返回此请求标识符。由于管理进程可同时向许多代理发出请求读取变量值的报文，因此设置了请求标识符可使管理进程能够识别返回的响应是对应于哪一个请求报文。</li><li><strong>差错状态</strong>　在请求报文中，这个字段是零。当代理进程响应时，就填入 0～18 中的一个数字。例如 0 表示 noError，1 表示 tooBig，2 表示 noSuchName，3 表示badValue。</li><li><strong>差错索引</strong>　在请求报文中，这个字段是零。当代理进程响应时，若出现 noSuchName，badValue 或 readOnly 的差错，代理进程就设置一个整数，指明有差错的变量在变量列表中的偏移。</li><li><strong>变量绑定</strong>　指明一个或多个变量的名和对应的值。在请求报文中，变量的值应忽略 (类型是 NULL)。</li></ul></li></ol></li></ul><h1 id="6-8-应用进程跨越网络的通信"><a href="#6-8-应用进程跨越网络的通信" class="headerlink" title="6.8 应用进程跨越网络的通信"></a>6.8 应用进程跨越网络的通信</h1><h2 id="6-8-1-系统调用和应用编程接口"><a href="#6-8-1-系统调用和应用编程接口" class="headerlink" title="6.8.1 系统调用和应用编程接口"></a>6.8.1 系统调用和应用编程接口</h2><ul><li>当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口。此接口再把控制权传递给计算机的操作系统。操作系统把这个调用转给某个内部过程，并执行所请求的操作。内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程。总之，只要应用进程需要从操作系统获得服务，就要把控制权传递给操作系统，操作系统在执行必要的操作后把控制权返回给应用进程。因此，系统调用接口实际上是应用进程的控制权和操作系统的控制权进行转换的一个接口。由于应用程序在使用系统调用之前要编写一些程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为<strong>应用编程接口</strong> API。API <strong>从程序设计的角度</strong>定义了许多标准的系统调用函数。应用进程只要使用标准的系统调用函数就可得到操作系统的服务。因此从程序设计的角度看，也可以把 API 看成是应用程序和操作系统之间的接口。</li><li>在套接字以上的进程是受应用程序控制的，而在套接字以下的运输层协议软件则是受计算机操作系统的控制。因此，只要应用程序使用 TCP&#x2F;IP 协议进行通信，它就必须通过套接字与操作系统交互 (这就要使用系统调用函数) 并请求其服务。</li></ul><h2 id="6-8-2-几种常用的系统调用"><a href="#6-8-2-几种常用的系统调用" class="headerlink" title="6.8.2 几种常用的系统调用"></a>6.8.2 几种常用的系统调用</h2><ul><li><strong>连接建立阶段</strong></li><li><strong>数据传送阶段</strong></li><li><strong>连接释放阶段</strong></li></ul><h1 id="6-9-P2P应用"><a href="#6-9-P2P应用" class="headerlink" title="6.9 P2P应用"></a>6.9 P2P应用</h1><h2 id="6-9-1-具有集中目录服务器-P2P-工作方式"><a href="#6-9-1-具有集中目录服务器-P2P-工作方式" class="headerlink" title="6.9.1 具有集中目录服务器 P2P 工作方式"></a>6.9.1 具有集中目录服务器 P2P 工作方式</h2><ul><li>集中式目录服务器的最大缺点就是可靠性差，而且会成为其性能的瓶颈 (尤其是在用户数非常多的情况下)。</li></ul><h2 id="6-9-2-具有全分布式结构的P2P文件共享程序"><a href="#6-9-2-具有全分布式结构的P2P文件共享程序" class="headerlink" title="6.9.2 具有全分布式结构的P2P文件共享程序"></a>6.9.2 具有全分布式结构的P2P文件共享程序</h2><h2 id="6-9-3-P2P文件分发的分析"><a href="#6-9-3-P2P文件分发的分析" class="headerlink" title="6.9.3 P2P文件分发的分析"></a>6.9.3 P2P文件分发的分析</h2><h2 id="6-9-4-在-P2P-对等方中搜索对象"><a href="#6-9-4-在-P2P-对等方中搜索对象" class="headerlink" title="6.9.4 在 P2P 对等方中搜索对象"></a>6.9.4 在 P2P 对等方中搜索对象</h2><ul><li>在 P2P 文件系统中，对等方用户的数量非常多，并且处于一种无序的状态。任何一个对等方可以随时加入进来或随时退出。在这种情况下，怎样有效地找到所需的文件，也就是怎样有效地定位对等方及其资源，是 P2P 系统中重要的问题。</li><li>现在广泛使用的索引和查找技术叫做<strong>分布式散列表</strong> DHT。DHT 也可译为分布式哈希表，它是由大量对等方共同维护的散列表。</li><li>分布式散列表 DHT 利用散列函数，把资源名 K 及其存放的结点 IP 地址 N 都分别映射为<strong>资源名标识符</strong> KID 和<strong>结点标识符</strong> NID。</li><li>为了加速查找，在 Chord 环上可以增加一些<strong>指针表</strong>，它又称为<strong>路由表</strong>或<strong>查找器表</strong>。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>应用层协议是为了解决某一类应用问题，而问题的解决又是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层规定了应用进程在通信时所遵循的协议。应用层的许多协议都是基于客户服务器方式的。客户是服务请求方，服务器是服务提供方。</p></li><li><p>域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。DNS 是一个联机分布式数据库系统，并采用客户服务器方式。</p></li><li><p>域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序 (即域名服务器) 共同完成的。</p></li><li><p>互联网采用层次树状结构的命名方法，任何一台连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。域名中的点和点分十进制 IP 地址中的点没有关系。</p></li><li><p>域名服务器分为根域名服务器、顶级域名服务器、权限域名服务器和本地域名服务器。</p></li><li><p>文件传送协议 FTP 使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。在进行文件传输时，FTP 的客户和服务器之间要建立两个并行的 TCP 连接：控制连接和数据连接。实际用于传输文件的是数据连接。</p></li><li><p>万维网 WWW 是一个大规模的、联机式的信息储藏所，可以非常方便地从互联网上的一个站点链接到另一个站点。</p></li><li><p>万维网的客户程序向互联网中的服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在客户程序主窗口上显示出的万维网文档称为页面。</p></li><li><p>万维网使用统一资源定位符 URL 来标志万维网上的各种文档，并使每一个文档在整个互联网的范围内具有唯一的标识符 URL。</p></li><li><p>万维网客户程序与服务器程序之间进行交互所使用的协议是超文本传送协议 HTTP。HTTP 使用 TCP 连接进行可靠的传送。但 HTTP 协议本身是无连接、无状态的。HTTP&#x2F;1.1 协议使用了持续连接 (分为非流水线方式和流水线方式)。</p></li><li><p>万维网使用超文本标记语言 HTML 来显示各种万维网页面。</p></li><li><p>万维网静态文档是指在文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建的。</p></li><li><p>活动文档技术可以使浏览器屏幕连续更新。活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。</p></li><li><p>在万维网中用来进行搜索的工具叫做搜索引擎。搜索引擎大体上可划分为全文检索搜索引擎和分类目录搜索引擎两大类。</p></li><li><p>电子邮件是互联网上使用最多的和最受用户欢迎的一种应用。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取，相当于“电子信箱”。</p></li><li><p>一个电子邮件系统有三个主要组成构件，即：用户代理、邮件服务器，以及邮件协议 (包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP)。用户代理和邮件服务器都要运行这些协议。</p></li><li><p>电子邮件的用户代理就是用户与电子邮件系统的接口，它向用户提供一个很友好的视窗界面来发送和接收邮件。</p></li><li><p>从用户代理把邮件传送到邮件服务器，以及在邮件服务器之间的传送，都要使用 SMTP 协议。但用户代理从邮件服务器读取邮件时，则要使用 POP3 (或 IMAP) 协议。</p></li><li><p>基于万维网的电子邮件使用户能够利用浏览器收发电子邮件。用户浏览器和邮件服务器之间的邮件传送使用 HTTP 协议，而在邮件服务器之间邮件的传送仍然使用 SMTP 协议。</p></li><li><p>简单网络管理协议 SNMP 由三部分组成：</p><ol><li>SNMP 本身，负责读取和改变各代理中的对象名及其状态数值</li><li>管理信息结构 SMI，定义命名对象和定义对象类型 (包括范围和长度) 的通用规则，以及把对象和对象的值进行编码的基本编码规则 BER</li><li>管理信息库 MIB，在被管理的实体中创建了命名对象，并规定了其类型。</li></ol></li><li><p>系统调用接口是应用进程的控制权和操作系统的控制权进行转换的一个接口，又称为应用编程接口 API。API 是应用程序和操作系统之间的接口。</p></li><li><p>套接字是应用进程和运输层协议之间的接口，是应用进程为了获得网络通信服务而与操作系统进行交互时使用的一种机制。</p></li><li><p>目前 P2P 工作方式下的文件共享在互联网流量中已占据最大的份额，比万维网应用所占的比例大得多。</p></li><li><p>BT 是很流行的一种 P2P 应用。BT 采用“最稀有的优先”的技术，可以尽早把最稀有的文件块收集到。此外，凡有当前以最高数据率向某个对等方传送文件块的相邻对等方，该对等方就优先把所请求的文件块传送给这些相邻对等方。这样做的结果是，这些对等方相互之间都能够以令人满意的速率交换文件块。</p></li><li><p>当对等方的数量很大时，采用 P2P 方式下载大文件，要比传统的客户−服务器方式快得多。</p></li><li><p>在 P2P 应用中，广泛使用的索引和查找技术是分布式散列表 DHT。</p></li><li><p>域名系统的主要功能是什么？域名系统中的根域名服务器、顶级域名服务器、权限域名服务器以及本地域名服务器有何区别？</p><blockquote><p>根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。根域名服务器是最重要的域名服务器，因为不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析 (即转换为 IP 地址)，只要自己无法解析，就首先要求助于根域名服务器。域名系统 DNS 是互联网使用的命名系统，用来把便于人们使用的机器名字转换为 IP 地址。在域名系统中使用了层次结构的许多域名服务器。<br>顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名。当收到 DNS 查询请求时，就给出相应的回答 (可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址)。一个服务器所负责管辖的 (或有权限的) 范围叫做区。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。<br>因此，权限域名服务器是负责一个区的域名服务器。当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。<br>本地域名服务器离用户较近，一般不超过几个路由器的距离。当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。当所要查询的主机也属于同一个本地 ISP 时，该本地域名服务器立即就能将所查询的主机名转换为它的 IP 地址，而不需要再去询问其他的域名服务器。</p></blockquote></li><li><p>简单文件传送协议 TFTP 与文件传送协议 FTP 的主要区别是什么？应用在什么场合？</p><blockquote><p>简单文件传送协议 TFTP是一个很小且易于实现的文件传送协议。虽然 TFTP 也使用客户服务器方式，但它使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。FTP 使用 TCP 传送数据，因而是很可靠的。但正因如此，FTP 比 TFTP 复杂得多。TFTP 只支持文件传输而不支持交互。TFTP 有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。<br>TFTP 的主要优点有两个: (1) TFTP 可用于 UDP 环境；(2) TFTP 代码所占的内存较小。<br>TFTP 的工作很像停止等待协议。发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。发完数据后在规定时间内收不到确认就要重发数据 PDU。发送确认 PDU 的一方，若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。当我们只需要复制一个文件而不需要 FTP 协议的功能时，就只需要一个能够迅速复制这些文件的协议，TFTP 就是一个很好的选择。<br><strong>复杂性</strong>：TFTP 是一种非常简单的文件传输协议，功能相对有限。它设计简单，只支持文件的读写操作，没有目录列表、权限管理等高级功能；FTP 是一个功能更为丰富和复杂的协议。它支持文件上传、下载、删除、重命名等操作，同时提供目录列表、权限管理、登录认证等多种功能。<br><strong>设计</strong>：TFTP 的设计目标是轻量级和简单，它使用 UDP 进行通信，没有建立连接的过程，因此具有低开销但也更容易受到网络中断等问题的影响；FTP 是一个基于 TCP 的协议，它建立连接后进行通信，具有更为可靠的传输机制，但相对来说会有更多的开销。<br><strong>安全性</strong>：TFTP 在安全性方面较为薄弱，没有提供加密和身份验证机制，传输的数据是明文的，容易受到中间人攻击；FTP 的安全性相对更强，支持加密和登录认证，可以更好地保护数据传输的隐私和完整性。<br><strong>TFTP</strong>：由于其简单性，TFTP 通常用于一些特定的场景，如在内部网络中进行配置文件的传输、嵌入式设备的固件升级等。<br><strong>FTP</strong>：FTP 适用于更复杂的文件传输需求，例如，Web 开发中文件上传、下载，或者在服务器之间进行文件的备份和同步等。<br>总体来说，TFTP 适用于简单的、对复杂性和安全性要求不高的文件传输场景，而 FTP 适用于更为复杂和安全要求较高的文件传输场景。</p></blockquote></li><li><p>DHCP 协议用在什么情况下？当一台计算机第一次运行引导程序时，其 ROM 中有没有该主机的 IP 地址、子网掩码，或某个域名服务器的 IP 地址？</p><blockquote><p>动态主机配置协议 DHCP 提供了即插即用连网机制。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。因此，每当一台计算机加入到一个新的网络时就需要运行 DHCP 协议来获取这台计算机的 IP 地址。<br>当一台计算机第一次运行引导程序时，ROM 中并没有该计算机的 IP 地址、子网掩码或某个域名服务器的 IP 地址的任何一个。</p></blockquote></li><li><p>SNMP 协议使用 UDP 传送报文，为什么不使用 TCP？</p><blockquote><p>SNMP 使用无连接的 UDP (要发送数据时不需要有连接建立过程，数据发送完毕后，也不需要连接释放过程)，因此在网络上传送 SNMP 报文的开销较小。但 UDP 是不保证可靠交付的，有丢失的可能。好在 SNMP 使用周期性地发送探询报文段的方法，来对网络资源进行实时监视，如果丢失了一个探寻报文，则经过一段时间后，会再发送一个。这样就比使用 TCP 要快速得多。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层</title>
      <link href="/2023/12/09/wang-luo-ceng/"/>
      <url>/2023/12/09/wang-luo-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h1><ul><li><strong>表4-1　虚电路服务与数据报服务的对比</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722192206.png"></li></ol></li></ul><h1 id="4-2-网际协议-IP"><a href="#4-2-网际协议-IP" class="headerlink" title="4.2 网际协议 IP"></a>4.2 网际协议 IP</h1><ul><li>网际协议 IP 是 TCP&#x2F;IP 体系中两个主要的协议之一，也是最重要的互联网标准协议之一。</li><li>与 IP 协议配套使用的还有三个协议：<ol><li><strong>地址解析协议 ARP</strong></li><li><strong>网际控制报文协议 ICMP</strong></li><li><strong>网际组管理协议 IGMP</strong></li></ol></li><li>图 4-2 画出了这三个协议和网际协议 IP 的关系。这一层中，ARP 画在最下面，因为 IP 经常使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722193402.png"></li></ol></li><li>网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP&#x2F;IP 体系中的网络层常常被称为<strong>网际层</strong>或 <strong>IP 层</strong>。</li></ul><h2 id="4-2-1-虚拟互连网络"><a href="#4-2-1-虚拟互连网络" class="headerlink" title="4.2.1 虚拟互连网络"></a>4.2.1 虚拟互连网络</h2><ul><li>用户的需求是多种多样的，<strong>没有一种单一的网络能够适应所有用户的需求</strong>。</li><li>将网络互相连接起来要使用<strong>中间设备</strong>。根据中间设备所在的层次，有以下不同的中间设备: <ol><li>物理层使用的中间设备叫做<strong>转发器</strong>。</li><li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>。</li><li>网络层使用的中间设备叫做<strong>路由器</strong>。</li><li>在网络层以上使用的中间设备叫做<strong>网关</strong>。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li></ol></li><li>图 4-3 (a) 表示有许多计算机网络通过路由器进行互连。由于参加互连的计算机网络都使用相同的<strong>网际协议</strong> IP，因此可以把互连以后的计算机网络看成如图 4-3 (b) 所示的一个<strong>虚拟互连网络</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722193637.png"></li></ol></li><li>利用 IP 协议可以使性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。</li><li>使用 IP 网的好处是: 当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节。</li><li>在图 4-4 所示的互联网中的源主机 H<sub>1</sub> 要把一个 IP 数据报发送给目的主机 H<sub>2</sub>。根据分组交换存储转发概念，主机 H<sub>1</sub> 先查找自己的路由表，看目的主机是否在本网络上。如在，则<strong>直接交付</strong>。如不在，则必须把 IP 数据报发送给某个路由器 (图中的 R<sub>1</sub>)。R<sub>1</sub> 在查找路由表后，知道应当把数据报转发给 R<sub>2</sub> 进行<strong>间接交付</strong>。这样一直转发下去，最后路由器 R<sub>5</sub> 和 H<sub>2</sub> 连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报<strong>直接交付</strong>目的主机 H<sub>2</sub>。图中画出了源主机、目的主机以及各路由器的协议栈。主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向 (用黑色粗线表示)。在 R<sub>4</sub> 和 R<sub>5</sub> 之间使用了卫星链路，R<sub>5</sub> 所连接的是个无线局域网。在 R<sub>1</sub> 到 R<sub>4</sub> 之间的三个网络则可以是任意类型的网络。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723110729.png"></li></ol></li><li><strong>互联网可以由多种异构网络互连组成</strong>。</li></ul><h2 id="4-2-2-分类的-IP-地址"><a href="#4-2-2-分类的-IP-地址" class="headerlink" title="4.2.2 分类的 IP 地址"></a>4.2.2 分类的 IP 地址</h2><ul><li><strong>IP 地址及其表示方法</strong><ol><li>互联网是一个<strong>单一的、抽象的网络</strong>。IP 地址是给互联网上的每台主机 (或路由器) 的每个接口分配一个在全世界范围唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上方便地进行寻址。</li><li>IP 地址的编址方法共经过了三个历史阶段：<ul><li><strong>分类的 IP 地址</strong>是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li><li><strong>子网的划分</strong>是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</li><li><strong>构成超网</strong>是比较新的无分类编址方法。1993年提出后很快就得到推广应用。</li></ul></li><li>“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成。第一个字段是<strong>网络号</strong>，它标志主机 (或路由器) 所连接到的网络，网络号是唯一的。第二个字段是<strong>主机号</strong>，它标志该主机 (或路由器)。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。一个 IP 地址<strong>在整个互联网范围内是唯一的</strong>。</li><li>这种两级的 IP 地址可以记为：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112010.png"></li><li>式 4-1 中的符号“::&#x3D;”表示“<strong>定义为</strong>”。图  4-5 给出了各种 IP 地址的网络号字段和主机号字段，A 类、B 类和 C 类地址都是<strong>单播地址</strong>，是最常用的。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112033.png"></li></ol></li><li>从图4-5 可以看出：<ol><li>A 类、B 类和 C 类地址的网络号字段分别为 1、2 和 3 个字节长，而在网络号字段的最前面有 1～3 位的<strong>类别位</strong> ，其数值分别规定为 0，10 和 110。</li><li>A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。</li><li>D 类地址 (前 4 位是 1110) 用于<strong>多播</strong>。</li><li>E 类地址 (前 4 位是 1111) 保留为以后用。</li></ol></li></ul></li><li>从 IP 地址的结构来看，<strong>IP</strong> 地址并不仅仅指明一台主机，还指明了主机所连接到的网络。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112436.png"></li></ol></li><li><strong>常用的三种类别的 IP 地址</strong><ol><li>A类地址<ul><li>A 类地址的网络号字段占 1 个字节，只有 7 位可供使用 (该字段的第一位固定为 0)，但可指派的网络号是 126 个 (即 2<sup>7</sup>–2)。减 2 的原因是：第一，IP 地址中的全 0 表示“<strong>这个</strong>”。网络号字段为全 0 的 IP 地址是个保留地址，意思是“<strong>本网络</strong>”；第二，网络号为 127 (即01111111) 保留作为本地软件<strong>环回测试</strong>本主机的进程之间的通信。若主机发送一个目的地址为环回地址 (例如127.0.0.1) 的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址不是网络地址。</li><li>A 类地址的主机号占 3 个字节，因此每一个 A 类网络中的最大主机数是 2<sup>24</sup>–2，即16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>单个网络地址</strong> (例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是5.0.0.0)，全 1 表示“<strong>所有的</strong>”，因此全 1 的主机号字段表示该网络上的所有主机。</li><li>IP 地址空间共有 2<sup>32</sup> (4294967296) 个地址。整个 A 类地址空间共有 2<sup>31</sup> 个地址，占整个IP地址空间的 50％。</li></ul></li><li>B 类地址<ul><li>B 类地址的网络号字段有 2 个字节，前面两位 (10) 已固定了，剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此不存在网络总数减 2 的问题。实际上 B 类网络地址 128.0.0.0 是不指派的，可以指派的 B 类最小网络地址是 128.1.0.0。因此 B 类地址可指派的网络数为 2<sup>14</sup>−1，即 16383。B 类地址的每一个网络上的最大主机数是 2<sup>16</sup>–2，即 65534。这里需要减2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 2<sup>30</sup> 个地址，占整个 IP地址空间的 25％。</li></ul></li><li>C 类地址<ul><li>C 类地址有 3 个字节的网络号字段，最前面的 3 位是 (110)，还有 21 位可以进行分配。C类网络地址 192.0.0.0 是不指派的，可指派的 C 类最小网络地址 192.0.1.0，因此 C 类地址可指派的网络总数是 2<sup>21</sup>−1，即 2097151。每一个 C 类地址的最大主机数是 2<sup>8</sup>–2，即254。整个 C 类地址空间共约有 2<sup>29</sup> 个地址，占整个 IP 地址的 12.5％。</li></ul></li><li>得出表 4-2 所示的 IP 地址的指派范围。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112931.png"></li></ul></li><li>表 4-3 给出了一般不使用的特殊 IP 地址，这些地址只能在特定的情况下使用。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112945.png"></li></ul></li><li>IP 地址具有以下一些重要特点：<ul><li>每个 IP 地址都由网络号和主机号两部分组成。IP 地址是一种<strong>分等级的地址结构</strong>。分两个等级的好处是：<ol><li>IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong> (第一级)，而剩下的主机号 (第二级) 由得到该网络号的单位自行分配。方便了 IP 地址的管理。</li><li>路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong> (不考虑目的主机号)，可以使路由表中的项目数大幅度减少，从而<strong>减小了路由表所占的存储空间以及查找路由表的时间</strong>。</li></ol></li><li>实际上 IP 地址是标志一台主机 (或路由器) 和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>。一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。</li><li>一个网络指具有相同网络号 net-id 的主机的集合，因此，<strong>用转发器或网桥连接的若干个局域网仍为一个网络</strong>，这些局域网具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li><li>在 IP 地址中，所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域)，互联网都会同等对待每一个 IP 地址。</li></ul></li><li><h2 id="图-4-7-画出了三个局域网-LAN1，LAN2-和-LAN3-通过三个路由器-R1，R2-和-R3-互连起来所构成的一个互联网-互联网用虚线圆角方框表示-。其中局域网-LAN2-是由两个网段通过网桥-B-互连的。图中的小圆圈表示需要有-IP-地址。"><a href="#图-4-7-画出了三个局域网-LAN1，LAN2-和-LAN3-通过三个路由器-R1，R2-和-R3-互连起来所构成的一个互联网-互联网用虚线圆角方框表示-。其中局域网-LAN2-是由两个网段通过网桥-B-互连的。图中的小圆圈表示需要有-IP-地址。" class="headerlink" title="图 4-7 画出了三个局域网 (LAN1，LAN2 和 LAN3) 通过三个路由器 (R1，R2 和 R3) 互连起来所构成的一个互联网 (互联网用虚线圆角方框表示)。其中局域网 LAN2 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有 IP 地址。 - "></a>图 4-7 画出了三个局域网 (LAN<sub>1</sub>，LAN<sub>2</sub> 和 LAN<sub>3</sub>) 通过三个路由器 (R<sub>1</sub>，R<sub>2</sub> 和 R<sub>3</sub>) 互连起来所构成的一个互联网 (互联网用虚线圆角方框表示)。其中局域网 LAN<sub>2</sub> 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有 IP 地址。<br> - <img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723113523.png"></h2><pre><code> 1. 在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。图中所示的网络号就是 IP 地址中的网络号字段的值。另一种表示方法是用主机号为全 0 的网络IP 地址。 2. 用网桥互连的网段仍然是一个局域网，只能有一个网络号。 3. 路由器总是具有两个或两个以上的 IP 地址。即路由器的每一个接口都有一个不同网络号的 IP 地址。 4. 当两个路由器直接相连时 (例如通过一条租用线路)，在连线两端的接口处，可以分配也可以不分配 IP 地址。如分配了 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” (如图中的 N&lt;sub&gt;1&lt;/sub&gt;，N&lt;sub&gt;2&lt;/sub&gt; 和 N&lt;sub&gt;3&lt;/sub&gt;)。之所以叫做“网络”是因为它有 IP 地址。但为了节省 IP 地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配 IP 地址。通常把这样的特殊网络叫做**无编号网络**或**无名网络**。</code></pre></li></ol></li></ul><h2 id="4-2-3-IP-地址与硬件地址"><a href="#4-2-3-IP-地址与硬件地址" class="headerlink" title="4.2.3 IP 地址与硬件地址"></a>4.2.3 IP 地址与硬件地址</h2><ul><li>图 4-8 说明了物理地址与 IP 地址的区别。从层次的角度看，<strong>物理地址是数据链路层和物理层使用的地址</strong>，IP <strong>地址是网络层和以上各层使用的地址，是一种逻辑地址</strong> (称 IP 地址为逻辑地址是因为 IP 地址是用软件实现的)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723113843.png"></li></ol></li><li>在发送数据时，数据从高层下到低层，然后到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中；连接在通信链路上的设备 (主机或路由器) 在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址；总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。</li><li>图 4-9 (a) 画的是三个局域网用两个路由器 R<sub>1</sub> 和 R<sub>2</sub> 互连起来。现在主机 H<sub>1</sub> 要和主机 H<sub>2</sub> 通信。这两台主机的 IP 地址分别是 IP<sub>1</sub> 和 IP<sub>2</sub>，而它们的硬件地址分别为 HA<sub>1</sub> 和 HA<sub>2</sub> (HA 表示 Hardware Address)。通信的路径是：H<sub>1</sub>→ 经过 R<sub>1</sub> 转发 → 再经过 R<sub>2</sub> 转发 →H<sub>2</sub>。路由器 R<sub>1</sub> 因同时连接到两个局域网上，因此它有两个硬件地址，即 HA<sub>3</sub> 和 HA<sub>4</sub>。同理，路由器 R<sub>2</sub> 也有两个硬件地址 HA<sub>5</sub> 和 HA<sub>6</sub>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723234703.png"></li><li>图 4-9 (b) 特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723234720.png"></li></ul></li></ol></li><li>强调指出以下几点：<ol><li><strong>在 IP 层抽象的互联网上只能看到 IP 数据报</strong>。虽然 IP 数据报要经过路由器 R<sub>1</sub> 和 R<sub>2</sub> 的两次转发，但源地址和目的地址始终是 IP<sub>1</sub> 和 IP<sub>2</sub>。图中的数据报上写的“从 IP<sub>1</sub> 到 IP<sub>2</sub>”表示前者是源地址，后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li><li>虽然在 IP 数据报首部有源站 IP 地址，但<strong>路由器只根据目的站的 IP 地址的网络号进行路由选择</strong>。</li><li><strong>在局域网的链路层，只能看见 MAC 帧</strong>。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图4-9 (b)。开始在 H<sub>1</sub> 到 R<sub>1</sub> 间传送时，MAC 帧首部中写的是从硬件地址 HA<sub>1</sub> 发送到硬件地址 HA<sub>3</sub>，路由器 R<sub>1</sub> 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新添加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 HA<sub>4</sub>和 HA<sub>5</sub>。路由器 R<sub>2</sub> 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变成为 HA<sub>6</sub> 和 HA<sub>2</sub>。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。</li><li>尽管互连在一起的网络的硬件地址体系各不相同，<strong>但 IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。在网络层上讨论问题时，能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信</strong>。</li></ol></li></ul><h2 id="4-2-4-地址解析协议-ARP"><a href="#4-2-4-地址解析协议-ARP" class="headerlink" title="4.2.4 地址解析协议 ARP"></a>4.2.4 地址解析协议 ARP</h2><ul><li>图 4-10 说明了 ARP 协议的作用。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724110352.png"></li></ol></li><li>在网络层中，数据包使用 IP 地址进行路由和传输。然而，在实际的网络链路上，数据帧必须使用该网络的硬件地址进行传输。</li><li><strong>地址解析协议</strong> ARP 是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新 (新增或超时删除)。</li><li>如果不使用 ARP 高速缓存，那么任何一台主机只要进行一次通信，就必须在网络上用广播方式发送 ARP 请求分组，使网络上的通信量增加。ARP 把已经得到的地址映射保存在高速缓存中，使该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。</li><li>ARP 对保存在高速缓存中的每一个映射地址项目设置<strong>生存时间</strong>，超过生存时间的项目就从高速缓存中删除掉。</li><li>ARP 解决<strong>同一个局域网上</strong>的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，就无法解析另一个局域网主机的硬件地址。</li><li>归纳出使用 ARP 的四种典型情况 (图 4-12)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724110844.png"></li><li>发送方是主机 (如 H<sub>1</sub>)，要把 IP 数据报发送到同一个网络上的另一台主机 (如 H<sub>2</sub>)。这时 H<sub>1</sub> 发送 ARP 请求分组 (在网 1 上广播)，找到目的主机 H<sub>2</sub> 的硬件地址。</li><li>发送方是主机 (如 H<sub>1</sub>），要把 IP 数据报发送到另一个网络上的一台主机 (如 H<sub>3</sub> 或 H<sub>4</sub>)。这时 H<sub>1</sub>发送 ARP 请求分组 (在网 1 上广播)，找到网 1 上的一个路由器 R<sub>1</sub> 的硬件地址。剩下的工作由路由器 R<sub>1</sub> 来完成。R<sub>1</sub> 要做的事情是下面的 (3) 或 (4)。</li><li>发送方是路由器 (如 R<sub>1</sub>)，要把 IP 数据报转发到与 R<sub>1</sub> 连接在同一个网络 (网 2) 上的主机 (如 H<sub>3</sub>)。这时 R<sub>1</sub> 发送 ARP 请求分组 (在网 2 上广播)，找到目的主机 H<sub>3</sub> 的硬件地址。</li><li>发送方是路由器 (如 R<sub>1</sub>)，要把 IP 数据报转发到网3上的一台主机 (如 H<sub>4</sub>)。H<sub>4</sub> 与 R<sub>1</sub> 不是连接在同一个网络上。这时 R<sub>1</sub> 发送 ARP 请求分组 (在网 2 上广播)，找到连接在网 2 上的一个路由器 R<sub>2</sub> 的硬件地址。剩下的工作由这个路由器 R<sub>2</sub> 来完成。</li></ol></li><li>存在着各式各样的网络，<strong>它们使用不同的硬件地址</strong>。要使这些异构网络能够互相通信就必须进行<strong>非常复杂的硬件地址转换工作</strong>，因此由用户或用户主机来完成这项工作几乎是不可能的事。</li></ul><h2 id="4-2-5-IP-数据报的格式"><a href="#4-2-5-IP-数据报的格式" class="headerlink" title="4.2.5 IP 数据报的格式"></a>4.2.5 IP 数据报的格式</h2><ul><li>图 4-13 是 IP 数据报的完整格式。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724111741.png"></li></ol></li><li>一个 IP 数据报由首部和数据两部分组成。首部的前一部分是<strong>固定长度</strong>，共 20 字节，所有 IP 数据报必须具有。在首部的固定部分的后面是一些<strong>可选字段</strong>，其长度可变。</li><li><strong>IP 数据报首部的固定部分中的各字段</strong><ol><li><strong>版本</strong>   占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4 (即 IPv4)。</li><li><strong>首部长度</strong>   占 4 位，可表示的最大十进制数值是 15。首部长度字段所表示数的单位是 32 位字长 (1 个 32 位字长是 4 字节)。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 0101。而当首部长度为最大值 1111 时，就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用，但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节 (即首部长度为 0101)，这时不使用任何选项。</li><li><strong>区分服务</strong>   占 8 位，用来获得更好的服务。只有在使用区分服务时，这个字段才起作用，在一般的情况下都不使用这个字段。</li><li><strong>总长度</strong>   总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 2<sup>16</sup>–1＝65535 字节。</li><li><strong>标识</strong>   占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li><li><strong>标志</strong>   占 3 位，目前只有两位有意义。<ul><li>标志字段中的最低位记为 <strong>MF</strong>。MF＝1 即表示后面“<strong>还有分片</strong>”的数据报。MF＝0 表示这已是若干数据报片中的最后一个。</li><li>标志字段中间的一位记为 <strong>DF</strong>，意思是“<strong>不能分片</strong>”。只有当 DF＝0 时才允许分片。</li></ul></li><li><strong>片偏移</strong>   占 13 位。片偏移指：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位，每个分片的长度是 8 字节 (64 位) 的整数倍。</li><li><strong>生存时间</strong> 　占 8 位。生存时间字段的英文缩写是 TTL，是数据报在网络中的<strong>寿命</strong>。由发出数据报的源点设置这个字段。目的是防止无法交付的数据报无限制地在互联网中兜圈子，消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。</li><li><strong>协议</strong>   占 8 位。协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP 层知道应将数据部分上交给哪个协议进行处理。</li><li><strong>首部检验和</strong>   占 16 位。这个字段<strong>只检验数据报的首部，但不包括数据部分</strong>。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和，但不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的 CRC 检验码而采用下面的简单计算方法：在发送方，先把 IP 数据报首部划分为许多 16 位字的序列，并把检验和字段置零。用反码算术运算把所有 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有 16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为 0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。图 4-15 说明了 IP 数据报首部检验和的计算过程。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230729164523.png"></li></ol></li><li><strong>源地址</strong> 　占 32 位。</li><li><strong>目的地址</strong> 　占 32 位。</li></ol></li><li><strong>IP 数据报首部的可变部分</strong><ol><li>IP 数据报首部的可变部分是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容丰富。</li><li>增加首部的可变部分是为了增加 IP 数据报的功能，同时也增加了每一个路由器处理数据报的开销。</li></ol></li></ul><h2 id="4-2-6-IP-层转发分组的流程"><a href="#4-2-6-IP-层转发分组的流程" class="headerlink" title="4.2.6 IP 层转发分组的流程"></a>4.2.6 IP 层转发分组的流程</h2><ul><li>若路由表指出到每一台主机应怎样转发，则所得出的路由表就会过于庞大，即<strong>每一行对应于一台主机</strong>；但若路由表指出到某个网络应如何转发，则每个路由器中的路由表就只包含 4 个项目，即<strong>每一行对应于一个网络</strong>。</li><li>在互联网上转发分组时，是<strong>从一个路由器转发到下一个路由器</strong>。</li><li>在路由表中，对每一条路由最主要的是以下两个信息：<strong>目的网络地址，下一跳地址</strong>。</li><li>根据目的网络地址来确定下一跳路由器，可得出以下的结果：<ol><li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ol></li><li>互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>。</li><li>采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，也可在需要考虑某种安全问题时采用这种特定主机路由。</li><li>路由器还可采用<strong>默认路由</strong>以减小路由表所占用的空间和搜索路由表所用的时间。</li><li><strong>分组转发算法</strong>如下：<ol><li>从数据报的首部提取目的主机的 IP 地址 <em>D</em>，得出目的网络地址为 <em>N</em>。</li><li>若 <em>N</em> 是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 <em>D</em> 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行 3。</li><li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。</li><li>若路由表中有到达网络 <em>N</em> 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 5。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。</li><li>报告转发分组出错。</li></ol></li></ul><h1 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3 划分子网和构造超网"></a>4.3 划分子网和构造超网</h1><h2 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1 划分子网"></a>4.3.1 划分子网</h2><ul><li><strong>从两级 IP 地址到三级 IP 地址</strong><ol><li>在 ARPANET 的早期，IP 地址的设计不够合理：<ul><li>IP <strong>地址空间的利用率有时很低</strong></li><li>给每一个物理网络分配一个网络号会<strong>使路由表变得太大</strong>因而使网络性能变坏</li><li><strong>两级 IP 地址不够灵活</strong></li></ul></li><li>为解决上述问题，在 IP 地址中增加了一个“<strong>子网号字段</strong>”，使两级 IP 地址变成为三级 IP地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做<strong>划分子网</strong>，或<strong>子网寻址</strong>或<strong>子网路由选择</strong>。划分子网已成为互联网的正式标准协议。</li><li>划分子网的基本思路如下：<ul><li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个<strong>子网</strong>。划分子网是一个单位内部的事情。本单位以外的网络<strong>看不见</strong>这个网络是由多少个子网组成，因为这个单位<strong>对外仍然表现为一个网络</strong>。</li><li>划分子网的方法是从网络的主机号借用若干位作为子网号，主机号也就相应减少了同样的位数。于是两级 IP 地址在<strong>本单位内部</strong>就变为<strong>三级</strong> IP 地址：网络号、子网号和主机号。也可以用以下记法来表示：IP 地址 ::&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</li><li>凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。</li></ul></li></ol></li><li><strong>子网掩码</strong><ol><li>从 IP 数据报的首部<strong>无法看出</strong>源主机或目的主机所连接的网络是否进行了子网的划分。因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。必须使用<strong>子网掩码</strong>。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730151524.png"></li></ul></li><li>使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“与”运算，就立即得出网络地址来。</li><li>为了更便于查找路由表，即使在不划分子网时，还要使用子网掩码。</li><li>如果一个网络不划分子网，那么该网络的子网掩码就使用<strong>默认子网掩码</strong>。默认子网掩码中 1 的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相“与”，就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。<ul><li>A 类地址的默认子网掩码是 255.0.0.0，或 0xFF000000。</li><li>B 类地址的默认子网掩码是 255.255.0.0，或 0xFFFF0000。</li><li>C 类地址的默认子网掩码是 255.255.255.0，或 0xFFFFFF00。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730153614.png"></li></ul></li><li><strong>子网掩码是一个网络或一个子网的重要属性</strong>。</li><li>采用固定长度子网时，所划分的<strong>所有</strong>子网的子网掩码都是相同的<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730153818.png"></li><li>子网数是根据子网号 subnet-id 计算出来的。若 subnet-id 有 <em>n</em> 位，则共有 2<sup>n</sup> 种可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数。</li></ul></li><li>虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，<strong>现在全 1 和全 0 的子网号也可以使用了</strong>。</li><li><strong>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数</strong>。</li></ol></li></ul><h2 id="4-3-2-使用子网时分组的转发"><a href="#4-3-2-使用子网时分组的转发" class="headerlink" title="4.3.2 使用子网时分组的转发"></a>4.3.2 使用子网时分组的转发</h2><ul><li>使用子网划分后，路由表必须包含以下三项内容：<strong>目的网络地址、子网掩码和下一跳地址</strong>。</li><li>在划分子网的情况下，路由器转发分组的算法如下：<ol><li>从收到的数据报的首部提取目的 IP 地址 <em>D</em>。</li><li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 <em>D</em> 逐位相“<strong>与</strong>” (AND 操作)，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付)，转发任务结束。否则是间接交付，执行 3。</li><li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。</li><li>对路由表中的每一行 (目的网络地址，子网掩码，下一跳地址)，用其中的子网掩码和 <em>D</em> 逐位相“与” (AND操作)，其结果为 <em>N</em>。若 <em>N</em> 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行 5。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。</li><li>报告转发分组出错。</li></ol></li></ul><h2 id="4-3-3-无分类编址-CIDR-构造超网"><a href="#4-3-3-无分类编址-CIDR-构造超网" class="headerlink" title="4.3.3 无分类编址 CIDR (构造超网)"></a>4.3.3 无分类编址 CIDR (构造超网)</h2><ul><li><strong>网络前缀</strong><ol><li>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：<ul><li>B 类地址在 1992 年已分配了近一半，很快将分配完毕。</li><li>互联网主干网上的路由表中的项目数急剧增长。</li><li>整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽。</li></ul></li><li>早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用<strong>变长子网掩码</strong> VLSM 可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出<strong>无分类编址</strong>方法，它的正式名字是<strong>无分类域间路由选择</strong> CIDR。</li><li>CIDR 主要的特点有两个：<ul><li>CIDR <strong>消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念</strong>，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是“<strong>网络前缀</strong>” (简称“<strong>前缀</strong>”)，用来指明网络，后面部分则用来指明主机。因此 CIDR 使 IP 地址从三级编址 (使用子网掩码) 又回到了两级编址，但这已是<strong>无分类的两级编址</strong>。其记法是：IP 地址 ::&#x3D;{&lt;网络前缀&gt;,&lt;主机号&gt;}；CIDR 还使用“<strong>斜线记法</strong>”，或称为 <strong>CIDR 记法</strong> ，即在 IP 地址后面加上斜线“&#x2F;”，然后写上网络前缀所占的位数。</li><li>CIDR 把<strong>网络前缀都相同</strong>的连续的 IP 地址组成一个“CIDR <strong>地址块</strong>”。只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址 (即最小地址) 和最大地址，以及地址块中的地址数。</li></ul></li><li>为了更方便地进行路由选择，CIDR 使用 32 位的<strong>地址掩码</strong>。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为<strong>子网掩码</strong>。<strong>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数</strong>。</li><li>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong> (构成超网)，它使得路由表中的一个项目可以表示原来传统分类地址的很多个 (例如上千个) 路由。</li><li>路由聚合有利于减少路由器之间的路由选择信息的交换，提高了整个互联网的性能。</li><li>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。</li><li><strong>网络前缀越短，其地址块所包含的地址数就越多</strong>。</li></ol></li><li><strong>最长前缀匹配</strong><ol><li>在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要有相应的改变。每个项目由“<strong>网络前缀</strong>”和“<strong>下一跳地址</strong>”组成。在查找路由表时<strong>可能会得到不止一个匹配结果</strong>。</li><li><strong>最长前缀匹配</strong>是<strong>从匹配结果中选择具有最长网络前缀的路由</strong>，最长前缀匹配又称为<strong>最长匹配</strong>或<strong>最佳匹配</strong>。</li><li>网络前缀越长，地址块越小，路由越具体。</li></ol></li><li><strong>使用二叉线索查找路由表</strong><ol><li>使用 CIDR 后，由于要寻找最长前缀匹配，路由表的查找过程变得更加复杂了。</li><li>对无分类编址的路由表的最简单的查找算法是对所有可能的前缀进行循环查找，这种简单算法的缺点是查找的次数太多。最坏的情况是路由表中没有这个路由。</li><li>为了进行更加有效的查找，通常把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。最常用的就是<strong>二叉线索</strong>，它是一种特殊结构的树。IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。</li><li>为了提高二叉线索的查找速度，使用了各种<strong>压缩技术</strong>。</li></ol></li></ul><h1 id="4-4-网际控制报文协议-ICMP"><a href="#4-4-网际控制报文协议-ICMP" class="headerlink" title="4.4 网际控制报文协议 ICMP"></a>4.4 网际控制报文协议 ICMP</h1><ul><li>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了<strong>网际控制报文协议 ICMP</strong>。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议，但不是高层协议，而是 IP 层的协议。ICMP 报文作为 IP 层数据报的数据部分，加上数据报的首部，组成 IP 数据报发送出去。ICMP 报文格式如图 4-27 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230731164920.png"></li></ol></li></ul><h2 id="4-4-1-ICMP-报文的种类"><a href="#4-4-1-ICMP-报文的种类" class="headerlink" title="4.4.1 ICMP 报文的种类"></a>4.4.1 ICMP 报文的种类</h2><ul><li>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</li><li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段，其长度取决于 ICMP 的类型。表 4-8 给出了几种常用的 ICMP 报文类型。</li><li>ICMP 报文的代码字段能进一步区分某种类型中的几种不同情况。检验和字段用来检验整个 ICMP 报文。IP 数据报首部的检验和并不检验 IP 数据报的内容 (检验首部)，因此不能保证经过传输的 ICMP 报文不产生差错。</li><li>表 4-8 给出的 ICMP 差错报告报文共有四种：<ol><li><strong>终点不可达</strong> 　当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li><li><strong>时间超过</strong> 　当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li><strong>参数问题</strong> 　当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li><strong>改变路由 (重定向)</strong> 　路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器 (可通过更好的路由)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230802183434.png"></li></ol></li><li>对改变路由报文进行解释。在互联网的主机中要有一个路由表，当主机要发送数据报时，首先查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由 (通过和其他路由器交换路由信息)。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器 R (而不是默认路由器)。</li><li>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式 (图 4-28)。把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段。再加上相应的 ICMP 差错报告报文的前 8 个字节，就构成了 ICMP 差错报告报文。提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号 (对于 TCP 和 UDP) 以及运输层报文的发送序号 (对于 TCP)。这些信息对源点通知高层协议是有用的。整个 ICMP报文作为 IP 数据报的数据字段发送给源点。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230802184415.png"></li></ol></li><li>下面是不应发送 ICMP 差错报告报文的几种情况：<ol><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报，都不发送 ICMP 差错报告报文。</li><li>对具有特殊地址 (如 127.0.0.0 或 0.0.0.0) 的数据报，不发送 ICMP 差错报告报文。</li></ol></li><li>常用的 ICMP 询问报文有两种，即：<ol><li><strong>回送请求和回答</strong> 　ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</li><li><strong>时间戳请求和回答</strong> 　ICMP 时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。****</li></ol></li></ul><h2 id="4-4-2-ICMP的应用举例"><a href="#4-4-2-ICMP的应用举例" class="headerlink" title="4.4.2 ICMP的应用举例"></a>4.4.2 ICMP的应用举例</h2><ul><li>ICMP 的一个重要应用是分组网间探测 <strong>PING</strong>，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的一个例子，没有通过运输层的 TCP 或 UDP。</li><li>另一个非常有用的应用是 traceroute (这是 UNIX 操作系统中名字)，它用来跟踪一个分组从源点到终点的路径。在 Windows 操作系统中这个命令是 tracert。</li></ul><h1 id="4-5-互联网的路由选择协议"><a href="#4-5-互联网的路由选择协议" class="headerlink" title="4.5 互联网的路由选择协议"></a>4.5 互联网的路由选择协议</h1><h2 id="4-5-1-有关路由选择协议的几个基本概念"><a href="#4-5-1-有关路由选择协议的几个基本概念" class="headerlink" title="4.5.1 有关路由选择协议的几个基本概念"></a>4.5.1 有关路由选择协议的几个基本概念</h2><ul><li><strong>理想的路由算法</strong><ol><li>路由选择协议的核心是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点：<ul><li><strong>算法必须是正确的和完整的</strong>。“正确”是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li><li><strong>算法在计算上应简单</strong>。路由选择的计算不应使网络通信量增加太多的额外开销。</li><li><strong>算法应能适应通信量和网络拓扑的变化</strong>，要有<strong>自适应性</strong>。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“<strong>稳健性</strong>“。</li><li><strong>算法应具有稳定性</strong>。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li><li><strong>算法应是公平的</strong>。路由选择算法应对所有用户 (除对少数优先级高的用户) 都是平等的。</li><li><strong>算法应是最佳的</strong>。路由选择算法应当能找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li></ul></li><li>路由选择是个复杂的问题，因为它是网络中的所有结点共同协调工作的结果。其次，路由选择的环境是不断变化的，这种变化无法事先知道，此外，当网络发生拥塞时，需要有能缓解拥塞的路由选择策略。</li><li>从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，有两大类：<ul><li><strong>静态路由选择策略</strong>，也称<strong>非自适应路由选择</strong><ol><li>特点：简单、开销小，但不能及时适应网络状态的变化。对于很简单的小网络，采用静态路由选择，用人工配置每一条路由。</li></ol></li><li><strong>动态路由选择策略</strong>，也称<strong>自适应路由选择</strong><ol><li>特点：能较好地适应网络状态的变化，实现起来较复杂，开销也较大。因此，动态路由选择适用于较复杂的大网络。</li></ol></li></ul></li></ol></li><li><strong>分层次的路由选择协议</strong><ol><li>互联网采用的路由选择协议主要是自适应的 (即动态的)、分布式路由选择协议。由于以下两个原因，互联网采用分层次的路由选择协议：<ul><li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li><li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。</li></ul></li><li>可以把整个互联网划分为许多较小的<strong>自治系统</strong>，一般记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</li><li>在目前的互联网中，一个 ISP 就是一个自治系统。互联网就把路由选择协议划分为两大类：<ul><li><strong>内部网关协议</strong> IGP　在一个自治系统内部使用的路由选择协议，与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li><li><strong>外部网关协议</strong> EGP　若源主机和目的主机处在不同的自治系统中 (这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，需要使用协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4 (BGP-4)。</li></ul></li><li>自治系统之间的路由选择叫做<strong>域间路由选择</strong>，自治系统内部的路由选择叫做<strong>域内路由选择</strong>。</li><li>图 4-31 是两个自治系统互连在一起的示意图。每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议 (例如，可以是 RIP，也可以是 OSPF)，但每个自治系统都有一个或多个路由器 (图中的路由器 R<sub>1</sub> 和 R<sub>2</sub>) ,除运行本系统的内部路由选择协议外，还要运行自治系统间的路由选择协议 (BGP-4)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230803100909.png"></li></ul></li></ol></li></ul><h2 id="4-5-2-内部网关协议-RIP"><a href="#4-5-2-内部网关协议-RIP" class="headerlink" title="4.5.2 内部网关协议 RIP"></a>4.5.2 内部网关协议 RIP</h2><ul><li><strong>工作原理</strong><ol><li>RIP 是内部网关协议 IGP 中最先广泛使用的协议，是一种分布式的<strong>基于距离向量的路由选择协议</strong>，是互联网的标准协议，最大优点是简单。</li><li>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录 (因此，这是<strong>一组距离</strong>，即“<strong>距离向量</strong>”)。</li><li>RIP 认为好的路由通过的路由器的数目少，即“距离短”。它允许一条路径最多只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。<strong>RIP 只适用于小型互联网</strong>。</li><li>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由 (即最短路由)，哪怕还存在另一条高速 (低时延) 但路由器较多的路由。</li><li>RIP协议的特点是：<ul><li><strong>仅和相邻路由器交换信息</strong>。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。</li><li>路由器交换的信息是<strong>当前本路由器所知道的全部信息，即自己现在的路由表</strong>。即：“我到本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器”。</li><li><strong>按固定的时间间隔</strong>交换路由信息，然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li></ul></li><li>路由器在<strong>刚刚开始工作时</strong>，它的路由表是空的。然后路由器就得出直接相连的几个网络的距离 (这些距离定义为 1)。接着，每一个路由器只和<strong>数目非常有限的</strong>相邻路由器交换并更新路由信息。经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 </li><li>在一般情况下，RIP 协议可以<strong>收敛</strong>，且过程较快。“收敛”是在自治系统中所有的结点都得到正确的路由选择信息的过程。</li><li>路由表中主要的信息是：到某个网络的距离 (即最短距离)，以及应经过的下一跳地址。路由表更新的原则是找出到每个目的网络的<strong>最短距离</strong>。这种更新算法又称为<strong>距离向量算法</strong>。</li></ol></li><li><strong>距离向量算法</strong><ol><li>对<strong>每一个相邻路由器</strong>发送过来的 RIP 报文，进行以下步骤：<ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的<strong>所有项目</strong> ：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。每一个项目都有三个关键数据，即：到目的网络 N，距离是 d，下一跳路由器是 X。</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：若原来的路由表中没有目的网络 N，则把该项目添加到路由表中。否则（即在路由表中有目的网络 N，这时就再查看下一跳路由器地址）若下一跳路由器地址是 X，则把收到的项目替换原路由表中的项目。否则（即这个项目是：到目的网络 N，但下一跳路由器不是 X）若收到的项目中的距离 d 小于路由表中的距离，则进行更新，否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为 16（距离为 16 表示不可达）。</li><li>返回。</li></ul></li><li>RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从<strong>每一个路由器到每一个目的网络的路由都是最短的</strong>。</li><li>所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表也应当是不同的。</li></ol></li><li><strong>RIP 协议的报文格式</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230803131532.png"></li><li>RIP 协议使用运输层的用户数据报 UDP 进行传送。</li><li>RIP 报文由首部和路由部分组成。</li><li>RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1 表示请求路由信息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为 0”是为了 4 字节字的对齐。</li><li>RIP 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。<strong>地址族标识符</strong> (地址类别) 字段用来标志所使用的地址协议。如采用 IP 地址就令这个字段的值为 2。<strong>路由标记</strong>填入<strong>自治系统号</strong> ASN，因为 RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个<strong>网络地址</strong>、该网络的<strong>子网掩码</strong>、<strong>下一跳路由器地址</strong>以及<strong>到此网络的距离</strong>。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4＋20×25＝504 字节。如超过，必须再用一个 RIP 报文来传送。</li><li>RIP 具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息 (20 字节) 的位置用作鉴别。这时应将地址族标识符置为全 1 (即 0xFFFF)，而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，这时最多只能再放入 24 个路由信息。</li><li>RIP 的问题是<strong>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器</strong>。网络出故障的传播时间往往需要较长的时间。这是 RIP 的主要缺点。</li><li>RIP 协议的优点是<strong>实现简单，开销小</strong>。</li><li>RIP 有很多缺点：RIP 限制了网络的规模，它能使用的最大距离为 15 (16 表示不可达)。其次，路由器之间交换的路由信息是路由器中的完整路由表，随着网络规模的扩大，开销也增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用 OSPF 协议。在规模较小的网络中，使用 RIP 协议。</li></ol></li></ul><h2 id="4-5-3-内部网关协议-OSPF"><a href="#4-5-3-内部网关协议-OSPF" class="headerlink" title="4.5.3 内部网关协议 OSPF"></a>4.5.3 内部网关协议 OSPF</h2><ul><li><strong>OSPF 协议的基本特点</strong><ol><li>协议的名字是<strong>开放最短路径优先</strong> OSPF，是为克服 RIP 的缺点开发出来的。</li><li>OSPF 只是一个协议的名字，<strong>并不表示其他的路由选择协议不是“最短路径优先”</strong>。所有的在自治系统内部使用的路由选择协议 (包括 RIP 协议) 都要寻找一条最短的路径。</li><li>OSPF 主要的特征是使用分布式的<strong>链路状态协议</strong>，不像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样：<ul><li>向本自治系统中<strong>所有路由器</strong>发送信息。使用的方法是<strong>洪泛法</strong>，就是路由器通过所有输出端口向所有相邻的路由器发送信息。每一个相邻路由器又再将此信息发往其所有的相邻路由器 (但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。RIP 协议仅仅向自己相邻的几个路由器发送信息。</li><li>发送的信息是与本路由器<strong>相邻的所有路由器的链路状态</strong>，但这只是路由器知道的<strong>部分信息</strong>。所谓“链路状态”就是说明本路由器和哪些路由器相邻，以及该链路的“<strong>度量</strong>”。度量用来表示费用、距离、时延、带宽等等。这些由网络管理人员决定，较灵活。有时为了方便就称度量为“<strong>代价</strong>”。对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。</li><li>只有当链路状态<strong>发生变化时</strong>，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li></ul></li><li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库</strong>，这个数据库实际上是全网的拓扑结构图。</li><li>RIP 协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却<strong>不知道全网的拓扑结构</strong>。</li><li>OSPF 的<strong>更新过程收敛得快</strong>是其重要优点。</li><li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统划分为若干个更小的范围，叫做<strong>区域</strong>。图 4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符 (用点分十进制表示)。一个区域不能太大，在一个区域内的路由器最好不超过 200 个。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804152244.png"></li></ul></li><li>划分区域的好处是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做<strong>主干区域</strong>。主干区域的标识符规定为 0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息由<strong>区域边界路由器</strong>进行概括。在图 4-34 中，路由器 R<sub>3</sub>，R<sub>4</sub> 和 R<sub>7</sub> 都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫做<strong>主干路由器</strong>，如 R<sub>3</sub>，R<sub>4</sub>，R<sub>5</sub>，R<sub>6</sub> 和 R<sub>7</sub>。一个主干路由器可以同时是区域边界路由器，如 R<sub>3</sub>，R<sub>4</sub> 和 R<sub>7</sub>。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong> (如图中的 R<sub>6</sub>)。</li><li>采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复杂。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议能够用于规模很大的自治系统中。</li><li>OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong> (其 IP 数据报首部的协议字段值为 89)。OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li><li>OSPF 分组使用 24 字节的固定长度首部 (见图 4-35)，分组的数据部分可以是五种类型分组中的一种：<ul><li><strong>版本</strong> 　当前的版本号是 2。</li><li><strong>类型</strong> 　可以是五种类型分组中的一种。</li><li><strong>分组长度</strong> 　包括 OSPF 首部在内的分组长度，以字节为单位。</li><li><strong>路由器标识符</strong> 　标志发送该分组的路由器的接口的 IP 地址。</li><li><strong>区域标识符</strong> 　分组属于的区域的标识符。</li><li><strong>检验和</strong> 　用来检测分组中的差错。</li><li><strong>鉴别类型</strong> 　只有两种，0 (不用) 和1 (口令)。</li><li><strong>鉴别</strong> 　鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字符的口令。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804152901.png"></li></ul></li><li>除了以上的几个基本特点外，OSPF 还具有下列的一些特点：<ul><li>OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF <strong>对于不同类型的业务可计算出不同的路由</strong>。链路的代价可以是 1 至 65535 中的任何一个无量纲的数，因此十分灵活。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的<strong>负载平衡</strong>。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。</li><li>所有在 OSPF 路由器之间交换的分组 (例如，链路状态更新分组) 都具有鉴别的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</li><li>OSPF 支持可变长度的子网划分和无分类的编址 CIDR。</li><li>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过每 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复号。</li></ul></li></ol></li><li><strong>OSPF 的五种分组类型</strong><ol><li>OSPF 有五种分组类型：<ul><li><strong>类型 1，问候</strong>分组，用来发现和维持邻站的可达性。</li><li><strong>类型 2，数据库描述</strong>分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li><li><strong>类型 3，链路状态请求</strong>分组，向对方请求发送某些链路状态项目的详细信息。</li><li><strong>类型 4，链路状态更新</strong>分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是 OSPF 协议的核心部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有五种不同的链路状态。</li><li><strong>类型 5，链路状态确认</strong>分组，对链路更新分组的确认。</li></ul></li><li>OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要是指出有哪些路由器的链路状态信息 (以及其序号) 已经写入了数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。图 4-36 给出了 OSPF 的基本操作，说明了两个路由器需要交换各种类型的分组。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804153513.png"></li></ul></li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，与整个互联网的规模无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</li><li>OSPF 协议对多点接入的局域网采用了<strong>指定的路由器</strong>的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</li></ol></li></ul><h2 id="4-5-4-外部网关协议-BGP"><a href="#4-5-4-外部网关协议-BGP" class="headerlink" title="4.5.4 外部网关协议 BGP"></a>4.5.4 外部网关协议 BGP</h2><ul><li>内部网关协议主要是设法使数据报在一个 AS 中尽可能有效地从源站传送到目的站。</li><li>BGP 使用的环境不同，主要是因为以下原因：<ol><li><strong>互联网的规模太大，使得自治系统 AS 之间路由选择非常困难</strong>。</li><li><strong>自治系统 AS 之间的路由选择必须考虑有关策略</strong>。</li></ol></li><li>边界网关协议 BGP 力求寻找一条能够到达目的网络且比较好的路由，<strong>并非要寻找一条最佳路由</strong>。BGP 采用了<strong>路径向量路由选择协议</strong> ，它与距离向量协议 (如 RIP) 和链路状态协议 (如 OSPF) 都有很大的区别。</li><li>BGP 协议交换路由信息的结点数量级是<strong>自治系统个数</strong>的量级，比自治系统中的<strong>网络数</strong>少。</li><li>在 RFC 4271 中规定了 BGP-4 的四种报文：<ol><li>OPEN (打开) 报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。</li><li>UPDATE (更新) 报文，用来通告某一路由的信息，以及列出要撤销的多条路由。</li><li>KEEPALIVE (保活) 报文，用来周期性地证实邻站的连通性。</li><li>NOTIFICATION (通知) 报文，用来发送检测到的差错。</li></ol></li><li>图 4-41 给出了 BGP 报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度为 19 字节。通用首部为三个字段。<strong>标记</strong>字段为 16 字节长，用来鉴别收到的 BGP 报文。当不使用鉴别时，标记字段要置为全 1。<strong>长度</strong>字段指出包括通用首部在内的整个 BGP 报文以字节为单位的长度，最小值是 19，最大值是 4096。<strong>类型</strong>字段的值为 1 到 4，分别对应于上述四种 BGP 报文中的一种。<ol><li>OPEN <strong>报文</strong>共有 6 个字段，即<strong>版本</strong> (1 字节，现在的值是 4)、<strong>本自治系统号</strong> (2 字节，使用全球唯一的 16 位自治系统号，由 ICANN 地区登记机构分配)、<strong>保持时间</strong> (2 字节，以秒计算的保持为邻站关系的时间)、<strong>BGP 标识符</strong> (4 字节，通常就是该路由器的 IP 地址)、<strong>可选参数长</strong>(1 字节) 和<strong>可选参数</strong>。</li><li>UPDATE <strong>报文</strong>共有 5 个字段，即<strong>不可行路由长度</strong> (2 字节，指明下一个字段的长度)、<strong>撤销的路由</strong> (列出所有要撤销的路由)、<strong>路径属性总长度</strong> (2 字节，指明下一个字段的长度)、<strong>路径属性</strong> (定义在这个报文中增加的路径的属性) 和<strong>网络层可达性信息 NLRI</strong>。最后这个字段定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀。</li><li>KEEPALIVE <strong>报文</strong>只有 BGP 的 19 字节长的通用首部。</li><li>NOTIFICATION <strong>报文</strong>有 3 个字段，即差错代码 (1 字节)、差错子代码 (1 字节) 和差错数据 (给出有关差错的诊断信息)。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804161110.png"></li></ol></li></ul><h2 id="4-5-5-路由器的构成"><a href="#4-5-5-路由器的构成" class="headerlink" title="4.5.5 路由器的构成"></a>4.5.5 路由器的构成</h2><ul><li><strong>路由器的结构</strong><ol><li>路由器是一种具有多个输入端口和多个输出端口的专用计算机，任务是转发分组。</li><li>典型的路由器的结构<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170016.png"></li><li>从图 4-42 可以看出，路由器结构可划分为两部分：<strong>路由选择</strong>部分和<strong>分组转发部分</strong>。</li><li>路由选择部分也叫<strong>控制部分</strong>，其核心构件是路由选择处理机。</li><li>分组转发由三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>。</li><li>交换结构又称为<strong>交换组织</strong>，作用是根据<strong>转发表</strong>对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中的网络”。</li><li>在图 4-42 中，路由器的输入和输出端口里面都各有三个方框，用方框中的 1，2 和 3 分别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。若接收到的分组是路由器之间交换路由信息的分组 (如 RIP 或 OSPF 分组等)，则把这种分组送交路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得出的结果，分组经过交换结构到达合适的输出端口。一个路由器的输入端口和输出端口安装在路由器的<strong>线路接口卡上</strong>。</li><li>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中 (如图 4-42 中的虚线箭头所示)。路由选择处理机负责对各转发表的副本进行更新。这些副本常称为“<strong>影子副本</strong>”。分散化交换可以避免在路由器中的某一点上出现瓶颈。</li></ul></li><li>输入端口对线路上收到的分组的处理<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170325.png"></li><li>当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个后到的分组必须在队列中排队等待，产生了一定的时延。图 4-43 给出了在输入端口的队列中排队的分组的示意图。</li></ul></li><li>输出端口把交换结构传送过来的分组发送到线路上<ul><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_networkSnipaste_2023-12-04_11-02-43.png"></li><li>观察在输出端口上的情况 (图 4-44 )。输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上是一个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</li></ul></li><li>分组在路由器的输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</li></ol></li><li><strong>交换结构</strong><ol><li>三种常用的交换方法<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170614.png"></li><li>最早的路由器：当路由器的某个输入端口收到一个分组时，用中断方式通知路由选择处理机。然后分组从输入端口复制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。</li><li>图 4-45 (a) 的示意图表示分组通过存储器进行交换。与早期的路由器的区别是，目的地址的查找和分组在存储器中的缓存是在输入端口中进行的。</li><li>图 4-45 (b) 是通过总线进行交换的示意图。数据报从输入端口通过共享的总线直接传送到合适的输出端口，不需要路由选择处理机的干预。由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线忙，则被阻塞不能通过交换结构，并在输入端口排队等待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品都采用这种通过总线的交换方式。</li><li>图4-45 (c) 是通过纵横交换结构进行交换。这种交换机构称为<strong>互连网络</strong>，它有 2<em>N</em> 条总线，可以使 <em>N</em> 个输入端口和 <em>N</em> 个输出端口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。但若该垂直总线已被占用 (有另一个分组正在转发到同一个输出端口)，则后到达的分组就被阻塞，必须在输入端口排队。</li></ul></li></ol></li></ul><h1 id="4-6-IPv6"><a href="#4-6-IPv6" class="headerlink" title="4.6 IPv6"></a>4.6 IPv6</h1><h2 id="4-6-1-IPv6-的基本首部"><a href="#4-6-1-IPv6-的基本首部" class="headerlink" title="4.6.1 IPv6 的基本首部"></a>4.6.1 IPv6 的基本首部</h2><ul><li>IPv6 支持无连接的传送，但将协议数据单元 PDU 称为<strong>分组</strong>，而不是 IPv4 的数据报。</li><li>IPv6 所引进的主要变化如下：<ol><li><strong>更大的地址空间</strong>。IPv6 把地址从 IPv4 的 32 位增大 4 倍，即增大到 128 位，使地址空间增大了2<sup>96</sup> 倍。这样大的地址空间在可预见的将来是不会用完的。</li><li><strong>扩展的地址层次结构</strong>。IPv6 由于地址空间很大，因此可以划分为更多的层次。</li><li><strong>灵活的首部格式</strong>。IPv6 数据报的首部和 IPv4 的并不兼容。IPv6 定义了许多可选的扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路由器对扩展首部不进行处理 (除逐跳扩展首部外)。</li><li><strong>改进的选项</strong>。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选项。但 IPv6 的<strong>首部长度是固定的</strong>，其选项放在有效载荷中。IPv4 所规定的选项是固定不变的，其选项放在首部的可变部分。</li><li><strong>允许协议继续扩充</strong>。因为技术总是在不断地发展而新的应用也还会出现。</li><li>支持即插即用 (即自动配置)。因此 IPv6 不需要使用 DHCP。</li><li><strong>支持资源的预分配</strong>。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。</li><li>IPv6 首部改为 8 <strong>字节对齐</strong> (即首部长度必须是 8 字节的整数倍)。原来的 IPv4 首部是 4 字节对齐。</li></ol></li><li>IPv6 数据报由两大部分组成，即<strong>基本首部和后面的有效载荷</strong>。有效载荷也称为净负荷。有效载荷允许有零个或多个<strong>扩展首部</strong>，再后面是数据部分 (图 4-46)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804173631.png"></li><li>与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：<ul><li>取消了首部长度字段，因为它的首部长度是固定的 (40 字节)。</li><li>取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。</li><li>取消了总长度字段，改用有效载荷长度字段。</li><li>取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。</li><li>把 TTL 字段改称为跳数限制字段，但作用是一样的。</li><li>取消了协议字段，改用下一个首部字段。</li><li>取消了检验和字段，加快了路由器处理数据报的速度。在数据链路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确传送到目的进程为止。因此在网络层的差错检测可以精简掉。</li><li>取消了选项字段，而用扩展首部来实现选项功能。</li></ul></li></ol></li><li>解释 IPv6 基本首部中各字段的作用 (参见图 4-47)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804173739.png"></li></ul><ol><li><strong>版本</strong>　占 4 位。它指明了协议的版本，IPv6 字段是 6。</li><li><strong>通信量类</strong>　占 8 位。这是为了区分不同的 IPv6 数据报的类别或优先级。</li><li><strong>流标号</strong>　占 20 位。IPv6 的一个新的机制是支持资源预分配，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流的抽象概念。所谓“流“<strong>是互联网络上从特定源点到特定终点 (单播或多播) 的一系列数据报 (如实时音频或视频传输)，“流”所经过的路径上的路由器都保证指明的服务质量</strong>。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频&#x2F;视频数据的传送有用。对于传统的电子邮件或非实时数据，流标号则没用，把它置为 0 即可。</li><li><strong>有效载荷长度</strong>　占 16 位。它指明 IPv6 数据报除基本首部以外的字节数 (所有扩展首部都算在有效载荷之内)。这个字段的最大值是 64KB (65535字节)。</li><li><strong>下一个首部</strong>　占 8 位。相当于 IPv4 的协议字段或可选字段。<ul><li>当 IPv6 数据报没有扩展首部时，下一个首部字段的作用和 IPv4 的协议字段一样，它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议 (例如：6 或17 分别表示应交付运输层 TCP 或 UDP)。</li><li>当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。</li></ul></li><li><strong>跳数限制</strong>　占 8 位。用来防止数据报在网络中无限期地存在。源点在每个数据报发出时即设定某个跳数限制 (最大为 255 跳)。每个路由器在转发数据报时，要先把跳数限制字段中的值减 1。当跳数限制的值为零时，就要把这个数据报丢弃。</li><li><strong>源地址</strong> 　占 128 位。是数据报的发送端的 IP 地址。</li><li><strong>目的地址</strong> 　占 128 位。是数据报的接收端的 IP 地址。</li></ol></li><li>IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，降低了路由器处理数据报的速度。然而实际上很多的选项在途中的路由器上是不需要检查的 (因为不需要使用这些选项的信息)。IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理，数据报途中经过的<strong>路由器都不处理这些扩展首部</strong> (只有一个首部例外，即逐跳选项扩展首部)，<strong>大大提高了路由器的处理效率</strong>。</li><li>在 RFC 2460 中定义了以下六种扩展首部：<ol><li>逐跳选项</li><li>路由选择</li><li>分片</li><li>鉴别</li><li>封装安全有效载荷</li><li>目的站选项</li></ol></li></ul><h2 id="4-6-2-IPv6-的地址"><a href="#4-6-2-IPv6-的地址" class="headerlink" title="4.6.2 IPv6 的地址"></a>4.6.2 IPv6 的地址</h2><ul><li>一个 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：<ol><li><strong>单播</strong>　单播是传统的点对点通信。</li><li><strong>多播</strong>　多播是一对多的通信，数据报发送到一组计算机中的每一个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li><li><strong>任播</strong>　IPv6 增加的一种类型。任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。</li></ol></li><li>IPv6 把实现 IPv6 的主机和路由器均称为<strong>结点</strong>。由于一个结点可能会使用多条链路与其他的一些结点相连，因此一个结点可能有多个与链路相连的接口。IPv6 给结点的每一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当作到达该结点的目的地址。</li><li>为了使地址再稍简洁些，IPv6 使用<strong>冒号十六进制记法</strong>，它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。</li><li>IPv6 的地址分类见表 4-10 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805093424.png"></li></ol></li><li>对表 4-10 所列举的几种地址简单解释如下。<ol><li><strong>未指明地址</strong> 　这是 16 字节的全 0 地址，可缩写为两个冒号“::”。这个地址不能用作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的 IP 地址。这类地址仅此一个。</li><li><strong>环回地址</strong> 　IPv6 的环回地址是 0:0:0:0:0:0:0:1，可缩写为 ::1。它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。</li><li><strong>多播地址</strong> 　功能和 IPv4 的一样。这类地址占 IPv6 地址总数的 1&#x2F;256。</li><li><strong>本地链路单播地址</strong>　有些单位的网络使用 TCP&#x2F;IP 协议，但<strong>并没有连接到互联网上</strong> 。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。这类地址占 IPv6 地址总数的 1&#x2F;1024。</li><li><strong>全球单播地址</strong> 　使用得最多的一类。IPv6 单播地址的划分方法非常灵活，可以如图 4-48 所示的任何一种。可把整个的 128 比特都作为一个结点的地址。也可用 <em>n</em> 比特作为子网前缀，用剩下的 (128–<em>n</em>) 比特作为接口标识符 (相当于 IPv4 的主机号)。当然也可以划分为三级，用 <em>n</em> 比特作为全球路由选择前缀，用 <em>m</em> 比特作为子网前缀，而用剩下的 (128–<em>n</em>–<em>m</em>) 比特作为接口标识符。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805093530.png"></li></ul></li></ol></li></ul><h2 id="4-6-3-从-IPv4-向-IPv6-过渡"><a href="#4-6-3-从-IPv4-向-IPv6-过渡" class="headerlink" title="4.6.3 从 IPv4 向 IPv6 过渡"></a>4.6.3 从 IPv4 向 IPv6 过渡</h2><ul><li><strong>双协议栈</strong><ol><li><strong>双协议栈</strong>是指在完全过渡到 IPv6 之前，使一部分主机 (或路由器) 装有双协议栈：一个 IPv4 和一个 IPv6。因此双协议栈主机 (或路由器) 既能够和 IPv6 的系统通信，又能够和 IPv4 的系统通信。双协议栈的主机 (或路由器) 记为 IPv6&#x2F;IPv4，表明它同时具有两种 IP 地址：一个 IPv6 地址和一个 IPv4 地址。</li></ol></li><li><strong>隧道技术</strong><ol><li>向 IPv6 过渡的另一种方法是<strong>隧道技术</strong>， 这种方法的要点是在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报。</li><li>要使双协议栈的主机知道 IPv4 数据报里面封装的数据是一个 IPv6 数据报，就必须把 IPv4 首部的协议字段的值设置为 41 (41 表示数据报的数据部分是 IPv6 数据报)。</li></ol></li></ul><h2 id="4-6-4-ICMPv6"><a href="#4-6-4-ICMPv6" class="headerlink" title="4.6.4 ICMPv6"></a>4.6.4 ICMPv6</h2><ul><li>和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数据报。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。</li><li>ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为 ICMPv6 报文，而把另一些报文定义为<strong>邻站发现</strong> ND 报文或<strong>多播听众交付</strong> MLD 报文。其实所有这些报文都是 ICMPv6 报文，只是功能和作用不同而已。</li></ul><h1 id="4-7-IP-多播"><a href="#4-7-IP-多播" class="headerlink" title="4.7 IP 多播"></a>4.7 IP 多播</h1><h2 id="4-7-1-IP-多播的基本概念"><a href="#4-7-1-IP-多播的基本概念" class="headerlink" title="4.7.1 IP 多播的基本概念"></a>4.7.1 IP 多播的基本概念</h2><ul><li>与单播相比，在一对多的通信中，多播可大大节约网络资源。图 4-53(a) 是视频服务器用单播方式向 90 台主机传送同样的视频节目。为此，需要发送 90 个单播，即同一个视频分组要发送 90 个副本。图 4-53(b) 是视频服务器用多播方式向属于同一个多播组的 90 个成员传送节目。这时，视频服务器只需把视频分组当作多播数据报来发送，并且<strong>只需发送一次</strong>。路由器 R<sub>1</sub> 在转发分组时，需要把收到的分组<strong>复制</strong>成 3 个副本，分别向 R<sub>2</sub>、R<sub>3</sub> 和 R<sub>4</sub> 各转发 1个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此<strong>不需要复制分组</strong>，在局域网上的多播组成员都能收到这个视频分组。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805150914.png"></li></ol></li><li>当多播组的主机数很大时 (如成千上万个)，多播明显地减轻网络中各种资源的消耗。在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件。能够运行多播协议的路由器称为<strong>多播路由器</strong>。多播路由器当然也可以转发普通的单播 IP 数据报。</li><li>在互联网上进行多播叫做 <strong>IP 多播</strong>。IP 多播所传送的分组需要使用多播 IP 地址。</li><li>多播数据报的目的地址不能写入主机的 IP 地址。因为在同一时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入如此多的主机 IP 地址。目的地址写入的是多播组的标识符，然后设法让加入到这个多播组的主机 IP 地址与多播组的标识符关联起来。</li><li><strong>多播地址只能用于目的地址，不能用于源地址</strong>。此外，对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，永远不会收到响应。</li><li>IP 多播可以分为两种。一种是在本地局域网上进行硬件多播，另一种是在互联网上进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付多播组的所有成员。</li></ul><h2 id="4-7-2-在局域网上进行硬件多播"><a href="#4-7-2-在局域网上进行硬件多播" class="headerlink" title="4.7.2 在局域网上进行硬件多播"></a>4.7.2 在局域网上进行硬件多播</h2><h2 id="4-7-3-网际组管理协议-IGMP-和多播路由选择协议"><a href="#4-7-3-网际组管理协议-IGMP-和多播路由选择协议" class="headerlink" title="4.7.3 网际组管理协议 IGMP 和多播路由选择协议"></a>4.7.3 网际组管理协议 IGMP 和多播路由选择协议</h2><ul><li><strong>IP 多播需要两种协议</strong><ol><li>图 4-55 是在互联网上传送多播数据报的例子。图中标有 IP 地址的四台主机都参加了一个多播组，其组地址是 226.15.37.123。显然，多播数据报应传送到路由器 R<sub>1</sub>，R<sub>2</sub> 和 R<sub>3</sub>，而不应传送到路由器 R<sub>4</sub>，因为与 R<sub>4</sub> 连接的局域网上现在没有这个多播组的成员。路由器需要用<strong>网际组管理协议</strong> IGMP 来识别多播组的成员信息。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806153909.png"></li><li>图 4-55 强调了 IGMP 的<strong>本地使用范围</strong> 。IGMP 并非在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上等等。IGMP 协议是让<strong>连接在本地局域网</strong>上的多播路由器知道<strong>本局域网上</strong>是否有主机 (严格讲，是主机上的某个进程) 参加或退出了某个多播组。</li></ul></li><li>仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员，需要使用<strong>多播路由选择协议</strong>。</li><li>**多播转发必须动态地适应多播组成员的变化 (这时网络拓扑并未发生变化)**。</li><li><strong>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址</strong>。</li><li><strong>多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络</strong>。</li></ol></li><li><strong>网际组管理协议 IGMP</strong><ol><li>和网际控制报文协议 ICMP 相似，IGMP 使用 IP 数据报传递其报文 (即 IGMP 报文加上 IP 首部构成 IP 数据报)，但它也向 IP 提供服务。因此，IGMP 不是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。</li><li>从概念上讲，IGMP 的工作可分为两个阶段：<ul><li>第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li><li>第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续当组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍没有一台主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li></ul></li><li>IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些具体措施如下：<ul><li>在主机和多播路由器之间的所有通信都是使用 IP 多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加 IP 多播的主机不会收到 IGMP 报文。</li><li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，不需要对每一个组都发送询问报文。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。</li><li>在 IGMP 的询问报文中有一个数值 <em>N</em>，它指明一个最长响应时间。当收到询问时，主机在 0 到 <em>N</em> 之间随机选择发送响应所需经过的时延。因此，若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。</li><li>同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。</li></ul></li><li>多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据报使用硬件多播。多播路由器只需要知道网络上是否至少还有一台主机是本组成员即可。实际上，对询问报文每一个组只需有一台主机发送响应。</li><li>如果一台主机上有多个进程都加入了某个多播组，那么这台主机对发给这个多播组的每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。</li></ol></li><li><strong>多播路由选择协议</strong><ol><li>多播路由选择实际上就是要找出以源主机为根节点的<strong>多播转发树</strong>。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据报，但在多播转发树上的路由器不会收到重复的多播数据报。</li><li>已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：<ul><li><strong>洪泛与剪除</strong>。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。一开始，路由器转发多播数据报使用洪泛的方法 (广播)。为了避免兜圈子，采用了叫做<strong>反向路径广播 RPB</strong> 的策略。RPB 的要点是：每一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进行这种检查很容易，只要从本路由器寻找到源点的最短路径上 (之所以叫做反向路径，因为在计算最短路径时把源点当作终点) 的第一个路由器是否是刚才把多播数据报送来的路由器。若是，就向所有其他方向转发刚才收到的多播数据报 (进入的方向除外)，否则就丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上 (也就是说，存在几条同样长度的最短路径)，那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。图 4-57 的例子说明了这一概念。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806161532.png"></li></ol></li><li><strong>隧道技术</strong>。隧道技术适用于多播组的位置在地理上很分散的情况。例如在图 4-58中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R<sub>1</sub> 和 R<sub>2</sub> 之间的网络并不支持多播，因而 R<sub>1</sub> 和 R<sub>2</sub> 不能按多播地址转发数据报。为此，路由器 R<sub>1</sub> 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的<strong>单播</strong>数据报，然后通过“<strong>隧道</strong>”从 R<sub>1</sub> 发送到 R<sub>2</sub> 。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806161545.png"></li></ol></li><li><strong>基于核心的发现技术</strong>。这种方法对于多播组的大小在较大范围内变化时都适合。对每一个多播组 G 指定一个<strong>核心路由器</strong>，给出它的 IP 单播地址。核心路由器创建出对应于多播组 G 的转发树。如果有一个路由器 R<sub>1</sub> 向这个核心路由器发送数据报，在途中经过的每一个路由器都要检查其内容。当数据报到达参加了多播组 G 的路由器 R<sub>2</sub> 时，R<sub>2</sub> 就处理这个数据报。如果 R<sub>1</sub> 发出的是一个多播数据报，其目的地址是 G 的组地址，R<sub>2</sub> 就向多播组 G 的成员转发这个多播数据报。如果 R<sub>1</sub> 发出的数据报是一个请求加入多播组 G 的数据报，R<sub>2</sub> 就把这个信息加到它的路由中，并用隧道技术向 R<sub>1</sub> 转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。</li></ul></li><li>使用的多播路由选择协议：<ul><li><strong>距离向量多播路由选择协议</strong> DVMRP 是在互联网上使用的第一个多播路由选择协议。它使用 DVMRP 在路由器之间传播路由信息。</li><li><strong>基于核心的转发树 CBT</strong>。这个协议使用核心路由器作为转发树的根节点。一个大的自治系统 AS 可划分为几个区域，每一个区域选择一个核心路由器。</li><li><strong>开放最短通路优先的多播扩展 MOSPF</strong>。这个协议是单播路由选择协议 OSPF 的扩充，使用于一个机构内。MOSPF 使用多播链路状态路由选择创建出基于源点的多播转发树。</li><li><strong>协议无关多播-稀疏方式 PIM-SM</strong>。这个协议使用和 CBT 同样的方法构成多播转发树。“协议无关”强调：虽然在建立多播转发树时是使用单播数据报来和远程路由器联系的，但这并不要求使用特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。</li><li><strong>协议无关多播-密集方式 PIM-DM</strong>。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。PIM-DM 不使用核心路由器，而是使用洪泛方式转发数据报。</li></ul></li></ol></li></ul><h1 id="4-8-虚拟专用网-VPN-和网络地址转换-NAT"><a href="#4-8-虚拟专用网-VPN-和网络地址转换-NAT" class="headerlink" title="4.8 虚拟专用网 VPN 和网络地址转换 NAT"></a>4.8 虚拟专用网 VPN 和网络地址转换 NAT</h1><h2 id="4-8-1-虚拟专用网-VPN"><a href="#4-8-1-虚拟专用网-VPN" class="headerlink" title="4.8.1 虚拟专用网 VPN"></a>4.8.1 虚拟专用网 VPN</h2><ul><li><strong>在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</strong>。RFC 6890 全面地给出了所有特殊用途的 IPv4 地址，但三个专用地址块的指派并无变化，即：<ol><li>10.0.0.0 到 10.255.255.255 (或记为 10.0.0.0&#x2F;8，它又称为 24 位块)</li><li>172.16.0.0 到 172.31.255.255 (或记为 172.16.0.0&#x2F;12，它又称为 20 位块)</li><li>192.168.0.0 到 192.168.255.255 (或记为 192.168.0.0&#x2F;16，它又称为 16 位块)</li></ol></li><li>有时一个机构的许多部门分布的范围很广，这些部门要互相交换信息，有两种方法：<ol><li>租用电信公司的通信线路为本机构专用。这种方法简单方便，但线租金高，一般难于承受。</li><li>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为<strong>虚拟专用网</strong> VPN。</li></ol></li><li>“专用网”是指为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信的网络。如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么<strong>所有通过互联网传送的数据都必须加密</strong>。</li><li>VPN 只是<strong>在效果上</strong>和专用网一样。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</li><li>由场所 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为<strong>内联网</strong>，表示场所 A 和 B 都属于同一个机构。</li><li>有时一个机构的 VPN 需要有某些<strong>外部机构</strong> (通常就是合作伙伴) 参加进来。这样的 VPN 就称为<strong>外联网</strong>。</li><li>还有一种类型的 VPN，是<strong>远程接入</strong> VPN。</li></ul><h2 id="4-8-2-网络地址转换-NAT"><a href="#4-8-2-网络地址转换-NAT" class="headerlink" title="4.8.2 网络地址转换 NAT"></a>4.8.2 网络地址转换 NAT</h2><ul><li>装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个有效的外部全球 IP 地址。</li><li>图 4-60 给出了 NAT 路由器的工作原理。在图中，专用网 192.168.0.0 内所有主机的 IP 地址都是本地 IP 地址 192.168.x.x。NAT 路由器至少要有一个全球 IP 地址，才能和互联网相连。图 4-60 表示出 NAT 路由器有一个全球 IP 地址 172.38.1.5。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806174735.png"></li></ol></li><li>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和互联网上的不同主机进行通信。</li><li>使用端口号的 NAT 也叫做<strong>网络地址与端口号转换</strong> NAPT，而不使用端口号的 NAT 就叫做传统的 NAT。</li></ul><h1 id="4-9-多协议标记交换-MPLS"><a href="#4-9-多协议标记交换-MPLS" class="headerlink" title="4.9 多协议标记交换 MPLS"></a>4.9 多协议标记交换 MPLS</h1><ul><li>MPLS 利用面向连接技术，使每个分组携带一个叫做<strong>标记</strong>的小整数。当分组到达交换机 (即标记交换路由器) 时，交换机读取分组的标记，并用标记值来检索分组转发表，比查找路由表来转发分组要快得多。</li><li>MPLS 常与<strong>异步传递方式</strong> ATM 联系起来，因为它们都采用了面向连接的工作方式。</li><li>MPLS 具有以下三个方面的特点：<ol><li>支持面向连接的服务质量。</li><li>支持流量工程，平衡网络负载。</li><li>有效地支持虚拟专用网 VPN。</li></ol></li></ul><h2 id="4-9-1-MPLS-的工作原理"><a href="#4-9-1-MPLS-的工作原理" class="headerlink" title="4.9.1 MPLS 的工作原理"></a>4.9.1 MPLS 的工作原理</h2><ul><li><strong>基本工作过程</strong><ol><li>在传统的 IP 网络中，分组每到达一个路由器，都必须查找路由表，并按照“最长前缀匹配”的原则找到下一跳的 IP 地址。当网络很大时，查找含有大量项目的路由表要花费很多的时间。在出现突发性的通信量时，往往还会使缓存溢出，引起分组丢失、传输时延增大和服务质量下降。</li><li>MPLS 的一个重要特点是在 MPLS 域的入口处，给每一个 IP 数据报打上固定长度“标记”，<strong>然后对打上标记的 IP 数据报用硬件进行转发</strong>，使 IP 数据报转发的过程大大加快。采用硬件技术对打上标记的 IP 数据报进行转发就称为<strong>标记交换</strong> 。“交换”也表示在转发时不再上升到第三层查找转发表，而是<strong>根据标记在第二层 (链路层) 用硬件进行转发</strong>。MPLS 可使用多种链路层协议，如 PPP、以太网、ATM 以及帧中继等。图 4-61是 MPLS 协议的基本原理的示意图。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175138.png"></li></ul></li><li>MPLS 域是指该域中有许多彼此相邻的路由器，并且所有的路由器都是支持 MPLS 技术的<strong>标记交换路由器</strong> LSR。LSR 同时具有标记交换和路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择功能构造转发表。</li><li>MPLS 的基本工作过程如下：<ul><li>MPLS 域中的各 LSR 使用专门的<strong>标记分配协议 LDP</strong> 交换报文，并找出和特定标记相对应的路径，即<strong>标记交换路径</strong> LSP。例如在图中的路径 A→B→C→D。各 LSR 根据这些路径构造出转发表。这个过程和路由器构造自己的路由表相似。MPLS 是面向连接的，因为在标记交换路径 LSP上 的第一个 LSR 就根据 IP 数据报的初始标记确定了整个的标记交换路径，就像一条虚连接一样。</li><li>当一个 IP 数据报进入到 MPLS 域时，MPLS <strong>入口结点</strong>就给它打上标记，并按照转发表把它转发给下一个 LSR。以后的所有 LSR 都按照标记进行转发；给 IP 数据报打标记的过程叫做<strong>分类</strong>。严格的<strong>第三层 (网络层) 分类</strong>只使用了 IP 首部中的字段，如源 IP 地址和目的 IP 地址等。大多数运营商实现了<strong>第四层 (运输层) 分类</strong>，而有些运营商则实现了<strong>第五层 (应用层) 分类</strong>。</li><li>在全网内统一分配全局标记数值是非常困难的，因此<strong>一个标记仅仅在两个标记交换路由器 LSR 之间才有意义</strong>。分组每经过一个 LSR，LSR 做两件事：一是转发，二是更换新的标记，即把<strong>入标记</strong>更换成为<strong>出标记</strong>。这就叫做<strong>标记对换</strong>。做这两件事所需的数据需要写在转发表中。例如，图 4-61 中的标记交换路由器 B 从入接口 0 收到一个入标记为 3 的 IP 数据报，查找了如下的转发表：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175430.png"></li></ol></li><li>当 IP 数据报离开 MPLS 域时，MPLS <strong>出口结点</strong>就把 MPLS 的标记去除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。</li></ul></li></ol></li><li><strong>转发等价类 FEC</strong><ol><li>MPLS 有个很重要的概念是<strong>转发等价类</strong> FEC。所谓“转发等价类”就是路由器<strong>按照同样方式对待</strong>的 IP 数据报的集合。这里“按照同样方式对待”表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等。FEC 的例子是：<ul><li>目的 IP 地址与某一个特定 IP 地址的前缀匹配的 IP 数据报；</li><li>所有源地址与目的地址都相同的 IP 数据报；</li><li>具有某种服务质量需求的 IP 数据报。</li></ul></li></ol></li></ul><h2 id="4-9-2-MPLS-首部的位置与格式"><a href="#4-9-2-MPLS-首部的位置与格式" class="headerlink" title="4.9.2 MPLS 首部的位置与格式"></a>4.9.2 MPLS 首部的位置与格式</h2><ul><li>MPLS 不要求下层的网络都使用面向连接的技术。因此一对 MPLS 路由器之间的物理连接，既可以由一个专用电路组成，如 OC-48 线路，也可以使用像以太网这样的网络。但是这些网络并不提供打标记的手段，而 IPv4 数据报首部也没有多余的位置存放 MPLS 标记。需要使用一种封装技术：在把 IP 数据报封装成以太网帧之前，先要插入一个 MPLS 首部。从层次的角度看，MPLS 首部就处在第二层和第三层之间 (图 4-63)。在把加上 MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为 8847 16 ，在多播的情况下为 8848 16 。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的 IP 数据报。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175802.png"></li></ol></li><li>图 4-64 给出了 MPLS 首部的格式。给 IP 数据报打上标记其实就是在以太网的帧首部和 IP 数据报的首部之间插入一个 4 字节的 MPLS 首部。具体的标记在“标记值”这个字段中。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175822.png"></li><li>MPLS 首部共包括以下四个字段：<ul><li><strong>标记值</strong> 　占 20 位。由于一个 MPLS 标记占 20 位，因此从理论上讲，在设置 MPLS 时可以使用标记的所有 20 位，因而可以同时容纳高达 2<sup>20</sup> 个流 (即 1048576 个流)。但是，实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管理和设置每条交换路径。</li><li><strong>试验</strong> 　占 3 位，目前保留用于试验。</li><li><strong>栈</strong> S　占 1 位，在有“标记栈”时使用。</li><li><strong>生存时间</strong> TTL　占 8 位，用来防止 MPLS 分组在 MPLS 域中兜圈子。</li></ul></li></ol></li></ul><h1 id="本章重要概念"><a href="#本章重要概念" class="headerlink" title="本章重要概念"></a>本章重要概念</h1><ul><li><p>TCP&#x2F;IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。</p></li><li><p>IP 网是虚拟的，因为从网络层上看，IP 网是一个统一的、抽象的网络。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统一的、抽象的 IP 地址处理主机之间的通信问题。</p></li><li><p>在互联网上的交付有两种：</p><ol><li>在本网络上的直接交付 (不经过路由器) </li><li>到其他网络的间接交付 (经过至少一个路由器，但最后一次一定是直接交付)。</li></ol></li><li><p>一个 IP 地址在整个互联网范围内是唯一的。分类的 IP 地址包括 A 类、B 类和 C 类地址 (单播地址)，以及 D 类地址 (多播地址)。E 类地址未使用。</p></li><li><p>分类的 IP 地址由网络号字段 (指明网络) 和主机号字段 (指明主机) 组成。网络号字段最前面的类别位指明 IP 地址的类别。</p></li><li><p>IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。</p></li><li><p>IP 地址标志一台主机 (或路由器) 和一条链路的接口。多归属主机同时连接到两个或更多的网络上。这样的主机同时具有两个或更多的 IP 地址，其网络号必须是不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。</p></li><li><p>用转发器或网桥连接起来的若干个局域网仍为一个网络。所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网) 都是平等的。</p></li><li><p>物理地址 (硬件地址) 是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，在数据链路层看不见数据报的 IP 地址。</p></li><li><p>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。一些长度可变的可选字段放在固定首部的后面。</p></li><li><p>IP 首部中的生存时间字段给出了 IP 数据报在互联网中所能经过的最大路由器数，可防止 IP 数据报在互联网中兜圈子。</p></li><li><p>地址解析协议 ARP 把 IP 地址解析为硬件地址，它解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。ARP 的高速缓存大大减少网络上的通信量。</p></li><li><p>在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。</p></li><li><p>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线“&#x2F;”，然后写上前缀所占的位数。前缀 (或网络前缀) 用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的IP地址组成一个“CIDR 地址块”。IP 地址的分配都以 CIDR 地址块为单位。</p></li><li><p>CIDR 的 32 位地址掩码 (或子网掩码) 由一串 1 和一串 0 组成，而 1 的个数就是前缀的长度。只要把 IP 地址和地址掩码逐位进行“逻辑与 (AND) ”运算，就很容易得出网络地址。A 类地址的默认地址掩码是 255.0.0.0。B 类地址的默认地址掩码是 255.255.0.0。C 类地址的默认地址掩码是 255.255.255.0。</p></li><li><p>路由聚合 (把许多前缀相同的地址用一个来代替) 有利于减少路由表中的项目，减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p></li><li><p>“转发”和“路由选择”不同。“转发”是单个路由器的动作。“路由选择”是许多路由器共同协作的过程，这些路由器相互交换信息，目的是生成路由表，再从路由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使用路由表这一名词。</p></li><li><p>自治系统 (AS) 是在单一的技术管理下的一组路由器。一个自治系统对其他自治系统表现出的是一个单一的和一致的路由选择策略。</p></li><li><p>路由选择协议有两大类：</p><ol><li>内部网关协议 (或自治系统内部的路由选择协议)，如 RIP 和 OSPF；</li><li>外部网关协议 (或自治系统之间的路由选择协议)，如 BGP-4。</li></ol></li><li><p>RIP 是分布式的基于距离向量的路由选择协议，适用于小型互联网，按固定的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器。</p></li><li><p>OSPF 是分布式的链路状态协议，适用于大型互联网，只在链路状态发生变化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路的“度量”。“度量”可表示费用、距离、时延、带宽等，统称为“代价”。所有的路由器最终都能建立一个全网的拓扑结构图。</p></li><li><p>BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP力求寻找一条能够到达目的网络 (可达) 且比较好的路由 (不兜圈子)，而并非要寻找一条最佳路由。</p></li><li><p>网际控制报文协议 ICMP 是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 并非为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p></li><li><p>ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。</p></li><li><p>要解决 IP 地址耗尽的问题，根本的办法是采用有更大地址空间的新版本 IP 协议，即 IPv6。</p></li><li><p>IPv6 所带来的主要变化是：</p><ol><li>更大的地址空间 (采用 128 位的地址)；</li><li>灵活的首部格式；</li><li>改进的选项；</li><li>支持即插即用；</li><li>支持资源的预分配；</li><li>IPv6 首部改为 8 字节对齐。</li></ol></li><li><p>IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。</p></li><li><p>IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。</p></li><li><p>IPv6 的地址使用冒号十六进制记法。</p></li><li><p>向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的 IPv6 系统能够向后兼容。向 IPv6 过渡可以使用双协议栈或使用隧道技术。</p></li><li><p>与单播相比，在一对多的通信中，IP 多播可大大节约网络资源。IP 多播使用 D 类 IP 地址。IP 多播需要使用网际组管理协议 IGMP 和多播路由选择协议。</p></li><li><p>虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体。VPN 内部使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都必须加密。</p></li><li><p>使用网络地址转换 NAT 技术，可以在专用网络内部使用专用 IP 地址，而仅在连接到互联网的路由器使用全球 IP 地址。这样就大大节约了宝贵的 IP 地址。</p></li><li><p>MPLS 的特点：</p><ol><li>支持面向连接的服务质量；</li><li>支持流量工程，平衡网络负载；</li><li>有效地支持虚拟专用网 VPN。</li></ol></li><li><p>MPLS 在入口结点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层 (链路层) 用硬件进行转发 (在标记交换路由器中进行标记对换)，因而转发速率大大加快。</p></li><li><p>子网划分为什么全0全1子网号不能使用？</p><blockquote><p>看看 RFC950 提到的原因：<br>假设我们有一个网络：192.168.0.0&#x2F;24，我们现在需要两个子网，那么按照 RFC950，应该使用使用两位子网号，即 &#x2F;26，得到两个可以使用的子网 192.168.0.64&#x2F;26 和 192.168.0.128&#x2F;26<br>对于主网络 192.168.0.0&#x2F;24，网络地址是192.168.0.0，广播地址是 192.168.0.255<br>对于子网 192.168.0.0&#x2F;26 (子网号全 0)，网络地址是 192.168.0.0，广播地址是 192.168.0.63<br>对于子网 192.168.0.64&#x2F;26，网络地址是 192.168.0.64，广播地址是 192.168.0.127<br>对于子网 192.168.0.128&#x2F;26，网络地址是 192.168.0.128，广播地址是 192.168.0.191<br>对于子网 192.168.0.192&#x2F;26 (子网号全1)，网络地址是 192.168.0.192，广播地址是 192.168.0.255</p><p>可以看出，对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。这样的重叠将导致极大的混乱。比如，一个发往192.168.0.255 的广播是发给主网络的还是子网的？这就是为什么在当时不建议使用全 0 和全 1 子网。</p></blockquote></li><li><p>IP, ARP, RARP, ICMP 协议的作用：</p><blockquote><p>网际协议 IP: 使用 IP 协议就可以把互连以后的计算机网络看成是一个虚拟互连网络。所谓虚拟互连网络也就是逻辑互连网络，或称为互联网。我们知道，各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用 IP 协议的虚拟互连网络可简称为 IP 网。使用 IP 网的好处是: 当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节 (如具体的编址方案、路由选择协议，等等)。<br>地址解析协议 ARP: 用来把一个机器 (主机或路由器) 的 IP 地址转换为相应的物理地址或硬件地址)。<br>逆地址解析协议 RARP: 和 ARP 相反，用来把一个机器 (主机或路由器)的物理地址 (或硬件地址) 转换为相应的 IP 地址。<br>网际控制报文协议 ICMP: 用来使主机或路由器报告差错情况和提供有关异常情况的报告，这样就可以更有效地转发 IP 数据报和提高交付成功的机会。</p></blockquote></li><li><p>IP 地址分为几类？各如何表示？IP 地址的主要特点是什么？</p><blockquote><p>在 IPv4 的地址中，所有的地址都是 32 位，并且可记为: IP 地址 ::&#x3D;&lt;网络号&gt;,主机号&gt;<br>IP 地址共分为五类:<br>A 类地址: 网络号字段为 1 字节，最前面的 1 位是 0<br>B 类地址: 网络号字段为 2 字节，最前面的 2 位是 10。<br>C 类地址: 网络号字段为 3 字节，最前面的 3 位是 110<br>D 类地址: 用于多播，最前面的 4 位是 1110。<br>E 类地址: 保留今后使用，最前面的 4 位是 1111。<br>IP 地址具有以下一些重要特点:<br>(1) 每一个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种分等级的地址结构。<br>(2) 实际上 IP 地址是标志一个主机(或路由器)和一条链路的接口。换言之，IP 地址并不仅仅指明一个主机，同时还指明了主机所连接到的网络。<br>(3) 按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连<br>(4) 在 IP 地址中，所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网) 都是平等的。</p></blockquote></li><li><p>IP 地址与硬件地址的区别，为什么使用两种不同的地址？</p><blockquote><p>从层次的角度看，物理地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址 (称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的)。<br>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的 IP 地址把这个复杂问题解决了。连接到互联网的主机只需拥有统一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便。当需要把 IP 地址转换为物理地址时，调用 ARP 的复杂过程都由计算机软件自动进行，而用户是看不见这种调用过程的。因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来很大的方便。</p></blockquote></li><li><p>IGP 和 EGP 这两类协议的主要区别？</p><blockquote><p>IGP 是内部网关协议，即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。EGP 是外部网关协议。若源主机和目的主机处在不同的自治系统中 (这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4 (BGP-4)。</p></blockquote></li><li><p>试简述 RIP, OSPF 和 BGP 路由选择协议的主要特点。</p><blockquote><p>RIP 是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大优点就是简单。RIP 协议的特点是:<br>(1) 仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。<br>(2) 路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。也就是说，交换的信息是:“我到本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器”。<br>(3) 按固定的时间间隔交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。<br>OSPF 最主要的特征就是使用分布式的链路状态协议。OSPF 协议的特点是:<br>(1) 向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法，这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。<br>(2) 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。<br>(3) 只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。<br>BGP 是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议。BGP 协议的主要特点是:<br>(1) BGP 在自治系统之问交换“可达性”信息 (即“可到达”或“不可到达”)。例如，告诉相邻路由器:“到达目的网络 N 可经过 AS<sub>x</sub>”<br>(2) 自治系统之间的路由选择必须考虑有关策略。<br>(3) BGP 只能是力求寻找一条能够到达目的网络且比较好的路由 (不能兜圈子)，而并非要寻找一条最佳路由。</p></blockquote></li><li><p>IGMP 协议的要点是什么？隧道技术在多播中是怎样使用的？</p><blockquote><p>IGMP 是网际组管理协议，它不是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。IGMP 并非是在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上，等等。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机 (严格讲，是主机上的某个进程) 参加或退出了某个多播组。显然，仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。<br>从概念上讲，IGMP的工作可分为两个阶段。<br>第一阶段: 当某个主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器<br>第二阶段: 组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一个主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。隧道技术适用于多播组的位置在地理上很分散的情况。例如在图 T-4-43 中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R<sub>1</sub> 和 R<sub>2</sub> 之间的网络并不支持多播，因而 R<sub>1</sub> 和 R<sub>2</sub>不能按多播地址转发数据报。为此，路由器 R<sub>1</sub> 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的单播数据报，然后通过“隧道”从 R<sub>1</sub> 发送到 R<sub>2</sub>。<br><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network20231217162537.png"><br>单播数据报到达路由器 R 后，再由路由器 R 剥去其首部，使它又恢复成原来的多播数据报，继续向多个目的站转发。</p></blockquote></li><li><p>VPN 的优缺点：</p><blockquote><p>优点是比专用网造价便宜，缺点是技术复杂，并且当进行加密通信时，需要更加安全的加密措施。</p></blockquote></li><li><p>什么是 NAT ？NAPT 有哪些特点？NAT 的优缺点有哪些？</p><blockquote><p>NAT 是网络地址转换。NAPT 是网络地址与端口号转换，是使用端口号的 NAT。<br>NAP 的优点是可以通过使用 NAT 路由器使专用网用户与互联网用户连接。缺点是通过 NAT 路由器的通信必须由专用网内的主机发起，另一个缺点是当 NAT 路由器只有一个全球 IP 地址时，专用网内部只能有一个主机接入互联网。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2023/12/09/shu-ju-lian-lu-ceng/"/>
      <url>/2023/12/09/shu-ju-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h1><ul><li>数据链路层属于计算机网络的低层。数据链路层使用的信道有以下两种类型：<ol><li><strong>点对点信道</strong>。使用一对一的点对点通信方式。</li><li><strong>广播信道</strong>。使用一对多的广播通信方式，过程复杂。广播信道上连接的主机很多，必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ol></li><li>本章重要的内容：<ol><li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议 (PPP 协议以及 CSMA&#x2F;CD 协议) 的特点。</li><li>数据链路层的三个基本问题：封装成帧、透明传输和差错检测。</li><li>以太网 MAC 层的硬件地址。</li><li>适配器、转发器、集线器、网桥、以太网交换机的作用以及使用场合。</li></ol></li></ul><h2 id="3-1-1-数据链路和帧"><a href="#3-1-1-数据链路和帧" class="headerlink" title="3.1.1 数据链路和帧"></a>3.1.1 数据链路和帧</h2><ul><li><strong>链路</strong>是从一个结点<strong>到相邻结点</strong>的一段物理线路，中间没有其他的交换结点。在进行数据通信时，两台计算机之间的通信路径要经过许多段链路。链路只是一条路径的组成部分。</li><li>当需要在一条线路上传送数据时，除了必须有一条物理线路外，还必须有一些通信协议控制数据的传输。把实现这些协议的硬件和软件加到链路上，构成了数据链路。常用的方法是使用<strong>网络适配器</strong>来实现协议。一般适配器都包括了数据链路层和物理层这两层的功能。</li><li>数据链路层把网络层交下来的数据构成<strong>帧</strong>发送到链路上，把接收到的帧中的数据取出并上交给网络层。在互联网中，网络层协议数据单元就是 IP 数据报 (或简称为<strong>数据报、分组</strong>或<strong>包</strong>)。</li><li>点对点信道的数据链路层在进行通信时的主要步骤如下：<ol><li>结点 A 的数据链路层把网络层交下来的 IP 数据报添加首部和尾部封装成帧。</li><li>结点 A 把封装好的帧发送给结点 B 的数据链路层。</li><li>若结点 B 的数据链路层收到的帧无差错，则从收到的帧中提取出 IP 数据报交给上面的网络层；否则丢弃这个帧。</li></ol></li><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network%7BB2EB60AE-6404-40b9-9EEA-BE05ACDFE73D%7D.png"></li></ul><h2 id="3-1-2-三个基本问腿"><a href="#3-1-2-三个基本问腿" class="headerlink" title="3.1.2 三个基本问腿"></a>3.1.2 三个基本问腿</h2><ul><li>数据链路层协议有多种，但有三个基本问题是共同的：<strong>封装成帧、透明传输和差错检测</strong>：<ol><li><strong>封装成帧</strong><ul><li><strong>封装成帧</strong>是在一段数据的前后添加首部和尾部，构成了一个帧。</li><li>帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。</li><li>首部和尾部的作用是进行<strong>帧定界</strong> (即确定帧的界限)。首部和尾部还包括许多控制信息。</li><li>为了提高帧的传输效率，应当使帧的<strong>数据部分长度尽可能地大于首部和尾部的长度。但是，每一种链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元</strong>(MTU)。</li><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_networkSnipaste_2023-11-20_16-00-59.png"></li></ul></li><li><strong>透明传输</strong><ul><li>由于帧的开始和结束的标记使用指明的控制字符，因此，所传输的数据中任何 8 比特的组合不允许和用作帧定界的控制字符的比特编码一样，否则会出现帧定界的错误。</li><li>当传送的帧是用文本文件组成的帧时 (文本文件中的字符都是从键盘上输入的)，其数据部分不会出现像 SOH 或 EOT 这样的帧定界控制字符。不管从键盘上输入什么字符都可以放在这样的帧中传输过去，这样的传输就是透明传输。</li><li>当数据部分是非 ASCII 码的文本文件时 (如二进制代码的计算机程序或图像等)。如果数据中的某个字节的二进制代码和 SOH 或 EOT 这种控制字符一样 (见图 3-6)，数据链路层会<strong>错误地</strong>找到帧的边界，把部分帧收下，而把剩下的那部分数据丢弃。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711095956.png"></li></ol></li><li>解决透明传输问题，必须使<strong>数据中</strong>可能出现的控制字符 SOH 和 EOT 在接收端不被解释为控制字符。方法是：发送端的数据链路层在数据中出现控制字符的前面插入一个<strong>转义字符</strong> ESC。在接收端的数据链路层，在把数据送往网络层之前删除插入的转义字符。这被称为<strong>字节填充</strong>或<strong>字符填充</strong>。如果转义字符也出现在数据当中，那么解决方法仍然是在转义字符的前面插入一个转义字符。因此，当接收端收到连续的两个转义字符时，就删除其中前面的一个。图 3-7 表示用字节填充法解决透明传输的问题。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711100111.png"></li></ol></li></ul></li><li><strong>差错检测</strong><ul><li>现实的通信链路不是理想的。比特在传输过程中可能会产生差错：1 可能变成 0，而 0 可能变成 1。这就叫做<strong>比特差错</strong>。比特差错是传输差错中的一种。</li><li>一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong> (BER)。</li><li>为保证数据传输的可靠性，在数据链路层广泛使用<strong>循环冗余检验</strong> (CRC) 的检错技术。</li><li>通过例子说明循环冗余检验的原理。<ol><li>在发送端，把数据划分为组，假定每组 <em>k</em> 个比特。待传送的数据 <em>M</em>＝101001 (<em>k</em>＝6)。CRC 运算就是在数据 <em>M</em> 的后面添加供差错检测用的 <em>n</em> 位<strong>冗余码</strong>，构成一个帧发送出去，一共发送 (<em>k</em> ＋ <em>n</em>) 位。在所要发送的数据后面增加 <em>n</em> 位的冗余码，虽然增大了数据传输的开销，但可以进行差错检测。</li><li>这 <em>n</em> 位冗余码可用以下方法得出。用二进制的<strong>模 2 运算</strong>进行 2<sup>n</sup> 乘 <em>M</em> 的运算，这相当于在 <em>M</em> 后面添加 <em>n</em> 个 0。得到的 (<em>k</em>＋<em>n</em>) 位的数除以收发双方事先商定的长度为 (<em>n</em>＋1) 位的除数 <em>P</em>，得出商是 <em>Q</em> 而余数是 <em>R</em> (<em>n</em> 位，比 <em>P</em> 少一位)。在图 3-8 所示的例子中，<em>M</em>＝101001 (即 <em>k</em>＝6)。假定除数 <em>P</em>＝1101 (即 <em>n</em>＝3)。经模 2 除法运算后的结果是：商 <em>Q</em>＝110101 (这个商并没有什么用处)，余数 <em>R</em>＝001。余数 <em>R</em> 作为冗余码拼接在数据 <em>M</em> 的后面发送出去。这种为了进行检错而添加的冗余码常称为<strong>帧检验序列</strong> (FCS)。因此加上 FCS 后发送的帧是 101001001，共有 (<em>k</em>＋<em>n</em>) 位。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711102631.png"></li></ol></li><li>循环冗余检验 CRC 和帧检验序列 FCS 并不是同一个概念。CRC 是一种<strong>检错方法</strong>，而 FCS 是添加在数据后面的<strong>冗余码</strong>，在检错方法上可选用 CRC，也可不选用 CRC。</li><li>在接收端对收到的每一帧经过 CRC 检验后，有两种情况：<ol><li>得出的余数 <em>R</em>＝0，判定这个帧没有差错，接受。</li><li>余数 <em>R</em>≠0，这个帧有差错 (但无法确定究竟是哪一位或哪几位出现了差错)，丢弃。</li></ol></li><li>用多项式来表示循环冗余检验过程。用多项式 <em>P</em>(<em>X</em>) ＝<em>X</em><sup>3</sup> ＋<em>X</em><sup>2</sup>＋1表示上面的除数 <em>P</em>＝1101 (最高位对应于 <em>X</em><sup>3</sup>，最低位对应于 <em>X</em><sup>0</sup>)。多项式 <em>P</em>(<em>X</em>) 称为<strong>生成多项式</strong>。现在广泛使用的生成多项式 <em>P</em>(<em>X</em>) 有以下几种：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230711104339.png"></li></ol></li><li>在数据链路层，发送端帧检验序列 FCS 的生成和接收端的 CRC 检验都是用硬件完成的，处理很迅速，不会延误数据的传输。</li><li>在数据链路层若<strong>仅仅</strong>使用循环冗余检验 CRC 差错检测技术，只能做到对帧的<strong>无差错接受</strong>，即：“<strong>凡是接收端数据链路层接受的帧均无差错</strong>”。</li><li>传输差错分为两大类：<ol><li>最基本的比特差错</li><li>收到的帧并没有出现比特差错，却出现了<strong>帧丢失、帧重复</strong>或<strong>帧失序</strong>。例如，发送方连续传送三个帧：1，2，3。假定接收端收到的每一个帧都没有比特差错，但却出现下面的几种情况：<ul><li><strong>帧丢失</strong> ：收到 1，3 (丢失 2)。</li><li><strong>帧重复</strong> ：收到1，2，2，3 (收到两个2)。</li><li><strong>帧失序</strong> ：收到1，3，2 (后发送的帧反而先到达了接收端，这与一般数据链路层的传输概念不一样)。</li></ul></li></ol></li><li>现在的通信线路的质量大大提高，由通信链路质量不好引起差错的概率大大降低。现在互联网采取了区别对待的方法：<ol><li>对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议来完成。</li><li>对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。</li></ol></li></ul></li></ol></li></ul><h1 id="3-2-点对点协议-PPP"><a href="#3-2-点对点协议-PPP" class="headerlink" title="3.2 点对点协议 PPP"></a>3.2 点对点协议 PPP</h1><ul><li>在通信线路质量较差的年代，使用可靠传输协议是种好办法，能实现可靠传输的<strong>高级数据链路控制</strong> (HDLC) 成为流行的数据链路层协议。对于点对点的链路，简单的<strong>点对点协议</strong> (PPP) 是目前使用得最广泛的数据链路层协议。</li></ul><h2 id="3-2-1-PPP-协议的特点"><a href="#3-2-1-PPP-协议的特点" class="headerlink" title="3.2.1 PPP 协议的特点"></a>3.2.1 PPP 协议的特点</h2><ul><li>PPP 协议是用户计算机和 ISP 进行通信时使用的数据链路层协议。</li><li><strong>PPP 协议应满足的需求</strong><ol><li><strong>简单</strong> 　在设计互联网体系结构时复杂的部分在 TCP 协议中，而网际协议 IP 比较简单，它提供的是不可靠的数据报服务。在这种情况下，数据链路层没有必要提供比 IP 协议更多的功能。因此，对数据链路层的帧，不需要纠错，不需要序号，也不需要流量控制。</li><li><strong>封装成帧</strong> 　PPP 协议规定特殊的字符作为<strong>帧定界符</strong>，以便使接收端从收到的比特流中能准确地找出帧的开始和结束位置。</li><li><strong>透明性</strong> 　PPP 协议保证数据传输的透明性。如果数据中碰巧出现了和帧定界符一样的比特组合时，要采取有效的措施来解决问题。</li><li><strong>多种网络层协议</strong> 　PPP 协议能够在<strong>在同一条物理链路上同时支持多种网络层协议</strong> (如 IP 和 IPX 等) 的运行。当点对点链路所连接的是局域网或路由器时，PPP 协议必须同时支持在链路所连接的局域网或路由器上运行的各种网络层协议。</li><li><strong>多种类型链路</strong> 　除了要支持多种网络层的协议外，PPP 还必须能够在多种类型的链路上运行。</li><li><strong>差错检测</strong> 　PPP 协议必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong>。若在数据链路层不进行差错检测，那么出现差错的无用帧还要在网络中继续向前转发，白白浪费许多的网络资源。</li><li><strong>检测连接状态</strong> 　PPP 协议必须具有一种能够及时自动检测出链路是否处于正常工作状态的机制。当出现故障的链路隔了一段时间后又重新恢复正常工作时，就需要这种及时检测功能。</li><li><strong>最大传送单元</strong> 　PPP 协议必须对每种类型的点对点链路设置<strong>最大传送单元</strong> MTU 的标准默认值，目的是为了促进各种实现之间的互操作性。如果高层协议发送的分组过长并超过 MTU 的数值，PPP 就要丢弃这样的帧，并返回差错。MTU 是数据链路层的帧可以载荷的<strong>数据部分</strong>的最大长度，<strong>不是帧的总长度</strong>。</li><li><strong>网络层地址协商</strong> 　PPP 协议必须提供一种机制使通信的两个网络层的实体能够通过协商知道或能够配置彼此的网络层地址。协商的算法应尽可能简单，并且能够在所有的情况下得出协商结果。</li><li><strong>数据压缩协商</strong> 　PPP 协议必须提供一种方法来协商使用数据压缩算法。但 PPP 协议并不要求将数据压缩算法进行标准化。</li></ol></li><li><strong>PPP 协议的组成</strong><ol><li>一个将 IP 数据报封装到串行链路的方法。PPP 既支持异步链路，也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分。这个信息部分的长度受最大传送单元 MTU 的限制。</li><li>一个用来建立、配置和测试数据链路连接的<strong>链路控制协议</strong> (LCP)。</li><li>一套<strong>网络控制协议</strong> (NCP)，其中的每一个协议支持不同的网络层协议。</li></ol></li></ul><h2 id="3-2-2-PPP-协议的帧格式"><a href="#3-2-2-PPP-协议的帧格式" class="headerlink" title="3.2.2 PPP 协议的帧格式"></a>3.2.2 PPP 协议的帧格式</h2><ul><li><strong>各字段的意义</strong><ol><li>PPP 的帧格式如图 3-10 所示。PPP 帧的首部和尾部分别为四个字段和两个字段。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714175950.png"></li><li>首部的第一个字段和尾部的第二个字段都是标志字段 F (Flag)，规定为 0x7E (符号“0x”表示它后面的字符是用十六进制表示的。十六进制的 7E 的二进制表示是 01111110)。标志字段表示一个帧的开始或结束。因此标志字段就是 PPP 帧的定界符。连续两帧之间只需要用一个标志字段。如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃；首部中的地址字段 A 规定为 0xFF (即 11111111)，控制字段 C 规定为 0x03 (即 00000011)。这两个字段并没有携带 PPP 帧的信息；PPP 首部的第四个字段是 2 字节的协议字段。当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。若为 0xC021，则信息字段是 PPP 链路控制协议 LCP 的数据，而 0x8021 表示这是网络层的控制数据；信息字段的长度是可变的，不超过 1500 字节；尾部中的第一个字段 (2 字节) 是使用 CRC 的帧检验序列 FCS。</li></ol></li><li><strong>字节填充</strong><ol><li>PPP 使用异步传输时，把转义符定义为 0x7D (即 01111101)，并使用<strong>字节填充</strong>，RFC 1662 规定了如下所述的填充方法：<ul><li>把信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列 (0x7D，0x5E)。</li><li>若信息字段中出现一个 0x7D 的字节 (即出现了和转义字符一样的比特组合)，则把 0x7D 转变成为 2 字节序列 (0x7D，0x5D)。</li></ul></li></ol></li><li><strong>零比特填充</strong><ol><li>PPP 协议用在 SONET&#x2F;SDH 链路时，使用同步传输 (一连串的比特连续传送) 而不是异步传输 (逐个字符地传送)。在这种情况下，PPP 协议采用零比特填充方法来实现透明传输。</li><li>零比特填充的做法是：在发送端，扫描整个信息字段。只要发现有 5 个连续 1，则立即填入一个 0。因此经过这种零比特填充后的数据，可以保证在信息字段中不会出现 6 个连续 1。接收端在收到一个帧时，先找到标志字段 F 以确定一个帧的边界，接着再用硬件对其中的比特流进行扫描。每当发现 5 个连续 1 时，就把这 5 个连续 1 后的一个 0 删除，以还原成原来的信息比特流 (图 3-11)。这样就保证了透明传输：在所传送的数据比特流中可以传送任意组合的比特流，而不会引起对帧边界的错误判断。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714180243.png"></li></ol></li></ul><h2 id="3-2-3-PPP-协议的工作状态"><a href="#3-2-3-PPP-协议的工作状态" class="headerlink" title="3.2.3 PPP 协议的工作状态"></a>3.2.3 PPP 协议的工作状态</h2><ul><li>当用户拨号接入 ISP 后，建立了一条从用户个人电脑到 ISP 的物理连接。这时，用户个人电脑向 ISP 发送一系列的链路控制协议 LCP 分组 (封装成多个 PPP 帧)，以便建立 LCP 连接。这些分组及其响应选择了将要使用的一些 PPP 参数。接着进行网络层配置，网络控制协议 NCP 为新接入的用户个人电脑分配一个临时的 IP 地址。用户个人电脑成为互联网上的一个有 IP 地址的主机；当用户通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放物理层的连接。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_RR12G7EOJ~98TROOF1YPF_Y.png"></li><li>PPP 链路的起始和终止状态永远是图 3-12 中的“<strong>链路静止</strong>”状态，这时在用户个人电脑和 ISP 的路由器之间并不存在物理层的连接。</li><li>当用户个人电脑通过调制解调器呼叫路由器时，路由器能够检测到调制解调器发出的载波信号。在双方建立了物理层连接后，PPP 进入“<strong>链路建立</strong>”状态，目的是建立链路层的 LCP 连接。</li><li>这时 LCP 开始协商<strong>配置选项</strong>，即发送 LCP 的<strong>配置请求帧</strong>。这是个 PPP 帧，其协议字段置为 LCP 对应的代码，而信息字段包含特定的配置请求。链路的另一端可以发送以下几种响应中的一种：<ul><li><strong>配置确认帧</strong>　所有选项都接受</li><li><strong>配置否认帧</strong>　所有选项都理解但不能接受。</li><li><strong>配置拒绝帧</strong>　选项有的无法识别或不能接受，需要协商。</li></ul></li><li>LCP 配置选项包括链路上的最大帧长、所使用的<strong>鉴别协议</strong>的规约，以及不使用 PPP 帧中的地址和控制字段。</li><li>协商结束后双方就建立了 LCP 链路，接着就进入“<strong>鉴别</strong>”状态。在这一状态，只允许传送 LCP 协议的分组、鉴别协议的分组以及监测链路质量的分组。若使用<strong>口令鉴别协议</strong> (PAP)，发起通信的一方需要发送身份标识符和口令。系统允许用户重试若干次。如果需要有更好的安全性，可使用更加复杂的<strong>口令握手鉴别协议</strong> (CHAP)。若鉴别身份失败，则转到“<strong>链路终止</strong>”状态。若鉴别成功，则进入“<strong>网络层协议</strong>”状态。</li><li>在“<strong>网络层协议</strong>”状态，PPP 链路两端的网络控制协议 NCP 根据网络层的不同协议互相交换网络层特定的网络控制分组。现在的路由器能同时支持多种网络层协议。PPP 协议两端的网络层可以运行不同的网络层协议，但仍然可使用同一个 PPP 协议进行通信。</li><li>如果在 PPP 链路上运行的是 IP 协议，则对 PPP 链路的每一端配置 IP 协议模块时要使用 NCP 中支持 IP 的协议——IP <strong>控制协议</strong> (IPCP)。IPCP 分组也封装成 PPP 帧 (其中的协议字段为 0x8021) 在 PPP 链路上传送。在低速链路上运行时，双方可以协商使用压缩的 TCP 和 IP 首部，以减少在链路上发送的比特数。</li><li>网络层配置完毕后，链路进入可进行数据通信的“<strong>链路打开</strong>”状态。链路的两个 PPP 端点可以彼此向对方发送分组。两个 PPP 端点还可发送<strong>回送请求</strong> LCP 分组和<strong>回送回答</strong> LCP 分组，以检查链路的状态。</li><li>数据传输结束后，可以由链路的一端发出<strong>终止请求</strong> LCP 分组请求终止链路连接，在收到对方发来的<strong>终止确认</strong> LCP 分组后，转到“<strong>链路终止</strong>”状态。如果链路出现故障，会从“<strong>链路打开</strong>”状态转到“<strong>链路终止</strong>”状态。当调制解调器的载波停止后，则回到“<strong>链路静止</strong>”状态。</li></ol></li></ul><h1 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h1><h2 id="3-3-1-局域网的数据链路层"><a href="#3-3-1-局域网的数据链路层" class="headerlink" title="3.3.1 局域网的数据链路层"></a>3.3.1 局域网的数据链路层</h2><ul><li>局域网按网络拓扑进行分类。图 3-13(a) 是<strong>星形网</strong> 。由于<strong>集线器</strong>的出现和双绞线大量用于局域网中，星形以太网以及多级星形结构的以太网获得了广泛的应用。图 3-13(b) 是<strong>环形网</strong> ，图 3-13(c) 为<strong>总线网</strong>，各站直接连在总线上。总线两端的匹配电阻吸收在总线上传播的电磁波信号的能量，避免在总线上产生有害的电磁波反射。总线网以传统以太网最为著名。局域网经过了四十年的发展，以太网已经在局域网市场中占据了绝对优势。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230714234326.png"></li></ol></li><li>共享信道要着重考虑的一个问题是如何使众多用户能够合理而方便地共享通信媒体资源。在技术上有两种方法：<ol><li><strong>静态划分信道</strong>，如频分复用、时分复用、波分复用和码分复用等。用户只要分配到了信道就不会和其他用户发生冲突。但这种划分信道的方法代价高，不适合局域网使用。</li><li><strong>动态媒体接入控制</strong> ，又称<strong>多点接入</strong>，特点是信道并非在用户通信时固定分配给用户。分为两类：<ul><li><strong>随机接入</strong> 　特点是所有的用户可随机地发送信息。但如果恰巧有两个或更多的用户在同一时刻发送信息，在共享媒体上会产生<strong>碰撞</strong> (即发生了<strong>冲突</strong>)，使得这些用户的发送都失败。因此，必须有解决碰撞的网络协议。</li><li><strong>受控接入</strong> 　特点是用户不能随机地发送信息，必须服从控制。典型代表有分散控制的令牌环局域网和集中控制的多点线路<strong>探询</strong>，或称为<strong>轮询</strong>。</li></ul></li></ol></li><li><strong>以太网的两个标准</strong><ol><li>为了使数据链路层能更好地适应多种局域网标准，局域网的数据链路层又拆成两个子层，即<strong>逻辑链路控制</strong> (LLC) 子层和<strong>媒体接入控制</strong> (MAC) 子层。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230715094124.png"></li></ol></li><li><strong>适配器的作用</strong><ol><li>适配器的一个功能是：进行数据串行传输和并行传输的转换。</li><li>适配器所实现的功能包含了数据链路层及物理层这两个层次的功能。</li><li>计算机的硬件地址在适配器的 ROM 中，而软件地址——IP 地址，在计算机的存储器中。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230715095506.png"></li></ol></li></ul><h2 id="3-3-2-CSMA-CD-协议"><a href="#3-3-2-CSMA-CD-协议" class="headerlink" title="3.3.2 CSMA&#x2F;CD 协议"></a>3.3.2 CSMA&#x2F;CD 协议</h2><ul><li>局域网上的计算机被称为“<strong>主机</strong>”、“<strong>工作站</strong>”、“<strong>站点</strong>”或“<strong>站</strong>”。</li><li>为了通信的简便，以太网采取两种措施：<ol><li>采用灵活的<strong>无连接</strong>的工作方式，不必先建立连接，可以直接发送数据。适配器对发送的数据帧<strong>不进行编号，也不要求对方发回确</strong>。<strong>以太网提供的服务是尽最大努力的交付</strong>，即<strong>不可靠的交付</strong>。当目的站收到有差错的数据帧时，就把帧丢弃，其他什么也不做。<strong>对有差错帧是否需要重传则由高层来决定</strong>。例如，如果高层使用 TCP 协议，那么 TCP 就会发现丢失了一些数据。于是经过一定的时间后，TCP 就把这些数据重新传递给以太网进行重传。<strong>但以太网并不知道这是重传帧，而是当作新的数据帧来发送</strong>。</li><li>以太网发送的数据使用<strong>曼彻斯特编码</strong>的信号。二进制基带数字信号通常是高、低电压交替出现的信号。使用这种信号的问题是当出现一长串的连 1 或连 0 时，接收端就无法从收到的比特流中提取位同步 (即比特同步) 信号。如图 3-16 所示，曼彻斯特编码的编码方法是把每一个码元分成两个相等的间隔。码元 1 是前一个间隔为低电压而后一个间隔为高电压。码元 0 则正好相反，从高电压变到低电压 (也可采用相反的约定，即 1 是“前高后低”而 0 是“前低后高”)，保证了在每一个码元的正中间出现一次电压的转换，接收端利用这种电压的转换很方便地把位同步信号提取出来。缺点是它所占的频带宽度比原始的基带信号增加了一倍 (因为每秒传送的码元数加倍了)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716104158.png"></li></ul></li></ol></li><li>CSMA&#x2F;CD 协议的要点：<ol><li><strong>多点接入</strong>　　总线型网络，计算机以多点接入的方式连接在一根总线上。实质是”载波监听”和”碰撞检测”。</li><li><strong>载波监听</strong>　　用电子技术检测总线上有没有其他计算机也在发送。载波监听是检测信道。<strong>不管在发送前，还是在发送中，每个站都必须不停地检测信道</strong>。在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则暂时不发送数据，等到信道变为空闲时才发送。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。</li><li><strong>碰撞检测</strong>　　<strong>边发送边监听</strong>，即适配器边发送数据边检测信道上的信号电压的变化情况，以判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度会增大 (互相叠加)。当适配器检测到信号电压变化幅度超过门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，总线上传输的信号严重失真，无法从中恢复出有用的信息来。任何一个正在发送数据的站，一旦发现总线上出现了碰撞，其适配器要停止发送。“碰撞检测”也称为“<strong>冲突检测</strong>”。</li><li>因为电磁波在总线上以有限的速率传播，所以即使每个站在发送数据之前已经监听到信道为“<strong>空闲</strong>”，还会出现数据在总线上的碰撞。这和开会相似，一听见会场安静，我们就立即发言，但偶尔也会发生几个人同时抢着发言而产生冲突的情况。</li><li>图 3-17 所示的例子可以说明这种情况。设图中的局域网两端的站 A 和 B 相距 1km，用同轴电缆相连。<strong>电磁波在</strong> 1km <strong>电缆的传播时延约为</strong> 5µs。因此，A 向 B 发出的数据，在约 5µs 后才能传送到 B。 若在 A 发送的数据到达 B 前，B 也发送，则在某个时间和 A 发送的帧会发生碰撞。碰撞的结果是两个帧都变得无用。在局域网的分析中，常把总线上的<strong>单程端到端传播时延</strong>记为 τ。A 发送数据后，<strong>最迟要两倍的总线端到端的传播时延</strong> (2τ)，或总线的端到端往返传播时延才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。由于局域网上任意两个站之间的传播时延有长有短，因此局域网必须按最坏情况设计，即取总线两端的两个站之间的传播时延  (这两个站之间的距离最大) 为端到端传播时延。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716104615.png"><ul><li>下面是图 3-17 中的一些重要的时刻。<br> 在 <em>t</em>＝0 时，A 发送数据。B 检测到信道为空闲。<br> 在 <em>t</em>＝<em>τ−δ</em> 时，A 发送的数据还没有到达 B 时，由于 B 检测到信道是空闲的，因此 B 发送数据。<br> 经过时间 <em>δ</em>&#x2F;2 后，即在 <em>t</em>＝<em>τ−δ</em>&#x2F;2 时，A 发送的数据和 B 发送的数据发生了碰撞。但这时 A 和 B 都不知道发生了碰撞。<br> 在 <em>t</em>＝<em>τ</em>  时，B 检测到发生了碰撞，于是停止发送数据。<br> 在 <em>t</em>＝2<em>τ−δ</em> 时，A 也检测到发生了碰撞，因而也停止发送数据。<br> A 和 B 发送数据均失败，它们都要推迟一段时间再重新发送。</li><li><strong>每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性</strong>。这一小段时间是<strong>不确定的</strong>，它取决于另一个发送数据的站到本站的距离。因此，以太网<strong>不能保证</strong>某一时间之内一定能够把自己的数据帧成功地发送出去。这一特点称为<strong>发送的不确定性</strong>。如果希望在以太网上发生碰撞的机会很小，必须使整个以太网的平均通信量远小于以太网的最高数据率。</li><li>从图 3-17 可看出，最先发送数据帧的 A 站，在发送数据帧后<strong>至多</strong>经过时间 2<em>τ</em> 就可知道所发送的数据帧是否遭受了碰撞。这就是 <em>δ</em>→0 的情况。因此以太网的端到端往返时间 2<em>τ</em> 称为<strong>争用期</strong>。争用期又称为<strong>碰撞窗口</strong>。因为一个站在发送完数据后，只有通过争用期的“考验”，即<strong>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。这时，就可以放心把这一帧数据顺利发送完毕。</li></ul></li><li>在使用 CSMA&#x2F;CD 协议时，一个站<strong>不能同时进行发送和接收 (但必须边发送边监听信道</strong>)，以太网不能进行全双工通信而只能进行**双向交替通信 (半双工通信)**。</li><li>以太网使用<strong>截断二进制指数退避</strong>算法确定碰撞后重传的时机。这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后立即再发送数据，而是<strong>推迟</strong> (即退避 ) 一个随机的时间。因为如果几个发生碰撞的站都在监听信道，那么都会同时发现信道变成了空闲。如果大家都同时再重新发送，那么肯定又会发生碰撞。为了使各站进行重传时再次发生冲突的概率减小，具体的退避算法如下：<ul><li>协议规定了基本退避时间为争用期 2<em>τ</em>，具体的<strong>争用期时间是</strong> 51.2µs。对于 10Mbit&#x2F;s 以太网，在争用期内可发送 512bit，即 64 字节。也可以<strong>直接使用比特作为争用期的单位</strong>，争用期是 512bit，即发送 512bit 所需的时间。</li><li>从离散的整数集合［0，1，…，(2<em>k</em> −1)］中随机取出一个数，记为 <em>r</em>。重传应推后的时间就是 <em>r</em> 倍的争用期。参数 <em>k</em> 按下面的公式 (3-1) 计算：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716154602.png"></li><li>可见当重传次数不超过 10 时，参数 <em>k</em> 等于重传次数；但当重传次数超过 10 时，<em>k</em> 就等于 10。</li></ol></li><li>当重传达 16 次仍不能成功时，则丢弃该帧，并向高层报告。</li></ul></li><li>以太网在发送数据时，如果在争用期 (共发送了 64 字节) 没有发生碰撞，那么后续发送的数据就一定不会发生冲突。如果发生碰撞，一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节，因此<strong>凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧</strong>。只要收到了这种无效帧，就应当立即将其丢弃。</li><li><strong>强化碰撞</strong>是当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送 32 比特或 48 比特的<strong>人为干扰信号</strong>，以便让所有用户都知道现在已经发生了碰撞。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716154825.png"></li><li>A 站从发送数据开始到发现碰撞并停止发送的时间间隔是 *T<sub>B</sub>*。A 站得知碰撞已经发生时所发送的强化碰撞的干扰信号的持续时间是 <em>T<sub>J</sub></em> 。图中的 B 站在得知发生碰撞后，也要发送人为干扰信号。发生碰撞使 A浪费时间 <em>T<sub>B</sub></em> ＋ <em>T<sub>J</sub><em>。可是整个信道被占用的时间还要增加一个单程端到端的传播时延 t。因此总线被占用的时间是 <em>T<sub>B</sub></em> ＋</em>T<sub>J</sub></em> ＋τ。</li></ul></li><li>CSMA&#x2F;CD 协议的要点如下：<ul><li>准备发送：适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中。但在发送之前，必须<strong>先检测信道</strong>。</li><li>检测信道：若检测到信道忙，则应不停地检测，一直等待信道转为空闲。若检测到信道空闲，并在 96 比特时间内信道保持空闲 (保证了帧间最小间隔)，就发送这个帧。</li><li>在发送过程中仍不停地检测信道，即网络适配器要<strong>边发送边监听</strong>。有两种可能性：<ol><li>发送成功：在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 (1)。</li><li>发送失败：在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 <em>r</em> 倍 512 比特时间后，返回到步骤(2)，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。</li></ol></li></ul></li></ol></li></ul><h2 id="3-3-3-使用集线器的星形拓扑"><a href="#3-3-3-使用集线器的星形拓扑" class="headerlink" title="3.3.3 使用集线器的星形拓扑"></a>3.3.3 使用集线器的星形拓扑</h2><ul><li>10BASE-T <strong>双绞线以太网的出现，是局域网发展史上的一个重要的里程碑</strong>，从此以太网的拓扑就从总线型变为更加方便的星形网络，而以太网也就在局域网中占据了统治地位。双绞线比无源电缆可靠、价格便宜且使用方便。</li><li>使双绞线能够传送高速数据的措施是把双绞线的绞合度做得非常精确。这样不仅可使特性阻抗均匀以减少失真，而且减少了电磁波辐射和无线电频率的干扰。</li><li>集线器的特点如下：<ol><li>从表面上看，使用集线器的局域网在物理上是一个星形网，但由于集线器使用电子器件来模拟实际电缆线的工作，因此整个系统仍像一个传统以太网那样运行。<strong>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是 CSMA&#x2F;CD 协议</strong>。网络中的各站必须竞争对传输媒体的控制，并且在<strong>同一时刻至多只允许一个站发送数据</strong>。</li><li>一个集线器有许多<strong>接口</strong>，用两对双绞线与一台计算机上的适配器相连，很像一个<strong>多接口的转发器</strong>。</li><li><strong>集线器工作在物理层</strong>，它的每个接口仅仅<strong>简单地转发比特</strong>——收到 1 就转发 1，收到 0 就转发 0，<strong>不进行碰撞检测</strong>。若两个接口同时有信号输入 (即发生碰撞)，那么所有的接口都将收不到正确的帧。图 3-20 是具有三个接口的集线器的示意图。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716163035.png"></li></ul></li><li>集线器采用专门的芯片，进行自适应串音回波抵消。可使接口转发出去的较强信号不致对该接口接收到的较弱信号产生干扰 (这种干扰即近端串音)。每个比特在转发之前还要进行再生整形并重新定时。</li></ol></li></ul><h2 id="3-3-4-以太网的信道利用率"><a href="#3-3-4-以太网的信道利用率" class="headerlink" title="3.3.4 以太网的信道利用率"></a>3.3.4 以太网的信道利用率</h2><ul><li>一个站在发送帧时出现了碰撞。经过一个争用期 2<em>τ</em> 后，可能又出现了碰撞，经过若干个争用期后发送成功。假定发送帧需要的时间是 *T<sub>0</sub>*。它等于帧长 (bit) 除以发送速率 (10Mbit&#x2F;s)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716221408.png"></li><li>成功发送一个帧需要占用信道的时间是 <em>T<sub>0</sub></em>+<em>τ</em>，比这个帧的发送时间要多一个单程端到端时延 <em>τ</em>。这是因为当一个站发送完最后一个比特时，这个比特还要在以太网上传播。在极端的情况下，发送站在传输媒体的一端，而比特在媒体上传输到另一端所需的时间是 <em>τ</em>。因此，必须在经过时间 <em>T<sub>0</sub></em>+<em>τ</em> 后以太网的媒体才完全进入空闲状态，才能允许其他站发送数据。</li><li>要提高以太网的信道利用率，就必须减小 <em>τ</em> 与 <em>T<sub>0</sub></em> 之比。在以太网中定义了参数 <em>a</em>，它是以太网<strong>单程端到端时延</strong> <em>τ</em> 与<strong>帧的发送时间</strong> <em>T<sub>0</sub></em> 之比：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716222853.png"></li><li>当 <em>a</em>→0 时，表示只要发生碰撞，就立即可以检测出来，并立即停止发送，因而信道资源被浪费的时间非常少。反之，表明争用期所占的比例越大，使得每发生一次碰撞就浪费了不少的信道资源，信道利用率明显降低。因此，以太网的<strong>参数</strong> <em>a</em> <strong>的值应当尽可能小些</strong> 。这就要求分子 <em>τ</em> 的数值要小些，分母 <em>T<sub>0</sub></em> 的数值要大些。当数据率一定时，<strong>以太网的连线的长度受到限制</strong>，同时<strong>以太网的帧长不能太短</strong>。</li></ul></li><li>考虑一种<strong>理想化</strong>的情况。假定以太网上的各站发送数据都不会产生碰撞，并且能够有效地利用网络的传输资源，即总线一旦空闲就有某一个站立即发送数据。这样，发送一帧占用线路的时间是 <em>T<sub>0</sub></em> ＋<em>τ</em>，而帧本身的发送时间是 *T<sub>0</sub>*。于是我们可计算出极限信道利用率 <em>S<sub>max</sub></em> 为：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230716225325.png"></li><li>虽然实际的以太网不可能有这样高的极限信道利用率，<strong>只有当参数</strong> <em>a</em> <strong>远小于 1 才能得到尽可能高的极限信道利用率</strong>。若参数 <em>a</em> 远大于1，则极限信道利用率就远小于 1，实际的信道利用率就更小了。据统计，当以太网的利用率达到 30％ 时就已经处于重载的情况。很多的网络容量被网上的碰撞消耗掉了。</li></ul></li></ol></li></ul><h2 id="3-3-5-以太网的-MAC-层"><a href="#3-3-5-以太网的-MAC-层" class="headerlink" title="3.3.5 以太网的 MAC 层"></a>3.3.5 以太网的 MAC 层</h2><ul><li><strong>MAC 层的硬件地址</strong><ol><li>在局域网中，<strong>硬件地址</strong>又称<strong>物理地址</strong>或 <strong>MAC 地址</strong> (因为这种地址用在 MAC 帧中)。</li><li>在所有计算机系统的设计中，<strong>标识系统</strong>都是一个核心问题。在标识系统中，地址是识别某个系统的标识符。<ul><li><strong>名字指出我们所要寻找的那个资源，地址指出那个资源在何处，路由告诉我们如何到达该处</strong>。</li><li><strong>严格地讲，名字与系统的所在地无关</strong>。就像我们每一个人的名字一样，不随我们所处的地点而改变。但是 IEEE 802 标准为局域网规定了一种 48 位的全球地址，是指局域网上的每一台计算机中<strong>固化在适配器的 ROM 中的地址</strong>。<ol><li>假定连接在局域网上的一台计算机的适配器坏了，我们更换了一个新的适配器，那么这台计算机的局域网的“地址”就改变了。</li><li>假定我们把位于南京的某局域网上的一台笔记本电脑携带到北京，并连接在北京的某局域网上。虽然这台电脑的地理位置改变了，但只要电脑中的适配器不变，那么该电脑在北京的局域网中的“地址”仍然和它在南京的局域网中的“地址”一样。</li></ol></li></ul></li><li>在生产适配器时，6 字节的 MAC 地址已被固化在适配器的 ROM 中。因此，MAC 地址也叫做<strong>硬件地址</strong>或<strong>物理地址</strong>，实际上就是<strong>适配器地址</strong>或<strong>适配器标识符</strong> EUI-48。当这块适配器插入(或嵌入) 到某台计算机后，适配器上的标识符 EUI-48 就成为这台计算机的 MAC 地址了。</li><li>地址记法中有两种标准：<ul><li>第一种记法是把每一字节的<strong>最低位</strong>写在最左边 (最左边的最低位是第一位)。</li><li>第二种记法是把每一字节的<strong>最高位</strong>写在最左边 (最左边的最高位是第一位)。</li><li>在发送数据时，两种记法都是按照字节的顺序发送，但每一个字节中先发送哪一位则不同：第一种记法先发送最低位，第二种记法先发送最高位。</li></ul></li><li>适配器有<strong>过滤功能</strong>。但适配器从网络上每收到一个 MAC 帧就先用硬件检查 MAC 帧中的目的地址。如果是发往本站的帧，则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。这里“发往本站的帧”包括以下三种帧：<ul><li><strong>单播帧</strong> (一对一)，即收到的帧的 MAC 地址与本站的硬件地址相同。</li><li><strong>广播帧</strong> (一对全体)，即发送给本局域网上所有站点的帧 (全 1 地址)。</li><li><strong>多播帧</strong> (一对多)，即发送给本局域网上一部分站点的帧。</li></ul></li></ol></li><li><strong>MAC 帧的格式</strong><ol><li>常用的以太网 MAC 帧格式有两种标准，一种是 DIX Ethernet V2 标准 (即以太网 V2 标准)，另一种是 IEEE 的 802.3 标准。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717111013.png"></li></ul></li><li>以太网 V2 的 MAC 帧较为简单，由五个字段组成。前两个字段分别为 6 字节长的<strong>目的地址</strong>和<strong>源地址</strong>字段。第三个字段是 2 字节的<strong>类型字段</strong>，用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。第四个字段是<strong>数据字段</strong>，其长度在 46 到 1500 字节之间 (46 字节是这样得出的：最小长度 64 字节减去 18 字节的首部和尾部就得出数据字段的最小长度)。最后一个字段是 4 字节的<strong>帧检验序列</strong> FCS (使用 CRC 检验)。当传输媒体的误码率为 1×10<sup>−8</sup> 时，MAC 子层可使未检测到的差错小于 1×10<sup>−14</sup>。</li><li>为了接收端实现位同步，从 MAC 子层向下传到物理层时要在帧的前面插入 8 字节 (由硬件生成)，它由两个字段构成：<ul><li>7 个字节的<strong>前同步码</strong> (1 和 0 交替码)，作用是使接收端的适配器在接收 MAC 帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是“实现位同步”。</li><li><strong>帧开始定界符</strong>，定义为 10101011。它的前六位的作用和前同步码一样，最后的两个连续的 1 就是告诉接收端适配器：“MAC 帧的信息马上就要来了，请适配器注意接收”。</li></ul></li><li>IEEE 802.3 标准规定凡出现下列情况之一的即为无效的 MAC 帧：<ul><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>收到的帧的 MAC 客户数据字段的长度不在 46～1500 字节之间。考虑到 MAC 帧首部和尾部的长度共有 18 字节，可以得出有效的 MAC 帧长度为 64～1518 字节之间。</li></ul></li></ol></li></ul><h1 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h1><h2 id="3-4-1-在物理层扩展以太网"><a href="#3-4-1-在物理层扩展以太网" class="headerlink" title="3.4.1 在物理层扩展以太网"></a>3.4.1 在物理层扩展以太网</h2><ul><li>扩展主机和集线器之间距离的一种方法是使用一对光纤和一对光纤调制解调器，如图 3-23 所示：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717223544.png"></li></ol></li><li>光纤调制解调器的作用是进行电信号和光信号的转换。光纤的时延小，带宽宽，使用这种方法可以使主机和几公里以外的集线器相连接。</li><li>如果使用多个集线器，可以连接成覆盖更大范围的多级星形结构的以太网。例如，一个学院的三个系各有一个 10BASE-T 以太网 (a)，可通过一个主干集线器把各系的以太网连接起来，成为一个更大的以太网 (b)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230717223829.png"></li><li>有以下好处：<ul><li>使这个学院不同系的以太网上的计算机能够进行跨系的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ul></li><li>但这种多级结构的集线器以太网也带来了一些缺点：<ul><li>如图 (a) 所示的例子，在三个系的以太网互连起来之前，每一个系的以太网是一个独立的<strong>碰撞域</strong> (冲突域)，在任一时刻，在每一个碰撞域中只能有一个站在发送数据。每一个系的以太网的最大吞吐量是 10Mbit&#x2F;s，因此三个系总的最大吞吐量共有 30Mbit&#x2F;s。在三个系的以太网通过集线器互连起来后就把三个碰撞域变成一个碰撞域 (范围扩大到三个系)，如图 (b) 所示，而这时的最大吞吐量仍然是一个系的吞吐量 10Mbit&#x2F;s。这就是说，当某个系的两个站在通信时所传送的数据会通过所有的集线器进行转发，使得其他系的内部在这时都不能通信 (一发送数据就会碰撞)。</li><li>如果不同的系使用不同的以太网技术 (如数据率不同)，那么就不可能用集线器将它们互连起来。如果在图 3-24 中，一个系使用 10Mbit&#x2F;s 的适配器，而另外两个系使用10&#x2F;100Mbit&#x2F;s 的适配器，那么用集线器连接起来后，大家都只能工作在 10Mbit&#x2F;s 的速率。集线器基本上是个多接口的转发器，不能把帧进行缓存。</li></ul></li></ol></li></ul><h2 id="3-4-2-在数据链路层扩展以太网"><a href="#3-4-2-在数据链路层扩展以太网" class="headerlink" title="3.4.2 在数据链路层扩展以太网"></a>3.4.2 在数据链路层扩展以太网</h2><ul><li>使用<strong>网桥</strong>扩展以太网的方法在数据链路层进行。网桥对收到的帧根据其 MAC 帧的目的地址进行<strong>转发</strong>和<strong>过滤</strong>。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是根据此帧的目的 MAC 地址，查找网桥中的地址表，然后确定将该帧转发到哪一个接口，或者是把它丢弃。</li><li><strong>交换式集线器</strong>淘汰了网桥。交换式集线器称为以太网<strong>交换机</strong>或<strong>第二层交换机</strong>，强调这种交换机<strong>工作在数据链路层</strong>。</li><li><strong>以太网交换机的特点：</strong><ol><li>以太网交换机实质上是一个<strong>多接口的网桥</strong>，通常都有十几个或更多的接口，和工作在物理层的转发器、集线器有很大的差别。以太网交换机的每个接口都直接与一个单台主机或另一个以太网交换机相连，一般都在全双工方式。以太网交换机还具有并行性，能同时连通多对接口，使多对主机能同时通信 (而网桥只能一次分析和转发一个帧)。相互通信的主机都是<strong>独占传输媒体，无碰撞地传输数据</strong>。</li><li>以太网交换机的接口有存储器，能在输出端口繁忙时把到来的帧进行缓存。如果连接在以太网交换机上的两台主机，同时向另一台主机发送帧，那么当这台主机的接口繁忙时，发送帧的这两台主机的接口会把收到的帧暂存一下，以后再发送出去。</li><li>以太网交换机是一种即插即用设备，其内部的帧<strong>交换表</strong> (地址表) 是通过自学习算法自动地逐渐建立起来的。以太网交换机由于使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。</li><li>以太网交换机的性能远超普通的集线器，而且价格不贵。</li><li>以太网交换机都具有多种速率的接口，方便了各种不同情况的用户。</li></ol></li><li><strong>以太网交换机的自学习功能</strong><ol><li>假定在图 3-25 中的以太网交换机有 4 个接口，各连接一台计算机，其 MAC 地址分别是 A，B，C 和 D。在一开始，以太网交换机里面的交换表是空的 (a)。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718171025.png"></li><li>A 先向 B 发送一帧，从接口 1 进入到交换机。交换机收到帧后，先查找交换表，没有查到应从哪个接口转发这个帧 (在 MAC 地址这一列中，找不到目的地址为 B 的项目)。接着，交换机把这个帧的源地址 A 和接口 1 写入交换表中，并向除接口 1 以外的所有接口广播这个帧。</li><li>C 和 D 丢弃这个帧，因为目的地址不对。B 收下这个帧。也称<strong>过滤</strong>。</li><li>从新写入交换表的项目 (A，1) 可以看出，以后不管从哪一个接口收到帧，只要其目的地址是 A，就应当把收到的帧从接口 1 转发出去。依据是：既然 A 发出的帧是从接口 1 进入到交换机的，那么从交换机的接口 1 转发出的帧也应可以到达 A。</li><li>假定接下来 B 通过接口 3 向 A 发送一帧。交换机查找交换表，发现交换表中的 MAC 地址有 A。表明要发送给 A 的帧 (即目的地址为 A 的帧) 应从接口 1 转发。于是就把这个帧传送到接口 1 转发给 A。显然，现在已经没有必要再广播收到的帧。交换表这时新增加的项目 (B，3)，表明今后如有发送给 B 的帧，就应当从接口 3 转发出去。</li><li>经过一段时间后，只要主机 C 和 D 也向其他主机发送帧，以太网交换机中的交换表就会把转发到 C 或 D 应当经过的接口号 (2 或 4) 写入到交换表中。这样，交换表中的项目就齐全了。要转发给任何一台主机的帧，都能够很快地在交换表中找到相应的转发接口。</li></ul></li><li>考虑到有时可能要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。用这样的方法保证交换表中的数据符合当前网络的实际状况。</li><li>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，非常方便。</li><li>为了增加网络的可靠性，在使用以太网交换机组网时，会增加一些冗余的链路。在这种情况下，自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子。用图 3-26 的例子来说明这个问题。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718172449.png"></li><li>在图3-26 中，假定一开始主机 A 通过接口交换机 #1 向主机 B 发送一帧。交换机 #1 收到这个帧后就向所有其他接口进行广播发送。现观察其中一个帧的走向：离开交换机 #1 的接口 3→ 交换机 #2 的接口 1→ 接口 2→ 交换机 #1 的接口 4→ 接口 3→ 交换机 #2 的接口 1→……。无限制地循环兜圈子下去，消耗网络资源。</li><li>为了解决这种兜圈子问题，制定了一个<strong>生成树协议</strong> STP。要点是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</li></ul></li></ol></li><li><strong>从总线以太网到星形以太网</strong><ol><li>随着以太网上站点数目的增多，总线结构以太网的可靠性下降。与此同时，大规模集成电路以及专用芯片的发展，使得星形结构的以太网交换机既便宜又可靠。在这种情况下，采用以太网交换机的星形结构成为首选拓扑，而传统的总线以太网也很快从市场上消失了。</li><li>总线以太网使用 CSMA&#x2F;CD 协议，以半双工方式工作。但以太网交换机不使用共享总线，没有碰撞问题，因此不使用 CSMA&#x2F;CD 协议，而是以全双工方式工作。以太网交换机的帧结构未改变，<strong>仍然采用以太网的帧结构</strong>。</li></ol></li></ul><h2 id="3-4-3-虚拟局域网"><a href="#3-4-3-虚拟局域网" class="headerlink" title="3.4.3 虚拟局域网"></a>3.4.3 虚拟局域网</h2><ul><li>虚拟局域网 VLAN 这样定义：虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，这些网段具有某些共同的需求。每一个 VLAN 的帧都有明确的标识符，指明发送这个帧的计算机属于哪一个 VLAN。</li><li>虚拟局域网其实是局域网给用户提供的一种服务，并不是新型局域网。</li><li>图 3-27 画的是使用了四个交换机的网络拓扑。设有 10 台计算机分配在三个楼层中，构成了三个局域网，即: LAN<sub>1</sub>:  (A<sub>1</sub>，A<sub>2</sub>，B<sub>1</sub>，C<sub>1</sub>)，LAN<sub>2</sub>: (A<sub>3</sub>，B<sub>2</sub>，C<sub>2</sub>)，LAN<sub>3</sub>: (A<sub>4</sub>，B<sub>3</sub>，C<sub>3</sub>)；这 10 个用户划分为三个工作组，也就是说划分为三个虚拟局域网 VLAN。即: VLAN<sub>1</sub>: (A<sub>1</sub>，A<sub>2</sub>，A<sub>3</sub>，A<sub>4</sub>)，VLAN<sub>2</sub>: (B<sub>1</sub>，B<sub>2</sub>，B<sub>3</sub>)；VLAN<sub>3</sub>：(C<sub>1</sub>，C<sub>2</sub>，C<sub>3</sub>)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230718180349.png"></li><li>从图 3-27 可看出，每一个 VLAN 的计算机可处在不同的局域网中，也可以不在同一层楼中。</li></ol></li></ul><h1 id="3-5-高速以太网"><a href="#3-5-高速以太网" class="headerlink" title="3.5 高速以太网"></a>3.5 高速以太网</h1><h2 id="3-5-1-100BASE-T-以太网"><a href="#3-5-1-100BASE-T-以太网" class="headerlink" title="3.5.1 100BASE-T 以太网"></a>3.5.1 100BASE-T 以太网</h2><ul><li>100BASE-T 是在双绞线上传送 100Mbit&#x2F;s 基带信号的星形拓扑以太网，CSMA&#x2F;CD 协议，它又称为<strong>快速以太网</strong>。</li><li>100BASE-T 可使用以太网交换机提供很好的服务质量，可在全双工方式下工作而无冲突发生。因此，CSMA&#x2F;CD 协议对全双工方式工作的快速以太网是不起作用的 (但在半双工方式工作时则一定要使用 CSMA&#x2F;CD 协议)。快速以太网使用的 MAC 帧格式仍然是 IEEE 802.3标准规定的帧格式。</li><li><strong>从细缆以太网升级到快速以太网的用户必须重新布线</strong>。</li></ul><h2 id="3-5-2-吉比特以太网"><a href="#3-5-2-吉比特以太网" class="headerlink" title="3.5.2 吉比特以太网"></a>3.5.2 吉比特以太网</h2><ul><li>吉比特以太网的标准 IEEE 802.3z 有以下特点：<ol><li>允许在 1Gbit&#x2F;s 下以全双工和半双工两种方式工作。</li><li>使用 IEEE 802.3 协议规定的帧格式。</li><li>在半双工方式下使用 CSMA&#x2F;CD 协议，而在全双工方式不使用 CSMA&#x2F;CD 协议。</li><li>与 10BASE-T 和 100BASE-T 技术向后兼容。</li></ol></li><li>吉比特以太网的物理层使用两种成熟的技术：<ol><li>来自现有的以太网。</li><li>美国国家标准协会 ANSI 制定的<strong>光纤通道</strong>，采用成熟技术就能大大缩短吉比特以太网标准的开发时间。</li></ol></li><li>吉比特以太网工作在半双工方式时，必须进行碰撞检测。由于数据率提高了，因此只有减小最大电缆长度或增大帧的最小长度，才能使参数 <em>a</em> 保持为较小的数值。若将吉比特以太网最大电缆长度减小到 10m，网络的实际价值就大大减小。而若将最短帧长提高到 640 字节，则在发送短数据时开销太大。因此，吉比特以太网仍然保持一个网段的最大长度为 100m，采用了<strong>载波延伸</strong>的办法，使最短帧长仍为 64 字节，同时将争用期增大为 512 字节。凡发送的 MAC 帧长不足 512 字节时，就用一些特殊字符填充在帧的后面，使 MAC 帧的发送长度增大到 512 字节，这对有效载荷并无影响。接收端在收到以太网的 MAC 帧后，要把所填充的特殊字符删除后才向高层交付。当原来仅 64 字节长的短帧填充到 512 字节时，所填充的 448 字节就造成了很大的开销。为此，吉比特以太网还增加了一种功能称为<strong>分组突发</strong>。这就是当很多短帧要发送时，第一个短帧要采用上面所说的载波延伸的方法进行填充。但随后的一些短帧则可一个接一个地发送，它们之间只需留有必要的帧间最小间隔即可。这样就形成一串分组的突发，直到达到 1500 字节或稍多一些为止。当吉比特以太网工作在全双工方式时 (即通信双方可同时进行发送和接收数据)，不使用载波延伸和分组突发。</li></ul><h2 id="3-5-3-10-吉比特以太网"><a href="#3-5-3-10-吉比特以太网" class="headerlink" title="3.5.3 10 吉比特以太网"></a>3.5.3 10 吉比特以太网</h2><ul><li>10GE 的帧格式与 10Mbit&#x2F;s，100Mbit&#x2F;s 和 1Gbit&#x2F;s 以太网的<strong>帧格式完全相同</strong>，并保留了 802.3 标准规定的<strong>以太网最小帧长和最大帧长</strong>。使用户在将其已有的以太网进行升级时，仍能和较低速率的以太网很方便地通信。</li><li>10GE <strong>只工作在全双工方式，不存在争用问题，也不使用</strong> CSMA&#x2F;CD <strong>协议</strong>。使得 10GE 的传输距离大大提高了 (因为不再受必须进行碰撞检测的限制)。</li><li>现在以太网的工作范围已经从局域网 (校园网、企业网) 扩大到城域网和广域网，从而实现了端到端的以太网传输。这种工作方式的好处是：<ol><li>以太网是一种经过实践证明的成熟技术，无论是互联网服务提供者 ISP 还是端用户都愿意使用以太网。对 ISP 来说，使用以太网还需要在更大的范围进行试验。</li><li>以太网的互操作性很好，不同厂商生产的以太网都能可靠地进行互操作。</li><li>在广域网中使用以太网时，价格大约只有同步光纤网 SONET 的五分之一和异步传递方式 ATM 的十分之一。以太网还能够适应多种传输媒体，如铜缆、双绞线以及各种光缆。使具有不同传输媒体的用户在进行通信时不必重新布线。</li><li>端到端的以太网连接使帧的格式全都是以太网的格式，而不需要再进行帧的格式转换，简化了操作和管理。但是，以太网和现有的其他网络，如帧中继或 ATM 网络，仍然需要有相应的接口才能进行互连。</li></ol></li><li>以太网从 10Mbit&#x2F;s 到 10Gbit&#x2F;s 甚至到 100Gbit&#x2F;s 的演进，证明了以太网是：<ol><li>可扩展的 (速率从 10Mbit&#x2F;s 到 100Gbit&#x2F;s)。</li><li>灵活的 (多种媒体、全&#x2F;半双工、共享&#x2F;交换)。</li><li>易于安装。</li><li>稳健性好。</li></ol></li></ul><h2 id="3-5-4-使用以太网进行宽带接入"><a href="#3-5-4-使用以太网进行宽带接入" class="headerlink" title="3.5.4 使用以太网进行宽带接入"></a>3.5.4 使用以太网进行宽带接入</h2><ul><li>以太网接入的一个重要特点是它可以提供双向的宽带通信，并且可以根据用户对带宽的需求灵活地进行带宽升级。当城域网和广域网都采用吉比特以太网或 10 吉比特以太网时，采用以太网接入可以实现端到端的以太网传输，中间不需要再进行帧格式的转换。提高了数据的传输效率且降低了传输的成本。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>链路是从一个结点到相邻结点的一段物理线路，数据链路则是在链路的基础上增加了一些必要的硬件 (如网络适配器) 和软件 (如协议的实现)。</p></li><li><p>数据链路层使用的信道有点对点信道和广播信道两种。</p></li><li><p>数据链路层传送的协议数据单元是帧。数据链路层的三个基本问题则是：封装成帧、透明传输和差错检测。</p></li><li><p>循环冗余检验 CRC 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码。</p></li><li><p>点对点协议 PPP 是数据链路层使用最多的一种协议，它的特点是: </p><ol><li>简单；</li><li>只检测差错，而不是纠正差错；</li><li>不使用序号，也不进行流量控制；</li><li>可同时支持多种网络层协议。</li></ol></li><li><p>PPPoE 是为宽带上网的主机使用的链路层协议。</p></li><li><p>局域网的优点是：</p><ol><li>具有广播功能，从一个站点可很方便地访问全网；</li><li>便于系统的扩展和逐渐演变；提高了系统的可靠性、可用性和生存性。</li></ol></li><li><p>共享通信媒体资源的方法有两种: </p><ol><li>静态划分信道 (各种复用技术)；</li><li>动态媒体接入控制，又称为多点接入 (随机接入或受控接入)。</li></ol></li><li><p>IEEE 802  委员会曾把局域网的数据链路层拆成两个子层，即逻辑链路控制 (LLC) 子层 (与传输媒体无关) 和媒体接入控制 (MAC) 子层 (与传输媒体有关) 。但现在 LLC 子层已成为历史。</p></li><li><p>计算机与外界局域网的通信要通过通信适配器 (网络适配器)，它又称为网络接口卡或网卡。计算机的硬件地址就在适配器的 ROM 中。</p></li><li><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做。</p></li><li><p>以太网采用的协议是具有冲突检测的载波监听多点接入 CSMA&#x2F;CD。协议的要点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。因此，每一个站在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上各站点都平等地争用以太网信道。</p></li><li><p>传统的总线以太网基本上都是使用集线器的双绞线以太网。这种以太网在物理上是星形网，但在逻辑上则是总线形网。集线器工作在物理层，它的每个接口仅仅简单地转发比特，不进行碰撞检测。</p></li><li><p>以太网的硬件地址，即 MAC 地址实际上就是适配器地址或适配器标识符，与主机所在的地点无关。源地址和目的地址都是 48 位长。</p></li><li><p>以太网的适配器有过滤功能，它只接收单播帧、广播帧或多播帧。</p></li><li><p>使用集线器可以在物理层扩展以太网 (扩展后的以太网仍然是一个网络)。</p></li><li><p>交换式集线器常称为以太网交换机或第二层交换机 (工作在数据链路层)，是一个多接口的网桥，每个接口都直接与某台单主机或另一个集线器相连，且工作在全双工方式。以太网交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。</p></li><li><p>高速以太网有 100Mbit&#x2F;s 的快速以太网、吉比特以太网和 10Gbit&#x2F;s 的 10 吉比特以太网。最近还发展到 100 吉比特以太网。在宽带接入技术中，也常使用高速以太网进行接入。</p></li><li><p>数据链路层的三个基本问题 (封装成帧、透明传输和差错检测) 为什么都必须加以解决？</p><blockquote><p>封装成帧就是在一段数据的前后分别添加首部和尾(在首部和尾部里面有许多必要的控制信息)，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。<br>所谓“透明传输”就是上层交下来的数据，不管是什么形式的比特组合，都必须能够正确传送。由于帧的开始和结束的标记是使用专门指明的控制字符，因此，所传输的数据中的任何比特组合一定不允许和用作帧定界的控制字符的比特编码一样，否则就会出现帧定界的错误。数据链路层不应当对要传送的数据提出限制，即不应当规定某种形式的比特组合不能够传送。<br>如果数据链路层没有差错检测，那么当目的主机收到其他主机发送来的数据时，在交给高层后，如果应用程序要求收到的数据必须正确无误，那么目的主机的高层软件可以对收到的数据进行差错检测。如果发现数据中有差错，就可以请求源主机重传这些数据。这样做就可以达到正确接收数据的目的。但这种工作方式有一个很大的缺点，就是一些在传输过程中出现了错误的数据 (请注意，这些已经是没有用处的数据) 还会继续在网络中传送，这样就浪费了网络的资源。例如，源主机到目的主机的路径中共有 20 个结点。在传送数据时，第一个结点就检测出了差错。如果数据链路层有差错检测的功能，就可以把这个有差错的帧丢弃以后就不再传送了。否则这个没有用处的帧还要在网络上继续传送，还要陆续通过后面的 19 个结点，这就造成了网络资源的浪费。</p></blockquote></li><li><p>局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</p><blockquote><p>局域网最主要的特点是: 网络为一个单位所拥有，且地理范围和站点数目均有限在局域网刚刚出现时，局域网比广域网具有更高的数据率、更低的时延和更小的误码率。但随着光纤技术在广域网中普遍使用，现在广域网也具有很高的数据率和很低的误码率局域网的地理范围较小，且为一个单位所拥有，采用广播通信方式十分简单方便。但广域网的地理范围很大，如果采用广播通信方式势必造成通信资源的极大浪费，因此广域网不采用广播通信方式。</p></blockquote></li><li><p>说明 10BASE-T中的“10”“BASE”和“T”所代表的意思。</p><blockquote><p>“10”代表这种以太网具有 10 Mbit&#x2F;s 的数据率，BASE 表示连接线上的信号是基带信号，T 代表双绞线 (Twisted-pair)。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物理层</title>
      <link href="/2023/12/09/wu-li-ceng/"/>
      <url>/2023/12/09/wu-li-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h1><ul><li>物理层的作用是屏蔽掉传输媒体和通信手段的差异，使数据链路层感觉不到这些差异，只考虑如何完成本层的协议和服务，不考虑网络具体的传输媒体和通信手段是什么。</li><li>用于物理层的协议也常称为物理层<strong>规程</strong>。</li><li>将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性，即：<ol><li><strong>机械特性</strong> 　指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。</li><li><strong>电气特性</strong> 　指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong> 　指明某条线上出现的某一电平的电压的意义。</li><li><strong>过程特性</strong> 　指明对于不同功能的各种可能事件的出现顺序。</li></ol></li><li>数据在计算机内部多采用并行输出方式。但数据在通信线路上的传输方式一般是<strong>串行传输</strong>，即逐个比特按照时间顺序传输。物理层还要完成传输方式的转换。</li></ul><h1 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h1><h2 id="2-2-1-数据通信系统的模型"><a href="#2-2-1-数据通信系统的模型" class="headerlink" title="2.2.1  数据通信系统的模型"></a>2.2.1  数据通信系统的模型</h2><ul><li>如图 2-1 所示，数据通信系统可划分为三大部分，即<strong>源系统</strong>、<strong>传输系统</strong>和<strong>目的系统</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230704174305.png"></li></ol></li><li>源系统包括两个部分：<ol><li><strong>源点</strong> 　源点设备产生要传输的数据。源点又称为<strong>源站</strong>，或<strong>信源</strong>。</li><li><strong>发送器</strong> 　通常源点生成的数字比特流要通过发送器编码后才能在传输系统中进行传输。典型的发送器就是调制器。</li></ol></li><li>目的系统也包括两个部分：<ol><li><strong>接收器</strong> 　接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信息。典型的接收器是解调器，它把来自传输线路上的模拟信号进行解调，提取出在发送端置入的消息，还原出发送端产生的数字比特流。</li><li><strong>终点</strong> 　终点设备从接收器获取传送来的数字比特流，然后把信息输出。终点又称为<strong>目的站</strong>，或<strong>信宿</strong>。</li></ol></li><li>在源系统和目的系统之间的传输系统可以是简单的传输线，也可以是连接在源系统和目的系统之间的复杂网络系统。</li><li>通信的目的是传送<strong>消息</strong>。如话音、文字、图像、视频等都是消息。<strong>数据</strong>是运送消息的实体。根据RFC 4949 给出的定义，数据是使用特定方式表示的信息，是有意义的符号序列。这种信息的表示可用计算机或其他机器处理或产生。<strong>信号</strong>则是数据的电气或电磁的表现。</li><li>根据信号中代表消息的参数的取值方式不同，信号分为两大类：<ol><li><strong>模拟信号</strong>，或<strong>连续信号</strong>——代表消息的参数的取值是连续的。例如在图 2-1中，用户家中的调制解调器到电话端局之间的用户线上传送的就是模拟信号。</li><li><strong>数字信号</strong>，或<strong>离散信号</strong>——代表消息的参数的取值是离散的。例如在图 2-1中，用户家中的计算机到调制解调器之间，或在电话网中继线上传送的就是数字信号。在使用时间域 (或简称为时域) 的波形表示数字信号时，代表不同离散数值的基本波形就称为码元。在使用二进制编码时，只有两种不同的码元，一种代表 0 状态而另一种代表 1 状态。</li></ol></li></ul><h2 id="2-2-2-有关信道的几个基本概念"><a href="#2-2-2-有关信道的几个基本概念" class="headerlink" title="2.2.2 有关信道的几个基本概念"></a>2.2.2 有关信道的几个基本概念</h2><ul><li>信道用来表示向某一个方向传送信息的媒体。一条通信电路包含一条发送信道和一条接收信道。</li><li>从通信的双方信息交互的方式来看，有三种基本方式：<ol><li><strong>单向通信</strong> 　又称为<strong>单工通信</strong>，只有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信</strong> 　又称为<strong>半双工通信</strong>，通信的双方都可以发送信息，但不能同时发送。这种通信方式是一方发送另一方接收，过一段时间后可以再反过来。</li><li><strong>双向同时通信</strong> 　又称为<strong>全双工通信</strong>，通信的双方可以同时发送和接收信息。</li></ol></li><li>单向通信只需要一条信道，而双向交替通信或双向同时通信则都需要两条信道 (每个方向各一条)。双向同时通信的传输效率最高。</li><li>来自信源的信号称为<strong>基带信号</strong>。计算机输出的代表各种文字或图像文件的数据信号就属于基带信号。基带信号包含有低频成分，甚至有直流成分，许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行<strong>调制</strong>。</li><li>调制可分为两大类。一类是对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号，这类调制称为<strong>基带调制</strong>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此把这种过程称为<strong>编码</strong>。另一类调制需要使用<strong>载波</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>，使用载波的调制称为<strong>带通调制</strong>。<ol><li><strong>常用编码方式</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222731.png"></li><li><strong>不归零制</strong> 　正电平代表 1，负电平代表 0。</li><li><strong>归零制</strong> 　正脉冲代表 1，负脉冲代表 0。</li><li><strong>曼彻斯特编码</strong> 　位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。</li><li><strong>差分曼彻斯特编码</strong> 　在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。</li><li>从信号波形中可以看出，曼彻斯特编码产生的信号频率比不归零制高。从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率 (这叫做没有自同步能力)，而曼彻斯特编码具有自同步能力。</li></ul></li><li><strong>基本的带通调制方法</strong><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222830.png"></li><li><strong>调幅</strong> (AM)　载波的振幅随基带数字信号而变化。0 或 1 分别对应于无载波或有载波输出。</li><li><strong>调频</strong> (FM)　载波的频率随基带数字信号而变化。0 或 1 分别对应于频率 <em>f<sub>1</sub></em> 或 <em>f<sub>2</sub>。</em></li><li><strong>调相</strong> (PM)　载波的初始相位随基带数字信号而变化。0 或 1 分别对应于相位 0 度或 180度。</li><li>为了达到更高的信息传输速率，必须采用更复杂的多元制的振幅相位混合调制方法。例如，<strong>正交振幅调制</strong> QAM。</li></ul></li></ol></li></ul><h2 id="2-2-3-信道的极限容量"><a href="#2-2-3-信道的极限容量" class="headerlink" title="2.2.3 信道的极限容量"></a>2.2.3 信道的极限容量</h2><ul><li>数字通信的优点是：虽然信号在信道上传输时会不可避免地产生失真，但在接收端只要从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就没有影响。例如图 2-4(a) 表示信号通过实际的信道传输后虽然有失真，但在接收端可识别并恢复出原来的码元。图 2-4(b)信号失真严重，在接收端无法识别码元是 1 还是 0。码元传输的速率越高，或信号传输的距离越远，或噪声干扰越大，或传输媒体质量越差，在接收端的波形的失真就越严重。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705222925.png"></li></ol></li><li>限制码元在信道上的传输速率的因素下两个：<ol><li><strong>信道能够通过的频率范围</strong><ul><li>信道所能通过的频率范围是有限的，信号中的许多高频分量不能通过信道。像图 2-4 所示的发送信号是一种矩形脉冲信号，包含很丰富的高频分量。如果信号中的高频分量在传输时受到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，每一个码元所占的时间界限也不再是很明确的，而是前后都拖了“尾巴”。这样，在接收端收到的信号波形就失去了码元之间的清晰界限。这种现象叫做<strong>码间串扰</strong>。严重的码间串扰使得本来分得很清楚的一串码元变得模糊而无法识别。<strong>在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的识别成为不可能</strong> 。</li><li>信道的频带越宽，能够通过的信号高频分量越多，就可以用更高的速率传送码元而不出现码间串扰。</li></ul></li><li><strong>信噪比</strong><ul><li>噪声存在于所有的电子设备和通信信道中。由于噪声是随机产生的，它的瞬时值有时会很大，因此噪声会使接收端对码元的识别产生错误 (1 误判为 0 或 0 误判为 1)。噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。因此，信噪比很重要。所谓信噪比就是信号的平均功率和噪声的平均功率之比，常记为 S&#x2F;N，并用分贝 (dB) 作为度量单位。即：</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705223051.png"></li><li>香农公式指出：<strong>信道的极限信息传输速率</strong> <em>C</em> 是</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230705223107.png"></li><li><em>W</em> 为信道的带宽（以 Hz 为单位）；<em>S</em> 为信道内所传信号的平均功率；<em>N</em> 为信道内部的高斯噪声功率。</li><li>香农公式表明，<strong>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高</strong>。香农公式的意义在于：只要信息传输速率低于信道的极限信息传输速率，就一定存在某种办法来实现无差错的传输。</li><li>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，可以用编码的方法<strong>让每一个码元携带更多比特的信息量</strong>来提高信息的传输速率。</li></ul></li></ol></li></ul><h1 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h1><ul><li><strong>传输媒体</strong>也称为传输介质或传输媒介，是数据传输系统中在发送器和接收器之间的物理通路。</li><li>传输媒体分为两大类，<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong>。在导引型传输媒体中，电磁波被导引沿着固体媒体 (铜线或光纤) 传播，而非导引型传输媒体是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。图 2-5 是电信领域使用的电磁波的频谱。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706092821.png"></li></ul><h2 id="2-3-1-导引型传输媒体"><a href="#2-3-1-导引型传输媒体" class="headerlink" title="2.3.1 导引型传输媒体"></a>2.3.1 导引型传输媒体</h2><ol><li><strong>双绞线</strong><ul><li>双绞线也称双扭线，把两根互相绝缘的铜导线并排放在一起，然后用规则的方法<strong>绞合</strong>就构成了双绞线。绞合可减少对相邻导线的电磁干扰。几乎所有的电话都用双绞线连接到电话交换机。从用户电话机到交换机的双绞线称为<strong>用户线</strong>或<strong>用户环路</strong>。</li><li>模拟传输和数字传输可以使用双绞线，通信距离一般为几到十几公里。距离太长时就要加放大器将衰减的信号放大到合适的数值 (对于模拟传输)，或者加上中继器对失真的数字信号进行整形 (对于数字传输)。导线越粗，其通信距离就越远，价格也越高。在数字传输时，若传输速率为每秒几个兆比特，则传输距离可达几公里。由于双绞线的价格便宜且性能也不错，因此使用十分广泛。</li><li>为了提高双绞线抗电磁干扰的能力，可在双绞线的外面加上一层用金属丝编织成的屏蔽层。这就是<strong>屏蔽双绞线</strong>，简称为 STP。它的价格比<strong>无屏蔽双绞线</strong> UTP 要高。图 2-6 是无屏蔽双绞线和屏蔽双绞线的示意图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706095419.png"></li></ol></li></ul></li><li><strong>同轴电缆</strong><ul><li>同轴电缆由内导体铜质芯线、绝缘层、网状编织的外导体屏蔽层以及保护塑料外层所组成 (图2-7)。由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230706095526.png"></li></ol></li></ul></li><li><strong>光缆</strong><ul><li>光纤通信就是利用光导纤维传递光脉冲来进行通信。有光脉冲相当于 1，没有光脉冲相当于 0。由于可见光的频率非常高，约为10<sup>8</sup> MHz 的量级，因此一个光纤通信系统的传输带宽大于目前其他各种传输媒体的带宽。</li><li>光纤是光纤通信的传输媒体。在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲的作用下能产生出光脉冲。在接收端利用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</li><li>光纤不仅具有通信容量大的优点，而且还有其他特点：<ol><li>传输损耗小，中继距离长，远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。这在有大电流脉冲干扰的环境下尤为重要。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。这在电缆管道拥塞不堪的情况下特别有利。</li></ol></li></ul></li></ol><h2 id="2-3-2-非导引型传输媒体"><a href="#2-3-2-非导引型传输媒体" class="headerlink" title="2.3.2 非导引型传输媒体"></a>2.3.2 非导引型传输媒体</h2><ol><li>短波通信 (高频通信) 靠电离层的反射。电离层的不稳定所产生的衰落现象和电离层反射所产生的多径效应，使得短波信道的通信质量较差。当必须使用短波无线电台传送数据时，一般是低速传输，即速率为一个标准模拟话路传几十至几百比特&#x2F;秒</li><li>无线电微波通信在数据通信中占有重要地位。微波在空间是直线传播。由于微波会穿透电离层进入宇宙空间，因此它不像短波那样可以经电离层反射传播到地面上很远的地方。传统的微波通信有两种，即<strong>地面微波接力通信</strong>和<strong>卫星通信</strong>。<ol><li>微波接力通信可传输电话、电报、图像、数据等信息。<ul><li>特点：<ol><li>微波波段频率高，频段范围宽，通信信道的容量大。</li><li>工业干扰和天电干扰的频谱成分比微波频率低得多，对微波通信的危害比对短波和米波 (即甚高频) 通信小，因而微波传输质量高。</li><li>与相同容量和长度的电缆载波通信比较，微波接力通信建设投资少，见效快，易于跨越山区、江河。</li></ol></li><li>缺点：<ol><li>相邻站之间必须直视 (常称为视距 LOS)，不能有障碍物。有时一个天线发射出的信号会分成几条略有差别的路径到达接收天线，因而造成失真。</li><li>微波的传播会受恶劣气候的影响。</li><li>与电缆通信系统比较，微波通信的隐蔽性和保密性差。</li><li>中继站的使用和维护要耗费较多的人力和物力。</li></ol></li></ul></li><li>卫星通信的特点是通信距离远，且通信费用与通信距离无关。<ul><li>和微波接力通信相似，卫星通信的频带宽，通信容量大，信号受到的干扰小，通信稳定。</li><li>卫星通信的另一特点是有<strong>较大的传播时延</strong> 。</li><li>“卫星信道的传播时延较大”不等于“用卫星信道传送数据的时延较大”。因为传送数据的总时延除了传播时延外，还有发送时延、处理时延和排队时延等。传播时延在总时延中所占的比例有多大，取决于具体情况。但利用卫星信道进行交互式的网上游戏显然是不合适的。</li><li>卫星通信适合于广播通信，因为它的覆盖面很广。从安全方面考虑，卫星通信系统的保密性则相对较差。</li><li>卫星通信的费用较高。</li></ul></li></ol></li></ol><h1 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h1><h2 id="2-4-1-频分复用、时分复用和统计时分复用"><a href="#2-4-1-频分复用、时分复用和统计时分复用" class="headerlink" title="2.4.1 频分复用、时分复用和统计时分复用"></a>2.4.1 频分复用、时分复用和统计时分复用</h2><ul><li>图 2-13(a) 表示 A<sub>1</sub>，B<sub>1</sub> 和 C<sub>1</sub> 分别使用一个单独的信道进行通信，总共需要三个信道。如果在发送端使用一个复用器，它们可以合起来使用一个共享信道进行通信。在接收端使用分用器，把合起来传输的信息分别送到相应的终点。图 2-13(b) 是复用的示意图。复用要付出代价。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707095902.png"></li></ol></li><li>最基本的复用就是<strong>频分复用</strong> (FDM) 和<strong>时分复用</strong> (TDM)。<ol><li><strong>频分复用</strong><ul><li>频分复用最简单，其特点如图 2-14(a) 所示。用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<strong>频分复用的所有用户在同样的时间占用不同的带宽资源</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707100801.png"></li><li>使用频分复用时，若每一个用户占用的带宽不变，则当复用的用户数增加时，复用后的信道的总带宽就跟着变宽。</li></ul></li><li><strong>时分复用</strong><ul><li>时分复用是将时间划分为一段段等长的时分复用帧 (TDM 帧)。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。在图 2-14(b) 中画出了 4 个用户 A，B，C 和 D。每一个用户所占用的时隙周期性地出现 (周期是 TDM 帧的长度）。因此 TDM 信号也称<strong>等时</strong>信号。<strong>时分复用的所有用户是在不同的时间占用同样的频带宽度</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230707100841.png"></li><li>使用时分复用时，每一个时分复用帧的长度是不变的，始终是 125µs。若有 1000 个用户进行时分复用，则每一个用户分配到的时隙宽度就是 125µs 的千分之一，即 0.125µs，时隙宽度变得非常窄。</li></ul></li><li>这两种复用方法的优点是技术成熟，缺点是不灵活。时分复用则更有利于数字信号的传输。</li></ol></li><li>在进行通信时，<strong>复用器</strong>总和<strong>分用器</strong>成对地使用。在复用器和分用器之间是用户共享的高速信道。分用器的作用和复用器相反，把高速信道传送过来的数据进行分用，分别送交到相应的用户。</li></ul><h2 id="2-4-2-波分复用"><a href="#2-4-2-波分复用" class="headerlink" title="2.4.2 波分复用"></a>2.4.2 波分复用</h2><ul><li><strong>波分复用</strong> (WDM) 就是<strong>光的频分复用</strong>。</li><li><strong>光复用器</strong>：波分复用的复用器又称为<strong>合波器</strong>。</li><li><strong>光分用器</strong>：波分复用的分用器又称为<strong>分波器</strong>。</li><li>光信号传输了一段距离后会衰减，对衰减了的光信号进行放大才能继续传输。</li><li><strong>掺铒光纤放大器</strong> (EDFA)。不需要进行光电转换直接对光信号进行放大。</li></ul><h2 id="2-4-3-码分复用"><a href="#2-4-3-码分复用" class="headerlink" title="2.4.3 码分复用"></a>2.4.3 码分复用</h2><ul><li><strong>码分复用</strong> (CDM) 是一种共享信道的方法。也叫作<strong>码分多址</strong> (CDMA)。每个用户可在同样的时间使用同样的频带进行通信。由于<strong>各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰</strong>。码分复用发送的信号有很强的抗干扰能力，<strong>其频谱类似于白噪声，不易被发现</strong>。采用 CDMA 可提高通信的话音质量和数据传输的可靠性，减少干扰对通信的影响，增大通信系统的容量，降低手机的平均发射功率。</li><li>在 CDMA 中，每个比特时间划分为 m 个短的间隔，称为<strong>码片</strong>。</li><li>使用 CDMA 的每个站被指派一个唯一的 m bit <strong>码片序列</strong>。一个站如果要发送比特 1，则发送它自己的 m bit 码片序列。如果要发送比特 0，则发送该码片序列的二进制反码。<ol><li>例如指派给 S 站的 8 bit 码片序列是 0001 1011。当 S 发送比特 1 时，它就发送序列 0001 1011，而当 S 发送比特 0 时，就发送 1110 0100。将码片中的 0 写为 – 1，将 1 写为＋1。因此 S 站的码片序列是 (–1 –1 –1＋1＋1 –1＋1＋1)。</li></ol></li><li>假定 S 站要发送信息的数据率为 b bit&#x2F;s。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit&#x2F;s，S 站所占用的频带宽度也提高到原来数值的 m 倍。这种通信方式是<strong>扩频</strong>通信中的一种。扩频通信有两类。<ol><li>一种是<strong>直接序列扩频</strong> (DSSS)，如码片序列。</li><li>另一种是<strong>跳频扩频</strong> (FHSS)。</li></ol></li><li>CDMA 系统的特点是这种体制给每个站分配的码片序列不仅必须各不相同，还必须互相<strong>正交</strong>。在实用的系统中使用<strong>伪随机码序列</strong>。</li><li>数学公式可清楚地表示码片序列的正交关系。令向量 <em><strong>S</strong></em> 表示站 S 的码片向量，再令 <em><strong>T</strong></em> 表示其他任何站的码片向量。两个不同站的码片序列正交，就是向量 <em><strong>S</strong></em> 和 <em><strong>T</strong></em> 的规格化<strong>内积</strong>都是 0：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230709160115.png"></li></ol></li><li>向量 <em><strong>S</strong></em> 为 (–1 –1 –1＋1＋1 –1＋1＋1)，同时设向量 <em><strong>T</strong></em> 为 (–1 –1＋1 –1＋1＋1＋1 –1)，相当于 T 站的码片序列为 00101110。将向量 <em><strong>S</strong></em> 和 <em><strong>T</strong></em> 的各分量值代入 (2-3) 式就可看出这两个码片序列是正交的。向量 <em><strong>S</strong></em> 和各站码片反码的向量的内积也是 0。任何一个码片向量和该码片向量自己的规格化内积都是 1。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230709160135.png"></li></ol></li></ul><h1 id="2-5-数字传输系统"><a href="#2-5-数字传输系统" class="headerlink" title="2.5 数字传输系统"></a>2.5 数字传输系统</h1><ul><li>早期的数字传输系统存在许多缺点，主要是以下两个：<ol><li><strong>速率标准不统一</strong>。多路复用的速率体系有两个互不兼容的国际标准，北美和日本的 T<sub>1</sub> 速率(1.544Mbit&#x2F;s) 和欧洲的 E<sub>1</sub> 速率 (2.048Mbit&#x2F;s)。</li><li><strong>不是同步传输</strong>。为了节约经费，各国的数字网主要采用<strong>准同步</strong>方式。在准同步系统中由于各支路信号的时钟频率有偏差，给时分复用和分用带来许多麻烦。当数据传输的速率很高时，收发双方的时钟同步就成大问题。</li></ol></li></ul><h1 id="2-6-宽带接入技术"><a href="#2-6-宽带接入技术" class="headerlink" title="2.6 宽带接入技术"></a>2.6 宽带接入技术</h1><h2 id="2-6-1-ADSL-技术"><a href="#2-6-1-ADSL-技术" class="headerlink" title="2.6.1 ADSL 技术"></a>2.6.1 ADSL 技术</h2><ul><li><strong>非对称数字用户线</strong> (ADSL) 技术是<strong>用数字技术对现有的模拟电话用户线进行改造</strong>，使它能承载宽带数字业务。    </li><li>ADSL 的传输距离取决于数据率和用户线的线径。ADSL 能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。<ol><li>用户线越细，信号传输时的衰减就越大。</li><li>传输速率越快，信号传输时的衰减就越大。</li></ol></li><li>基于ADSL 的接入网由三部分组成：<strong>数字用户线接入复用器</strong> DSLAM、用户线和用户家中的设施 (见图 2-20)。数字用户线接入复用器包括 ADSL 调制解调器。ADSL 调制解调器又称<strong>接入端接单元</strong> ATU。ADSL 调制解调器必须成对使用，因此把在电话端局 (或远端站) 和用户家中所用的 ADSL 调制解调器分别记为 ATU-C (C 代表<strong>端局</strong>) 和 ATU-R (R 代表<strong>远端</strong>)。用户电话通过电话<strong>分离器</strong>和 ATU-R 连在一起，经用户线到端局，并再经过电话分离器把电话连到本地电话交换机。电话分离器是无源的，它利用低通滤波器将电话信号与数字信号分开。将电话分离器做成无源的是为了在停电时不影响传统电话的使用。一个 DSLAM 可支持多达 500～1000 个用户。若按每户 6Mbit&#x2F;s 计算，则具有 1000 个端口的 DSLAM (这就需要用 1000 个 ATU-C) 应有高达 6Gbit&#x2F;s 的转发能力。ATU-C 要使用数字信号处理技术，因此 DSLAM 的价格较高。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230710170833.png"></li></ol></li><li>第二代 ADSL 改进的地方是：<ol><li>提高调制效率得到更高的数据率。</li><li>采用<strong>无缝速率自适应</strong>技术 (SRA)，可在运营中不中断通信和不产生误码的情况下，根据线路的实时状况，自适应地调整数据率。</li><li>改善线路质量评测和故障定位功能，对提高网络的运行维护水平具有重要意义。</li></ol></li></ul><h2 id="2-6-2-光纤同轴混合网-HFC-网"><a href="#2-6-2-光纤同轴混合网-HFC-网" class="headerlink" title="2.6.2 光纤同轴混合网 (HFC 网)"></a>2.6.2 光纤同轴混合网 (HFC 网)</h2><ul><li><strong>光纤同轴混合网</strong> (HFC 网) 是在目前覆盖面很广的有线电视网的基础上开发的一种居民宽带接入网，除可传送电视节目外，还提供电话、数据和其他宽带交互型业务。</li><li>光纤同轴混合网 HFC 的特点：<ol><li>为提高传输的可靠性和电视信号的质量，HFC 网把原有线电视网中的同轴电缆主干部分改换为光纤 (图 2-23)。光纤从头端连接到<strong>光纤结点</strong>。在光纤结点光信号转换为电信号，然后通过同轴电缆传送到用户家庭。从头端到用户家庭所需的放大器数目减少到 4～5 个。连接到一个光纤结点的典型用户数是 500 左右，不超过 2000。</li><li>HFC 网具有双向传输功能，扩展了传输频带。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230710172306.png"></li></ol></li><li>使模拟电视机能接收数字电视信号，需要把<strong>机顶盒</strong>连接在同轴电缆和用户的电视机之间。为了使用户能够利用 HFC 网接入到互联网，以及在上行信道中传送交互数字电视所需的一些信息，还需要增加一个为 HFC 网使用的调制解调器，它又称为<strong>电缆调制解调器</strong>。</li></ul><h2 id="2-6-3-FTTx-技术"><a href="#2-6-3-FTTx-技术" class="headerlink" title="2.6.3 FTTx 技术"></a>2.6.3 FTTx 技术</h2><ul><li>为了更快地下载视频文件，更流畅地欣赏网上的高清视频节目，尽快地把用户的上网速率进行升级就成为 ISP 的重要任务，<strong>光纤到户</strong> (FTTH) 是最好的选择。</li><li>光纤到户 FTTH 有两个问题：<ol><li>价格不便宜</li><li>一般的家庭用户不需要过高的数据率的需求</li></ol></li><li>为了有效地利用光纤资源，在光纤干线和用户间，需要铺设一段中间的转换装置<strong>光配线网</strong> (ODN)，使数十个家庭用户能够共享一根光纤干线。</li><li>图 2-25 是广泛使用的无源光配线网的示意图。“无源”表明在光配线网中无须配备电源，基本上不用维护，其长期运营成本和管理成本很低。无源的光配线网常称为<strong>无源光网络</strong> (PON)。<ol><li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network%7B419185F1-78FE-4077-9766-E3333D89BF52%7D.png"></li><li>在图 2-25 中，<strong>光线路终端</strong> OLT 是连接到光纤干线的终端设备。OLT 把收到的下行数据发往无源的 1：N <strong>光分路器</strong>，然后用广播方式向所有用户端的<strong>光网络单元</strong> ONU发送。</li><li>当 ONU 发送上行数据时，先把电信号转换为光信号，光分路器把各 ONU 发来的上行数据汇总后，以 TDMA 方式发往 OLT，而发送时间和长度都由 OLT 集中控制，以便有序地共享光纤主干。</li><li>无源光网络 PON 的种类很多，流行的有以下两种：<ul><li>以太网无源光网络 (EPON)，在链路层使用以太网协议，利用 PON 的拓扑结构实现了以太网的接入。EPON 的优点是：与现有以太网的兼容性好，并且成本低，扩展性强，管理方便。</li><li>吉比特无源光网络 (GPON)，GPON 采用<strong>通用封装方法</strong> (GEM)，可承载多业务，对各种业务类型都能够提供服务质量保证，是很有潜力的宽带光纤接入技术。</li></ul></li></ol></li><li>现在已有很多种不同的 FTTx。除了光纤到户 FTTH 外，还有<strong>光纤到路边</strong> FTTC (C 表示 Curb)、<strong>光纤到小区</strong> FTTZ (Z 表示 Zone)、<strong>光纤到大楼</strong> FTTB (B 表示 Building)、<strong>光纤到楼层</strong> FTTF (F 表示Floor)、<strong>光纤到办公室</strong> FTTO (O 表示 Office)、<strong>光纤到桌面</strong> FTTD (D 表示 Desk)，等等。</li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>物理层的任务是确定与传输媒体的接口有关的一些特性，如机械特性、电气特性、功能特性和过程特性。</p></li><li><p>一个数据通信系统可划分为三部分，即源系统、传输系统和目的系统。源系统包括源点 (或源站、信源) 和发送器，目的系统包括接收器和终点 (或目的站，或信宿)。</p></li><li><p>通信的目的是传送消息。如话音、文字、图像、视频等。数据是运送消息的实体。信号则是数据的电气或电磁的表现。</p></li><li><p>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号 (连续信号) 和数字信号 (离散信号)。代表数字信号不同离散数值的基本波形称为码元。</p></li><li><p>根据双方信息交互的方式，通信划分为单向通信 (单工通信)、双向交替通信 (半双工通信) 和双向同时通信 (全双工通信)。</p></li><li><p>来自信源的信号叫基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅、调频和调相。还有更复杂的调制方法，如正交振幅调制。</p></li><li><p>要提高数据在信道上的传输速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能被任意地提高。</p></li><li><p>传输媒体分为两类，即导引型传输媒体 (双绞线、同轴电缆或光纤) 和非导引型传输媒体 (无线或红外或大气激光)。</p></li><li><p>常用的信道复用技术有频分复用、时分复用、统计时分复用、码分复用和波分复用 (光的频分复用)。</p></li><li><p>最初在数字传输系统中使用的传输标准是脉冲编码调制 PCM。现在高速的数字传输系统使用同步光纤网 SONET (美国标准) 或同步数字系列 SDH (国际标准)。</p></li><li><p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL (用数字技术对现有的模拟电话用户线进行改造)、光纤同轴混合网 HFC (在有线电视网的基础上开发的) 和 FTTx。</p></li><li><p>为了有效地利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无须配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</p></li><li><p>为什么要使用信道复用技术?常用的信道复用技术有哪些？</p><blockquote><p>许多用户通过复用技术就可以共同使用一个共享信道来进行通信。虽然复用要付出一定代价 (共享信道由于带宽较大因而费用也较高,再加上复用器和分用器也要增加成本) 但如果复用的信道数量较大，那么总的来看在经济上还是合算的。<br>常用的复用技术有: 频分复用、时分复用 (包括统计时分复用)、波分复用 (包括密集波分复用和稀疏波分复用) 和码分复用 (即码分多址)。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运输层</title>
      <link href="/2023/12/09/yun-shu-ceng/"/>
      <url>/2023/12/09/yun-shu-ceng/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-运输层协议概述"><a href="#5-1-运输层协议概述" class="headerlink" title="5.1 运输层协议概述"></a>5.1 运输层协议概述</h1><h2 id="5-1-1-进程之间的通信"><a href="#5-1-1-进程之间的通信" class="headerlink" title="5.1.1 进程之间的通信"></a>5.1.1 进程之间的通信</h2><ul><li><strong>运输层向应用层提供通信服务</strong>，属于面向通信部分的最高层、用户功能中的最低层。当网络边缘部分中的两台主机使用网络核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时只用到下三层的功能。</li><li>进行通信的实体是主机中的进程，是主机中的一个<strong>进程</strong>和另一台主机中的一个<strong>进程</strong>交换数据。两台主机进行通信就是两台主机中的<strong>应用进程互相通信</strong>。IP 协议虽然能把分组送到目的主机，但是分组还停留在主机的网络层，没有交付主机中的应用进程。从运输层的角度看，<strong>通信的真正端点不是主机，而是主机中的进程</strong>。<strong>端到端的通信</strong>是应用进程之间的通信。</li><li>运输层有个重要功能：<strong>复用</strong>和<strong>分用</strong>。复用指在<strong>发送方</strong>不同的应用进程可以使用同一个运输层协议传送数据，分用指<strong>接收方</strong>的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</li><li><strong>运输层提供应用进程间的逻辑通信</strong>。逻辑通信的意思是：从应用层来看，只要把应用层报文交给运输层，运输层就可以把这报文传送到对方的运输层，<strong>好像这种通信就是沿水平方向直接传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接</strong>。</li><li><strong>网络层为主机之间提供逻辑通信，运输层为应用进程之间提供端到端的逻辑通信</strong>。</li><li>根据应用程序的不同需求，运输层有不同的运输协议，即<strong>面向连接的 TCP</strong> 和<strong>无连接的 UDP</strong>。</li><li><strong>运输层向高层用户屏蔽了下面网络核心的细节，使应用进程看见的是，好像在两个运输层实体之间有一条端到端的逻辑通信信道</strong>。当运输层<strong>采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的</strong>，但这种逻辑通信信道就相当于<strong>一条全双工的可靠信道</strong>。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条<strong>不可靠信道</strong>。</li></ul><h2 id="5-1-2-运输层的两个主要协议"><a href="#5-1-2-运输层的两个主要协议" class="headerlink" title="5.1.2 运输层的两个主要协议"></a>5.1.2 运输层的两个主要协议</h2><ul><li>TCP&#x2F;IP 运输层的两个主要协议即：<ol><li><strong>用户数据报协议</strong> UDP</li><li><strong>传输控制协议</strong> TCP</li></ol></li><li>图 5-3 给出了这两种协议在协议栈中的位置。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807163232.png"></li></ol></li><li>在 TCP&#x2F;IP 体系中，根据所使用的协议是 TCP 或 UDP，分别称之为 <strong>TCP 报文段</strong>或 <strong>UDP 用户数据报</strong></li><li>UDP 在传送数据之前<strong>不需要先建立连接</strong>。远地主机的运输层在收到 UDP 报文后，不需要回复。即使不提供可靠交付，但在某些情况下 UDP 仍是一种有效的工作方式。</li><li>TCP <strong>提供面向连接的服务</strong>。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此增加许多开销。使得协议数据单元的首部增大很多，占用许多的处理机资源。</li><li>表 5-1 给出了一些应用和应用层协议主要使用的运输层协议 (UDP 或 TCP)。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807163339.png"></li></ol></li></ul><h2 id="5-1-3-运输层的端口"><a href="#5-1-3-运输层的端口" class="headerlink" title="5.1.3 运输层的端口"></a>5.1.3 运输层的端口</h2><ul><li><strong>复用</strong>：应用层的应用进程数据可以通过运输层再传送到网络层 (IP 层)。<strong>分用</strong>：运输层从网络层收到发送给各应用进程的数据后，必须分别交付指明的各应用进程。</li><li>进程的创建和撤销是动态的，通信的一方几乎无法识别对方机器上的进程。需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程是哪一个。</li><li>通信的终点是应用进程，只要把需要传送的报文交到目的主机某个合适的目的端口，剩下的工作就由 TCP 或 UDP 来完成。</li><li><strong>在协议栈层间的抽象的协议端口是软件端口</strong>。硬件端口是<strong>不同硬件设备</strong>进行交互的接口，而<strong>软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址</strong>。</li><li>当运输层收到 IP 层交上来的运输层报文时，能够根据首部中的目的端口号把数据交付应用层的目的应用进程。</li><li><strong>端口号只具有本地意义</strong>，是为了标志<strong>本计算机</strong>应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是<strong>没有关联</strong>的。</li><li>两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址 (为了找到对方的计算机)，而且要知道对方的端口号 (为了找到对方计算机中的应用进程)。</li><li>运输层的端口号分为下面的两大类：<ol><li><strong>服务器端使用的端口号</strong> 　<ul><li>最重要的一类叫<strong>熟知端口号</strong>或<strong>系统端口号</strong>。IANA 把这些端口号指派给了 TCP&#x2F;IP 最重要的一些应用程序，让所有的用户都知道。当一种新的应用程序出现后，IANA 必须为它指派一个熟知端口，否则互联网上的其他应用进程就无法和它进行通信；</li><li>另一类叫做<strong>登记端口</strong>号。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在 IANA 按照规定的手续登记，以防止重复。</li></ul></li><li><strong>客户端使用的端口号</strong> 　这类端口号仅在客户进程运行时才动态选择，又叫<strong>短暂端口号</strong>。这类端口号留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已使用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。</li></ol></li></ul><h1 id="5-2-用户数据报协议-UDP"><a href="#5-2-用户数据报协议-UDP" class="headerlink" title="5.2 用户数据报协议 UDP"></a>5.2 用户数据报协议 UDP</h1><h2 id="5-2-1-UDP-概述"><a href="#5-2-1-UDP-概述" class="headerlink" title="5.2.1 UDP 概述"></a>5.2.1 UDP 概述</h2><ul><li>用户数据报协议 UDP 在 IP 的数据报服务之上增加了复用、分用以及差错检测的功能。UDP 的主要特点是：<ol><li>UDP 是<strong>无连接的</strong>，即发送数据之前不需要建立连接，减少了开销和发送数据之前的时延。</li><li>UDP 使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li><li>UDP <strong>面向报文</strong>。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文，如图 5-4 所示。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。UDP 一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，会降低 IP 层的效率。若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，降低了 IP 层的效率。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181018.png"></li></ul></li><li>UDP <strong>没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用 (如 IP 电话、实时视频会议等) 要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但不允许数据有太大的时延。</li><li>UDP <strong>支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li>UDP <strong>的首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</li></ol></li></ul><h2 id="5-2-2-UDP-的首部格式"><a href="#5-2-2-UDP-的首部格式" class="headerlink" title="5.2.2 UDP 的首部格式"></a>5.2.2 UDP 的首部格式</h2><ul><li>用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段很简单，只有 8 个字节 (图 5-5)，由四个字段组成，<strong>每个字段的长度都是两字节</strong> 。各字段意义如下：<ol><li><strong>源端口</strong> 　源端口号。在需要对方回信时选用。不需要时可用全 0。</li><li><strong>目的端口</strong> 　目的端口号。这在终点交付报文时必须使用。</li><li><strong>长度</strong> 　UDP 用户数据报的长度，其最小值是 8 (仅有首部)。</li><li><strong>检验和</strong> 　检测 UDP 用户数据报在传输中是否有错。有错就丢弃。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181355.png"></li></ol></li><li>当运输层从 IP 层收到 UDP 数据报时，根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程。图 5-6 是 UDP 基于端口分用的示意图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181414.png"></li></ol></li><li>如果接收方 UDP 发现收到的报文中的目的端口号不正确，就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。</li><li>虽然在 UDP 之间的通信要用到端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字 (TCP 之间的通信必须要在两个套接字之间建立连接)。</li><li>UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。但 IP 数据报的检验和只检验 IP 数据报的首部，UDP 的检验和是<strong>把首部和数据部分一起都检验</strong>。在发送方，首先把全零放入检验和字段。再把伪首部以及 UDP 用户数据报看成是由许多 16 位的字串接起来的。若 UDP 用户数据报的数据部分不是偶数个字节，则要填入一个全零字节 (但此字节不发送)。然后按二进制反码计算出这些 16 位字的和。将此和的二进制反码写入检验和字段后，就发送这样的 UDP 用户数据报。在接收方，把收到的 UDP 用户数据报连同伪首部 (以及可能的填充全零字节) 一起，按二进制反码求这些 16 位字的和。当无差错时其结果应为全 1。否则就表明有差错出现，接收方就应丢弃这个 UDP 用户数据报 (也可以上交给应用层，但附上出现了差错的警告)。图 5-7 给出了一个计算 UDP 检验和的例子。这里假定用户数据报的长度是 15 字节，因此要添加一个全 0 的字节。这种简单的差错检验方法的检错能力并不强，但它的好处是简单，处理起来较快。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807181600.png"></li></ol></li></ul><h1 id="5-3-传输控制协议-TCP-概述"><a href="#5-3-传输控制协议-TCP-概述" class="headerlink" title="5.3 传输控制协议 TCP 概述"></a>5.3 传输控制协议 TCP 概述</h1><h2 id="5-3-1-TCP-最主要的特点"><a href="#5-3-1-TCP-最主要的特点" class="headerlink" title="5.3.1 TCP 最主要的特点"></a>5.3.1 TCP 最主要的特点</h2><ul><li>TCP 的主要特点：<ol><li>TCP 是<strong>面向连接的运输层协议</strong>。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。</li><li>每一条 TCP 连接只能有两个端点，只能是点对点的 (一对一)。</li><li>TCP 提供<strong>可靠交付</strong>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。</li><li>TCP 提供<strong>全双工通信</strong>。允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序只需要把数据传送给 TCP 的缓存，TCP 把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层的应用进程读取缓存中的数据。</li><li><strong>面向字节流</strong>。TCP 中的“流”指的是<strong>流入到进程或从进程流出的字节序列</strong>。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块 (大小不等)，但 TCP 把应用程序交下来的数据仅仅看成一连串的<strong>无结构的字节流</strong>。并不知道所传送的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。</li></ol></li><li>TCP 和 UDP 在发送报文时采用的方式不同。TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段包含多少个字节 (UDP 发送的报文长度是应用进程给出的)。如果应用进程传送到 TCP 缓存的数据块太长，TCP 就把它划分短一些再传送。如果应用进程一次只发来一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</li></ul><h2 id="5-3-2-TCP-的连接"><a href="#5-3-2-TCP-的连接" class="headerlink" title="5.3.2 TCP 的连接"></a>5.3.2 TCP 的连接</h2><ul><li>TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是运输层的协议端口，而是<strong>套接字</strong>或<strong>插口</strong>。</li><li><strong>每一条 TCP 连接唯一地被通信两端的两个端点 (即两个套接字) 所确定</strong>。即：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230807210504.png"></li><li>IP<sub>1</sub> 和 IP<sub>2</sub> 分别是两个端点主机的 IP 地址，而 port<sub>1</sub> 和 port<sub>2</sub> 分别是两个端点主机中的端口号。TCP 连接的两个套接字就是 socket<sub>1</sub> 和 socket<sub>2</sub>。</li></ol></li><li><strong>TCP 连接的端点是个抽象的套接字</strong>，即 (<strong>IP地址：端口号</strong> )。同一个 IP 地址可以有多个不同的 TCP 连接，同一个端口号也可以出现在多个不同的 TCP 连接中。</li><li><strong>socket 表示多种不同的意思</strong>。例如：<ol><li>允许应用程序访问连网协议的应<strong>用编程接口 API</strong>，即运输层和应用层之间的一种接口，称为 socket API，并简称为 socket。</li><li>在 socket API 中使用的一个<strong>函数名</strong>也叫做 socket。</li><li>调用 socket 函数的<strong>端点</strong>称为 socket，如“创建一个数据报 socket”。</li><li>调用 socket 函数时，其<strong>返回值</strong>称为 socket 描述符，可简称为 socket。</li><li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket <strong>实现</strong>。</li></ol></li></ul><h1 id="5-4-可靠传输的工作原理"><a href="#5-4-可靠传输的工作原理" class="headerlink" title="5.4 可靠传输的工作原理"></a>5.4 可靠传输的工作原理</h1><ul><li>理想的传输条件有以下特点：<ol><li>传输信道不产生差错。</li><li>接收方总是来得及处理收到的数据。</li></ol></li></ul><h2 id="5-4-1-停止等待协议"><a href="#5-4-1-停止等待协议" class="headerlink" title="5.4.1 停止等待协议"></a>5.4.1 停止等待协议</h2><ul><li><strong>无差错情况</strong><ol><li>停止等待协议可用图 5-9 来说明。图 5-9(a) 是最简单的无差错情况。A 发送分组 M<sub>1</sub> ，发完暂停，等待 B 确认。B 收到了 M<sub>1</sub> 就向 A 发送确认。A 在收到了对确认后，就再发送下一个分组 M<sub>2</sub>。同样，在收到 B 确认后，再发送M<sub>3</sub>。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808145722.png"></li></ul></li></ol></li><li><strong>出现差错</strong><ol><li>图 5-9(b) 是分组在传输过程中出现差错的情况。B 接收 M<sub>1</sub> 时检测出了差错，丢弃 M<sub>1</sub>，其他什么也不做。这种情况下，B 不会发送任何信息。可靠传输协议是这样设计的：A 只要超过了一段时间没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫做<strong>超时重传</strong>。要实现超时重传，就要在每发送完一个分组时设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</li><li>注意以下三点。<ul><li>A 在发送完一个分组后，<strong>必须保留已发送的分组的副本</strong>。只有在收到相应的确认后才能清除保留的分组副本。</li><li>分组和确认分组都必须进行**编号。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li><li>超时计时器设置的重传时间<strong>应当比数据在分组传输的平均往返时间更长一些</strong>。图 5-9(b) 中的一段虚线表示如果 M<sub>1</sub> 正确到达 B 同时 A 也正确收到确认的过程。重传时间应设定为比平均往返时间更长一些。如果重传时间设定得很长，那么通信的效率会很低。但如果重传时间设定得太短，以致产生不必要的重传，就浪费了网络资源。然而，在运输层重传时间的准确设定是非常复杂的，这是因为已发送出的分组到底会<strong>经过哪些网络</strong>，以及这些网络将会<strong>产生多大的时延</strong> (这取决于这些网络<strong>当时的拥塞情况</strong>)，这些都是<strong>不确定因素</strong>。</li></ul></li></ol></li><li><strong>确认丢失和确认迟到</strong><ol><li>图 5-10(a) 说明的是另一种情况。B 所发送的对 M<sub>1</sub> 的确认丢失了。A 在设定的超时重传时间内没有收到确认，无法知道是自己发送的分组出错、丢失，或者是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M<sub>1</sub>。假定 B 又收到了重传的分组 M<sub>1</sub><ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150213.png"></li></ul></li><li>这时应采取两个行动：<ul><li><strong>丢弃这个重复的分组</strong> M<sub>1</sub>，不向上层交付。</li><li><strong>向 A 发送确认</strong>。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M<sub>1</sub> 就表示 A 没有收到对 M<sub>1</sub> 的确认。</li></ul></li><li>图 5-10(b) 也是一种可能出现的情况。传输过程中没有出现差错，但 B 对分组 M<sub>1</sub> 的确认迟到了。A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。B 仍然会收到重复的 M<sub>1</sub> ，并且同样要丢弃重复的 M<sub>1</sub>，并重传确认分组。</li></ol></li><li><strong>信道利用率</strong><ol><li>停止等待协议的优点是简单，缺点是信道利用率太低。可以用图 5-11 来说明这个问题。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150800.png"></li></ul></li><li>假定 A 发送分组需要的时间是 T<sub>D</sub>。T<sub>D</sub> 等于分组长度除以数据率。再假定分组正确到达 B 后，B 处理分组的时间忽略不计，同时立即发回确认。假定 B 发送确认分组需要时间 T<sub>A</sub>。如果 A 处理确认分组的时间也忽略不计，那么 A 在经过时间 (T<sub>D</sub>＋RTT＋T<sub>A</sub>) 后就可以再发送下一个分组，这里的 RTT 是往返时间。因为仅仅是在时间 T<sub>D</sub> 内才用来传送有用的数据 (包括分组的首部)，因此信道的利用率 U 可用下式计算：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808150820.png"></li></ul></li><li>为了提高传输效率，发送方不使用低效率的停止等待协议，采用<strong>流水线传输</strong> (如图 5-12 所示)。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。这种传输方式可以获得很高的信道利用率。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151106.png"></li></ul></li></ol></li></ul><h2 id="5-4-2-连续-ARQ-协议"><a href="#5-4-2-连续-ARQ-协议" class="headerlink" title="5.4.2 连续 ARQ 协议"></a>5.4.2 连续 ARQ 协议</h2><ul><li>图 5-13(a) 表示发送方维持的<strong>发送窗口</strong>，表示位于发送窗口内的 5 个分组可连续发送出去，不需要等待对方的确认。提高了信道利用率。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151146.png"></li></ol></li><li>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。图 5-13(b) 表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。</li><li>接收方采用<strong>累积确认</strong>的方式，<strong>对按序到达的最后一个分组发送确认</strong>。</li><li>累积确认有优点也有缺点：<ol><li>优点是容易实现，即使确认丢失也不必重传。</li><li>缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。</li></ol></li></ul><h1 id="5-5-TCP-报文段的首部格式"><a href="#5-5-TCP-报文段的首部格式" class="headerlink" title="5.5 TCP 报文段的首部格式"></a>5.5 TCP 报文段的首部格式</h1><ul><li>TCP 面向字节流，但 TCP 传送的数据单元却是报文段。</li><li>一个 TCP 报文段分为首部和数据两部分。</li><li>TCP 报文段首部的前 20 个字节是固定的 (图 5-14)，后面有 4<em>n</em> 字节是根据需要而增加的选项。因此 TCP 首部的最小长度是 20 字节。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808151426.png"></li></ol></li><li>首部固定部分各字段的意义如下：<ol><li><strong>源端口和目的端口</strong> 　各占 2 个字节，分别写入源端口号和目的端口号。</li><li><strong>序号</strong> 　占 4 字节。序号范围是［0，2<sup>32</sup>–1］，共 2<sup>32</sup> (即4 294 967 296) 个序号。序号增加到 2<sup>32</sup>–1 后，下一个序号就又回到 0。使用 mod 2<sup>32</sup> 运算。在一个 TCP 连接中传送的字节流中的<strong>每一个字节都按顺序编号</strong>。整个要传送的字节流的起始序号在连接建立时设置。首部中的序号字段值则指的是<strong>本报文段</strong>所发送的数据的第一个字节的序号。例如，一报文段的序号字段值是 301，而携带的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。字段的名称也叫做“<strong>报文段序号</strong>”。</li><li><strong>确认号</strong> 　占 4 字节，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。例如，B 收到 A 发来的一个报文段，其序号字段值是 501，而数据长度是 200 字节 (序号 501～700)，这表明 B 收到到序号 700 为止的数据。因此，B 期望收到的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。若确认号＝<em>N</em>，则表明：到序号 <em>N</em>–1 为止的所有数据都已正确收到。</li><li><strong>数据偏移</strong> 　占 4 位，指出 TCP 报文段的首部长度。“数据偏移”的单位是 4 字节 (即以 32 位字为计算单位)。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度 (即选项长度不能超过 40 字节)。</li><li><strong>保留</strong> 　占 6 位，保留为今后使用，但目前应置为 0。</li><li><strong>紧急</strong> URG　当 URG＝1 时，紧急指针字段有效，发送应用进程告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。这时要与首部中<strong>紧急指针</strong>字段配合使用。</li><li><strong>确认</strong> ACK　当 ACK＝1 时确认号字段有效。当 ACK＝0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li>(x) <strong>推送</strong> PSH　当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 使用推送操作。这时，发送方 TCP 把 PSH 置 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH＝1 的报文段，就尽快地交付接收应用进程，不再等到整个缓存都填满了后再向上交付。</li><li><strong>复位</strong> RST　当 RST＝1 时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接。RST 置 1 还用来拒绝一个非法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位。</li><li><strong>同步</strong> SYN　在连接建立时用来同步序号。当 SYN＝1 而 ACK＝0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使  SYN＝1 和 ACK＝1。因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。</li><li><strong>终止</strong> FIN　用来释放一个连接。当 FIN＝1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</li><li><strong>窗口</strong> 　占 2 字节。窗口值是［0，2<sup>16</sup>–1］之间的整数。窗口指的是发送本报文段的一方的<strong>接收窗口</strong>。窗口值<strong>告诉对方</strong> ：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量 (以字节为单位)。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。<strong>窗口值作为接收方让发送方设置其发送窗口的依据</strong>。窗口字段明确指出了现在允许对方发送的数据量，经常动态变化。</li><li>(x) <strong>检验和</strong> 　占 2 字节。检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式与图 5-5 中 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的17 改为 6（TCP 的协议号是 6），把第 5 字段中的 UDP 长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。</li><li>(x) <strong>紧急指针</strong> 　占 2 字节。紧急指针仅在 URG＝1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。</li><li><strong>选项</strong> 　长度可变，最长可达 40 字节。</li></ol></li><li>TCP 最初只规定了一种选项，即<strong>最大报文段长度</strong> MSS。MSS 是每一个 TCP 报文段中的<strong>数据字段的最大长度</strong>。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以 MSS 并不是整个 TCP 报文段的最大长度，而是“TCP 报文段长度减去 TCP 首部长度”。</li><li>随着互联网的发展，又增加了<strong>窗口扩大</strong>选项、<strong>时间戳</strong>选项、<strong>选择确认</strong>选项。<ol><li>窗口扩大选项<ul><li>窗口扩大选项是为了扩大窗口。TCP 首部中窗口字段长度是 16 位，因此最大的窗口大小为 64K 字节。</li><li>窗口扩大选项占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于 TCP 首部中的窗口位数从 16 增大到 (16＋S) 。移位值允许使用的最大值是 14，相当于窗口最大值增大到 2<sup>(16+14)</sup>–1＝2<sup>30</sup> –1。</li><li>窗口扩大选项可以在双方初始建立 TCP 连接时进行协商。如果接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送 S＝0 的选项，使窗口大小回到 16。</li></ul></li><li>时间戳选项<ul><li><strong>时间戳</strong>选项占 10 字节，最主要的字段是<strong>时间戳</strong>值字段 (4 字节) 和<strong>时间戳回送回答</strong>字段 (4 字节)。时间戳选项有以下两个功能：<ol><li>用来计算往返时间 RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出 RTT 来。</li><li>用于处理 TCP 序号超过 2<sup>32</sup> 的情况，又称<strong>防止序号绕回</strong> PAWS。TCP 报文段的序号只有 32 位，而每增加 2<sup>32</sup> 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次 TCP 连接的数据传送中序号很可能会被重复使用。</li></ol></li></ul></li></ol></li></ul><h1 id="5-6-TCP-可靠传输的实现"><a href="#5-6-TCP-可靠传输的实现" class="headerlink" title="5.6 TCP 可靠传输的实现"></a>5.6 TCP 可靠传输的实现</h1><h2 id="5-6-1-以字节为单位的滑动窗口"><a href="#5-6-1-以字节为单位的滑动窗口" class="headerlink" title="5.6.1 以字节为单位的滑动窗口"></a>5.6.1 以字节为单位的滑动窗口</h2><ul><li>TCP 的滑动窗口以字节为单位。假定 A 收到了 B <strong>发来</strong>的确认报文段，其中窗口是 20 字节，而确认号是 31 (这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了)。根据这两个数据，A 就构造出自己的发送窗口，如图 5-15 所示。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808160923.png"></li></ol></li><li>A 发送窗口表示：在没有收到 B 的确认的情况下，A 可以把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。</li><li>发送窗口里面的序号表示允许发送的序号。窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，获得更高的传输效率。接收方会把自己的接收窗口数值放在窗口字段中发送给对方，A 的发送窗口一定不能超过 B 的接收窗口数值。</li><li>发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据不需要保留。而发送窗口前沿的前面部分表示不允许发送的，因为接收方没有为这部分数据保留临时存放的缓存空间。</li><li>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动 (没有收到新的确认) 和前移 (收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：一是没有收到新的确认，对方通知的窗口大小也不变；二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。</li><li>发送窗口前沿也有可能<strong>向后收缩</strong>。这发生在接收方的接收窗口缩小了。但 TCP 的标准<strong>强烈不赞成这样做</strong>。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。</li><li>发送方的应用进程把字节流写入 TCP 的发送缓存，接收方的应用进程从 TCP 的接收缓存中读取字节流。图 5-19 画出了发送方维持的发送缓存和发送窗口，以及接收方维持的接收缓存和接收窗口。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808161130.png"></li><li>图 5-19(a) 所示的发送方的情况，发送缓存用来暂时存放：<ul><li>发送应用程序传送给发送方 TCP 准备发送的数据</li><li>TCP 已发送出但尚未收到确认的数据</li></ul></li><li>图 5-19(b) 所示的接收方的情况，接收缓存用来暂时存放：<ul><li>按序到达的、但尚未被接收应用程序读取的数据</li><li>未按序到达的数据。</li></ul></li></ol></li><li>强调以下三点：<ol><li>虽然 A 的发送窗口是根据 B 的接收窗口设置的，但在同一时刻，A 的发送窗口并不总是和 B 的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后。</li><li>对于不按序到达的数据如何处理，TCP 标准并无明确规定。如果接收方把不按序到达的数据丢弃，那么接收窗口的管理会比较简单，但这样做对网络资源的利用不利。因此 TCP 通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<strong>按序交付上层的应用进程</strong>。</li><li>TCP 要求接收方必须有累积确认的功能，减小传输开销。接收方可以在合适时发送确认，也可以在自己有数据要发送时把确认信息顺便<strong>捎带</strong>上。注意两点。一是接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须每隔一个报文段就发送一个确认。二是捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。</li></ol></li><li>TCP 的通信是全双工通信。通信中的每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接收窗口。</li></ul><h2 id="5-6-2-超时重传时间的选择"><a href="#5-6-2-超时重传时间的选择" class="headerlink" title="5.6.2 超时重传时间的选择"></a>5.6.2 超时重传时间的选择</h2><ul><li>由于 TCP 的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个 IP 数据报所选择的路由可能不同。如果把超时重传时间设置得太短，会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得过长，则使网络的空闲时间增大，降低了传输效率。</li><li>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。两个时间之差就是<strong>报文段的往返时间 RTT</strong>。TCP 保留了 RTT 的一个<strong>加权平均往返时间</strong> RTT<sub>S</sub> (又称为平滑的往返时间，S 表示 Smoothed)。每当第一次测量到 RTT 样本时，RTT<sub>S</sub> 值就取为所测量到的 RTT 样本值。但以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTT<sub>S</sub>：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162046.png"></li></ol></li><li>在上式中，0≤α&lt;1。若 α 很接近于零，表示新的 RTT<sub>S</sub> 值和旧的 RTT<sub>S</sub> 值相比变化不大，而对新的 RTT 样本影响不大 (RTT 值更新较慢)。若选择 α 接近于 1，则表示新的 RTT<sub>S</sub> 值受新的 RTT 样本的影响较大 (RTT 值更新较快)。</li><li>超时计时器设置的<strong>超时重传时间</strong> RTO 应略大于上面得出的加权平均往返时间 RTT<sub>S</sub> 。RFC 6298 建议使用下式计算 RTO：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162104.png"></li></ol></li><li>RTT<sub>D</sub> 是 RTT 的<strong>偏差</strong>的加权平均值，它与 RTT<sub>S</sub> 和新的 RTT 样本之差有关。RFC 6298 建议这样计算 RTT<sub>D</sub>。当第一次测量时，RTT<sub>D</sub> 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTT<sub>D</sub>：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162116.png"></li></ol></li><li>如图 5-20 所示，发送出一个报文段，设定的重传时间到了，还没有收到确认。于是重传报文段。经过了一段时间后，收到了确认报文段。现在的问题是：<strong>如何判定此确认报文段是对先发送的报文段的确认，还是对后来重传的报文段的确认</strong>。由于重传的报文段和原来的报文段完全一样，因此源主机在收到确认后，就无法做出正确的判断，而正确的判断对确定加权平均 RTT<sub>S</sub> 的值关系很大。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162135.png"></li><li>若收到的确认是对重传报文段的确认，却被源主机当成是对原来的报文段的确认，则这样计算出的 RTT<sub>S</sub> 和超时重传时间 RTO 就会偏大。若后面再发送的报文段又是经过重传后才收到确认报文段，则按此方法得出的超时重传时间 RTO 就越来越长；同样，若收到的确认是对原来的报文段的确认，但被当成是对重传报文段的确认，则由此计算出的RTT<sub>S</sub> 和 RTO 都会偏小。这就必然导致报文段过多地重传使，RTO 越来越短。</li><li>Karn 提出了一个算法：<strong>在计算加权平均 RTT<sub>S</sub> 时，只要报文段重传了，就不采用其往返时间样本。这样得出的加权平均 RTT<sub>S</sub> 和 RTO 就较准确</strong>。</li><li>但是，这又引起新的问题：报文段的时延突然增大了很多。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。</li><li>因此要对 Karn 算法进行修正。方法是：报文段每重传一次，就把超时重传时间 RTO 增大一些。典型的做法是取新的重传时间为旧的重传时间的 2 倍。当不再发生报文段的重传时，才根据上面给出的 (5-5) 式计算超时重传时间。</li><li>Karn 算法能够使运输层区分开有效的和无效的往返时间样本，从而改进了往返时间的估测，使计算结果更加合理。</li></ol></li></ul><h2 id="5-6-3-选择确认-SACK"><a href="#5-6-3-选择确认-SACK" class="headerlink" title="5.6.3 选择确认 SACK"></a>5.6.3 选择确认 SACK</h2><ul><li><strong>选择确认</strong>的工作原理。TCP 的接收方在接收对方发送过来的数据字节流的序号不连续时会形成一些不连续的字节块 (如图 5-21 所示)。序号 1～1000 收到了，但序号 1001～1500 没有收到。接下来的字节流又收到了，缺少了 3001～3500。再后面从序号 4501 起又没有收到。接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230808162315.png"></li><li>从图 5-21 可看出，与前后字节不连续的每一个字节块都有两个边界：左边界和右边界。因此在图中用四个指针标记这些边界。第一个字节块的左边界 L<sub>1</sub> ＝1501，右边界 R<sub>1</sub> ＝3001 而不是 3000。左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。同理，第二个字节块的左边界 L<sub>2</sub> ＝3501，而右边界 R<sub>2</sub> ＝4501。</li></ol></li></ul><h1 id="5-7-TCP-的流量控制"><a href="#5-7-TCP-的流量控制" class="headerlink" title="5.7 TCP 的流量控制"></a>5.7 TCP 的流量控制</h1><h2 id="5-7-1-利用滑动窗口实现流量控制"><a href="#5-7-1-利用滑动窗口实现流量控制" class="headerlink" title="5.7.1 利用滑动窗口实现流量控制"></a>5.7.1 利用滑动窗口实现流量控制</h2><ul><li><strong>流量控制</strong>就是<strong>让发送方的发送速率不要太快，让接收方来得及接收</strong>。</li><li><strong>发送方的发送窗口不能超过接收方给出的接收窗口的数值</strong>。</li><li>TCP 的<strong>窗口单位是字节，不是报文段</strong>。</li><li>TCP 为每一个连接设有一个<strong>持续计时器</strong>。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口<strong>探测报文段</strong>，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</li></ul><h2 id="5-7-2-TCP-的传输效率"><a href="#5-7-2-TCP-的传输效率" class="headerlink" title="5.7.2 TCP 的传输效率"></a>5.7.2 TCP 的传输效率</h2><ul><li>用不同的机制来控制 TCP 报文段的发送时机：<ol><li>TCP 维持一个等于<strong>最大报文段长度</strong> MSS 的变量。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li><li>由发送方的应用进程指明要求发送报文段，即 TCP 支持的<strong>推送</strong>操作。</li><li>发送方的一个计时器期限到了时，就把当前已有的缓存数据装入报文段 (但长度不能超过MSS) 发送出去。</li></ol></li><li>在 TCP 的实现中广泛使用 Nagle 算法。算法如下：<ol><li>若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。</li><li>当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。</li><li>只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，可明显地减少所用的网络带宽。</li><li>当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段，可以有效地提高网络的吞吐量。</li></ol></li><li><strong>糊涂窗口综合征</strong>，有时会使 TCP 的性能变坏。当 TCP 接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取 1 个字节 (这样就使接收缓存空间仅腾出 1 个字节)，然后向发送方发送确认，并把窗口设置为 1 个字节 (但发送的数据报是 40 字节长)。接着，发送方又发来 1 个字节的数据 (请注意，发送方发送的 IP 数据报是 41 字节长)。接收方发回确认，仍然将窗口设置为 1 个字节。这样进行下去，使网络的效率很低。</li><li>解决糊涂窗口综合征需要<strong>让接收方等待一段时间</strong>，使得接收缓存已有足够空间容纳一个最长的报文段，或者<strong>等到接收缓存已有一半空闲的空间</strong>。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</li></ul><h1 id="5-8-TCP-的拥塞控制"><a href="#5-8-TCP-的拥塞控制" class="headerlink" title="5.8 TCP 的拥塞控制"></a>5.8 TCP 的拥塞控制</h1><h2 id="5-8-1-拥塞控制的一般原理"><a href="#5-8-1-拥塞控制的一般原理" class="headerlink" title="5.8.1 拥塞控制的一般原理"></a>5.8.1 拥塞控制的一般原理</h2><ul><li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做<strong>拥塞</strong>。可以把出现网络拥塞的条件写成如下的关系式：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809093124.png"></li></ol></li><li>若网络中有许多资源同时呈现供应不足，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</li><li>网络拥塞由许多因素引起：<ol><li>当某个结点缓存的容量太小时，到达该结点的分组因无存储空间暂存而不得不被丢弃。</li><li>由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数分组的排队等待时间将会大大增加，上层软件只能重传。</li><li>处理机处理的速率太慢可能引起网络的拥塞。</li><li>拥塞常常趋于恶化。如果一个路由器没有足够的缓存空间，就会丢弃一些新到的分组。但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次，导致更多的分组流入网络和被网络中的路由器丢弃。</li></ol></li><li><strong>拥塞控制防止过多的数据注入到网络中，使网络中的路由器或链路不致过载</strong>。拥塞控制要做的有一个前提，就是<strong>网络能够承受现有的网络负荷</strong>。拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。但 TCP 连接的端点只要迟迟不能收到对方的确认信息，就猜想在当前网络中的某处很可能发生了拥塞，但无法知道拥塞到底发生在网络的何处，也无法知道发生拥塞的具体原因。</li><li><strong>流量控制往往指点对点通信量的控制</strong>，是个<strong>端到端</strong>的问题 (接收端控制发送端)。流量控制所要做的就是抑制发送端发送数据的速率，使接收端来得及接收。</li><li>进行拥塞控制需要付出代价。首先需要获得网络内部流量分布的信息。在实施拥塞控制时，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制，产生了额外开销。拥塞控制有时需要将一些资源 (如缓存、带宽等) 分配给个别用户单独使用，使得网络资源不能更好地实现共享。</li><li>拥塞控制所起的作用<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809093722.png"></li></ul><ol><li>在图 5-23 中的横坐标是<strong>提供的负载</strong>，代表单位时间内输入给网络的分组数目。因此提供的负载也称为<strong>输入负载</strong>或<strong>网络负载</strong>。纵坐标是<strong>吞吐量</strong>，代表单位时间内从网络输出的分组数目。</li><li>具有理想拥塞控制的网络，在吞吐量饱和之前，网络吞吐量应等于提供的负载，故吞吐量曲线是 45° 的斜线。但当提供的负载超过某一限度时，由于网络资源受限，吞吐量不再增长而保持为水平线，即吞吐量达到饱和。这就表明提供的负载中有一部分损失掉了。</li><li>实际网络的情况就很不相同了。从图 5-23 可看出，随着提供的负载的增大，网络吞吐量的增长速率逐渐减小。也就是说，在网络吞吐量还未达到饱和时，就已经有一部分的输入分组被丢弃了。当网络的吞吐量明显地小于理想的吞吐量时，网络就进入了<strong>轻度拥塞</strong>的状态。更值得注意的是，当提供的负载达到某一数值时，网络的吞吐量反而随提供的负载的增大而下降，这时<strong>网络就进入了拥塞状态</strong>。当提供的负载继续增大到某一数值时，网络的吞吐量就下降到零，网络已无法工作，这就是所谓的<strong>死锁</strong>。</li></ol></li><li>从原理上讲，寻找拥塞控制的方案是寻找使不等式 (5-7) 不再成立的条件。或者是增大网络的某些可用资源，或减少一些用户对某些资源的需求。</li><li>开环控制是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正。</li><li>闭环控制是基于反馈环路的概念，主要有以下几种措施：<ol><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>把拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ol></li><li>过于频繁地采取行动以缓和网络的拥塞，会使系统产生不稳定的振荡。但过于迟缓地采取行动又不具有任何实用价值。</li></ul><h2 id="5-8-2-TCP-的拥塞控制方法"><a href="#5-8-2-TCP-的拥塞控制方法" class="headerlink" title="5.8.2 TCP 的拥塞控制方法"></a>5.8.2 TCP 的拥塞控制方法</h2><ul><li>TCP 进行拥塞控制的算法有四种，<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传</strong>和<strong>快恢复</strong>。</li><li>发送方维持一个叫<strong>拥塞窗口</strong> cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态变化。<strong>发送方让自己的发送窗口等于拥塞窗口</strong>。</li><li>发送方<strong>控制拥塞窗口</strong>的原则：只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</li><li><strong>慢开始</strong>算法的思路：当主机开始发送数据时，由于并不清楚网络的负荷情况，如果立即把大量数据字节注入到网络，可能引起网络发生拥塞。应该<strong>由小到大逐渐增大发送窗口，由小到大逐渐增大拥塞窗口数值</strong>。</li><li>旧的规定是这样的：在刚刚开始发送报文段时，先把初始拥塞窗口 cwnd 设置为 1 至 2 个发送方的最大报文段 SMSS 的数值，但新的 RFC 5681 把初始拥塞窗口 cwnd 设置为不超过 2 至 4 个 SMSS 的数值。具体的规定如下：<ol><li>若 SMSS&gt;2190 字节，则设置初始拥塞窗口 cwnd＝2×SMSS 字节，且<strong>不得超过 2 个报文段。</strong></li><li>若 SMSS&gt;1095 字节 且 SMSS≤2190 字节，则设置初始拥塞窗口 cwnd＝3×SMSS 字节，且<strong>不得超过</strong> 3 个报文段。</li><li>若 SMSS≤1095 字节，则设置初始拥塞窗口 cwnd＝4×SMSS 字节，且<strong>不得超过</strong> 4 个报文段。</li></ol></li><li>慢开始规定，在每收到一个<strong>对新的报文段的确认</strong>后，可以把拥塞窗口增加最多一个 SMSS 的数值。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102613.png"></li><li>其中 <em>N</em> 是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。</li></ol></li><li>在一开始发送方先设置 cwnd＝1，发送第一个报文段 M<sub>1</sub>，接收方收到后确认 M<sub>1</sub>。发送方收到对 M<sub>1</sub> 的确认后，把 cwnd 从 1 增大到 2，于是发送方接着发送 M<sub>2</sub> 和 M<sub>3</sub> 两个报文段。接收方收到后发回对 M<sub>2</sub> 和 M<sub>3</sub> 的确认。发送方每收到一个<strong>对新报文段的确认</strong>就使发送方的拥塞窗口加 1，因此发送方在收到两个确认后，cwnd 就从 2 增大到 4，并可发送 M<sub>4</sub>～M<sub>7</sub> 共 4 个报文段 (见图 5-24)。因此使用慢开始算法后，<strong>每经过一个传输轮次</strong>，<strong>拥塞窗口</strong> cwnd <strong>就加倍</strong>。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102703.png"></li></ol></li><li>传输<strong>轮次</strong>。从图 5-24 可以看出，一个传输轮次所经历的时间就是往返时间 RTT。使用“传输轮次”是强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。例如，拥塞窗口 cwnd 的大小是 4 个报文段，那么这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这4个报文段的确认，总共经历的时间。</li><li>为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个<strong>慢开始门限</strong> ssthresh 状态变量。慢开始门限 ssthresh 的用法如下：<ol><li>当 cwnd&lt;ssthresh 时，使用上述的慢开始算法。</li><li>当 cwnd&gt;ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd&#x3D;ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ol></li><li><strong>拥塞避免</strong>算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“<strong>加法增大</strong>”AI 的特点。这表明在拥塞避免阶段，拥塞窗口 cwnd <strong>按线性规律缓慢增长</strong>，比慢开始算法的拥塞窗口增长速率缓慢得多。</li><li>采用快重传算法可以让发送方<strong>尽早知道发生了个别报文段的丢失</strong>。快重传算法要求接收方不要等待自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了<strong>失序的报文段</strong>也要立即发出对已收到的报文段的重复确认。</li><li>快重传算法规定，发送方只要<strong>一连收到 3 个重复确认</strong>，就知道接收方确实没有收到报文段 M<sub>3</sub>，因而应当<strong>立即进行重传</strong> (即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约 20％。</li><li>TCP 的拥塞控制可以归纳为图 5-27 的流程图。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809102925.png"></li></ol></li><li>接收方的缓存空间有限，根据自己的接收能力设定了接收方窗口 rwnd，并把这个窗口值写入 TCP 首部中的窗口字段，传送给发送方。因此，<strong>接收方窗口</strong>又称为<strong>通知窗口</strong>。因此，从接收方对发送方的流量控制的角度考虑，<strong>发送方的发送窗口一定不能超过对方给出的接收方窗口值</strong> rwnd。</li><li>如果把拥塞控制和接收方对发送方的流量控制一起考虑，那么发送方的窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，也就是说：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809103014.png"></li><li>当 rwnd&lt;cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</li><li>当 cwnd&lt;rwnd 时，则是网络的拥塞程度限制发送方窗口的最大值。</li><li>rwnd 和 cwnd 中数值较小的一个，控制了发送方发送数据的速率。</li></ol></li></ul><h2 id="5-8-3-主动队列管理-AQM"><a href="#5-8-3-主动队列管理-AQM" class="headerlink" title="5.8.3 主动队列管理 AQM"></a>5.8.3 主动队列管理 AQM</h2><ul><li>网络层的策略对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。在最简单的情况下，路由器的队列通常都是按照“<strong>先进先出</strong>” FIFO 的规则处理到来的分组。由于队列长度有限，因此当队列已满时，以后再到达的所有分组将都被丢弃，这叫<strong>尾部丢弃策略</strong>。</li><li>路由器的尾部丢弃会导致一连串分组的丢失，使发送方出现超时重传、TCP 进入拥塞控制的慢开始状态，使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。更为严重的是，在网络中通常有很多的 TCP 连接，这些连接中的报文段通常是复用在网络层的 IP 数据报中传送。在这种情况下，若发生了路由器中的尾部丢弃，可能会同时影响到很多条 TCP 连接，使许多 TCP 连接<strong>在同一时间</strong>突然都进入到慢开始状态。这在 TCP 的术语中称为<strong>全局同步</strong>。全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。</li><li>为了避免发生网络中的全局同步现象，提出了<strong>主动队列管理</strong> AQM。所谓“主动”是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。应当在队列长度达到某个值得警惕的数值时 (即当网络拥塞有了某些拥塞征兆时)，就主动丢弃到达的分组。这样就提醒了发送方放慢发送的速率，可能使网络拥塞的程度减轻，甚至不出现网络拥塞。</li><li>实现<strong>随机早期检测</strong> RED 时需要使路由器维持两个参数，即队列长度最小门限和最大门限。当每一个分组到达时，RED 就按照规定的算法先计算当前的平均队列长度。<ol><li>若平均队列长度小于最小门限，则把新到达的分组放入队列进行排队。</li><li>若平均队列长度超过最大门限，则把新到达的分组丢弃。</li><li>若平均队列长度在最小门限和最大门限之间，则按照某一丢弃概率 <em>p</em> 把新到达的分组丢弃 (这就体现了丢弃分组的随机性)。</li></ol></li><li>RED 不是等到已经发生网络拥塞后才把所有在队列尾部的分组全部丢弃，而是在检测到网络拥塞的<strong>早期征兆</strong>时 (即路由器的平均队列长度达到一定数值时)，就以概率 <em>p</em> 丢弃个别的分组，让拥塞控制只在个别的 TCP 连接上进行，因而避免发生全局性的拥塞控制。</li></ul><h1 id="5-9-TCP-的运输连接管理"><a href="#5-9-TCP-的运输连接管理" class="headerlink" title="5.9 TCP 的运输连接管理"></a>5.9 TCP 的运输连接管理</h1><ul><li>TCP 是面向连接的协议。运输连接是用来传送 TCP 报文的。TCP 运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。因此，运输连接就有三个阶段，即：<strong>连接建立、数据传送和连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</li><li>TCP 连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做<strong>客户</strong>，而被动等待连接建立的应用进程叫做<strong>服务器</strong>。</li></ul><h2 id="5-9-1-TCP-的连接建立"><a href="#5-9-1-TCP-的连接建立" class="headerlink" title="5.9.1 TCP 的连接建立"></a>5.9.1 TCP 的连接建立</h2><ul><li>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。图 5-28 画出了三报文握手建立 TCP 连接的过程。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230809153847.png"></li><li>A 的 TCP 客户进程也是首先创建<strong>传输控制模块</strong> TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN＝1，同时选择一个初始序号 seq＝x。TCP 规定，SYN 报文段(即 SYN＝1 的报文段) 不能携带数据，但要<strong>消耗掉一个序号</strong>。这时，TCP 客户进程进入 SYN-SENT (同步已发送) 状态。</li><li>B 收到连接请求报文段后，如同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack＝x＋1，同时也为自己选择一个初始序号 seq＝y。请注意，这个报文段也不能携带数据，但同样<strong>要消耗掉一个序号</strong>。这时 TCP 服务器进程进入 SYN-RCVD (同步收到) 状态。</li><li>TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack＝y＋1，而自己的序号 seq＝x＋1。TCP 的标准规定，ACK 报文段可以携带数据。但<strong>如果不携带数据则不消耗序号</strong>，在这种情况下，下一个数据报文段的序号仍是 seq＝x＋1。这时，TCP 连接已经建立，A 进入 ESTABLISHED (已建立连接) 状态。</li><li>当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。</li></ol></li></ul><h2 id="5-9-2-TCP-的链接释放"><a href="#5-9-2-TCP-的链接释放" class="headerlink" title="5.9.2 TCP 的链接释放"></a>5.9.2 TCP 的链接释放</h2><ul><li>数据传输结束后，通信的双方都可释放连接。现在 A 和 B 都处于 ESTABLISHED 状态 (图 5-29)。A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq＝u，它等于前面已传送过的数据的最后一个字节的序号加 1。这时 A 进入 FIN-WAIT-1 (终止等待 1)状态，等待 B 的确认。TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_%7B5BE8DB9C-8B4F-4d08-93E2-9B2367E7A0F0%7D.png">图 5-29</li><li>B 收到连接释放报文段后即发出确认，确认号是 ack＝u＋1，而这个报文段自己的序号是 v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。然后 B 就进入 CLOSE-WAIT (关闭等待) 状态。TCP 服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于<strong>半关闭</strong>状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。</li><li>A 收到来自 B 的确认后，就进入 FIN-WAIT-2 (终止等待2) 状态，等待 B 发出的连接释放报文段。</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN＝1。假定 B 的序号为 w (在半关闭状态 B 可能又发送了一些数据)。B 还必须重复上次已发送过的确认号 ack＝u＋1。这时 B 就进入 LAST-ACK (最后确认) 状态，等待 A 的确认。</li><li>A 在收到 B 的连接释放报文段后，对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack＝w＋1，而自己的序号是 seq＝u＋1 (根据 TCP 标准，前面发送过的 FIN 报文段要消耗一个序号)。然后进入到 TIME-WAIT (时间等待) 状态。现在 TCP 连接还没有释放掉。必须经过<strong>时间等待计时器</strong>设置的时间 2MSL 后，A 才进入到 CLOSED 状态。时间 MSL 叫做<strong>最长报文段寿命</strong>。从 A 进入到 TIME-WAIT 状态后，要经过 4 分钟才能进入到 CLOSED 状态，才能开始建立下一个新的连接。当 A 撤销相应的传输控制块 TCB 后，就结束了 TCP 连接。</li></ol></li></ul><h2 id="5-9-3-TCP-的有限状态机"><a href="#5-9-3-TCP-的有限状态机" class="headerlink" title="5.9.3 TCP 的有限状态机"></a>5.9.3 TCP 的有限状态机</h2><ul><li>为了更清晰地看出 TCP 连接的各种状态之间的关系，图 5-30 给出了 TCP 的有限状态机。图中每一个方框即 TCP 可能具有的状态。每个方框中的大写英文字符串是 TCP 标准所使用的TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。图中有三种不同的箭头，粗实线箭头表示对客户进程的正常变迁，粗虚线箭头表示对服务器进程的正常变迁，另一种细线箭头表示异常变迁。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_%7B4FCAAF4F-C6ED-46fa-ADF1-31A8D0D139AF%7D.png"></li></ol></li></ul><h1 id="本章重要概念"><a href="#本章重要概念" class="headerlink" title="本章重要概念"></a>本章重要概念</h1><ul><li><p>运输层提供应用进程间的逻辑通信，运输层之间的通信并不是真正在两个运输层之间直接传送数据。运输层向应用层屏蔽了下面网络的细节 (如网络拓扑、所采用的路由选择协议等)，使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p></li><li><p>网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</p></li><li><p>运输层有两个主要的协议：TCP 和 UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的 (只提供尽最大努力服务)，但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的 UDP 协议时，这种逻辑通信信道仍然是一条不可靠信道。</p></li><li><p>运输层用一个 16 位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。</p></li><li><p>两台计算机中的进程要互相通信，不仅要知道对方的 IP 地址 (为了找到对方的计算机)，而且还要知道对方的端口号 (为了找到对方计算机中的应用进程)。</p></li><li><p>运输层的端口号分为服务器端使用的端口号 (0～1023 指派给熟知端口，1024～49151 是登记端口号) 和客户端暂时使用的端口号 (49152～65535)。</p></li><li><p>UDP 的主要特点是：</p><ol><li>无连接；</li><li>尽最大努力交付；</li><li>面向报文；</li><li>无拥塞控制；</li><li>支持一对一、一对多、多对一和多对多的交互通信；</li><li>首部开销小 (只有四个字段：源端口、目的端口、长度、检验和)。</li></ol></li><li><p>TCP 的主要特点是：</p><ol><li>面向连接；</li><li>每一条 TCP 连接只能是点对点的 (一对一)；</li><li>提供可靠交付的服务；</li><li>提供全双工通信；</li><li>面向字节流。</li></ol></li><li><p>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字 (socket) 或插口。套接字用 (IP地址：端口号) 来表示。</p></li><li><p>停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组，分组需要进行编号。</p></li><li><p>超时重传指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p></li><li><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，同时还要发送确认。</p></li><li><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已正确收到了。</p></li><li><p>TCP 报文段首部的前 20 个字节是固定的，后面有 4<em>N</em> 字节是根据需要而增加的选项。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。</p></li><li><p>TCP 首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 <em>N</em>，则表明：到序号 <em>N</em>-1 为止的所有数据都已正确收到。</p></li><li><p>TCP 首部中的窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化着的。</p></li><li><p>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动 (没有收到新的确认) 和前移 (收到了新的确认)。发送窗口前沿通常是不断向前移动的。</p></li><li><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p></li><li><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。</p></li><li><p>流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p></li><li><p>为了进行拥塞控制，TCP 的发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p></li><li><p>TCP 的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网络层，也可以使路由器采用适当的分组丢弃策略 (如主动队列管理 AQM)，以减少网络拥塞的发生。</p></li><li><p>运输连接有三个阶段，即连接建立、数据传送和连接释放。</p></li><li><p>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 的连接建立采用三报文握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。</p></li><li><p>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后就进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接。</p></li><li><p>为什么说 UDP 面向报文，TCP 面向字节流？</p><blockquote><p>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP 一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。反之，若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。<br>(1) UDP 被称为”面向报文”的协议，因为它将数据视为独立的报文，而不是连续的字节流。每个UDP 报文都是一个独立的数据包，UDP 对报文的处理是原封不动地发送和接收，不保证它们的顺序，也不提供重传机制。每个 UDP 报文都是一个独立的实体，它们之间没有关联。<br>UDP 适用于一些实时性要求高、可以容忍一些数据丢失的应用场景，比如实时音视频传输、在线游戏等。<br>(2) TCP 则被称为”面向字节流”的协议，因为它将数据视为一个连续的字节流，而不是离散的报文。TCP 负责将应用层的数据划分为合适的数据块，然后将这些数据块封装为 TCP 报文段进行传输。在接收端，TCP 会负责重组这些字节流，确保按顺序交付给应用层。<br>TCP 提供了可靠的、面向连接的服务，通过序列号和确认机制保证数据的可靠传输，并能够处理数据的重传、流量控制和拥塞控制等问题。<br>TCP 适用于对数据可靠性和顺序性要求较高的应用，比如文件传输、网页访问等。</p></blockquote></li><li><p>为什么 UDP 首部中没有首部长度字段，而 TCP 首部中却有？</p><blockquote><p>UDP 数据报首部长度是固定的，不需要这个字段。<br>TCP 报文段除了固定长度的首部之外，还有选项字段，因此 TCP 报文段的首部长度是可变的。(TCP 报文段的首部长度字段就是“数据偏移”)</p></blockquote></li><li><p>流量控制与拥塞控制的主要区别是什么？发送窗口的大小取决于流量控制还是拥塞控制</p><blockquote><p>简单地说，流量控制是在一条 TCP 连接中的接收端采用的措施，用来限制对方 (发送端) 发送报文段的速率，以免在接收端来不及接收。流量控制只控制一个发送端。<br>拥塞控制是用来控制 TCP 连接中发送端发送报文段的速率，以免使互联网中的某处产生过载。拥寒控制可能会同时控制许多个发送端，限制它们的发送速率。不过每一个发送端只知道自己应当怎样调整发送速率，而不知道在互联网中还有哪些主机被限制了发送速率。<br>发送窗口的上限值是 Min[rwnd,cwnd]，即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个。接收窗口的大小体现了接收端对发送端施加的流量控制，而拥寨窗口的大小则是整个互联网的负载情况对发送端施加的拥寒控制。因此，当接收窗口小于拥塞窗口时，发送窗口的大小取决于流量控制，即取决于接收端的接收能力。但当拥塞窗口小于接收窗口时，则发送窗口的大小取决于拥塞控制，即取决于整个网络的拥塞状况。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概述</title>
      <link href="/2023/11/27/gai-shu/"/>
      <url>/2023/11/27/gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-计算机网络在信息时代中的作用"><a href="#1-1-计算机网络在信息时代中的作用" class="headerlink" title="1.1 计算机网络在信息时代中的作用"></a>1.1 计算机网络在信息时代中的作用</h1><ul><li>互联网具有两个重要基本特点，<strong>连通性</strong>和<strong>共享</strong>。<ol><li>连通性：互联网使上网用户之间，不管相距多远，都可以非常便捷、非常经济地交换各种信息。</li><li>共享指<strong>资源共享</strong>。资源共享可以是信息共享、软件共享，也可以是硬件共享。</li></ol></li></ul><h1 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h1><h2 id="1-2-1-网络的网络"><a href="#1-2-1-网络的网络" class="headerlink" title="1.2.1 网络的网络"></a>1.2.1 网络的网络</h2><ul><li><strong>计算机网络</strong>（简称为<strong>网络</strong>）由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。网络中的结点可以是计算机、集线器、交换机或路由器等。图 1-1(a) 给出了一个具有四个结点和三条链路的网络。有三台计算机通过三条链路连接到一个集线器上，构成了一个简单的计算机网络。可以用一朵云表示一个网络。</li><li>网络之间通过路由器互连起来，构成覆盖范围更大的计算机网络。这样的网络称为<strong>互连网</strong>，如图1-1(b) 所示。因此互连网是“<strong>网络的网络</strong>”。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630153611.png"></li><li><strong>网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机。</strong></li></ul><h2 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 <strong>互联网基础结构发展的三个阶段</strong></h2><ul><li>第一阶段是从单个网络 ARPANET 向互连网发展的过程。</li><li>第二阶段的特点是建成了<strong>三级结构的互联网</strong>。</li><li>第三阶段的特点是逐渐形成了<strong>多层次 ISP 结构的互联网</strong>。</li></ul><h2 id="1-2-3-互联网的标准化工作"><a href="#1-2-3-互联网的标准化工作" class="headerlink" title="1.2.3 互联网的标准化工作"></a>1.2.3 <strong>互联网的标准化工作</strong></h2><ul><li>国际性组织<strong>互联网协会</strong> (简称 ISOC)，对互联网进行全面管理以及在世界范围内促进其发展和使用。ISOC 下面有一个技术组织叫做<strong>互联网体系结构委员会</strong> (简称 IAB)，负责管理互联网有关协议的开发。IAB 下面又设有两个工程部：<ol><li><strong>互联网工程部</strong>（简称 IETF）</li><li><strong>互联网研究部</strong>（简称 IRTF）</li></ol></li><li>制定互联网的正式标准要经过以下三个阶段：<ol><li><strong>互联网草案</strong>——互联网草案的有效期只有六个月。在这个阶段还不能算是 RFC 文档。</li><li><strong>建议标准</strong>——从这个阶段开始就成为 RFC 文档。</li><li><strong>互联网标准</strong>——达到正式标准后，每个标准就分配到一个编号 STD xx。一个标准可以和多个RFC 文档关联。截止到 2016 年 7 月，互联网标准的最大编号是 STD 83。</li></ol></li></ul><h1 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h1><ul><li>互联网的拓扑结构非常复杂，并且覆盖了全球，从工作方式上看，划分为以下两大块：<ol><li><strong>边缘部分</strong>：由所有连接在互联网上的主机组成。<strong>用户直接使用</strong>，用来进行通信和资源共享。</li><li><strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。<strong>为边缘部分提供服务的</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630205219.png"></li></ol></li></ul><h2 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 <strong>互联网的边缘部分</strong></h2><ol><li><strong>计算机之间通信</strong>：<strong>主机 A 的某个进程和主机 B 上的另一个进程进行通信</strong></li><li><strong>客户——服务器方式</strong><ul><li><strong>客户</strong>和<strong>服务器</strong>是指通信中所涉及的两个应用进程。客户——服务器方式所描述的是进程之间服务和被服务的关系。</li><li><strong>客户是服务请求方，服务器是服务提供方。</strong></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630205735.png"></li><li><strong>客户程序：</strong><ol><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和复杂的操作系统。</li></ol></li><li><strong>服务器程序：</strong><ol><li>是一种用来提供某种服务的程序，<strong>可同时处理</strong>多个远地或本地客户的请求。</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。服务器程序不需要知道客户程序的地址。</li><li>需要有强大的硬件和高级的操作系统支持。</li></ol></li></ul></li><li><strong>对等连接方式</strong><ul><li><strong>对等连接</strong> (简称 P2P) 指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机运行了对等连接软件 (P2P 软件)，就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。因此这种工作方式也称为 <strong>P2P 方式</strong> 。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630223247.png"></li></ul></li></ol><h2 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2 互联网的核心部分"></a>1.3.2 互联网的核心部分</h2><ol><li>在网络核心部分起特殊作用的是<strong>路由器</strong>，是一种专用计算机。路由器是实现<strong>分组交换</strong>的关键构件，任务是<strong>转发收到的分组</strong>，是网络核心部分最重要的功能。</li><li><strong>电路交换的主要特点</strong><ul><li>从通信资源的分配角度来看，<strong>交换</strong>是按照某种方式动态地分配传输线路的资源</li><li>必须经过“<strong>建立连接</strong> (占用通信资源) →<strong>通话</strong> (一直占用通信资源) →<strong>释放连接</strong> (归还通信资源) ”三个步骤的交换方式称为<strong>电路交换</strong>。</li><li><strong>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</strong>。</li><li>使用电路交换来传送计算机数据时，<strong>线路的传输效率很低</strong>。因为计算机数据是突发式地出现在传输线路上的，因此线路上真正用来传送数据的时间很短。已被用户占用的通信线路资源在绝大部分时间里都是空闲的。</li></ul></li><li><strong>分组交换的主要特点</strong><ul><li>分组交换采用<strong>存储转发</strong>技术。</li><li>把要发送的整块数据称为一个<strong>报文</strong>。在发送报文前，把较长的报文划分成为一个个更小的等长数据段。在每一个数据段前，加上由必要的控制信息组成的<strong>首部</strong> (包头) 后，构成一个<strong>分组</strong> (包)。分组是在互联网中传送的数据单元。分组的首部包含目的地址和源地址等，使分组能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</li><li>位于网络边缘的主机和位于网络核心部分的路由器都是计算机，但作用不一样。<strong>主机是为用户进行信息处理的</strong>，并且可以和其他主机通过网络交换信息。<strong>路由器则是用来转发分组的，进行分组交换的</strong>。路由器收到一个分组，先暂时存储，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地以存储转发的方式，把分组交付最终的目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</li><li><strong>分组交换的优点</strong>：<ol><li>高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</li><li>灵活：为每一个分组选择合适的转发路由</li><li>迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性</li></ol></li><li><strong>分组交换的缺点</strong>：<ol><li>分组在各路由器存储转发时需要排队，会造成<strong>时延</strong>。由于分组交换不像电路交换那样通过建立连接来保证通信时所需的各种资源，因而无法确保通信时端到端所需的带宽。</li><li>各分组必须携带的控制信息造成了<strong>开销</strong>。分组交换网需要专门的管理和控制机制。</li></ol></li></ul></li></ol><ul><li>三种交换的比较<ol><li><strong>电路交换</strong>——整个报文的比特流连续地从源点直达终点</li><li><strong>报文交换</strong>——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li><li><strong>分组交换</strong>——单个分组 (这只是整个报文的一部分) 传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701111637.png"></li></ol></li></ul><h1 id="1-4-计算机网络在我国的发展"><a href="#1-4-计算机网络在我国的发展" class="headerlink" title="1.4 计算机网络在我国的发展"></a>1.4 计算机网络在我国的发展</h1><h1 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h1><h2 id="1-5-1-计算机网络的定义"><a href="#1-5-1-计算机网络的定义" class="headerlink" title="1.5.1 计算机网络的定义"></a>1.5.1 计算机网络的定义</h2><ul><li><strong>计算机网络的定义</strong><ol><li>计算机网络：计算机网络主要是由一些通用的、可编程的硬件互连而成的，这些硬件并非专门用来实现某一特定目的，它们能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，还包括了智能手机；计算机网络并非专门用来传送数据，还能支持很多种的应用。</li></ul></li></ol></li></ul><h2 id="1-5-2-几种不同类别的计算机网络"><a href="#1-5-2-几种不同类别的计算机网络" class="headerlink" title="1.5.2 几种不同类别的计算机网络"></a>1.5.2 几种不同类别的计算机网络</h2><ul><li><strong>几种不同类别的计算机网络</strong><ol><li><strong>按照网络的作用范围进行分类</strong><ul><li><strong>广域网</strong> (WAN) 作用范围通常为几十到几千公里，也称<strong>远程网</strong>。广域网是互联网的核心部分，任务是长距离运送主机所发送的数据。连接广域网各结点交换机的链路一般都是高速链路，具有较大的通信容量。</li><li><strong>城域网</strong> (MAN) 作用范围一般是城市，跨越几个街区甚至整个城市，作用距离约为 5～50km。城域网可以为一个或几个单位所拥有，也可以是一种公用设施，用来将多个局域网进行互连。目前很多城域网采用的是以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li><strong>局域网</strong> (LAN) 一般用微型计算机或工作站通过高速通信线路相连 (速率通常在10Mbit&#x2F;s 以上)，但地理上则局限在较小的范围 (如 1km 左右)。在局域网发展的初期，一个学校或工厂往往只拥有一个局域网，但现在局域网已非常广泛地使用，学校或企业大都拥有许多个互连的局域网 (这样的网络常称为<strong>校园网</strong>或<strong>企业网</strong>)。</li><li><strong>个人区域网</strong> (PAN) 在个人工作的地方把属于个人使用的电子设备 (如便携式电脑) 用无线技术连接起来的网络，因此也常称为<strong>无线个人区域网</strong> (WPAN)，其范围很小，大约在10m左右。</li></ul></li><li><strong>按照网络的使用者进行分类</strong><ul><li><strong>公用网</strong>：电信公司 (国有或私有) 出资建造的大型网络。“公用”的意思就是所有愿意按电信公司的规定交纳费用的人都可以使用这种网络。因此公用网也可称为<strong>公众网</strong>。</li><li><strong>专用网</strong>：某个部门为满足本单位的特殊业务工作的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如，军队、铁路、银行、电力等系统均有本系统的专用网。</li></ul></li><li><strong>用来把用户接入到互联网的网络</strong><ul><li><strong>接入网</strong> (AN)，又称为<strong>本地接入网</strong>或<strong>居民接入网</strong></li><li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。是从某个用户端系统到互联网中的第一个路由器之间的一种网络。</li></ul></li></ol></li></ul><h1 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h1><h2 id="1-6-1-计算机网络的性能"><a href="#1-6-1-计算机网络的性能" class="headerlink" title="1.6.1 计算机网络的性能"></a>1.6.1 计算机网络的性能</h2><ul><li><strong>计算机网络的性能指标</strong><ol><li>速率<ul><li><strong>比特</strong>来源于 binary digit，意思是一个“<strong>二进制数字</strong>”，因此一个比特就是二进制数字中的一个 1 或 0。</li><li>比特也是信息论中使用的<strong>信息量的单位</strong>。网络技术中的<strong>速率</strong>指的是<strong>数据的传送速率</strong>，它也称为<strong>数据率</strong>或<strong>比特率</strong>。</li></ul></li><li><strong>带宽</strong><ul><li>带宽本指某个<strong>信号具有的频带宽度</strong>。信号的带宽指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的<strong>带宽的单位</strong>是<strong>赫</strong> (或<strong>千赫、兆赫、吉赫</strong>等)。表示某信道允许通过的信号频带范围称为该信道的<strong>带宽</strong> (<strong>通频带</strong>)。</li><li>在计算机网络中，带宽用来表示网络中某<strong>通道</strong>传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“<strong>最高数据率</strong>”。这种意义的<strong>带宽的单位</strong>就是<strong>数据率的单位</strong> bit&#x2F;s，是<strong>比特每秒</strong>。</li><li>在“带宽”的上述两种表述中，前者为<strong>频域</strong>称谓，而后者为<strong>时域</strong>称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</li></ul></li><li><strong>吞吐量</strong><ul><li><strong>吞吐量</strong>表示在单位时间内通过某个网络的实际的数据量。</li><li>吞吐量受网络的带宽或网络的额定速率的限制。</li></ul></li><li><strong>时延</strong><ul><li><strong>时延</strong>指数据从网络的一端传送到另一端所需的时间。</li><li>时延是很重要的性能指标，有时也称为延迟或迟延。</li><li>时延由以下组成：<ol><li><strong>发送时延</strong>　发送时延是主机或路由器发送数据帧所需要的时间，从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。因此发送时延也叫做<strong>传输时延</strong>。发送时延的计算公式是：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701153549.png"></li><li>发送时延并非固定不变，而是与发送的帧长成正比，与发送速率成反比。</li></ul></li><li><strong>传播时延</strong>　传播时延是电磁波在信道中传播一定的距离需要花费的时间。传播时延的计算公式是：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701153757.png"></li><li>发送时延发生在机器内部的发送器中，<strong>与传输信道的长度 (或信号传送的距离) 没有关系</strong>。传播时延发生在机器外部的传输信道媒体上，<strong>与信号的发送速率无关</strong>。<strong>信号传送的距离越远，传播时延就越大</strong>。</li></ul></li><li><strong>处理时延</strong> 　主机或路由器在收到分组时要花费时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。</li><li><strong>排队时延</strong> 　分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。排队时延的长短往往取决于网络当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大。</li><li>数据在网络中经历的总时延就是四种时延之和：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702225623.png"></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702163416.png"></li><li><strong>对于高速网络链路，提高的仅是数据的发送速率而不是比特在链路上的传播速率</strong>。</li><li><strong>提高数据的发送速率减小了数据的发送时延</strong>。数据的发送速率的单位是每秒发送多少个比特，指在<strong>某个点</strong>或<strong>某个接口上</strong>的发送速率。而传播速率的单位是每秒传播多少公里，指在<strong>某一段传输线路上</strong>比特的传播速率。</li></ol></li></ul></li><li><strong>时延带宽积</strong><ul><li>把网络性能的两个度量——传播时延和带宽相乘，就得到另一个度量：传播<strong>时延带宽积</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702163707.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164122.png"></li></ol></li><li>若发送端连续发送数据，则在发送的第一个比特即将达到终点时，发送端就已经发送了20 万个比特，而这 20 万个比特都正在链路上向前移动。因此，链路的时延带宽积又称为<strong>以比特为单位的链路长度</strong>。</li></ul></li><li><strong>往返时间 RTT</strong><ul><li>互联网上的信息不是单向传输而是双向交互的。</li><li>A 向 B 发送数据。如果数据长度是 100MB，发送速率是 100Mbit&#x2F;s，那么<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164237.png"></li><li>如果 B 正确收完 100MB 的数据后，就立即向 A 发送确认。再假定 A 只有在收到 B 的确认信息后，才能继续向 B 发送数据。显然，这需要等待一个往返时间 RTT (这里假定确认信息很短，可忽略 B 发送确认的时间)。如果 RTT＝2s，那么可以算出 A 向 B 发送数据的有效数据率。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164313.png"></li></ol></li></ul></li><li><strong>利用率</strong><ul><li><strong>利用率</strong>有信道利用率和网络利用率两种。<ol><li>信道利用率指出某信道有百分之几的时间是被利用的。完全空闲的信道利用率是零。</li><li>网络利用率是全网络信道利用率的加权平均值。</li><li>信道利用率并非越高越好。根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也迅速增加。和高速公路的情况有些相似。当高速公路上的车流量很大时，由于在公路上的某些地方会出现堵塞，因此行车所需的时间就会变长。同样，当网络的通信量很少时，网络产生的时延并不大。但在网络通信量不断增大的情况下，由于分组在网络结点、进行处理时需要排队等候，因此网络引起的时延就会增大。</li></ol></li><li>如果令 <em>D<sub>0</sub></em> 表示网络空闲时的时延，<em>D</em> 表示网络当前的时延，用下面的公式来表示 <em>D</em>，<em>D<sub>0</sub></em> 和利用率 <em>U</em> 之间的关系：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702165329.png"></li><li><em>U</em> 是网络的利用率，数值在 0 到 1 之间。当网络的利用率达到其容量的 1&#x2F;2 时，时延就要加倍。</li><li>当网络的利用率接近最大值 1 时，网络的时延就趋于无穷大。</li><li><strong>信道或网络的利用率过高会产生非常大的时延</strong></li><li>一些拥有较大主干网的 ISP 通常控制信道利用率不超过 50％。如果超过了就要准备扩容，增大线路的带宽。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702205609.png"></li></ol></li></ul></li></ol></li></ul><h2 id="1-6-2-计算机网络的非性能特征"><a href="#1-6-2-计算机网络的非性能特征" class="headerlink" title="1.6.2 计算机网络的非性能特征"></a>1.6.2 计算机网络的非性能特征</h2><ul><li><strong>计算机网络的非性能特征</strong><ol><li><strong>费用</strong><ul><li>网络的性能与其价格密切相关。网络的速率越高，价格也越高。</li></ul></li><li><strong>质量</strong><ul><li>网络的质量取决于网络中所有构件的质量，以及这些构件是怎样组成网络的。网络的质量影响很多方面，如网络的可靠性、网络管理的简易性，以及网络的性能。但网络的性能与网络的质量并不一样。</li></ul></li><li><strong>标准化</strong><ul><li>网络的硬件和软件的设计既可以按照通用的国际标准，也可以遵循特定的专用网络标准。采用国际标准的设计，可以得到更好的互操作性，更易于升级换代和维修，也更容易得到技术上的支持。</li></ul></li><li><strong>可靠性</strong><ul><li>可靠性与网络的质量和性能密切相关。高速网络的可靠性不一定很差。但高速网络要可靠地运行，则往往更加困难，同时所需的费用也会较高。</li></ul></li><li><strong>可扩展性和可升级性</strong><ul><li>在构造网络时应当考虑到今后需要扩展和升级。网络的性能越高，其扩展费用往往也越高，难度也会相应增加。</li></ul></li><li><strong>易于管理和维护</strong><ul><li>网络如果没有良好的管理和维护，很难达到和保持所设计的性能。</li></ul></li></ol></li></ul><h1 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h1><ul><li>在计算机网络的基本概念中，分层次的体系结构是最基本的。</li></ul><h2 id="1-7-1-计算机网络体系结构的形成"><a href="#1-7-1-计算机网络体系结构的形成" class="headerlink" title="1.7.1 计算机网络体系结构的形成"></a>1.7.1 计算机网络体系结构的形成</h2><ul><li><strong>计算机网络体系结构的形成</strong><ol><li>计算机网络是个复杂的系统。、设想一种最简单的情况：连接在网络上的两台计算机要互相传送文件。在这两台计算机之间必须有一条传送数据的通路。但还有以下工作需要完成：<ul><li>发起通信的计算机必须将数据通信的通路进行<strong>激活</strong>，即发出一些信令，保证要传送的计算机数据能在这条通路上正确发送和接收。</li><li>要告诉网络如何识别接收数据的计算机。</li><li>发起通信的计算机必须查明对方计算机是否已开机，并且与网络连接正常。</li><li>发起通信的计算机中的应用程序必须清楚，在对方计算机中的文件管理程序是否已做好接收文件和存储文件的准备工作。</li><li>若计算机的文件格式不兼容，则至少其中一台计算机应完成格式转换功能。</li><li>对出现的各种差错和意外事故，如数据传送错误、重复或丢失，网络中某个结点交换机出现故障等，应当有可靠的措施保证对方计算机最终能够收到正确的文件。</li></ul></li></ol></li></ul><h2 id="1-7-2-协议与划分层次"><a href="#1-7-2-协议与划分层次" class="headerlink" title="1.7.2 协议与划分层次"></a>1.7.2 协议与划分层次</h2><ul><li><strong>协议与划分层次</strong><ol><li>在计算机网络中要做到有条不紊地交换数据，必须遵守一些事先约定好的规则。<strong>这些规则明确规定了所交换的数据的格式以及有关的同步问题</strong>。</li><li><strong>为进行网络中的数据交换而建立的规则、标准或约定</strong>称为<strong>网络协议</strong>。网络协议也可简称为<strong>协议</strong>，主要由以下三个要素组成：<ul><li>语法，即数据与控制信息的结构或格式；</li><li>语义，即需要发出何种控制信息，完成何种动作以及做出何种响应；</li><li>同步，即事件实现顺序的详细说明。</li></ul></li><li>协议通常有两种不同的形式。一种是使用便于人来阅读和理解的文字描述。另一种是使用让计算机能够理解的程序代码。这两种不同形式的协议都必须能够对网络上的信息交换过程做出精确的解释。</li><li>分层可以带来很多好处。如：<ul><li><strong>各层之间是独立的</strong>。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。整个问题的复杂程度就下降了。</li><li><strong>灵活性好</strong>。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某一层提供的服务还可进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。</li><li><strong>结构上可分割开</strong>。各层都可以采用最合适的技术来实现。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。</li><li><strong>能促进标准化工作</strong>。因为每一层的功能及其所提供的服务都已有了精确的说明。</li></ul></li><li>分层时应使每一层的功能非常明确。若层数太少，就会使每一层的协议太复杂。但层数太多又会在描述和综合各层功能的系统工程任务时遇到较多的困难。通常各层所要完成的功能主要有以下一些：<ul><li><strong>差错控制</strong> 　使相应层次对等方的通信更加可靠。</li><li><strong>流量控制</strong> 　发送端的发送速率必须使接收端来得及接收，不能太快。</li><li><strong>分段和重装</strong> 　发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><strong>复用和分用</strong> 　发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><strong>连接建立和释放</strong> 　交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li><li>分层也有一些缺点，例如，有些功能会在不同的层次中重复出现，产生额外开销。</li></ul></li><li><strong>计算机网络的各层及其协议的集合</strong>就是网络的<strong>体系结构</strong>。换种说法，<strong>计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义</strong>。</li><li><strong>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件</strong>。</li></ol></li></ul><h2 id="1-7-3-具有五层协议的体系结构"><a href="#1-7-3-具有五层协议的体系结构" class="headerlink" title="1.7.3 具有五层协议的体系结构"></a>1.7.3 具有五层协议的体系结构</h2><ul><li><strong>具有五层协议的体系结构</strong><ol><li><strong>应用层</strong><ul><li>应用层是体系结构中的最高层。</li><li>应用层的任务是<strong>通过应用进程间的交互来完成特定网络应用</strong>。</li><li>应用层协议定义的是<strong>应用进程间通信和交互的规则</strong>。<strong>进程</strong>指主机中<strong>正在运行的程序</strong>。</li><li>应用层交互的数据单元称为<strong>报文</strong>。</li></ul></li><li><strong>运输层</strong><ul><li>运输层的任务是负责向<strong>两台主机中进程之间的通信</strong>提供<strong>通用的数据传输</strong>服务。</li><li>运输层主要使用以下两种协议：<ol><li><strong>传输控制协议</strong> (TCP)——提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>。</li><li><strong>用户数据报协议</strong> (UDP)——提供无连接的、<strong>尽最大努力</strong>的数据传输服务，其数据传输的单位是<strong>用户数据报</strong>。</li></ol></li></ul></li><li><strong>网络层</strong><ul><li>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。</li><li>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成<strong>分组</strong>或<strong>包</strong>进行传送。</li><li>在 TCP&#x2F;IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 <strong>IP 数据报</strong>，简称<strong>数据报</strong>。</li><li><strong>无论在哪一层传送的数据单元，都可笼统地用“分组”来表示</strong>。</li><li>网络层的另一个任务是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</li><li>网络层中的“<strong>网络</strong>”，不是我们谈到的具体网络，而是在计算机网络体系结构模型中的第 3 层的名称。</li><li>互联网是由大量的<strong>异构</strong>网络通过<strong>路由器</strong>相互连接起来的，使用的网络层协议是无连接的<strong>网际协议</strong> (IP) 和许多种路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或 <strong>IP 层</strong>。</li></ul></li><li><strong>数据链路层</strong><ul><li>数据链路层简称<strong>链路层</strong>。</li><li>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报<strong>组装成帧</strong>，在两个相邻结点间的链路上传送<strong>帧</strong>。每一帧包括数据和<strong>控制信息</strong>。</li></ul></li><li><strong>物理层</strong><ul><li>在物理层上所传数据的单位是<strong>比特</strong>。</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703110014.png"></li><li>图1-19 说明应用进程的数据在各层之间的传递过程中所经历的变化。假定两台主机通过一台路由器连接起来。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703110122.png"></li><li>假定主机1的应用进程AP 1 向主机2的应用进程AP 2 传送数据。AP 1 先将其数据交给本主机的第5层（应用层）。第5层加上必要的控制信息H 5 就变成了下一层的数据单元。第4层（运输层）收到这个数据单元后，加上本层的控制信息H 4 ，再交给第3层（网络层），成为第3层的数据单元。依此类推。不过到了第2层（数据链路层）后，控制信息被分成两部分，分别加到本层数据单元的首部（H 2 ）和尾部（T 2 ）；而第1层（物理层）由于是比特流的传送，所以不再加上控制信息。请注意，传送比特流时应从首部开始传送。</li><li>OSI参考模型把对等层次之间传送的数据单位称为该层的<strong>协议数据单元</strong>（PDU）。这个名词现已被许多非OSI标准采用。</li><li>当这一串的比特流离开主机1经网络的物理媒体传送到路由器时，就从路由器的第1层依次上升到第3层。每一层都根据控制信息进行必要的操作，然后将控制信息剥去，将该层剩下的数据单元上交给更高的一层。当分组上升到了第3层时，就根据首部中的目的地址查找路由器中的转发表，找出转发分组的接口，然后往下传送到第2层，加上新的首部和尾部后，再到最下面的第1层，然后在物理媒体上把每一个比特发送出去。</li><li>当这一串的比特流离开路由器到达目的站主机2时，就从主机2的第1层按照上面讲过的方式，依次上升到第5层。最后，把应用进程AP 1 发送的数据交给目的站的应用进程AP 2 。</li><li>可以用一个简单例子来比喻上述过程。有一封信从最高层向下传。每经过一层就包上一个新的信封，写上必要的地址信息。包有多个信封的信件传送到目的站后，从第1层起，每层拆开一个信封后就把信封中的信交给它的上一层。传到最高层后，取出发信人所发的信交给收信人。</li><li>虽然应用进程数据要经过如图1-19所示的复杂过程才能送到终点的应用进程，但这些复杂过程对用户来说，却都被屏蔽掉了，以致应用进程AP 1 觉得好像是直接把数据交给了应用进程AP 2 。同理，任何两个同样的层次（例如在两个系统的第4层）之间，也好像如同图1-19中的水平虚线所示的那样，把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“<strong>对等层</strong> ”（peer layers）之间的通信。我们以前经常提到的各层协议，实际上就是在各个对等层之间传递数据时的各项规定。</li><li>在文献中也还可以见到术语“<strong>协议栈</strong>”。这是因为几个层次画在一起很像一个<strong>栈</strong>的结构。</li></ul></li></ol></li></ul><h2 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h2><ul><li><strong>实体、协议、服务和服务访问点</strong><ol><li>当研究开放系统中的信息交换时，使用<strong>实体</strong>这一抽象的名词表示<strong>任何可发送或接收信息的硬件或软件进程</strong>。</li><li><strong>协议是控制两个对等实体</strong> (或<strong>多个实体</strong>) <strong>进行通信的规则的集合</strong>。协议的语法方面规则定义了所交换信息的格式，协议的语义方面规则定义了发送者或接收者所要完成的操作，例如，在何种条件下，数据必须重传或丢弃。</li><li><strong>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</strong></li><li>协议和服务在概念上不一样：<ul><li>协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。下面的协议对上面的实体是透明的。</li><li><strong>协议是“水平的”</strong>，协议是控制对等实体之间通信的规则；但<strong>服务是“垂直的”</strong>，即服务是由下层向上层通过层间接口提供的。</li><li>并非在一个层内完成的全部功能都称为服务。只有能够被高一层实体“<strong>看得见</strong>”的功能才能称之为“服务”。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在 OSI 中称为<strong>服务原语</strong>。</li><li>在同一系统中相邻两层的实体进行交互的地方，通常称为<strong>服务访问点</strong> (SAP)。服务访问点 SAP 是一个抽象的概念，是一个逻辑接口，有点像邮政信箱 (可以把邮件放入信箱和从信箱中取走邮件)，但这种层间接口和两个设备之间的硬件接口并不一样。</li><li>在任何相邻两层之间的关系可概括为图 1-20 所示的那样。第 n 层的两个“实体 (n) ”之间通过“协议 (n) ”进行通信，而第 n＋1 层的两个“实体 (n＋1) ”之间则通过另外的“协议 (n＋1) ”进行通信 (每一层都使用不同的协议) 。第 n 层向上面的第 n＋1 层所提供的服务实际上已包括了在它以下各层所提供的服务。第 n 层的实体对第 n+1 层的实体就相当于一个服务提供者。在服务提供者的上一层的实体又称为“服务用户”，因为它使用下层服务提供者所提供的服务。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703113458.png"></li></ol></li></ul></li></ol></li></ul><h2 id="1-7-5-TCP-IP-的体系结构"><a href="#1-7-5-TCP-IP-的体系结构" class="headerlink" title="1.7.5 TCP&#x2F;IP 的体系结构"></a>1.7.5 TCP&#x2F;IP 的体系结构</h2><ul><li><strong>TCP&#x2F;IP 的体系结构</strong><ol><li>TCP&#x2F;IP 协议<strong>可以为应用提供服务</strong>，同时 TCP&#x2F;IP 协议也<strong>允许 IP 协议在网络构成的互联网上运行</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703152732.png"></li></ol></li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li><p>计算机网络把计算机连接在一起，互连网把网络连接在一起，是网络的网络。</p></li><li><p>以小写字母 i 开始的 internet (互连网) 是通用名词，泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</p></li><li><p>以大写字母 I 开始的 Internet (互联网) 是专用名词，指当前全球最大的、开放的、由网络相互连接而成的特定互连网，并采用 TCP&#x2F;IP 协议族作为通信规则。</p></li><li><p>互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。</p></li><li><p>互联网按工作方式划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</p></li><li><p>计算机通信是计算机中进程之间的通信。计算机网络采用的通信方式是客户–服务器方式和对等连接方式 (P2P 方式)。</p></li><li><p>客户和服务器指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</p></li><li><p>按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和个人区域网 PAN。</p></li><li><p>计算机网络常用的性能指标是：速率、带宽、吞吐量、时延 (发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道 (或网络) 利用率。</p></li><li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p></li><li><p>五层协议的体系结构由应用层、运输层、网络层 (或网际层)、数据链路层和物理层组成。运输层最重要的协议是 TCP 和 UDP 协议，而网络层最重要的协议是 IP 协议。</p></li><li><p>叙述具有五层协议的网络体系结构的要点，包括各层的主要功能。</p><blockquote><p>(1) 物理层一在物理层上所传数据的单位是比特bit)。物理层的任务就是透明地传送比特流。物理层还要确定连接电缆的插头应当有多少根引脚以及各条引脚应如何连接。当然，哪几个比特代表什么意思，则不是物理层所要管的。请注意，传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。因此也有人把物理媒体当作第 0 层。<br>(2) 数据链路层一一常简称为链路层。在两个相邻结点之间 (主机和路由器之间或两个路由器之间)传送数据是直接传送的 (即不需要经过转发的点对点通信)。这时就需要使用专门的链路层的协议。数据链路层将网络层交下来的 IP 数据报组装成，在两个相邻结点间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息 (如同步信息、地址信息、差错控制等)。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续传送下去白白浪费网络资源。如果需要改正错误，就由运输层的 TCP 协议来完成。<br>(3) 网络层一网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在 TCP&#x2F;IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 IP 数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。对于由广播信道构成的分组交换网，路由选择的问题很简单，因此这种网络的网络层非常简单，甚至可以没有。<br>(4) 运输层一一运输层的任务就是负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务,分用则是运输层把收到的信息分别交付上面应用层中的相应的进程运输层主要使用以下两种协议: 一个是传输控制协议 TCP，是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。另一个是用户数据报协议 UDP，是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能“尽最大努力交付”。<br>(5) 应用层一一应用层是体系结构中的最高层。应用层直接为用户的应用进程提供服务这里的进程就是指正在运行的程序。在百联网中的应用层协议很多，如支持万维网应用的 HTTP 协议、支持电子邮件的 SMTP 协议、支持文件传送的 FTP 协议，等等。</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概述</title>
      <link href="/2023/11/27/ji-suan-ji-wang-luo/"/>
      <url>/2023/11/27/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="1-1-计算机网络在信息时代中的作用"><a href="#1-1-计算机网络在信息时代中的作用" class="headerlink" title="1.1 计算机网络在信息时代中的作用"></a>1.1 计算机网络在信息时代中的作用</h1><ul><li>互联网具有两个重要基本特点，<strong>连通性</strong>和<strong>共享</strong>。<ol><li>连通性：互联网使上网用户之间，不管相距多远，都可以非常便捷、非常经济地交换各种信息。</li><li>共享指<strong>资源共享</strong>。资源共享可以是信息共享、软件共享，也可以是硬件共享。</li></ol></li></ul><h1 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h1><h2 id="1-2-1-网络的网络"><a href="#1-2-1-网络的网络" class="headerlink" title="1.2.1 网络的网络"></a>1.2.1 网络的网络</h2><ul><li><strong>计算机网络</strong>（简称为<strong>网络</strong>）由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。网络中的结点可以是计算机、集线器、交换机或路由器等。图 1-1(a) 给出了一个具有四个结点和三条链路的网络。有三台计算机通过三条链路连接到一个集线器上，构成了一个简单的计算机网络。可以用一朵云表示一个网络。</li><li>网络之间通过路由器互连起来，构成覆盖范围更大的计算机网络。这样的网络称为<strong>互连网</strong>，如图1-1(b) 所示。因此互连网是“<strong>网络的网络</strong>”。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630153611.png"></li><li><strong>网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为主机。</strong></li></ul><h2 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 <strong>互联网基础结构发展的三个阶段</strong></h2><ul><li>第一阶段是从单个网络 ARPANET 向互连网发展的过程。</li><li>第二阶段的特点是建成了<strong>三级结构的互联网</strong>。</li><li>第三阶段的特点是逐渐形成了<strong>多层次 ISP 结构的互联网</strong>。</li></ul><h2 id="1-2-3-互联网的标准化工作"><a href="#1-2-3-互联网的标准化工作" class="headerlink" title="1.2.3 互联网的标准化工作"></a>1.2.3 <strong>互联网的标准化工作</strong></h2><ul><li>国际性组织<strong>互联网协会</strong> (简称 ISOC)，对互联网进行全面管理以及在世界范围内促进其发展和使用。ISOC 下面有一个技术组织叫做<strong>互联网体系结构委员会</strong> (简称 IAB)，负责管理互联网有关协议的开发。IAB 下面又设有两个工程部：<ol><li><strong>互联网工程部</strong>（简称 IETF）</li><li><strong>互联网研究部</strong>（简称 IRTF）</li></ol></li><li>制定互联网的正式标准要经过以下三个阶段：<ol><li><strong>互联网草案</strong>——互联网草案的有效期只有六个月。在这个阶段还不能算是 RFC 文档。</li><li><strong>建议标准</strong>——从这个阶段开始就成为 RFC 文档。</li><li><strong>互联网标准</strong>——达到正式标准后，每个标准就分配到一个编号 STD xx。一个标准可以和多个RFC 文档关联。截止到 2016 年 7 月，互联网标准的最大编号是 STD 83。</li></ol></li></ul><h1 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h1><ul><li>互联网的拓扑结构非常复杂，并且覆盖了全球，从工作方式上看，划分为以下两大块：<ol><li><strong>边缘部分</strong>：由所有连接在互联网上的主机组成。<strong>用户直接使用</strong>，用来进行通信和资源共享。</li><li><strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。<strong>为边缘部分提供服务的</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630205219.png"></li></ol></li></ul><h2 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 <strong>互联网的边缘部分</strong></h2><ol><li><strong>计算机之间通信</strong>：<strong>主机 A 的某个进程和主机 B 上的另一个进程进行通信</strong></li><li><strong>客户——服务器方式</strong><ul><li><strong>客户</strong>和<strong>服务器</strong>是指通信中所涉及的两个应用进程。客户——服务器方式所描述的是进程之间服务和被服务的关系。</li><li><strong>客户是服务请求方，服务器是服务提供方。</strong></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630205735.png"></li><li><strong>客户程序：</strong><ol><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和复杂的操作系统。</li></ol></li><li><strong>服务器程序：</strong><ol><li>是一种用来提供某种服务的程序，<strong>可同时处理</strong>多个远地或本地客户的请求。</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。服务器程序不需要知道客户程序的地址。</li><li>需要有强大的硬件和高级的操作系统支持。</li></ol></li></ul></li><li><strong>对等连接方式</strong><ul><li><strong>对等连接</strong> (简称 P2P) 指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机运行了对等连接软件 (P2P 软件)，就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。因此这种工作方式也称为 <strong>P2P 方式</strong> 。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230630223247.png"></li></ul></li></ol><h2 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2 互联网的核心部分"></a>1.3.2 互联网的核心部分</h2><ol><li>在网络核心部分起特殊作用的是<strong>路由器</strong>，是一种专用计算机。路由器是实现<strong>分组交换</strong>的关键构件，任务是<strong>转发收到的分组</strong>，是网络核心部分最重要的功能。</li><li><strong>电路交换的主要特点</strong><ul><li>从通信资源的分配角度来看，<strong>交换</strong>是按照某种方式动态地分配传输线路的资源</li><li>必须经过“<strong>建立连接</strong> (占用通信资源) →<strong>通话</strong> (一直占用通信资源) →<strong>释放连接</strong> (归还通信资源) ”三个步骤的交换方式称为<strong>电路交换</strong>。</li><li><strong>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</strong>。</li><li>使用电路交换来传送计算机数据时，<strong>线路的传输效率很低</strong>。因为计算机数据是突发式地出现在传输线路上的，因此线路上真正用来传送数据的时间很短。已被用户占用的通信线路资源在绝大部分时间里都是空闲的。</li></ul></li><li><strong>分组交换的主要特点</strong><ul><li>分组交换采用<strong>存储转发</strong>技术。</li><li>把要发送的整块数据称为一个<strong>报文</strong>。在发送报文前，把较长的报文划分成为一个个更小的等长数据段。在每一个数据段前，加上由必要的控制信息组成的<strong>首部</strong> (包头) 后，构成一个<strong>分组</strong> (包)。分组是在互联网中传送的数据单元。分组的首部包含目的地址和源地址等，使分组能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</li><li>位于网络边缘的主机和位于网络核心部分的路由器都是计算机，但作用不一样。<strong>主机是为用户进行信息处理的</strong>，并且可以和其他主机通过网络交换信息。<strong>路由器则是用来转发分组的，进行分组交换的</strong>。路由器收到一个分组，先暂时存储，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地以存储转发的方式，把分组交付最终的目的主机。各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</li><li><strong>分组交换的优点</strong>：<ol><li>高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</li><li>灵活：为每一个分组选择合适的转发路由</li><li>迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性</li></ol></li><li><strong>分组交换的缺点</strong>：<ol><li>分组在各路由器存储转发时需要排队，会造成<strong>时延</strong>。由于分组交换不像电路交换那样通过建立连接来保证通信时所需的各种资源，因而无法确保通信时端到端所需的带宽。</li><li>各分组必须携带的控制信息造成了<strong>开销</strong>。分组交换网需要专门的管理和控制机制。</li></ol></li></ul></li></ol><ul><li>三种交换的比较<ol><li><strong>电路交换</strong>——整个报文的比特流连续地从源点直达终点</li><li><strong>报文交换</strong>——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li><li><strong>分组交换</strong>——单个分组 (这只是整个报文的一部分) 传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701111637.png"></li></ol></li></ul><h1 id="1-4-计算机网络在我国的发展"><a href="#1-4-计算机网络在我国的发展" class="headerlink" title="1.4 计算机网络在我国的发展"></a>1.4 计算机网络在我国的发展</h1><h1 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h1><h2 id="1-5-1-计算机网络的定义"><a href="#1-5-1-计算机网络的定义" class="headerlink" title="1.5.1 计算机网络的定义"></a>1.5.1 计算机网络的定义</h2><ul><li><strong>计算机网络的定义</strong><ol><li>计算机网络：计算机网络主要是由一些通用的、可编程的硬件互连而成的，这些硬件并非专门用来实现某一特定目的，它们能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，还包括了智能手机；计算机网络并非专门用来传送数据，还能支持很多种的应用。</li></ul></li></ol></li></ul><h2 id="1-5-2-几种不同类别的计算机网络"><a href="#1-5-2-几种不同类别的计算机网络" class="headerlink" title="1.5.2 几种不同类别的计算机网络"></a>1.5.2 几种不同类别的计算机网络</h2><ul><li><strong>几种不同类别的计算机网络</strong><ol><li><strong>按照网络的作用范围进行分类</strong><ul><li><strong>广域网</strong> (WAN) 作用范围通常为几十到几千公里，也称<strong>远程网</strong>。广域网是互联网的核心部分，任务是长距离运送主机所发送的数据。连接广域网各结点交换机的链路一般都是高速链路，具有较大的通信容量。</li><li><strong>城域网</strong> (MAN) 作用范围一般是城市，跨越几个街区甚至整个城市，作用距离约为 5～50km。城域网可以为一个或几个单位所拥有，也可以是一种公用设施，用来将多个局域网进行互连。目前很多城域网采用的是以太网技术，因此有时也常并入局域网的范围进行讨论。</li><li><strong>局域网</strong> (LAN) 一般用微型计算机或工作站通过高速通信线路相连 (速率通常在10Mbit&#x2F;s 以上)，但地理上则局限在较小的范围 (如 1km 左右)。在局域网发展的初期，一个学校或工厂往往只拥有一个局域网，但现在局域网已非常广泛地使用，学校或企业大都拥有许多个互连的局域网 (这样的网络常称为<strong>校园网</strong>或<strong>企业网</strong>)。</li><li><strong>个人区域网</strong> (PAN) 在个人工作的地方把属于个人使用的电子设备 (如便携式电脑) 用无线技术连接起来的网络，因此也常称为<strong>无线个人区域网</strong> (WPAN)，其范围很小，大约在10m左右。</li></ul></li><li><strong>按照网络的使用者进行分类</strong><ul><li><strong>公用网</strong>：电信公司 (国有或私有) 出资建造的大型网络。“公用”的意思就是所有愿意按电信公司的规定交纳费用的人都可以使用这种网络。因此公用网也可称为<strong>公众网</strong>。</li><li><strong>专用网</strong>：某个部门为满足本单位的特殊业务工作的需要而建造的网络。这种网络不向本单位以外的人提供服务。例如，军队、铁路、银行、电力等系统均有本系统的专用网。</li></ul></li><li><strong>用来把用户接入到互联网的网络</strong><ul><li><strong>接入网</strong> (AN)，又称为<strong>本地接入网</strong>或<strong>居民接入网</strong></li><li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。是从某个用户端系统到互联网中的第一个路由器之间的一种网络。</li></ul></li></ol></li></ul><h1 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h1><h2 id="1-6-1-计算机网络的性能"><a href="#1-6-1-计算机网络的性能" class="headerlink" title="1.6.1 计算机网络的性能"></a>1.6.1 计算机网络的性能</h2><ul><li><strong>计算机网络的性能指标</strong><ol><li>速率<ul><li><strong>比特</strong>来源于 binary digit，意思是一个“<strong>二进制数字</strong>”，因此一个比特就是二进制数字中的一个 1 或 0。</li><li>比特也是信息论中使用的<strong>信息量的单位</strong>。网络技术中的<strong>速率</strong>指的是<strong>数据的传送速率</strong>，它也称为<strong>数据率</strong>或<strong>比特率</strong>。</li></ul></li><li><strong>带宽</strong><ul><li>带宽本指某个<strong>信号具有的频带宽度</strong>。信号的带宽指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的<strong>带宽的单位</strong>是<strong>赫</strong> (或<strong>千赫、兆赫、吉赫</strong>等)。表示某信道允许通过的信号频带范围称为该信道的<strong>带宽</strong> (<strong>通频带</strong>)。</li><li>在计算机网络中，带宽用来表示网络中某<strong>通道</strong>传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“<strong>最高数据率</strong>”。这种意义的<strong>带宽的单位</strong>就是<strong>数据率的单位</strong> bit&#x2F;s，是<strong>比特每秒</strong>。</li><li>在“带宽”的上述两种表述中，前者为<strong>频域</strong>称谓，而后者为<strong>时域</strong>称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</li></ul></li><li><strong>吞吐量</strong><ul><li><strong>吞吐量</strong>表示在单位时间内通过某个网络的实际的数据量。</li><li>吞吐量受网络的带宽或网络的额定速率的限制。</li></ul></li><li><strong>时延</strong><ul><li><strong>时延</strong>指数据从网络的一端传送到另一端所需的时间。</li><li>时延是很重要的性能指标，有时也称为延迟或迟延。</li><li>时延由以下组成：<ol><li><strong>发送时延</strong>　发送时延是主机或路由器发送数据帧所需要的时间，从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。因此发送时延也叫做<strong>传输时延</strong>。发送时延的计算公式是：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701153549.png"></li><li>发送时延并非固定不变，而是与发送的帧长成正比，与发送速率成反比。</li></ul></li><li><strong>传播时延</strong>　传播时延是电磁波在信道中传播一定的距离需要花费的时间。传播时延的计算公式是：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230701153757.png"></li><li>发送时延发生在机器内部的发送器中，<strong>与传输信道的长度 (或信号传送的距离) 没有关系</strong>。传播时延发生在机器外部的传输信道媒体上，<strong>与信号的发送速率无关</strong>。<strong>信号传送的距离越远，传播时延就越大</strong>。</li></ul></li><li><strong>处理时延</strong> 　主机或路由器在收到分组时要花费时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等，这就产生了处理时延。</li><li><strong>排队时延</strong> 　分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。排队时延的长短往往取决于网络当时的通信量。当网络的通信量很大时会发生队列溢出，使分组丢失，这相当于排队时延为无穷大。</li><li>数据在网络中经历的总时延就是四种时延之和：<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702225623.png"></li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702163416.png"></li><li><strong>对于高速网络链路，提高的仅是数据的发送速率而不是比特在链路上的传播速率</strong>。</li><li><strong>提高数据的发送速率减小了数据的发送时延</strong>。数据的发送速率的单位是每秒发送多少个比特，指在<strong>某个点</strong>或<strong>某个接口上</strong>的发送速率。而传播速率的单位是每秒传播多少公里，指在<strong>某一段传输线路上</strong>比特的传播速率。</li></ol></li></ul></li><li><strong>时延带宽积</strong><ul><li>把网络性能的两个度量——传播时延和带宽相乘，就得到另一个度量：传播<strong>时延带宽积</strong><ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702163707.png"></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164122.png"></li></ol></li><li>若发送端连续发送数据，则在发送的第一个比特即将达到终点时，发送端就已经发送了20 万个比特，而这 20 万个比特都正在链路上向前移动。因此，链路的时延带宽积又称为<strong>以比特为单位的链路长度</strong>。</li></ul></li><li><strong>往返时间 RTT</strong><ul><li>互联网上的信息不是单向传输而是双向交互的。</li><li>A 向 B 发送数据。如果数据长度是 100MB，发送速率是 100Mbit&#x2F;s，那么<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164237.png"></li><li>如果 B 正确收完 100MB 的数据后，就立即向 A 发送确认。再假定 A 只有在收到 B 的确认信息后，才能继续向 B 发送数据。显然，这需要等待一个往返时间 RTT (这里假定确认信息很短，可忽略 B 发送确认的时间)。如果 RTT＝2s，那么可以算出 A 向 B 发送数据的有效数据率。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702164313.png"></li></ol></li></ul></li><li><strong>利用率</strong><ul><li><strong>利用率</strong>有信道利用率和网络利用率两种。<ol><li>信道利用率指出某信道有百分之几的时间是被利用的。完全空闲的信道利用率是零。</li><li>网络利用率是全网络信道利用率的加权平均值。</li><li>信道利用率并非越高越好。根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也迅速增加。和高速公路的情况有些相似。当高速公路上的车流量很大时，由于在公路上的某些地方会出现堵塞，因此行车所需的时间就会变长。同样，当网络的通信量很少时，网络产生的时延并不大。但在网络通信量不断增大的情况下，由于分组在网络结点、进行处理时需要排队等候，因此网络引起的时延就会增大。</li></ol></li><li>如果令 <em>D<sub>0</sub></em> 表示网络空闲时的时延，<em>D</em> 表示网络当前的时延，用下面的公式来表示 <em>D</em>，<em>D<sub>0</sub></em> 和利用率 <em>U</em> 之间的关系：<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702165329.png"></li><li><em>U</em> 是网络的利用率，数值在 0 到 1 之间。当网络的利用率达到其容量的 1&#x2F;2 时，时延就要加倍。</li><li>当网络的利用率接近最大值 1 时，网络的时延就趋于无穷大。</li><li><strong>信道或网络的利用率过高会产生非常大的时延</strong></li><li>一些拥有较大主干网的 ISP 通常控制信道利用率不超过 50％。如果超过了就要准备扩容，增大线路的带宽。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230702205609.png"></li></ol></li></ul></li></ol></li></ul><h2 id="1-6-2-计算机网络的非性能特征"><a href="#1-6-2-计算机网络的非性能特征" class="headerlink" title="1.6.2 计算机网络的非性能特征"></a>1.6.2 计算机网络的非性能特征</h2><ul><li><strong>计算机网络的非性能特征</strong><ol><li><strong>费用</strong><ul><li>网络的性能与其价格密切相关。网络的速率越高，价格也越高。</li></ul></li><li><strong>质量</strong><ul><li>网络的质量取决于网络中所有构件的质量，以及这些构件是怎样组成网络的。网络的质量影响很多方面，如网络的可靠性、网络管理的简易性，以及网络的性能。但网络的性能与网络的质量并不一样。</li></ul></li><li><strong>标准化</strong><ul><li>网络的硬件和软件的设计既可以按照通用的国际标准，也可以遵循特定的专用网络标准。采用国际标准的设计，可以得到更好的互操作性，更易于升级换代和维修，也更容易得到技术上的支持。</li></ul></li><li><strong>可靠性</strong><ul><li>可靠性与网络的质量和性能密切相关。高速网络的可靠性不一定很差。但高速网络要可靠地运行，则往往更加困难，同时所需的费用也会较高。</li></ul></li><li><strong>可扩展性和可升级性</strong><ul><li>在构造网络时应当考虑到今后需要扩展和升级。网络的性能越高，其扩展费用往往也越高，难度也会相应增加。</li></ul></li><li><strong>易于管理和维护</strong><ul><li>网络如果没有良好的管理和维护，很难达到和保持所设计的性能。</li></ul></li></ol></li></ul><h1 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h1><ul><li>在计算机网络的基本概念中，分层次的体系结构是最基本的。</li></ul><h2 id="1-7-1-计算机网络体系结构的形成"><a href="#1-7-1-计算机网络体系结构的形成" class="headerlink" title="1.7.1 计算机网络体系结构的形成"></a>1.7.1 计算机网络体系结构的形成</h2><ul><li><strong>计算机网络体系结构的形成</strong><ol><li>计算机网络是个复杂的系统。、设想一种最简单的情况：连接在网络上的两台计算机要互相传送文件。在这两台计算机之间必须有一条传送数据的通路。但还有以下工作需要完成：<ul><li>发起通信的计算机必须将数据通信的通路进行<strong>激活</strong>，即发出一些信令，保证要传送的计算机数据能在这条通路上正确发送和接收。</li><li>要告诉网络如何识别接收数据的计算机。</li><li>发起通信的计算机必须查明对方计算机是否已开机，并且与网络连接正常。</li><li>发起通信的计算机中的应用程序必须清楚，在对方计算机中的文件管理程序是否已做好接收文件和存储文件的准备工作。</li><li>若计算机的文件格式不兼容，则至少其中一台计算机应完成格式转换功能。</li><li>对出现的各种差错和意外事故，如数据传送错误、重复或丢失，网络中某个结点交换机出现故障等，应当有可靠的措施保证对方计算机最终能够收到正确的文件。</li></ul></li></ol></li></ul><h2 id="1-7-2-协议与划分层次"><a href="#1-7-2-协议与划分层次" class="headerlink" title="1.7.2 协议与划分层次"></a>1.7.2 协议与划分层次</h2><ul><li><strong>协议与划分层次</strong><ol><li>在计算机网络中要做到有条不紊地交换数据，必须遵守一些事先约定好的规则。<strong>这些规则明确规定了所交换的数据的格式以及有关的同步问题</strong>。</li><li><strong>为进行网络中的数据交换而建立的规则、标准或约定</strong>称为<strong>网络协议</strong>。网络协议也可简称为<strong>协议</strong>，主要由以下三个要素组成：<ul><li>语法，即数据与控制信息的结构或格式；</li><li>语义，即需要发出何种控制信息，完成何种动作以及做出何种响应；</li><li>同步，即事件实现顺序的详细说明。</li></ul></li><li>协议通常有两种不同的形式。一种是使用便于人来阅读和理解的文字描述。另一种是使用让计算机能够理解的程序代码。这两种不同形式的协议都必须能够对网络上的信息交换过程做出精确的解释。</li><li>分层可以带来很多好处。如：<ul><li><strong>各层之间是独立的</strong>。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可将一个难以处理的复杂问题分解为若干个较容易处理的更小一些的问题。整个问题的复杂程度就下降了。</li><li><strong>灵活性好</strong>。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某一层提供的服务还可进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。</li><li><strong>结构上可分割开</strong>。各层都可以采用最合适的技术来实现。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。</li><li><strong>能促进标准化工作</strong>。因为每一层的功能及其所提供的服务都已有了精确的说明。</li></ul></li><li>分层时应使每一层的功能非常明确。若层数太少，就会使每一层的协议太复杂。但层数太多又会在描述和综合各层功能的系统工程任务时遇到较多的困难。通常各层所要完成的功能主要有以下一些：<ul><li><strong>差错控制</strong> 　使相应层次对等方的通信更加可靠。</li><li><strong>流量控制</strong> 　发送端的发送速率必须使接收端来得及接收，不能太快。</li><li><strong>分段和重装</strong> 　发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li><strong>复用和分用</strong> 　发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li><strong>连接建立和释放</strong> 　交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li><li>分层也有一些缺点，例如，有些功能会在不同的层次中重复出现，产生额外开销。</li></ul></li><li><strong>计算机网络的各层及其协议的集合</strong>就是网络的<strong>体系结构</strong>。换种说法，<strong>计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义</strong>。</li><li><strong>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件</strong>。</li></ol></li></ul><h2 id="1-7-3-具有五层协议的体系结构"><a href="#1-7-3-具有五层协议的体系结构" class="headerlink" title="1.7.3 具有五层协议的体系结构"></a>1.7.3 具有五层协议的体系结构</h2><ul><li><strong>具有五层协议的体系结构</strong><ol><li><strong>应用层</strong><ul><li>应用层是体系结构中的最高层。</li><li>应用层的任务是<strong>通过应用进程间的交互来完成特定网络应用</strong>。</li><li>应用层协议定义的是<strong>应用进程间通信和交互的规则</strong>。<strong>进程</strong>指主机中<strong>正在运行的程序</strong>。</li><li>应用层交互的数据单元称为<strong>报文</strong>。</li></ul></li><li><strong>运输层</strong><ul><li>运输层的任务是负责向<strong>两台主机中进程之间的通信</strong>提供<strong>通用的数据传输</strong>服务。</li><li>运输层主要使用以下两种协议：<ol><li><strong>传输控制协议</strong> (TCP)——提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>。</li><li><strong>用户数据报协议</strong> (UDP)——提供无连接的、<strong>尽最大努力</strong>的数据传输服务，其数据传输的单位是<strong>用户数据报</strong>。</li></ol></li></ul></li><li><strong>网络层</strong><ul><li>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。</li><li>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成<strong>分组</strong>或<strong>包</strong>进行传送。</li><li>在 TCP&#x2F;IP 体系中，由于网络层使用 IP 协议，因此分组也叫做 <strong>IP 数据报</strong>，简称<strong>数据报</strong>。</li><li><strong>无论在哪一层传送的数据单元，都可笼统地用“分组”来表示</strong>。</li><li>网络层的另一个任务是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</li><li>网络层中的“<strong>网络</strong>”，不是我们谈到的具体网络，而是在计算机网络体系结构模型中的第 3 层的名称。</li><li>互联网是由大量的<strong>异构</strong>网络通过<strong>路由器</strong>相互连接起来的，使用的网络层协议是无连接的<strong>网际协议</strong> (IP) 和许多种路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或 <strong>IP 层</strong>。</li></ul></li><li><strong>数据链路层</strong><ul><li>数据链路层简称<strong>链路层</strong>。</li><li>在两个相邻结点之间传送数据时，数据链路层将网络层交下来的 IP 数据报<strong>组装成帧</strong>，在两个相邻结点间的链路上传送<strong>帧</strong>。每一帧包括数据和<strong>控制信息</strong>。</li></ul></li><li><strong>物理层</strong><ul><li>在物理层上所传数据的单位是<strong>比特</strong>。</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703110014.png"></li><li>图1-19 说明应用进程的数据在各层之间的传递过程中所经历的变化。假定两台主机通过一台路由器连接起来。<ul><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703110122.png"></li><li>假定主机1的应用进程AP 1 向主机2的应用进程AP 2 传送数据。AP 1 先将其数据交给本主机的第5层（应用层）。第5层加上必要的控制信息H 5 就变成了下一层的数据单元。第4层（运输层）收到这个数据单元后，加上本层的控制信息H 4 ，再交给第3层（网络层），成为第3层的数据单元。依此类推。不过到了第2层（数据链路层）后，控制信息被分成两部分，分别加到本层数据单元的首部（H 2 ）和尾部（T 2 ）；而第1层（物理层）由于是比特流的传送，所以不再加上控制信息。请注意，传送比特流时应从首部开始传送。</li><li>OSI参考模型把对等层次之间传送的数据单位称为该层的<strong>协议数据单元</strong>（PDU）。这个名词现已被许多非OSI标准采用。</li><li>当这一串的比特流离开主机1经网络的物理媒体传送到路由器时，就从路由器的第1层依次上升到第3层。每一层都根据控制信息进行必要的操作，然后将控制信息剥去，将该层剩下的数据单元上交给更高的一层。当分组上升到了第3层时，就根据首部中的目的地址查找路由器中的转发表，找出转发分组的接口，然后往下传送到第2层，加上新的首部和尾部后，再到最下面的第1层，然后在物理媒体上把每一个比特发送出去。</li><li>当这一串的比特流离开路由器到达目的站主机2时，就从主机2的第1层按照上面讲过的方式，依次上升到第5层。最后，把应用进程AP 1 发送的数据交给目的站的应用进程AP 2 。</li><li>可以用一个简单例子来比喻上述过程。有一封信从最高层向下传。每经过一层就包上一个新的信封，写上必要的地址信息。包有多个信封的信件传送到目的站后，从第1层起，每层拆开一个信封后就把信封中的信交给它的上一层。传到最高层后，取出发信人所发的信交给收信人。</li><li>虽然应用进程数据要经过如图1-19所示的复杂过程才能送到终点的应用进程，但这些复杂过程对用户来说，却都被屏蔽掉了，以致应用进程AP 1 觉得好像是直接把数据交给了应用进程AP 2 。同理，任何两个同样的层次（例如在两个系统的第4层）之间，也好像如同图1-19中的水平虚线所示的那样，把数据（即数据单元加上控制信息）通过水平虚线直接传递给对方。这就是所谓的“<strong>对等层</strong> ”（peer layers）之间的通信。我们以前经常提到的各层协议，实际上就是在各个对等层之间传递数据时的各项规定。</li><li>在文献中也还可以见到术语“<strong>协议栈</strong>”。这是因为几个层次画在一起很像一个<strong>栈</strong>的结构。</li></ul></li></ol></li></ul><h2 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h2><ul><li><strong>实体、协议、服务和服务访问点</strong><ol><li>当研究开放系统中的信息交换时，使用<strong>实体</strong>这一抽象的名词表示<strong>任何可发送或接收信息的硬件或软件进程</strong>。</li><li><strong>协议是控制两个对等实体</strong> (或<strong>多个实体</strong>) <strong>进行通信的规则的集合</strong>。协议的语法方面规则定义了所交换信息的格式，协议的语义方面规则定义了发送者或接收者所要完成的操作，例如，在何种条件下，数据必须重传或丢弃。</li><li><strong>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</strong></li><li>协议和服务在概念上不一样：<ul><li>协议的实现保证了能够向上一层提供服务。使用本层服务的实体只能看见服务而无法看见下面的协议。下面的协议对上面的实体是透明的。</li><li><strong>协议是“水平的”</strong>，协议是控制对等实体之间通信的规则；但<strong>服务是“垂直的”</strong>，即服务是由下层向上层通过层间接口提供的。</li><li>并非在一个层内完成的全部功能都称为服务。只有能够被高一层实体“<strong>看得见</strong>”的功能才能称之为“服务”。上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令在 OSI 中称为<strong>服务原语</strong>。</li><li>在同一系统中相邻两层的实体进行交互的地方，通常称为<strong>服务访问点</strong> (SAP)。服务访问点 SAP 是一个抽象的概念，是一个逻辑接口，有点像邮政信箱 (可以把邮件放入信箱和从信箱中取走邮件)，但这种层间接口和两个设备之间的硬件接口并不一样。</li><li>在任何相邻两层之间的关系可概括为图 1-20 所示的那样。第 n 层的两个“实体 (n) ”之间通过“协议 (n) ”进行通信，而第 n＋1 层的两个“实体 (n＋1) ”之间则通过另外的“协议 (n＋1) ”进行通信 (每一层都使用不同的协议) 。第 n 层向上面的第 n＋1 层所提供的服务实际上已包括了在它以下各层所提供的服务。第 n 层的实体对第 n+1 层的实体就相当于一个服务提供者。在服务提供者的上一层的实体又称为“服务用户”，因为它使用下层服务提供者所提供的服务。<ol><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703113458.png"></li></ol></li></ul></li></ol></li></ul><h2 id="1-7-5-TCP-IP-的体系结构"><a href="#1-7-5-TCP-IP-的体系结构" class="headerlink" title="1.7.5 TCP&#x2F;IP 的体系结构"></a>1.7.5 TCP&#x2F;IP 的体系结构</h2><ul><li><strong>TCP&#x2F;IP 的体系结构</strong><ol><li>TCP&#x2F;IP 协议<strong>可以为应用提供服务</strong>，同时 TCP&#x2F;IP 协议也<strong>允许 IP 协议在网络构成的互联网上运行</strong>。</li><li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230703152732.png"></li></ol></li></ul><h1 id="本章的重要概念"><a href="#本章的重要概念" class="headerlink" title="本章的重要概念"></a>本章的重要概念</h1><ul><li>计算机网络把计算机连接在一起，互连网把网络连接在一起，是网络的网络。</li><li>以小写字母 i 开始的 internet (互连网) 是通用名词，泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</li><li>以大写字母 I 开始的 Internet (互联网) 是专用名词，指当前全球最大的、开放的、由网络相互连接而成的特定互连网，并采用 TCP&#x2F;IP 协议族作为通信规则。</li><li>互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。</li><li>互联网按工作方式划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</li><li>计算机通信是计算机中进程之间的通信。计算机网络采用的通信方式是客户–服务器方式和对等连接方式 (P2P 方式)。</li><li>客户和服务器指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li><li>按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和个人区域网 PAN。</li><li>计算机网络常用的性能指标是：速率、带宽、吞吐量、时延 (发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道 (或网络) 利用率。</li><li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</li><li>五层协议的体系结构由应用层、运输层、网络层 (或网际层)、数据链路层和物理层组成。运输层最重要的协议是 TCP 和 UDP 协议，而网络层最重要的协议是 IP 协议。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络（谢希仁） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/26/hello-world/"/>
      <url>/2023/11/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hall-A：赛博朋克酒保行动</title>
      <link href="/2023/09/08/hall-a-sai-bo-peng-ke-jiu-bao-xing-dong/"/>
      <url>/2023/09/08/hall-a-sai-bo-peng-ke-jiu-bao-xing-dong/</url>
      
        <content type="html"><![CDATA[<p><strong>调制人生 改变饮料</strong></p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>ingram：看似放荡，实则比较富有学识<br>dorothy haze：开朗可爱的魅魔机器人<br>kim：<br>jamie：独眼杀手<br>kira miki：沉迷于扮演kira而迷失自我的歌星<br>alma：jill的好朋友，好像是黑客？推心置腹，互吐苦水的贝斯特 friend<br>sei：白骑士<br>stella：白骑士的朋友？可爱的富婆<br>art von delay：一名犀利的侦探<br>streaming-chan ：可怜的主动式楚门<br>betty：狗狗公司<br>deal：狗狗公司<br>taylor：一位大脑宅男？<br>virgilio armandio：像个外强中干的变态<br>brian：BTC老大<br>cass：<br>rad shiba：一条柴犬。<br>norma：被过于期待的未成年少女<br>mario：<br>gaby：jill前女友的妹妹<br>nacho：shiba的boss<br>vella：coser<br>essentia：lilim<br>anna：好像是心中的自我？</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>random</title>
      <link href="/2023/09/08/random/"/>
      <url>/2023/09/08/random/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">random.seed(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置完种子后，每次生成的随机数相同</li></ul><pre class="line-numbers language-none"><code class="language-none">random.random()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成0-1的随机浮点数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.randint(strat, stop)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成某一区间的随机整数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.randrange(strat, stop[, step])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成一个在<code>start</code>与<code>stop</code>之间的随机整数，<code>step</code>是随机数之间的不长，<code>step</code>默认为 1 。</li><li><code>random.randrange(0, 10, 2)</code>只能生成0、2、4、6、8中的一个。</li></ul><pre class="line-numbers language-none"><code class="language-none">random.uniform(strat, stop)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成随机浮点数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.choice(seq)random.choice(seq, k)random.sample(seq, k)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>random.choice(seq)</code>用于从序列中获取一个随机元素，并返回一个（列表，元组或字符串中的）随机项，其中参数 <code>seq</code> 是一个非空序列。</li><li><code>random.choice(seq, k)</code>&#x3D;<code>random.sample(seq, k)</code>，表示随机生成<code>k</code>个元素。</li></ul><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>obsidian</title>
      <link href="/2023/09/08/obsidian/"/>
      <url>/2023/09/08/obsidian/</url>
      
        <content type="html"><![CDATA[<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><ul><li>输入<code>[[</code>后，会自动弹出列表对话框，其中包含了笔记名、图片名，选中想要链接的笔记。之后输入<code>^</code>，再次选择笔记中的文本，找到自己想要链接的具体内容；输入<code>|</code>显示链接的名字。在<code>[[]]</code>前加上<code>!</code>会显示出链接的内容。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy</title>
      <link href="/2023/09/08/numpy/"/>
      <url>/2023/09/08/numpy/</url>
      
        <content type="html"><![CDATA[<h5 id="生成数组或序"><a href="#生成数组或序" class="headerlink" title="生成数组或序"></a>生成数组或序</h5><pre class="line-numbers language-none"><code class="language-none">numpy.zeros(shape, dtype&#x3D;float, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>shape</code>：这是一个表示所需数组形状的元组或整数。例如，要创建一个2行3列的零数组，可以使用<code>shape=(2, 3)</code>。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。</li><li>行主序，横为行；列主序，竖为行。<pre class="line-numbers language-none"><code class="language-none">numpy.ones(shape, dtype&#x3D;None, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>shape</code>：这是一个表示所需数组形状的元组或整数。例如，要创建一个2行3列的全1数组，可以使用<code>shape=(2, 3)</code>。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。<pre class="line-numbers language-none"><code class="language-none">numpy.eye(N, M&#x3D;None, k&#x3D;0, dtype&#x3D;float, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>N</code>：矩阵的行数（以及列数，因为单位矩阵是方阵）。这是必需的参数。</li><li><code>M</code>（可选）：矩阵的列数。默认情况下，它等于 <code>N</code>，因此创建的是一个 <code>N x N</code> 的方阵。</li><li><code>k</code>（可选）：对角线的偏移。默认为0，表示主对角线上的元素为1。如果将其设置为正数或负数，将在主对角线上偏离 <code>k</code> 步的位置放置1。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。<pre class="line-numbers language-none"><code class="language-none">numpy.arange([start, ]stop, [step, ]dtype&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>start</code>（可选）：序列的起始值。如果不提供，默认为0。</li><li><code>stop</code>：序列的终止值（不包括该值）。</li><li><code>step</code>（可选）：序列中的值之间的间隔（步长）。如果不提供，默认为1。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下为<code>None</code>，它会自动推断为适当的数据类型。<pre class="line-numbers language-none"><code class="language-none">numpy.linspace(start, stop, num&#x3D;50, endpoint&#x3D;True, retstep&#x3D;False, dtype&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>start</code>：生成的范围的起始值。</li><li><code>stop</code>：生成的范围的结束值。生成的数组将包括此值。</li><li><code>num</code>（可选）：要生成的样本数量，默认为50。</li><li><code>endpoint</code>（可选）：如果为True（默认值），则生成的数组包括<code>stop</code>值；如果为False，生成的数组不包括<code>stop</code>值。</li><li><code>retstep</code>（可选）：如果为True，函数将返回一个元组，其中包括生成的数组和生成的步长值。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>None</code>，这意味着数据类型将根据输入的参数来确定。</li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">numpy.frombuffer(buffer, dtype&#x3D;float, count&#x3D;-1, offset&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>buffer</code>：要从中创建数组的缓冲区对象，通常是字节数组或字节对象。</li><li><code>dtype</code>：可选参数，指定数组的数据类型，默认为 <code>float</code>。你可以指定其他的数据类型，如 <code>int</code>、<code>str</code> 等。</li><li><code>count</code>：可选参数，要从缓冲区中读取的元素数量，默认为 -1，表示读取整个缓冲区的内容。</li><li><code>offset</code>：可选参数，指定从缓冲区的哪个位置开始读取数据，默认为 0，表示从缓冲区的开头开始读取。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pyautogui</title>
      <link href="/2023/09/07/pyautogui/"/>
      <url>/2023/09/07/pyautogui/</url>
      
        <content type="html"><![CDATA[<h5 id="屏幕的分辨率"><a href="#屏幕的分辨率" class="headerlink" title="屏幕的分辨率"></a>屏幕的分辨率</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui  width, height &#x3D; pyautogui.size()  x, y &#x3D; pyautogui.position()    result &#x3D; pyautogui.onScreen(2000, 2222) print(f&quot;宽度：&#123;width&#125;, 高度：&#123;height&#125;&quot;)print(f&quot;&#123;x&#125;, &#123;y&#125;&quot;)print(f&quot;&#123;result&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>print(f&quot;宽度：&#123;width&#125;, 高度：&#123;height&#125;&quot;)</code>中的<code>f</code>将<code>width</code>和<code>height</code>替换成了获取的值，可以将其当成<code>%s</code>的作用。详情见<a href="https://realpython.com/python-f-strings/">f字符串</a></p><h5 id="鼠标的移动"><a href="#鼠标的移动" class="headerlink" title="鼠标的移动"></a>鼠标的移动</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(800, 800, duration&#x3D;2)  pyautogui.move(0, -200, duration&#x3D;0.1)  pyautogui.move(-200, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>duration</code>表示移动持续的时间，不设置<code>duration</code>则默认为0.1。</p><h5 id="拖动鼠标"><a href="#拖动鼠标" class="headerlink" title="拖动鼠标"></a>拖动鼠标</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(700, 530, duration&#x3D;2)  pyautogui.dragTo(1, 1, button&#x3D;&#39;left&#39;, duration&#x3D;2)  pyautogui.drag(100, 400, button&#x3D;&#39;right&#39;, duration&#x3D;2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dragTo</code>是拖动到某个点，<code>drag</code>是向某个方向拖动多少像素。</p><h5 id="鼠标的点击"><a href="#鼠标的点击" class="headerlink" title="鼠标的点击"></a>鼠标的点击</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    x, y &#x3D; pyautogui.position()    pyautogui.click(button&#x3D;&#39;left&#39;)  pyautogui.click(x, y, button&#x3D;&#39;left&#39;, clicks&#x3D;2, interval&#x3D;0.1, duration&#x3D;2)  pyautogui.doubleClick(x, y, button&#x3D;&#39;left&#39;)  pyautogui.tripleClick(x, y, button&#x3D;&#39;left&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="鼠标的按压和释放"><a href="#鼠标的按压和释放" class="headerlink" title="鼠标的按压和释放"></a>鼠标的按压和释放</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.click(328, 190)  pyautogui.moveTo(220, 480)  pyautogui.mouseDown(button&#x3D;&#39;left&#39;)  pyautogui.move(500, 0)  pyautogui.mouseUp(button&#x3D;&#39;left&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="鼠标的滚动"><a href="#鼠标的滚动" class="headerlink" title="鼠标的滚动&#96;&#96;"></a>鼠标的滚动&#96;&#96;</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(220, 480)  pyautogui.scroll(-10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="键盘的输入"><a href="#键盘的输入" class="headerlink" title="键盘的输入"></a>键盘的输入</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.click(960, 460)  pyautogui.write(&#39;This is a test!&#39;, interval&#x3D;0.5)  This is a test!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="键盘的按压"><a href="#键盘的按压" class="headerlink" title="键盘的按压"></a>键盘的按压</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.press(&#39;x&#39;)  pyautogui.press(&#39;crtl&#39;)  pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)    pyautogui.keyDown(&#39;crtl&#39;)  pyautogui.keyUp(&#39;ctrl&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV入门</title>
      <link href="/2023/09/03/opencv-ru-men/"/>
      <url>/2023/09/03/opencv-ru-men/</url>
      
        <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><ol><li>3.4.1之后的一些命令、函数被申请了专利</li></ol><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><pre class="line-numbers language-none"><code class="language-none">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple opencv-python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)    cv2.imshow(&quot;blue&quot;, image[:, :, 0])  cv2.imshow(&quot;green&quot;, image[:, :, 1])  cv2.imshow(&quot;red&quot;, image[:, :, 2])    gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  cv2.imshow(&quot;gray&quot;, gray)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="图像的裁剪"><a href="#图像的裁剪" class="headerlink" title="图像的裁剪"></a>图像的裁剪</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)    crop &#x3D; image[10:170, 40:200]    cv2.imshow(&quot;crop&quot;, crop)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    image &#x3D; np.zeros([300, 300, 3], dtype&#x3D;np.uint8)    cv2.line(image, (100, 200), (250, 250), (255, 255, 0), 2)  cv2.rectangle(image, (30, 100), (60, 150), (0, 255, 255), 4)  cv2.circle(image, (150, 100), 20, (255, 0, 255), 5)  cv2.putText(image, &quot;hello&quot;, (100, 50), 0, 1, (255, 255, 255), 1)    cv2.imshow(&quot;image&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="噪点去除"><a href="#噪点去除" class="headerlink" title="噪点去除"></a>噪点去除</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;plane.jpg&quot;)    gauss &#x3D; cv2.GaussianBlur(image, (5, 5), 0)  median &#x3D; cv2.medianBlur(image, 5)    cv2.imshow(&quot;image&quot;, image)  cv2.imshow(&quot;gauss&quot;, gauss)  cv2.imshow(&quot;median&quot;, median)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取转角"><a href="#获取转角" class="headerlink" title="获取转角"></a>获取转角</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)  gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    corners &#x3D; cv2.goodFeaturesToTrack(gray, 500, 0.1, 10)  for corner in corners:      x, y &#x3D; corner.ravel()      cv2.circle(image, (int(x), int(y)), 3, (255, 0, 255), -1)    cv2.imshow(&quot;corners&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="匹配菱形框"><a href="#匹配菱形框" class="headerlink" title="匹配菱形框"></a>匹配菱形框</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    image &#x3D; cv2.imread(&quot;poker.jpg&quot;)  gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    template &#x3D; gray[75:105, 235:265]    match &#x3D; cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)  location &#x3D; np.where(match &gt;&#x3D; 0.9)    w, h &#x3D; template.shape[0:2]  for p in zip(*location[::-1]):      x1, y1 &#x3D; p[0], p[1]      x2, y2 &#x3D; x1 + w, y1 + h      cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)    cv2.imshow(&quot;image&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="图像明暗变化梯度图"><a href="#图像明暗变化梯度图" class="headerlink" title="图像明暗变化梯度图"></a>图像明暗变化梯度图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    gray &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;, cv2.IMREAD_GRAYSCALE)    laplacian &#x3D; cv2.Laplacian(gray, cv2.CV_64F)  canny &#x3D; cv2.Canny(gray, 100, 200)    cv2.imshow(&quot;gray&quot;, gray)  cv2.imshow(&quot;laplacian&quot;, laplacian)  cv2.imshow(&quot;canny&quot;, canny)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="阈值处理"><a href="#阈值处理" class="headerlink" title="阈值处理"></a>阈值处理</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    gray &#x3D; cv2.imread(&quot;bookpage.jpg&quot;, cv2.IMREAD_GRAYSCALE)  ret, binary &#x3D; cv2.threshold(gray, 10, 255, cv2.THRESH_BINARY)  binary_adaptive &#x3D; cv2.adaptiveThreshold(      gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 155, 1)  ret1, binary_otsu &#x3D; cv2.threshold(gray, 0 ,255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)    cv2.imshow(&quot;gray&quot;, gray)  cv2.imshow(&quot;binary&quot;, binary)  cv2.imshow(&quot;adaptive&quot;, binary_adaptive)  cv2.imshow(&quot;otsu&quot;, binary_otsu)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="形态学算法（腐蚀、膨胀）"><a href="#形态学算法（腐蚀、膨胀）" class="headerlink" title="形态学算法（腐蚀、膨胀）"></a>形态学算法（腐蚀、膨胀）</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    gray &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;, cv2.IMREAD_GRAYSCALE)    _, binary &#x3D; cv2.threshold(gray, 200, 255, cv2. THRESH_BINARY_INV)  kernel &#x3D; np.ones((5, 5), np.uint8)    erosion &#x3D; cv2.erode(binary, kernel)  dilation &#x3D; cv2.dilate(binary, kernel)    cv2.imshow(&quot;binary&quot;, binary)  cv2.imshow(&quot;erosion&quot;, erosion)  cv2.imshow(&quot;dilation&quot;, dilation)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">cv2.cvtColor(src, code[, dst[, dstCn]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>src</code>：需要转换颜色空间的图像。</li><li><code>code</code>：颜色空间转换代码。</li><li><code>dst</code>（可选）：与源图像大小和深度相同的输出图像。</li><li><code>dstCn</code>（可选）：目标图像中的通道数。如果该参数为 0，则根据 <code>src</code> 和 <code>code</code> 自动推导通道数。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.destoryAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>窗口保持打开：如果不调用<code>cv2.destroyAllWindows()</code>，OpenCV创建的窗口将保持打开状态，直到用户手动关闭它们或程序终止。</li><li>可能导致资源泄漏：不关闭窗口可能会导致资源泄漏，特别是在循环中使用<code>cv2.imshow()</code>时，每次迭代都会创建新窗口，而不关闭旧窗口。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.imwrite(filename, image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>filename</code>可以指明路径，如果该路径不存在，则创建。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.imread(filename, image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>filename</code>为读出图片的名字 。</p><pre class="line-numbers language-none"><code class="language-none">cv2.IMREAD_COLORcv2.IMREAD_GRAYSCALEcv2.IMREAD_ANYCOLORcv2.IMREAD_UNCHANGEDcv2.IMREAD_ANYDEPTHcv2.IMREAD_ANYDEPTH|cv2.IMREAD_COLORcv2.IMREAD_REDUCED_GRAYSCALE_2cv2.IMREAD_REDUCED_COLOR_2cv2.IMREAD_REDUCED_GRAYSCALE_4cv2.IMREAD_REDUCED_COLOR_4cv2.IMREAD_REDUCED_GRAYSCALE_8cv2.IMREAD_REDUCED_COLOR_8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cv2.IMREAD_COLOR</code>：以彩色模式加载图像。这是默认选项，为每个通道提供 3 通道 BGR 图像，每个图像具有 8 位值（0-255）。</li><li><code>cv2.IMREAD_GRAYSCALE</code>：以灰度模式加载图像。这提供了一个 8 位灰度图像。</li><li><code>cv2.IMREAD_ANYCOLOR</code>：尝试加载图像，但不关心颜色格式，如果图象是彩色的，它将以彩色模式加载，否则以灰度模式加载。根据文件中的元数据，它提供每通道 8 位的 BGR 图像或 8 位的灰度图像。</li><li><code>cv2.IMREAD_UNCHANGED</code>：加载图像，包括[[杂项#^025801|图像的阿尔法通道]]，不进行任何修改。读取所有图像数据，包括 alpha 或透明通道（如果有）作为第四通道。</li><li><code>cv2.IMREAD_ANYDEPTH</code>：尝试加载图像，不关心位深度，图像的位深度是指每个像素的颜色通道的位数。这将以原始位深度加载灰度图像。 例如，如果文件表示此格式的图像，它将提供每通道 16 位的灰度图像。</li><li><code>cv2.IMREAD_ANYDEPTH | cv2.IMREAD_COLOR</code>：尝试加载图像，不关心位深度，以彩色模式加载。此组合以原始位深度加载 BGR 颜色的图像。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_2</code>：这会以原始分辨率的一半加载灰度图像。 例如，如果文件包含<code>640 x 480</code>的图像，则它将作为<code>640 x 480</code>的图像加载。</li><li><code>cv2.IMREAD_REDUCED_COLOR_2</code>：这将以每通道 8 位 BGR 的颜色加载图像，其分辨率为原始分辨率的一半。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_4</code>：这会以原始分辨率的四分之一加载灰度图像。</li><li><code>cv2.IMREAD_REDUCED_COLOR_4</code>：这将以每通道 8 位的颜色加载原始分辨率的四分之一的图像。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_8</code>：这会以原始分辨率的八分之一以灰度加载图像。</li><li><code>cv2.IMREAD_REDUCED_COLOR_8</code>：这将以每通道 8 位的颜色加载图像，其分辨率为原始分辨率的八分之一。<br>以不同的降采样级别加载图像。这些常量用于加载具有不同降采样级别的图像。数字表示降采样的级别，例如，”2”表示图像宽度和高度减小到原始大小的1&#x2F;2。</li></ul><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="使用numpy-array访问图像数据并显示图像"><a href="#使用numpy-array访问图像数据并显示图像" class="headerlink" title="使用numpy.array访问图像数据并显示图像"></a>使用<code>numpy.array</code>访问图像数据并显示图像</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  img[150, 120] &#x3D; [255, 255, 255]    cv2.imshow(&#39;1&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>操作 BGR 图像中坐标<code>(150, 120)</code>处的像素并将其变成白色像素，</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)    cv2.imshow(&#39;1&#39;, img)    img.itemset((150, 120, 0), 255)    print(img.item(150, 120, 0))      cv2.imshow(&#39;2&#39;, img)cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更改特定像素的蓝色值，例如坐标<code>(150, 120)</code>处的像素。 <code>numpy.array</code>类型提供了一种方便的方法<code>item</code>，它采用三个参数：<code>x</code>（或左侧）位置，<code>y</code>（或顶部）位置以及索引 （<code>x</code>，<code>y</code>）位置处的数组内（请记住，在 BGR 图像中，特定位置的数据是包含 B，G 和 R 值按此顺序排列），并在索引位置返回该值。 另一种方法<code>itemset</code>将特定像素的特定通道的值设置为指定值。 <code>itemset</code>接受两个参数：一个三元素元组（<code>x</code>，<code>y</code>和索引）和新值。</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  img[:, :, 1] &#x3D; 0    cv2.imshow(&#39;1&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>它基本上指示程序从所有行和列中获取所有像素，并将绿色值（三元素 BGR 数组的索引之一）设置为<code>0</code>。 如果显示此图像，您会注意到完全没有绿色。</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)    cv2.imshow(&#39;1&#39;, img)    my_roi &#x3D; img[0:100, 0:100]  img[300:400, 300:400] &#x3D; my_roi    cv2.imshow(&#39;2&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们可以通过使用 NumPy 的数组切片访问原始像素来做几件有趣的事情。 其中之一是定义<strong>兴趣区域</strong>（<strong>ROI</strong>）。 定义区域后，我们可以执行许多操作。 例如，我们可以将此区域绑定到变量，定义第二个区域，并将第一个区域的值分配给第二个区域（因此，将图像的一部分复制到图像中的另一个位置）</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  print(img.shape)  print(img.size)  print(img.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>shape</code>：这是一个描述数组形状的元组。 对于图像，它包含（按顺序）高度，宽度和（如果图像是彩色的）通道数。 <code>shape</code>元组的长度是确定图像是灰度还是彩色的有用方法。 对于灰度图像，我们有<code>len(shape) == 2</code>，对于彩色图像，我们有<code>len(shape) == 3</code>。</li><li><code>size</code>：这是数组中元素的数量。 在灰度图像的情况下，这与像素数相同。 在 BGR 图像的情况下，它是像素数的三倍，因为每个像素都由三个元素（B，G 和 R）表示。</li><li><code>dtype</code>：这是数组元素的数据类型。 对于每通道 8 位图像，数据类型为<code>numpy.uint8</code>。</li></ul><h5 id="读-写视频文件"><a href="#读-写视频文件" class="headerlink" title="读&#x2F;写视频文件"></a>读&#x2F;写视频文件</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    videoCapture &#x3D; cv2.VideoCapture(&#39;MyInputVid.mp4&#39;)  fps &#x3D; videoCapture.get(cv2.CAP_PROP_FPS)  size &#x3D; (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),          int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))  videoWriter &#x3D; cv2.VideoWriter(      &#39;MyOutputVid.mp4&#39;, cv2.VideoWriter_fourcc(*&#39;mp4v&#39;),      fps, size)    success, frame &#x3D; videoCapture.read()  while success:  # Loop until there are no more frames.      videoWriter.write(frame)      success, frame &#x3D; videoCapture.read()    videoCapture.release()  videoWriter.release()  cv2.destroyAllWindows()# 参考书代码import cv2videoCapture &#x3D; cv2.VideoCapture(&#39;MyInputVid.avi&#39;)fps &#x3D; videoCapture.get(cv2.CAP_PROP_FPS)size &#x3D; (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),        int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))videoWriter &#x3D; cv2.VideoWriter(    &#39;MyOutputVid.avi&#39;, cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),    fps, size)success, frame &#x3D; videoCapture.read()while success:  # Loop until there are no more frames.    videoWriter.write(frame)    success, frame &#x3D; videoCapture.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>注意</strong>参考书中适用的视频格式为<code>avi</code>，我将代码略加修改，适配了更常见的<code>mp4</code>格式。</li><li><code>VideoWriter</code>类的构造器的参数值得特别注意。 必须指定视频的文件名。 具有该名称的任何先前存在的文件都将被覆盖。 还必须指定视频编解码器。 可用的编解码器可能因系统而异。 支持的选项可能包括以下内容：<ol><li><code>0</code>：此选项是未压缩的原始视频文件。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;)</code>：此选项是未压缩的 YUV 编码，4:2:0 色度被二次采样。 这种编码具有广泛的兼容性，但会产生大文件。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;P&#39;,&#39;I&#39;,&#39;M&#39;,&#39;1&#39;)</code>：此选项是 MPEG-1。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;V&#39;,&#39;I&#39;,&#39;D&#39;)</code>：此选项是相对较旧的 MPEG-4 编码。 如果要限制生成的视频的大小，这是一个不错的选择。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;P&#39;,&#39;4&#39;,&#39;V&#39;)</code>：此选项是另一种相对较旧的 MPEG-4 编码。 如果要限制生成的视频的大小，这是一个不错的选择。 文件扩展名应为<code>.mp4</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;2&#39;,&#39;6&#39;,&#39;4&#39;)</code>：此选项是相对较新的 MPEG-4 编码。 如果您想限制最终视频的大小，这可能是最好的选择。 文件扩展名应为<code>.mp4</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;T&#39;,&#39;H&#39;,&#39;E&#39;,&#39;O&#39;)</code>：此选项为 <strong>Ogg Vorbis</strong>。 文件扩展名应为<code>.ogv</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;F&#39;,&#39;L&#39;,&#39;V&#39;,&#39;1&#39;)</code>：此选项是 Flash 视频。 文件扩展名应为<code>.flv</code>。</li></ol></li><li>但仍可能会遇见一些问题吗，下面是一些解决方案：<ol><li><strong>重新编译OpenCV</strong>：如果使用的是自定义构建的OpenCV，尝试重新编译OpenCV时确保启用了FFmpeg支持。在CMake配置时，启用相应的选项，以便OpenCV可以使用FFmpeg。然后重新构建OpenCV。</li><li><strong>使用不同的FourCC代码</strong>：尝试使用其他编解码器</li><li><strong>下载并安装对应的库</strong> </li><li><strong>检查OpenCV版本</strong>：如果 OpenCV 版本较旧，可能会存在问题。尝试更新到最新版本的 OpenCV，以获得更好的支持。</li></ol></li><li>还必须指定帧速率和帧大小。 由于我们正在从另一个视频复制，因此可以从<code>VideoCapture</code>类的<code>get</code>方法读取这些属性。</li></ul><h5 id="捕捉相机帧并输出相机"><a href="#捕捉相机帧并输出相机" class="headerlink" title="捕捉相机帧并输出相机"></a>捕捉相机帧并输出相机</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    cameraCapture &#x3D; cv2.VideoCapture(0)  fps &#x3D; 30  # An assumption  size &#x3D; (int(cameraCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),          int(cameraCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))  videoWriter &#x3D; cv2.VideoWriter(      &#39;MyOutputVid.avi&#39;, cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),      fps, size)    success, frame &#x3D; cameraCapture.read()  numFramesRemaining &#x3D; 10 * fps - 1 # 10 seconds of frames  while success and numFramesRemaining &gt; 0:      videoWriter.write(frame)      success, frame &#x3D; cameraCapture.read()      numFramesRemaining -&#x3D; 1    cameraCapture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在窗口中显示摄像机帧"><a href="#在窗口中显示摄像机帧" class="headerlink" title="在窗口中显示摄像机帧"></a>在窗口中显示摄像机帧</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    capture &#x3D; cv2.VideoCapture(0)    while True:      ret, frame &#x3D; capture.read()      cv2.imshow(&quot;camera&quot;, frame)      key &#x3D; cv2.waitKey(1)      if key !&#x3D; -1:          break    capture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>capture.read()</code> 是 OpenCV 中用于从视频捕获设备（例如摄像头）中读取一帧视频的函数。它返回两个值，第一个是布尔值（通常命名为 <code>ret</code>），表示是否成功读取帧，第二个是视频帧本身，通常是一个NumPy数组。</li><li><code>cv2.VideoCapture()</code> 是 OpenCV 中用于创建视频捕获对象的函数，可以用于从摄像头、视频文件或其他视频源中捕获视频帧。它接受一个参数，该参数可以是以下三种类型之一：<ol><li>整数（通常为0、1、2等）：表示要使用的摄像头的索引。通常情况下，0表示默认摄像头，1表示第二个摄像头（如果有多个摄像头）。  <pre class="line-numbers language-none"><code class="language-none">import cv2# 创建一个视频捕获对象，0表示默认摄像头capture &#x3D; cv2.VideoCapture(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>字符串：表示视频文件的路径，可以是本地文件路径或网络视频流的URL。</li><li>IP摄像头地址：如果您有网络摄像头，可以将其IP地址作为字符串传递给 <code>cv2.VideoCapture()</code>，以便从网络摄像头捕获视频。</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2clicked &#x3D; Falsedef onMouse(event, x, y, flags, param):    global clicked    if event &#x3D;&#x3D; cv2.EVENT_LBUTTONUP:        clicked &#x3D; TruecameraCapture &#x3D; cv2.VideoCapture(0)cv2.namedWindow(&#39;MyWindow&#39;)cv2.setMouseCallback(&#39;MyWindow&#39;, onMouse)print(&#39;Showing camera feed. Click window or press any key to stop.&#39;)success, frame &#x3D; cameraCapture.read()while success and cv2.waitKey(1) &#x3D;&#x3D; -1 and not clicked:    cv2.imshow(&#39;MyWindow&#39;, frame)    success, frame &#x3D; cameraCapture.read() cv2.destroyWindow(&#39;MyWindow&#39;)cameraCapture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>def onMouse(event, x, y, flags, param)</code>: 定义一个鼠标事件处理函数<code>onMouse</code>，该函数会在鼠标事件发生时被调用。它接受五个参数：<code>event</code>表示触发的事件类型，<code>x</code>和<code>y</code>表示鼠标事件发生的坐标，<code>flags</code>表示鼠标事件的附加标志，<code>param</code>表示可选参数。<ol><li>在<code>onMouse</code>函数中，当鼠标左键被释放（<code>cv2.EVENT_LBUTTONUP</code>事件）时，将全局变量<code>clicked</code>设置为True，表示用户点击了窗口。</li><li><code>event</code>参数表示触发的鼠标事件类型。在这个函数中，我们检查是否是左键释放事件 (<code>cv2.EVENT_LBUTTONUP</code>)。</li><li><code>x</code>和<code>y</code>参数表示鼠标事件发生的坐标，即鼠标指针在窗口上的位置。</li><li><code>flags</code>参数包含了与事件相关的附加标志，但在这个代码中没有使用。</li><li><code>param</code>参数是可选参数，通常用于传递额外的数据，但在这个代码中也没有使用。</li></ol></li><li><code>cv2.namedWindow(&#39;MyWindow&#39;)</code>: 创建一个名为”MyWindow”的窗口，用于显示摄像头捕获的视频。<ol><li><code>cv2.namedWindow()</code> 是OpenCV库中的一个函数，用于创建一个窗口以显示图像、视频或其他视觉数据。它的一般语法如下：&#96;cv2.namedWindow(winname, flags&#x3D;cv2.WINDOW_AUTOSIZE)</li><li><code>winname</code>: 表示要创建的窗口的名称或标识符。您可以自定义窗口的名称，以便在后续的操作中引用该窗口。</li><li><code>flags</code>（可选参数）: 指定窗口的标志。这是一个可选参数，默认值为<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口的大小会自动根据显示内容调整。您也可以将其设置为<code>cv2.WINDOW_NORMAL</code>，以允许手动调整窗口大小。</li></ol></li><li><code>cv2.setMouseCallback(&#39;MyWindow&#39;, onMouse)</code>: 在窗口”MyWindow”上设置鼠标事件回调函数，以便捕获鼠标事件。<ol><li><code>cv2.setMouseCallback()</code> 是OpenCV中的一个函数，用于设置鼠标事件的回调函数，以便在指定的窗口上捕获和处理鼠标事件。它的一般语法如下：<code>cv2.setMouseCallback(windowName, onMouse, param=None)</code></li><li><code>windowName</code>: 表示要在其上设置鼠标事件回调的窗口的名称。通常，您在使用<code>cv2.namedWindow()</code>创建窗口时指定的窗口名称。</li><li><code>onMouse</code>: 是一个回调函数，用于处理鼠标事件。当鼠标事件发生时，OpenCV将调用此函数并传递相关的事件信息。</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2023/08/31/markdown-yu-fa/"/>
      <url>/2023/08/31/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h5 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h5><ul><li>在一行中用三个以上的星号*、减号-、底线_来建立一个分隔线，行内不能有其他东西，但可以在星号或减号蹭插入空格。<pre class="line-numbers language-none"><code class="language-none">********** * * <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><ul><li>如果段落上的文字要添加删除线，在文字的两端加上两个波浪线~~<pre class="line-numbers language-none"><code class="language-none">~~需要添加删除线的文本~~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h5><ul><li>下划线通过 HTML 的标签来实现<pre class="line-numbers language-none"><code class="language-none">&lt;u&gt;需要添加下划线的文本&lt;&#x2F;u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h5><ul><li>脚注是对文本的补充说明。<pre class="line-numbers language-none"><code class="language-none">[^需要注明的文本]：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h5><ul><li>Markdown 区块引用是在段落开头使用 &gt; 符号，然后后面紧跟一个空格符号。区块可以嵌套使用。<pre class="line-numbers language-none"><code class="language-none">&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; &gt;&gt; &gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h5><ul><li>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，在特殊符号前使用反斜杠” \ “转义特殊字符<pre class="line-numbers language-none"><code class="language-none">*文本斜体*\*正常文本\*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客优化</title>
      <link href="/2023/08/31/bo-ke-you-hua/"/>
      <url>/2023/08/31/bo-ke-you-hua/</url>
      
        <content type="html"><![CDATA[<h5 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h5><ul><li>目录下配置文件<code>_config.yml</code>配置:<pre class="line-numbers language-none"><code class="language-none">theme: hexo-theme-matery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="博客站点相关信息"><a href="#博客站点相关信息" class="headerlink" title="博客站点相关信息"></a>博客站点相关信息</h5><pre class="line-numbers language-none"><code class="language-none">title: 七破风的博客 # 网站标题subtitle: &#39;&#39; # 网站副标题description: &#39;&#39; #keywords: # 关键字author: Chipforn # 博客作者姓名language: zh-CN # 博客使用的语言timezone: &#39;&#39; # 时区，默认电脑时区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码高亮设置"><a href="#代码高亮设置" class="headerlink" title="代码高亮设置"></a>代码高亮设置</h5><ul><li>安装hexo代码高亮插件<pre class="line-numbers language-none"><code class="language-none">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置：<pre class="line-numbers language-none"><code class="language-none">highlight:  enable: falseprism_plugin:  mode: &#39;preprocess&#39;      theme: &#39;tomorrow&#39;  line_number: false      custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h5><ul><li>安装 hexo-generator-search 搜索插件<pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：<pre class="line-numbers language-none"><code class="language-none">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="文章字数统计插件"><a href="#文章字数统计插件" class="headerlink" title="文章字数统计插件"></a>文章字数统计插件</h5><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。</p><pre class="line-numbers language-none"><code class="language-none">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class="line-numbers language-none"><code class="language-none">postInfo:  date: true # 发布日期  update: true # 更新日期  wordCount: true # 文章字数统计  totalCount: true # 站点总文章字数  min2read: true # 文章阅读时长  readCount: true # 文章阅读次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nonebot learning</title>
      <link href="/2023/08/28/nonebot-learning/"/>
      <url>/2023/08/28/nonebot-learning/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
