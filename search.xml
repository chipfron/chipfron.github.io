<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/26/hello-world/"/>
      <url>/2023/11/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hall-A：赛博朋克酒保行动</title>
      <link href="/2023/09/08/hall-a-sai-bo-peng-ke-jiu-bao-xing-dong/"/>
      <url>/2023/09/08/hall-a-sai-bo-peng-ke-jiu-bao-xing-dong/</url>
      
        <content type="html"><![CDATA[<p><strong>调制人生 改变饮料</strong></p><h1 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h1><p>ingram：看似放荡，实则比较富有学识<br>dorothy haze：开朗可爱的魅魔机器人<br>kim：<br>jamie：独眼杀手<br>kira miki：沉迷于扮演kira而迷失自我的歌星<br>alma：jill的好朋友，好像是黑客？推心置腹，互吐苦水的贝斯特 friend<br>sei：白骑士<br>stella：白骑士的朋友？可爱的富婆<br>art von delay：一名犀利的侦探<br>streaming-chan ：可怜的主动式楚门<br>betty：狗狗公司<br>deal：狗狗公司<br>taylor：一位大脑宅男？<br>virgilio armandio：像个外强中干的变态<br>brian：BTC老大<br>cass：<br>rad shiba：一条柴犬。<br>norma：被过于期待的未成年少女<br>mario：<br>gaby：jill前女友的妹妹<br>nacho：shiba的boss<br>vella：coser<br>essentia：lilim<br>anna：好像是心中的自我？</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>random</title>
      <link href="/2023/09/08/random/"/>
      <url>/2023/09/08/random/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">random.seed(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置完种子后，每次生成的随机数相同</li></ul><pre class="line-numbers language-none"><code class="language-none">random.random()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成0-1的随机浮点数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.randint(strat, stop)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成某一区间的随机整数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.randrange(strat, stop[, step])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成一个在<code>start</code>与<code>stop</code>之间的随机整数，<code>step</code>是随机数之间的不长，<code>step</code>默认为 1 。</li><li><code>random.randrange(0, 10, 2)</code>只能生成0、2、4、6、8中的一个。</li></ul><pre class="line-numbers language-none"><code class="language-none">random.uniform(strat, stop)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>生成随机浮点数</li></ul><pre class="line-numbers language-none"><code class="language-none">random.choice(seq)random.choice(seq, k)random.sample(seq, k)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>random.choice(seq)</code>用于从序列中获取一个随机元素，并返回一个（列表，元组或字符串中的）随机项，其中参数 <code>seq</code> 是一个非空序列。</li><li><code>random.choice(seq, k)</code>&#x3D;<code>random.sample(seq, k)</code>，表示随机生成<code>k</code>个元素。</li></ul><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>obsidian</title>
      <link href="/2023/09/08/obsidian/"/>
      <url>/2023/09/08/obsidian/</url>
      
        <content type="html"><![CDATA[<h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><ul><li>输入<code>[[</code>后，会自动弹出列表对话框，其中包含了笔记名、图片名，选中想要链接的笔记。之后输入<code>^</code>，再次选择笔记中的文本，找到自己想要链接的具体内容；输入<code>|</code>显示链接的名字。在<code>[[]]</code>前加上<code>!</code>会显示出链接的内容。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>numpy</title>
      <link href="/2023/09/08/numpy/"/>
      <url>/2023/09/08/numpy/</url>
      
        <content type="html"><![CDATA[<h5 id="生成数组或序"><a href="#生成数组或序" class="headerlink" title="生成数组或序"></a>生成数组或序</h5><pre class="line-numbers language-none"><code class="language-none">numpy.zeros(shape, dtype&#x3D;float, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>shape</code>：这是一个表示所需数组形状的元组或整数。例如，要创建一个2行3列的零数组，可以使用<code>shape=(2, 3)</code>。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。</li><li>行主序，横为行；列主序，竖为行。<pre class="line-numbers language-none"><code class="language-none">numpy.ones(shape, dtype&#x3D;None, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>shape</code>：这是一个表示所需数组形状的元组或整数。例如，要创建一个2行3列的全1数组，可以使用<code>shape=(2, 3)</code>。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。<pre class="line-numbers language-none"><code class="language-none">numpy.eye(N, M&#x3D;None, k&#x3D;0, dtype&#x3D;float, order&#x3D;&#39;C&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>N</code>：矩阵的行数（以及列数，因为单位矩阵是方阵）。这是必需的参数。</li><li><code>M</code>（可选）：矩阵的列数。默认情况下，它等于 <code>N</code>，因此创建的是一个 <code>N x N</code> 的方阵。</li><li><code>k</code>（可选）：对角线的偏移。默认为0，表示主对角线上的元素为1。如果将其设置为正数或负数，将在主对角线上偏离 <code>k</code> 步的位置放置1。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>float64</code>，但你可以根据需要选择其他数据类型，如<code>int</code>、<code>float32</code>等。</li><li><code>order</code>（可选）：这是数组的内存布局方式，通常可以忽略。默认值为’C’，表示按行主序（C顺序），或者可以选择’F’，表示按列主序（Fortran顺序）。<pre class="line-numbers language-none"><code class="language-none">numpy.arange([start, ]stop, [step, ]dtype&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>start</code>（可选）：序列的起始值。如果不提供，默认为0。</li><li><code>stop</code>：序列的终止值（不包括该值）。</li><li><code>step</code>（可选）：序列中的值之间的间隔（步长）。如果不提供，默认为1。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下为<code>None</code>，它会自动推断为适当的数据类型。<pre class="line-numbers language-none"><code class="language-none">numpy.linspace(start, stop, num&#x3D;50, endpoint&#x3D;True, retstep&#x3D;False, dtype&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><code>start</code>：生成的范围的起始值。</li><li><code>stop</code>：生成的范围的结束值。生成的数组将包括此值。</li><li><code>num</code>（可选）：要生成的样本数量，默认为50。</li><li><code>endpoint</code>（可选）：如果为True（默认值），则生成的数组包括<code>stop</code>值；如果为False，生成的数组不包括<code>stop</code>值。</li><li><code>retstep</code>（可选）：如果为True，函数将返回一个元组，其中包括生成的数组和生成的步长值。</li><li><code>dtype</code>（可选）：这是数组的数据类型。默认情况下，它是<code>None</code>，这意味着数据类型将根据输入的参数来确定。</li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">numpy.frombuffer(buffer, dtype&#x3D;float, count&#x3D;-1, offset&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>buffer</code>：要从中创建数组的缓冲区对象，通常是字节数组或字节对象。</li><li><code>dtype</code>：可选参数，指定数组的数据类型，默认为 <code>float</code>。你可以指定其他的数据类型，如 <code>int</code>、<code>str</code> 等。</li><li><code>count</code>：可选参数，要从缓冲区中读取的元素数量，默认为 -1，表示读取整个缓冲区的内容。</li><li><code>offset</code>：可选参数，指定从缓冲区的哪个位置开始读取数据，默认为 0，表示从缓冲区的开头开始读取。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pyautogui</title>
      <link href="/2023/09/07/pyautogui/"/>
      <url>/2023/09/07/pyautogui/</url>
      
        <content type="html"><![CDATA[<h5 id="屏幕的分辨率"><a href="#屏幕的分辨率" class="headerlink" title="屏幕的分辨率"></a>屏幕的分辨率</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui  width, height &#x3D; pyautogui.size()  x, y &#x3D; pyautogui.position()    result &#x3D; pyautogui.onScreen(2000, 2222) print(f&quot;宽度：&#123;width&#125;, 高度：&#123;height&#125;&quot;)print(f&quot;&#123;x&#125;, &#123;y&#125;&quot;)print(f&quot;&#123;result&#125;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>print(f&quot;宽度：&#123;width&#125;, 高度：&#123;height&#125;&quot;)</code>中的<code>f</code>将<code>width</code>和<code>height</code>替换成了获取的值，可以将其当成<code>%s</code>的作用。详情见<a href="https://realpython.com/python-f-strings/">f字符串</a></p><h5 id="鼠标的移动"><a href="#鼠标的移动" class="headerlink" title="鼠标的移动"></a>鼠标的移动</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(800, 800, duration&#x3D;2)  pyautogui.move(0, -200, duration&#x3D;0.1)  pyautogui.move(-200, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>duration</code>表示移动持续的时间，不设置<code>duration</code>则默认为0.1。</p><h5 id="拖动鼠标"><a href="#拖动鼠标" class="headerlink" title="拖动鼠标"></a>拖动鼠标</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(700, 530, duration&#x3D;2)  pyautogui.dragTo(1, 1, button&#x3D;&#39;left&#39;, duration&#x3D;2)  pyautogui.drag(100, 400, button&#x3D;&#39;right&#39;, duration&#x3D;2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dragTo</code>是拖动到某个点，<code>drag</code>是向某个方向拖动多少像素。</p><h5 id="鼠标的点击"><a href="#鼠标的点击" class="headerlink" title="鼠标的点击"></a>鼠标的点击</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    x, y &#x3D; pyautogui.position()    pyautogui.click(button&#x3D;&#39;left&#39;)  pyautogui.click(x, y, button&#x3D;&#39;left&#39;, clicks&#x3D;2, interval&#x3D;0.1, duration&#x3D;2)  pyautogui.doubleClick(x, y, button&#x3D;&#39;left&#39;)  pyautogui.tripleClick(x, y, button&#x3D;&#39;left&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="鼠标的按压和释放"><a href="#鼠标的按压和释放" class="headerlink" title="鼠标的按压和释放"></a>鼠标的按压和释放</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.click(328, 190)  pyautogui.moveTo(220, 480)  pyautogui.mouseDown(button&#x3D;&#39;left&#39;)  pyautogui.move(500, 0)  pyautogui.mouseUp(button&#x3D;&#39;left&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="鼠标的滚动"><a href="#鼠标的滚动" class="headerlink" title="鼠标的滚动&#96;&#96;"></a>鼠标的滚动&#96;&#96;</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.moveTo(220, 480)  pyautogui.scroll(-10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="键盘的输入"><a href="#键盘的输入" class="headerlink" title="键盘的输入"></a>键盘的输入</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.click(960, 460)  pyautogui.write(&#39;This is a test!&#39;, interval&#x3D;0.5)  This is a test!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="键盘的按压"><a href="#键盘的按压" class="headerlink" title="键盘的按压"></a>键盘的按压</h5><pre class="line-numbers language-none"><code class="language-none">import pyautogui    pyautogui.press(&#39;x&#39;)  pyautogui.press(&#39;crtl&#39;)  pyautogui.hotkey(&#39;ctrl&#39;, &#39;v&#39;)    pyautogui.keyDown(&#39;crtl&#39;)  pyautogui.keyUp(&#39;ctrl&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV入门</title>
      <link href="/2023/09/03/opencv-ru-men/"/>
      <url>/2023/09/03/opencv-ru-men/</url>
      
        <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><ol><li>3.4.1之后的一些命令、函数被申请了专利</li></ol><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><pre class="line-numbers language-none"><code class="language-none">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple opencv-python<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="灰度图"><a href="#灰度图" class="headerlink" title="灰度图"></a>灰度图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)    cv2.imshow(&quot;blue&quot;, image[:, :, 0])  cv2.imshow(&quot;green&quot;, image[:, :, 1])  cv2.imshow(&quot;red&quot;, image[:, :, 2])    gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)  cv2.imshow(&quot;gray&quot;, gray)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="图像的裁剪"><a href="#图像的裁剪" class="headerlink" title="图像的裁剪"></a>图像的裁剪</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)    crop &#x3D; image[10:170, 40:200]    cv2.imshow(&quot;crop&quot;, crop)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    image &#x3D; np.zeros([300, 300, 3], dtype&#x3D;np.uint8)    cv2.line(image, (100, 200), (250, 250), (255, 255, 0), 2)  cv2.rectangle(image, (30, 100), (60, 150), (0, 255, 255), 4)  cv2.circle(image, (150, 100), 20, (255, 0, 255), 5)  cv2.putText(image, &quot;hello&quot;, (100, 50), 0, 1, (255, 255, 255), 1)    cv2.imshow(&quot;image&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="噪点去除"><a href="#噪点去除" class="headerlink" title="噪点去除"></a>噪点去除</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;plane.jpg&quot;)    gauss &#x3D; cv2.GaussianBlur(image, (5, 5), 0)  median &#x3D; cv2.medianBlur(image, 5)    cv2.imshow(&quot;image&quot;, image)  cv2.imshow(&quot;gauss&quot;, gauss)  cv2.imshow(&quot;median&quot;, median)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="获取转角"><a href="#获取转角" class="headerlink" title="获取转角"></a>获取转角</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    image &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;)  gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    corners &#x3D; cv2.goodFeaturesToTrack(gray, 500, 0.1, 10)  for corner in corners:      x, y &#x3D; corner.ravel()      cv2.circle(image, (int(x), int(y)), 3, (255, 0, 255), -1)    cv2.imshow(&quot;corners&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="匹配菱形框"><a href="#匹配菱形框" class="headerlink" title="匹配菱形框"></a>匹配菱形框</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    image &#x3D; cv2.imread(&quot;poker.jpg&quot;)  gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)    template &#x3D; gray[75:105, 235:265]    match &#x3D; cv2.matchTemplate(gray, template, cv2.TM_CCOEFF_NORMED)  location &#x3D; np.where(match &gt;&#x3D; 0.9)    w, h &#x3D; template.shape[0:2]  for p in zip(*location[::-1]):      x1, y1 &#x3D; p[0], p[1]      x2, y2 &#x3D; x1 + w, y1 + h      cv2.rectangle(image, (x1, y1), (x2, y2), (0, 255, 0), 2)    cv2.imshow(&quot;image&quot;, image)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="图像明暗变化梯度图"><a href="#图像明暗变化梯度图" class="headerlink" title="图像明暗变化梯度图"></a>图像明暗变化梯度图</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    gray &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;, cv2.IMREAD_GRAYSCALE)    laplacian &#x3D; cv2.Laplacian(gray, cv2.CV_64F)  canny &#x3D; cv2.Canny(gray, 100, 200)    cv2.imshow(&quot;gray&quot;, gray)  cv2.imshow(&quot;laplacian&quot;, laplacian)  cv2.imshow(&quot;canny&quot;, canny)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="阈值处理"><a href="#阈值处理" class="headerlink" title="阈值处理"></a>阈值处理</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    gray &#x3D; cv2.imread(&quot;bookpage.jpg&quot;, cv2.IMREAD_GRAYSCALE)  ret, binary &#x3D; cv2.threshold(gray, 10, 255, cv2.THRESH_BINARY)  binary_adaptive &#x3D; cv2.adaptiveThreshold(      gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 155, 1)  ret1, binary_otsu &#x3D; cv2.threshold(gray, 0 ,255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)    cv2.imshow(&quot;gray&quot;, gray)  cv2.imshow(&quot;binary&quot;, binary)  cv2.imshow(&quot;adaptive&quot;, binary_adaptive)  cv2.imshow(&quot;otsu&quot;, binary_otsu)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="形态学算法（腐蚀、膨胀）"><a href="#形态学算法（腐蚀、膨胀）" class="headerlink" title="形态学算法（腐蚀、膨胀）"></a>形态学算法（腐蚀、膨胀）</h5><pre class="line-numbers language-none"><code class="language-none">import cv2  import numpy as np    gray &#x3D; cv2.imread(&quot;opencv_logo.jpg&quot;, cv2.IMREAD_GRAYSCALE)    _, binary &#x3D; cv2.threshold(gray, 200, 255, cv2. THRESH_BINARY_INV)  kernel &#x3D; np.ones((5, 5), np.uint8)    erosion &#x3D; cv2.erode(binary, kernel)  dilation &#x3D; cv2.dilate(binary, kernel)    cv2.imshow(&quot;binary&quot;, binary)  cv2.imshow(&quot;erosion&quot;, erosion)  cv2.imshow(&quot;dilation&quot;, dilation)    cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><pre class="line-numbers language-none"><code class="language-none">cv2.cvtColor(src, code[, dst[, dstCn]])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>src</code>：需要转换颜色空间的图像。</li><li><code>code</code>：颜色空间转换代码。</li><li><code>dst</code>（可选）：与源图像大小和深度相同的输出图像。</li><li><code>dstCn</code>（可选）：目标图像中的通道数。如果该参数为 0，则根据 <code>src</code> 和 <code>code</code> 自动推导通道数。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.destoryAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>窗口保持打开：如果不调用<code>cv2.destroyAllWindows()</code>，OpenCV创建的窗口将保持打开状态，直到用户手动关闭它们或程序终止。</li><li>可能导致资源泄漏：不关闭窗口可能会导致资源泄漏，特别是在循环中使用<code>cv2.imshow()</code>时，每次迭代都会创建新窗口，而不关闭旧窗口。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.imwrite(filename, image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>filename</code>可以指明路径，如果该路径不存在，则创建。</li></ul><pre class="line-numbers language-none"><code class="language-none">cv2.imread(filename, image)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>filename</code>为读出图片的名字 。</p><pre class="line-numbers language-none"><code class="language-none">cv2.IMREAD_COLORcv2.IMREAD_GRAYSCALEcv2.IMREAD_ANYCOLORcv2.IMREAD_UNCHANGEDcv2.IMREAD_ANYDEPTHcv2.IMREAD_ANYDEPTH|cv2.IMREAD_COLORcv2.IMREAD_REDUCED_GRAYSCALE_2cv2.IMREAD_REDUCED_COLOR_2cv2.IMREAD_REDUCED_GRAYSCALE_4cv2.IMREAD_REDUCED_COLOR_4cv2.IMREAD_REDUCED_GRAYSCALE_8cv2.IMREAD_REDUCED_COLOR_8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>cv2.IMREAD_COLOR</code>：以彩色模式加载图像。这是默认选项，为每个通道提供 3 通道 BGR 图像，每个图像具有 8 位值（0-255）。</li><li><code>cv2.IMREAD_GRAYSCALE</code>：以灰度模式加载图像。这提供了一个 8 位灰度图像。</li><li><code>cv2.IMREAD_ANYCOLOR</code>：尝试加载图像，但不关心颜色格式，如果图象是彩色的，它将以彩色模式加载，否则以灰度模式加载。根据文件中的元数据，它提供每通道 8 位的 BGR 图像或 8 位的灰度图像。</li><li><code>cv2.IMREAD_UNCHANGED</code>：加载图像，包括[[杂项#^025801|图像的阿尔法通道]]，不进行任何修改。读取所有图像数据，包括 alpha 或透明通道（如果有）作为第四通道。</li><li><code>cv2.IMREAD_ANYDEPTH</code>：尝试加载图像，不关心位深度，图像的位深度是指每个像素的颜色通道的位数。这将以原始位深度加载灰度图像。 例如，如果文件表示此格式的图像，它将提供每通道 16 位的灰度图像。</li><li><code>cv2.IMREAD_ANYDEPTH | cv2.IMREAD_COLOR</code>：尝试加载图像，不关心位深度，以彩色模式加载。此组合以原始位深度加载 BGR 颜色的图像。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_2</code>：这会以原始分辨率的一半加载灰度图像。 例如，如果文件包含<code>640 x 480</code>的图像，则它将作为<code>640 x 480</code>的图像加载。</li><li><code>cv2.IMREAD_REDUCED_COLOR_2</code>：这将以每通道 8 位 BGR 的颜色加载图像，其分辨率为原始分辨率的一半。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_4</code>：这会以原始分辨率的四分之一加载灰度图像。</li><li><code>cv2.IMREAD_REDUCED_COLOR_4</code>：这将以每通道 8 位的颜色加载原始分辨率的四分之一的图像。</li><li><code>cv2.IMREAD_REDUCED_GRAYSCALE_8</code>：这会以原始分辨率的八分之一以灰度加载图像。</li><li><code>cv2.IMREAD_REDUCED_COLOR_8</code>：这将以每通道 8 位的颜色加载图像，其分辨率为原始分辨率的八分之一。<br>以不同的降采样级别加载图像。这些常量用于加载具有不同降采样级别的图像。数字表示降采样的级别，例如，”2”表示图像宽度和高度减小到原始大小的1&#x2F;2。</li></ul><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="使用numpy-array访问图像数据并显示图像"><a href="#使用numpy-array访问图像数据并显示图像" class="headerlink" title="使用numpy.array访问图像数据并显示图像"></a>使用<code>numpy.array</code>访问图像数据并显示图像</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  img[150, 120] &#x3D; [255, 255, 255]    cv2.imshow(&#39;1&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>操作 BGR 图像中坐标<code>(150, 120)</code>处的像素并将其变成白色像素，</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)    cv2.imshow(&#39;1&#39;, img)    img.itemset((150, 120, 0), 255)    print(img.item(150, 120, 0))      cv2.imshow(&#39;2&#39;, img)cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更改特定像素的蓝色值，例如坐标<code>(150, 120)</code>处的像素。 <code>numpy.array</code>类型提供了一种方便的方法<code>item</code>，它采用三个参数：<code>x</code>（或左侧）位置，<code>y</code>（或顶部）位置以及索引 （<code>x</code>，<code>y</code>）位置处的数组内（请记住，在 BGR 图像中，特定位置的数据是包含 B，G 和 R 值按此顺序排列），并在索引位置返回该值。 另一种方法<code>itemset</code>将特定像素的特定通道的值设置为指定值。 <code>itemset</code>接受两个参数：一个三元素元组（<code>x</code>，<code>y</code>和索引）和新值。</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  img[:, :, 1] &#x3D; 0    cv2.imshow(&#39;1&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>它基本上指示程序从所有行和列中获取所有像素，并将绿色值（三元素 BGR 数组的索引之一）设置为<code>0</code>。 如果显示此图像，您会注意到完全没有绿色。</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)    cv2.imshow(&#39;1&#39;, img)    my_roi &#x3D; img[0:100, 0:100]  img[300:400, 300:400] &#x3D; my_roi    cv2.imshow(&#39;2&#39;, img)  cv2.waitKey()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>我们可以通过使用 NumPy 的数组切片访问原始像素来做几件有趣的事情。 其中之一是定义<strong>兴趣区域</strong>（<strong>ROI</strong>）。 定义区域后，我们可以执行许多操作。 例如，我们可以将此区域绑定到变量，定义第二个区域，并将第一个区域的值分配给第二个区域（因此，将图像的一部分复制到图像中的另一个位置）</li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2    img &#x3D; cv2.imread(&#39;MyPic.png&#39;)  print(img.shape)  print(img.size)  print(img.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>shape</code>：这是一个描述数组形状的元组。 对于图像，它包含（按顺序）高度，宽度和（如果图像是彩色的）通道数。 <code>shape</code>元组的长度是确定图像是灰度还是彩色的有用方法。 对于灰度图像，我们有<code>len(shape) == 2</code>，对于彩色图像，我们有<code>len(shape) == 3</code>。</li><li><code>size</code>：这是数组中元素的数量。 在灰度图像的情况下，这与像素数相同。 在 BGR 图像的情况下，它是像素数的三倍，因为每个像素都由三个元素（B，G 和 R）表示。</li><li><code>dtype</code>：这是数组元素的数据类型。 对于每通道 8 位图像，数据类型为<code>numpy.uint8</code>。</li></ul><h5 id="读-写视频文件"><a href="#读-写视频文件" class="headerlink" title="读&#x2F;写视频文件"></a>读&#x2F;写视频文件</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    videoCapture &#x3D; cv2.VideoCapture(&#39;MyInputVid.mp4&#39;)  fps &#x3D; videoCapture.get(cv2.CAP_PROP_FPS)  size &#x3D; (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),          int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))  videoWriter &#x3D; cv2.VideoWriter(      &#39;MyOutputVid.mp4&#39;, cv2.VideoWriter_fourcc(*&#39;mp4v&#39;),      fps, size)    success, frame &#x3D; videoCapture.read()  while success:  # Loop until there are no more frames.      videoWriter.write(frame)      success, frame &#x3D; videoCapture.read()    videoCapture.release()  videoWriter.release()  cv2.destroyAllWindows()# 参考书代码import cv2videoCapture &#x3D; cv2.VideoCapture(&#39;MyInputVid.avi&#39;)fps &#x3D; videoCapture.get(cv2.CAP_PROP_FPS)size &#x3D; (int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),        int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))videoWriter &#x3D; cv2.VideoWriter(    &#39;MyOutputVid.avi&#39;, cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),    fps, size)success, frame &#x3D; videoCapture.read()while success:  # Loop until there are no more frames.    videoWriter.write(frame)    success, frame &#x3D; videoCapture.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>注意</strong>参考书中适用的视频格式为<code>avi</code>，我将代码略加修改，适配了更常见的<code>mp4</code>格式。</li><li><code>VideoWriter</code>类的构造器的参数值得特别注意。 必须指定视频的文件名。 具有该名称的任何先前存在的文件都将被覆盖。 还必须指定视频编解码器。 可用的编解码器可能因系统而异。 支持的选项可能包括以下内容：<ol><li><code>0</code>：此选项是未压缩的原始视频文件。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;)</code>：此选项是未压缩的 YUV 编码，4:2:0 色度被二次采样。 这种编码具有广泛的兼容性，但会产生大文件。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;P&#39;,&#39;I&#39;,&#39;M&#39;,&#39;1&#39;)</code>：此选项是 MPEG-1。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;V&#39;,&#39;I&#39;,&#39;D&#39;)</code>：此选项是相对较旧的 MPEG-4 编码。 如果要限制生成的视频的大小，这是一个不错的选择。 文件扩展名应为<code>.avi</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;M&#39;,&#39;P&#39;,&#39;4&#39;,&#39;V&#39;)</code>：此选项是另一种相对较旧的 MPEG-4 编码。 如果要限制生成的视频的大小，这是一个不错的选择。 文件扩展名应为<code>.mp4</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;X&#39;,&#39;2&#39;,&#39;6&#39;,&#39;4&#39;)</code>：此选项是相对较新的 MPEG-4 编码。 如果您想限制最终视频的大小，这可能是最好的选择。 文件扩展名应为<code>.mp4</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;T&#39;,&#39;H&#39;,&#39;E&#39;,&#39;O&#39;)</code>：此选项为 <strong>Ogg Vorbis</strong>。 文件扩展名应为<code>.ogv</code>。</li><li><code>cv2.VideoWriter_fourcc(&#39;F&#39;,&#39;L&#39;,&#39;V&#39;,&#39;1&#39;)</code>：此选项是 Flash 视频。 文件扩展名应为<code>.flv</code>。</li></ol></li><li>但仍可能会遇见一些问题吗，下面是一些解决方案：<ol><li><strong>重新编译OpenCV</strong>：如果使用的是自定义构建的OpenCV，尝试重新编译OpenCV时确保启用了FFmpeg支持。在CMake配置时，启用相应的选项，以便OpenCV可以使用FFmpeg。然后重新构建OpenCV。</li><li><strong>使用不同的FourCC代码</strong>：尝试使用其他编解码器</li><li><strong>下载并安装对应的库</strong> </li><li><strong>检查OpenCV版本</strong>：如果 OpenCV 版本较旧，可能会存在问题。尝试更新到最新版本的 OpenCV，以获得更好的支持。</li></ol></li><li>还必须指定帧速率和帧大小。 由于我们正在从另一个视频复制，因此可以从<code>VideoCapture</code>类的<code>get</code>方法读取这些属性。</li></ul><h5 id="捕捉相机帧并输出相机"><a href="#捕捉相机帧并输出相机" class="headerlink" title="捕捉相机帧并输出相机"></a>捕捉相机帧并输出相机</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    cameraCapture &#x3D; cv2.VideoCapture(0)  fps &#x3D; 30  # An assumption  size &#x3D; (int(cameraCapture.get(cv2.CAP_PROP_FRAME_WIDTH)),          int(cameraCapture.get(cv2.CAP_PROP_FRAME_HEIGHT)))  videoWriter &#x3D; cv2.VideoWriter(      &#39;MyOutputVid.avi&#39;, cv2.VideoWriter_fourcc(&#39;I&#39;,&#39;4&#39;,&#39;2&#39;,&#39;0&#39;),      fps, size)    success, frame &#x3D; cameraCapture.read()  numFramesRemaining &#x3D; 10 * fps - 1 # 10 seconds of frames  while success and numFramesRemaining &gt; 0:      videoWriter.write(frame)      success, frame &#x3D; cameraCapture.read()      numFramesRemaining -&#x3D; 1    cameraCapture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在窗口中显示摄像机帧"><a href="#在窗口中显示摄像机帧" class="headerlink" title="在窗口中显示摄像机帧"></a>在窗口中显示摄像机帧</h5><pre class="line-numbers language-none"><code class="language-none">import cv2    capture &#x3D; cv2.VideoCapture(0)    while True:      ret, frame &#x3D; capture.read()      cv2.imshow(&quot;camera&quot;, frame)      key &#x3D; cv2.waitKey(1)      if key !&#x3D; -1:          break    capture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>capture.read()</code> 是 OpenCV 中用于从视频捕获设备（例如摄像头）中读取一帧视频的函数。它返回两个值，第一个是布尔值（通常命名为 <code>ret</code>），表示是否成功读取帧，第二个是视频帧本身，通常是一个NumPy数组。</li><li><code>cv2.VideoCapture()</code> 是 OpenCV 中用于创建视频捕获对象的函数，可以用于从摄像头、视频文件或其他视频源中捕获视频帧。它接受一个参数，该参数可以是以下三种类型之一：<ol><li>整数（通常为0、1、2等）：表示要使用的摄像头的索引。通常情况下，0表示默认摄像头，1表示第二个摄像头（如果有多个摄像头）。  <pre class="line-numbers language-none"><code class="language-none">import cv2# 创建一个视频捕获对象，0表示默认摄像头capture &#x3D; cv2.VideoCapture(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>字符串：表示视频文件的路径，可以是本地文件路径或网络视频流的URL。</li><li>IP摄像头地址：如果您有网络摄像头，可以将其IP地址作为字符串传递给 <code>cv2.VideoCapture()</code>，以便从网络摄像头捕获视频。</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">import cv2clicked &#x3D; Falsedef onMouse(event, x, y, flags, param):    global clicked    if event &#x3D;&#x3D; cv2.EVENT_LBUTTONUP:        clicked &#x3D; TruecameraCapture &#x3D; cv2.VideoCapture(0)cv2.namedWindow(&#39;MyWindow&#39;)cv2.setMouseCallback(&#39;MyWindow&#39;, onMouse)print(&#39;Showing camera feed. Click window or press any key to stop.&#39;)success, frame &#x3D; cameraCapture.read()while success and cv2.waitKey(1) &#x3D;&#x3D; -1 and not clicked:    cv2.imshow(&#39;MyWindow&#39;, frame)    success, frame &#x3D; cameraCapture.read() cv2.destroyWindow(&#39;MyWindow&#39;)cameraCapture.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>def onMouse(event, x, y, flags, param)</code>: 定义一个鼠标事件处理函数<code>onMouse</code>，该函数会在鼠标事件发生时被调用。它接受五个参数：<code>event</code>表示触发的事件类型，<code>x</code>和<code>y</code>表示鼠标事件发生的坐标，<code>flags</code>表示鼠标事件的附加标志，<code>param</code>表示可选参数。<ol><li>在<code>onMouse</code>函数中，当鼠标左键被释放（<code>cv2.EVENT_LBUTTONUP</code>事件）时，将全局变量<code>clicked</code>设置为True，表示用户点击了窗口。</li><li><code>event</code>参数表示触发的鼠标事件类型。在这个函数中，我们检查是否是左键释放事件 (<code>cv2.EVENT_LBUTTONUP</code>)。</li><li><code>x</code>和<code>y</code>参数表示鼠标事件发生的坐标，即鼠标指针在窗口上的位置。</li><li><code>flags</code>参数包含了与事件相关的附加标志，但在这个代码中没有使用。</li><li><code>param</code>参数是可选参数，通常用于传递额外的数据，但在这个代码中也没有使用。</li></ol></li><li><code>cv2.namedWindow(&#39;MyWindow&#39;)</code>: 创建一个名为”MyWindow”的窗口，用于显示摄像头捕获的视频。<ol><li><code>cv2.namedWindow()</code> 是OpenCV库中的一个函数，用于创建一个窗口以显示图像、视频或其他视觉数据。它的一般语法如下：&#96;cv2.namedWindow(winname, flags&#x3D;cv2.WINDOW_AUTOSIZE)</li><li><code>winname</code>: 表示要创建的窗口的名称或标识符。您可以自定义窗口的名称，以便在后续的操作中引用该窗口。</li><li><code>flags</code>（可选参数）: 指定窗口的标志。这是一个可选参数，默认值为<code>cv2.WINDOW_AUTOSIZE</code>，表示窗口的大小会自动根据显示内容调整。您也可以将其设置为<code>cv2.WINDOW_NORMAL</code>，以允许手动调整窗口大小。</li></ol></li><li><code>cv2.setMouseCallback(&#39;MyWindow&#39;, onMouse)</code>: 在窗口”MyWindow”上设置鼠标事件回调函数，以便捕获鼠标事件。<ol><li><code>cv2.setMouseCallback()</code> 是OpenCV中的一个函数，用于设置鼠标事件的回调函数，以便在指定的窗口上捕获和处理鼠标事件。它的一般语法如下：<code>cv2.setMouseCallback(windowName, onMouse, param=None)</code></li><li><code>windowName</code>: 表示要在其上设置鼠标事件回调的窗口的名称。通常，您在使用<code>cv2.namedWindow()</code>创建窗口时指定的窗口名称。</li><li><code>onMouse</code>: 是一个回调函数，用于处理鼠标事件。当鼠标事件发生时，OpenCV将调用此函数并传递相关的事件信息。</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2023/08/31/markdown-yu-fa/"/>
      <url>/2023/08/31/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h5 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h5><ul><li>在一行中用三个以上的星号*、减号-、底线_来建立一个分隔线，行内不能有其他东西，但可以在星号或减号蹭插入空格。<pre class="line-numbers language-none"><code class="language-none">********** * * <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5><ul><li>如果段落上的文字要添加删除线，在文字的两端加上两个波浪线~~<pre class="line-numbers language-none"><code class="language-none">~~需要添加删除线的文本~~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h5><ul><li>下划线通过 HTML 的标签来实现<pre class="line-numbers language-none"><code class="language-none">&lt;u&gt;需要添加下划线的文本&lt;&#x2F;u&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h5><ul><li>脚注是对文本的补充说明。<pre class="line-numbers language-none"><code class="language-none">[^需要注明的文本]：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h5><ul><li>Markdown 区块引用是在段落开头使用 &gt; 符号，然后后面紧跟一个空格符号。区块可以嵌套使用。<pre class="line-numbers language-none"><code class="language-none">&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt; &gt;&gt; &gt;&gt;&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h5><ul><li>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，在特殊符号前使用反斜杠” \ “转义特殊字符<pre class="line-numbers language-none"><code class="language-none">*文本斜体*\*正常文本\*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="-2"><a href="#-2" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客优化</title>
      <link href="/2023/08/31/bo-ke-you-hua/"/>
      <url>/2023/08/31/bo-ke-you-hua/</url>
      
        <content type="html"><![CDATA[<h5 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h5><ul><li>目录下配置文件<code>_config.yml</code>配置:<pre class="line-numbers language-none"><code class="language-none">theme: hexo-theme-matery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="博客站点相关信息"><a href="#博客站点相关信息" class="headerlink" title="博客站点相关信息"></a>博客站点相关信息</h5><pre class="line-numbers language-none"><code class="language-none">title: 七破风的博客 # 网站标题subtitle: &#39;&#39; # 网站副标题description: &#39;&#39; #keywords: # 关键字author: Chipforn # 博客作者姓名language: zh-CN # 博客使用的语言timezone: &#39;&#39; # 时区，默认电脑时区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码高亮设置"><a href="#代码高亮设置" class="headerlink" title="代码高亮设置"></a>代码高亮设置</h5><ul><li>安装hexo代码高亮插件<pre class="line-numbers language-none"><code class="language-none">npm i -S hexo-prism-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置：<pre class="line-numbers language-none"><code class="language-none">highlight:  enable: falseprism_plugin:  mode: &#39;preprocess&#39;      theme: &#39;tomorrow&#39;  line_number: false      custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h5><ul><li>安装 hexo-generator-search 搜索插件<pre class="line-numbers language-none"><code class="language-none">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：<pre class="line-numbers language-none"><code class="language-none">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="文章字数统计插件"><a href="#文章字数统计插件" class="headerlink" title="文章字数统计插件"></a>文章字数统计插件</h5><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。</p><pre class="line-numbers language-none"><code class="language-none">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class="line-numbers language-none"><code class="language-none">postInfo:  date: true # 发布日期  update: true # 更新日期  wordCount: true # 文章字数统计  totalCount: true # 站点总文章字数  min2read: true # 文章阅读时长  readCount: true # 文章阅读次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nonebot learning</title>
      <link href="/2023/08/28/nonebot-learning/"/>
      <url>/2023/08/28/nonebot-learning/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
