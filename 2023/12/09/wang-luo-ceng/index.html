<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="网络层, 编程">
    <meta name="description" content="4.1 网络层提供的两种服务
表4-1　虚电路服务与数据报服务的对比




4.2 网际协议 IP
网际协议 IP 是 TCP&amp;#x2F;IP 体系中两个主要的协议之一，也是最重要的互联网标准协议之一。
与 IP 协议配套使用的还有三个协">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>网络层 | 七破风的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">七破风的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/navigate" class="waves-effect waves-light">
      
      <i class="fas fa-location-arrow" style="zoom: 0.6;"></i>
      
      <span>导航</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">七破风的博客</div>
        <div class="logo-desc">
            
            高高山顶立，深深海底行。
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/navigate" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-location-arrow"></i>
			
			导航
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">网络层</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E8%B0%A2%E5%B8%8C%E4%BB%81%EF%BC%89/">
                                <span class="chip bg-color">计算机网络（谢希仁）</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-12-09
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-12-19
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    33.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    117 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="4-1-网络层提供的两种服务"><a href="#4-1-网络层提供的两种服务" class="headerlink" title="4.1 网络层提供的两种服务"></a>4.1 网络层提供的两种服务</h1><ul>
<li><strong>表4-1　虚电路服务与数据报服务的对比</strong><ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722192206.png"></li>
</ol>
</li>
</ul>
<h1 id="4-2-网际协议-IP"><a href="#4-2-网际协议-IP" class="headerlink" title="4.2 网际协议 IP"></a>4.2 网际协议 IP</h1><ul>
<li>网际协议 IP 是 TCP&#x2F;IP 体系中两个主要的协议之一，也是最重要的互联网标准协议之一。</li>
<li>与 IP 协议配套使用的还有三个协议：<ol>
<li><strong>地址解析协议 ARP</strong></li>
<li><strong>网际控制报文协议 ICMP</strong></li>
<li><strong>网际组管理协议 IGMP</strong></li>
</ol>
</li>
<li>图 4-2 画出了这三个协议和网际协议 IP 的关系。这一层中，ARP 画在最下面，因为 IP 经常使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722193402.png"></li>
</ol>
</li>
<li>网际协议 IP 是用来使互连起来的许多计算机网络能够进行通信的，因此 TCP&#x2F;IP 体系中的网络层常常被称为<strong>网际层</strong>或 <strong>IP 层</strong>。</li>
</ul>
<h2 id="4-2-1-虚拟互连网络"><a href="#4-2-1-虚拟互连网络" class="headerlink" title="4.2.1 虚拟互连网络"></a>4.2.1 虚拟互连网络</h2><ul>
<li>用户的需求是多种多样的，<strong>没有一种单一的网络能够适应所有用户的需求</strong>。</li>
<li>将网络互相连接起来要使用<strong>中间设备</strong>。根据中间设备所在的层次，有以下不同的中间设备: <ol>
<li>物理层使用的中间设备叫做<strong>转发器</strong>。</li>
<li>数据链路层使用的中间设备叫做<strong>网桥</strong>或<strong>桥接器</strong>。</li>
<li>网络层使用的中间设备叫做<strong>路由器</strong>。</li>
<li>在网络层以上使用的中间设备叫做<strong>网关</strong>。用网关连接两个不兼容的系统需要在高层进行协议的转换。</li>
</ol>
</li>
<li>图 4-3 (a) 表示有许多计算机网络通过路由器进行互连。由于参加互连的计算机网络都使用相同的<strong>网际协议</strong> IP，因此可以把互连以后的计算机网络看成如图 4-3 (b) 所示的一个<strong>虚拟互连网络</strong>。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230722193637.png"></li>
</ol>
</li>
<li>利用 IP 协议可以使性能各异的网络<strong>在网络层上看起来好像是一个统一的网络</strong>。</li>
<li>使用 IP 网的好处是: 当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节。</li>
<li>在图 4-4 所示的互联网中的源主机 H<sub>1</sub> 要把一个 IP 数据报发送给目的主机 H<sub>2</sub>。根据分组交换存储转发概念，主机 H<sub>1</sub> 先查找自己的路由表，看目的主机是否在本网络上。如在，则<strong>直接交付</strong>。如不在，则必须把 IP 数据报发送给某个路由器 (图中的 R<sub>1</sub>)。R<sub>1</sub> 在查找路由表后，知道应当把数据报转发给 R<sub>2</sub> 进行<strong>间接交付</strong>。这样一直转发下去，最后路由器 R<sub>5</sub> 和 H<sub>2</sub> 连接在同一个网络上，不需要再使用别的路由器转发了，于是就把数据报<strong>直接交付</strong>目的主机 H<sub>2</sub>。图中画出了源主机、目的主机以及各路由器的协议栈。主机的协议栈共有五层，但路由器的协议栈只有下三层。图中还画出了数据在各协议栈中流动的方向 (用黑色粗线表示)。在 R<sub>4</sub> 和 R<sub>5</sub> 之间使用了卫星链路，R<sub>5</sub> 所连接的是个无线局域网。在 R<sub>1</sub> 到 R<sub>4</sub> 之间的三个网络则可以是任意类型的网络。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723110729.png"></li>
</ol>
</li>
<li><strong>互联网可以由多种异构网络互连组成</strong>。</li>
</ul>
<h2 id="4-2-2-分类的-IP-地址"><a href="#4-2-2-分类的-IP-地址" class="headerlink" title="4.2.2 分类的 IP 地址"></a>4.2.2 分类的 IP 地址</h2><ul>
<li><strong>IP 地址及其表示方法</strong><ol>
<li>互联网是一个<strong>单一的、抽象的网络</strong>。IP 地址是给互联网上的每台主机 (或路由器) 的每个接口分配一个在全世界范围唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上方便地进行寻址。</li>
<li>IP 地址的编址方法共经过了三个历史阶段：<ul>
<li><strong>分类的 IP 地址</strong>是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li>
<li><strong>子网的划分</strong>是对最基本的编址方法的改进，其标准 RFC 950 在 1985 年通过。</li>
<li><strong>构成超网</strong>是比较新的无分类编址方法。1993年提出后很快就得到推广应用。</li>
</ul>
</li>
<li>“分类的 IP 地址”就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成。第一个字段是<strong>网络号</strong>，它标志主机 (或路由器) 所连接到的网络，网络号是唯一的。第二个字段是<strong>主机号</strong>，它标志该主机 (或路由器)。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。一个 IP 地址<strong>在整个互联网范围内是唯一的</strong>。</li>
<li>这种两级的 IP 地址可以记为：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112010.png"></li>
<li>式 4-1 中的符号“::&#x3D;”表示“<strong>定义为</strong>”。图  4-5 给出了各种 IP 地址的网络号字段和主机号字段，A 类、B 类和 C 类地址都是<strong>单播地址</strong>，是最常用的。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112033.png"></li>
</ol>
</li>
<li>从图4-5 可以看出：<ol>
<li>A 类、B 类和 C 类地址的网络号字段分别为 1、2 和 3 个字节长，而在网络号字段的最前面有 1～3 位的<strong>类别位</strong> ，其数值分别规定为 0，10 和 110。</li>
<li>A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。</li>
<li>D 类地址 (前 4 位是 1110) 用于<strong>多播</strong>。</li>
<li>E 类地址 (前 4 位是 1111) 保留为以后用。</li>
</ol>
</li>
</ul>
</li>
<li>从 IP 地址的结构来看，<strong>IP</strong> 地址并不仅仅指明一台主机，还指明了主机所连接到的网络。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112436.png"></li>
</ol>
</li>
<li><strong>常用的三种类别的 IP 地址</strong><ol>
<li>A类地址<ul>
<li>A 类地址的网络号字段占 1 个字节，只有 7 位可供使用 (该字段的第一位固定为 0)，但可指派的网络号是 126 个 (即 2<sup>7</sup>–2)。减 2 的原因是：第一，IP 地址中的全 0 表示“<strong>这个</strong>”。网络号字段为全 0 的 IP 地址是个保留地址，意思是“<strong>本网络</strong>”；第二，网络号为 127 (即01111111) 保留作为本地软件<strong>环回测试</strong>本主机的进程之间的通信。若主机发送一个目的地址为环回地址 (例如127.0.0.1) 的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址不是网络地址。</li>
<li>A 类地址的主机号占 3 个字节，因此每一个 A 类网络中的最大主机数是 2<sup>24</sup>–2，即16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是“本主机”所连接到的<strong>单个网络地址</strong> (例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是5.0.0.0)，全 1 表示“<strong>所有的</strong>”，因此全 1 的主机号字段表示该网络上的所有主机。</li>
<li>IP 地址空间共有 2<sup>32</sup> (4294967296) 个地址。整个 A 类地址空间共有 2<sup>31</sup> 个地址，占整个IP地址空间的 50％。</li>
</ul>
</li>
<li>B 类地址<ul>
<li>B 类地址的网络号字段有 2 个字节，前面两位 (10) 已固定了，剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此不存在网络总数减 2 的问题。实际上 B 类网络地址 128.0.0.0 是不指派的，可以指派的 B 类最小网络地址是 128.1.0.0。因此 B 类地址可指派的网络数为 2<sup>14</sup>−1，即 16383。B 类地址的每一个网络上的最大主机数是 2<sup>16</sup>–2，即 65534。这里需要减2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 2<sup>30</sup> 个地址，占整个 IP地址空间的 25％。</li>
</ul>
</li>
<li>C 类地址<ul>
<li>C 类地址有 3 个字节的网络号字段，最前面的 3 位是 (110)，还有 21 位可以进行分配。C类网络地址 192.0.0.0 是不指派的，可指派的 C 类最小网络地址 192.0.1.0，因此 C 类地址可指派的网络总数是 2<sup>21</sup>−1，即 2097151。每一个 C 类地址的最大主机数是 2<sup>8</sup>–2，即254。整个 C 类地址空间共约有 2<sup>29</sup> 个地址，占整个 IP 地址的 12.5％。</li>
</ul>
</li>
<li>得出表 4-2 所示的 IP 地址的指派范围。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112931.png"></li>
</ul>
</li>
<li>表 4-3 给出了一般不使用的特殊 IP 地址，这些地址只能在特定的情况下使用。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723112945.png"></li>
</ul>
</li>
<li>IP 地址具有以下一些重要特点：<ul>
<li>每个 IP 地址都由网络号和主机号两部分组成。IP 地址是一种<strong>分等级的地址结构</strong>。分两个等级的好处是：<ol>
<li>IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong> (第一级)，而剩下的主机号 (第二级) 由得到该网络号的单位自行分配。方便了 IP 地址的管理。</li>
<li>路由器<strong>仅根据目的主机所连接的网络号来转发分组</strong> (不考虑目的主机号)，可以使路由表中的项目数大幅度减少，从而<strong>减小了路由表所占的存储空间以及查找路由表的时间</strong>。</li>
</ol>
</li>
<li>实际上 IP 地址是标志一台主机 (或路由器) 和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为<strong>多归属主机</strong>。一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。</li>
<li>一个网络指具有相同网络号 net-id 的主机的集合，因此，<strong>用转发器或网桥连接的若干个局域网仍为一个网络</strong>，这些局域网具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。</li>
<li>在 IP 地址中，所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域)，互联网都会同等对待每一个 IP 地址。</li>
</ul>
</li>
<li><h2 id="图-4-7-画出了三个局域网-LAN1，LAN2-和-LAN3-通过三个路由器-R1，R2-和-R3-互连起来所构成的一个互联网-互联网用虚线圆角方框表示-。其中局域网-LAN2-是由两个网段通过网桥-B-互连的。图中的小圆圈表示需要有-IP-地址。"><a href="#图-4-7-画出了三个局域网-LAN1，LAN2-和-LAN3-通过三个路由器-R1，R2-和-R3-互连起来所构成的一个互联网-互联网用虚线圆角方框表示-。其中局域网-LAN2-是由两个网段通过网桥-B-互连的。图中的小圆圈表示需要有-IP-地址。" class="headerlink" title="图 4-7 画出了三个局域网 (LAN1，LAN2 和 LAN3) 通过三个路由器 (R1，R2 和 R3) 互连起来所构成的一个互联网 (互联网用虚线圆角方框表示)。其中局域网 LAN2 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有 IP 地址。 - "></a>图 4-7 画出了三个局域网 (LAN<sub>1</sub>，LAN<sub>2</sub> 和 LAN<sub>3</sub>) 通过三个路由器 (R<sub>1</sub>，R<sub>2</sub> 和 R<sub>3</sub>) 互连起来所构成的一个互联网 (互联网用虚线圆角方框表示)。其中局域网 LAN<sub>2</sub> 是由两个网段通过网桥 B 互连的。图中的小圆圈表示需要有 IP 地址。<br> - <img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723113523.png"></h2><pre><code> 1. 在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的。图中所示的网络号就是 IP 地址中的网络号字段的值。另一种表示方法是用主机号为全 0 的网络IP 地址。
 2. 用网桥互连的网段仍然是一个局域网，只能有一个网络号。
 3. 路由器总是具有两个或两个以上的 IP 地址。即路由器的每一个接口都有一个不同网络号的 IP 地址。
 4. 当两个路由器直接相连时 (例如通过一条租用线路)，在连线两端的接口处，可以分配也可以不分配 IP 地址。如分配了 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” (如图中的 N&lt;sub&gt;1&lt;/sub&gt;，N&lt;sub&gt;2&lt;/sub&gt; 和 N&lt;sub&gt;3&lt;/sub&gt;)。之所以叫做“网络”是因为它有 IP 地址。但为了节省 IP 地址资源，对于这种仅由一段连线构成的特殊“网络”，现在也常常不分配 IP 地址。通常把这样的特殊网络叫做**无编号网络**或**无名网络**。
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="4-2-3-IP-地址与硬件地址"><a href="#4-2-3-IP-地址与硬件地址" class="headerlink" title="4.2.3 IP 地址与硬件地址"></a>4.2.3 IP 地址与硬件地址</h2><ul>
<li>图 4-8 说明了物理地址与 IP 地址的区别。从层次的角度看，<strong>物理地址是数据链路层和物理层使用的地址</strong>，IP <strong>地址是网络层和以上各层使用的地址，是一种逻辑地址</strong> (称 IP 地址为逻辑地址是因为 IP 地址是用软件实现的)。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723113843.png"></li>
</ol>
</li>
<li>在发送数据时，数据从高层下到低层，然后到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中；连接在通信链路上的设备 (主机或路由器) 在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址；总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。</li>
<li>图 4-9 (a) 画的是三个局域网用两个路由器 R<sub>1</sub> 和 R<sub>2</sub> 互连起来。现在主机 H<sub>1</sub> 要和主机 H<sub>2</sub> 通信。这两台主机的 IP 地址分别是 IP<sub>1</sub> 和 IP<sub>2</sub>，而它们的硬件地址分别为 HA<sub>1</sub> 和 HA<sub>2</sub> (HA 表示 Hardware Address)。通信的路径是：H<sub>1</sub>→ 经过 R<sub>1</sub> 转发 → 再经过 R<sub>2</sub> 转发 →H<sub>2</sub>。路由器 R<sub>1</sub> 因同时连接到两个局域网上，因此它有两个硬件地址，即 HA<sub>3</sub> 和 HA<sub>4</sub>。同理，路由器 R<sub>2</sub> 也有两个硬件地址 HA<sub>5</sub> 和 HA<sub>6</sub>。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723234703.png"></li>
<li>图 4-9 (b) 特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230723234720.png"></li>
</ul>
</li>
</ol>
</li>
<li>强调指出以下几点：<ol>
<li><strong>在 IP 层抽象的互联网上只能看到 IP 数据报</strong>。虽然 IP 数据报要经过路由器 R<sub>1</sub> 和 R<sub>2</sub> 的两次转发，但源地址和目的地址始终是 IP<sub>1</sub> 和 IP<sub>2</sub>。图中的数据报上写的“从 IP<sub>1</sub> 到 IP<sub>2</sub>”表示前者是源地址，后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</li>
<li>虽然在 IP 数据报首部有源站 IP 地址，但<strong>路由器只根据目的站的 IP 地址的网络号进行路由选择</strong>。</li>
<li><strong>在局域网的链路层，只能看见 MAC 帧</strong>。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图4-9 (b)。开始在 H<sub>1</sub> 到 R<sub>1</sub> 间传送时，MAC 帧首部中写的是从硬件地址 HA<sub>1</sub> 发送到硬件地址 HA<sub>3</sub>，路由器 R<sub>1</sub> 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新添加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 HA<sub>4</sub>和 HA<sub>5</sub>。路由器 R<sub>2</sub> 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变成为 HA<sub>6</sub> 和 HA<sub>2</sub>。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。</li>
<li>尽管互连在一起的网络的硬件地址体系各不相同，<strong>但 IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。在网络层上讨论问题时，能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信</strong>。</li>
</ol>
</li>
</ul>
<h2 id="4-2-4-地址解析协议-ARP"><a href="#4-2-4-地址解析协议-ARP" class="headerlink" title="4.2.4 地址解析协议 ARP"></a>4.2.4 地址解析协议 ARP</h2><ul>
<li>图 4-10 说明了 ARP 协议的作用。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724110352.png"></li>
</ol>
</li>
<li>在网络层中，数据包使用 IP 地址进行路由和传输。然而，在实际的网络链路上，数据帧必须使用该网络的硬件地址进行传输。</li>
<li><strong>地址解析协议</strong> ARP 是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新 (新增或超时删除)。</li>
<li>如果不使用 ARP 高速缓存，那么任何一台主机只要进行一次通信，就必须在网络上用广播方式发送 ARP 请求分组，使网络上的通信量增加。ARP 把已经得到的地址映射保存在高速缓存中，使该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。</li>
<li>ARP 对保存在高速缓存中的每一个映射地址项目设置<strong>生存时间</strong>，超过生存时间的项目就从高速缓存中删除掉。</li>
<li>ARP 解决<strong>同一个局域网上</strong>的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，就无法解析另一个局域网主机的硬件地址。</li>
<li>归纳出使用 ARP 的四种典型情况 (图 4-12)。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724110844.png"></li>
<li>发送方是主机 (如 H<sub>1</sub>)，要把 IP 数据报发送到同一个网络上的另一台主机 (如 H<sub>2</sub>)。这时 H<sub>1</sub> 发送 ARP 请求分组 (在网 1 上广播)，找到目的主机 H<sub>2</sub> 的硬件地址。</li>
<li>发送方是主机 (如 H<sub>1</sub>），要把 IP 数据报发送到另一个网络上的一台主机 (如 H<sub>3</sub> 或 H<sub>4</sub>)。这时 H<sub>1</sub>发送 ARP 请求分组 (在网 1 上广播)，找到网 1 上的一个路由器 R<sub>1</sub> 的硬件地址。剩下的工作由路由器 R<sub>1</sub> 来完成。R<sub>1</sub> 要做的事情是下面的 (3) 或 (4)。</li>
<li>发送方是路由器 (如 R<sub>1</sub>)，要把 IP 数据报转发到与 R<sub>1</sub> 连接在同一个网络 (网 2) 上的主机 (如 H<sub>3</sub>)。这时 R<sub>1</sub> 发送 ARP 请求分组 (在网 2 上广播)，找到目的主机 H<sub>3</sub> 的硬件地址。</li>
<li>发送方是路由器 (如 R<sub>1</sub>)，要把 IP 数据报转发到网3上的一台主机 (如 H<sub>4</sub>)。H<sub>4</sub> 与 R<sub>1</sub> 不是连接在同一个网络上。这时 R<sub>1</sub> 发送 ARP 请求分组 (在网 2 上广播)，找到连接在网 2 上的一个路由器 R<sub>2</sub> 的硬件地址。剩下的工作由这个路由器 R<sub>2</sub> 来完成。</li>
</ol>
</li>
<li>存在着各式各样的网络，<strong>它们使用不同的硬件地址</strong>。要使这些异构网络能够互相通信就必须进行<strong>非常复杂的硬件地址转换工作</strong>，因此由用户或用户主机来完成这项工作几乎是不可能的事。</li>
</ul>
<h2 id="4-2-5-IP-数据报的格式"><a href="#4-2-5-IP-数据报的格式" class="headerlink" title="4.2.5 IP 数据报的格式"></a>4.2.5 IP 数据报的格式</h2><ul>
<li>图 4-13 是 IP 数据报的完整格式。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230724111741.png"></li>
</ol>
</li>
<li>一个 IP 数据报由首部和数据两部分组成。首部的前一部分是<strong>固定长度</strong>，共 20 字节，所有 IP 数据报必须具有。在首部的固定部分的后面是一些<strong>可选字段</strong>，其长度可变。</li>
<li><strong>IP 数据报首部的固定部分中的各字段</strong><ol>
<li><strong>版本</strong>   占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4 (即 IPv4)。</li>
<li><strong>首部长度</strong>   占 4 位，可表示的最大十进制数值是 15。首部长度字段所表示数的单位是 32 位字长 (1 个 32 位字长是 4 字节)。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 0101。而当首部长度为最大值 1111 时，就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用，但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节 (即首部长度为 0101)，这时不使用任何选项。</li>
<li><strong>区分服务</strong>   占 8 位，用来获得更好的服务。只有在使用区分服务时，这个字段才起作用，在一般的情况下都不使用这个字段。</li>
<li><strong>总长度</strong>   总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 2<sup>16</sup>–1＝65535 字节。</li>
<li><strong>标识</strong>   占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。</li>
<li><strong>标志</strong>   占 3 位，目前只有两位有意义。<ul>
<li>标志字段中的最低位记为 <strong>MF</strong>。MF＝1 即表示后面“<strong>还有分片</strong>”的数据报。MF＝0 表示这已是若干数据报片中的最后一个。</li>
<li>标志字段中间的一位记为 <strong>DF</strong>，意思是“<strong>不能分片</strong>”。只有当 DF＝0 时才允许分片。</li>
</ul>
</li>
<li><strong>片偏移</strong>   占 13 位。片偏移指：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位，每个分片的长度是 8 字节 (64 位) 的整数倍。</li>
<li><strong>生存时间</strong> 　占 8 位。生存时间字段的英文缩写是 TTL，是数据报在网络中的<strong>寿命</strong>。由发出数据报的源点设置这个字段。目的是防止无法交付的数据报无限制地在互联网中兜圈子，消耗网络资源。最初的设计是以秒作为 TTL 的单位。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉的一段时间。若数据报在路由器消耗的时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。</li>
<li><strong>协议</strong>   占 8 位。协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP 层知道应将数据部分上交给哪个协议进行处理。</li>
<li><strong>首部检验和</strong>   占 16 位。这个字段<strong>只检验数据报的首部，但不包括数据部分</strong>。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和，但不检验数据部分可减少计算的工作量。为了进一步减小计算检验和的工作量，IP 首部的检验和不采用复杂的 CRC 检验码而采用下面的简单计算方法：在发送方，先把 IP 数据报首部划分为许多 16 位字的序列，并把检验和字段置零。用反码算术运算把所有 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，将首部的所有 16 位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。若首部未发生任何变化，则此结果必为 0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。图 4-15 说明了 IP 数据报首部检验和的计算过程。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230729164523.png"></li>
</ol>
</li>
<li><strong>源地址</strong> 　占 32 位。</li>
<li><strong>目的地址</strong> 　占 32 位。</li>
</ol>
</li>
<li><strong>IP 数据报首部的可变部分</strong><ol>
<li>IP 数据报首部的可变部分是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容丰富。</li>
<li>增加首部的可变部分是为了增加 IP 数据报的功能，同时也增加了每一个路由器处理数据报的开销。</li>
</ol>
</li>
</ul>
<h2 id="4-2-6-IP-层转发分组的流程"><a href="#4-2-6-IP-层转发分组的流程" class="headerlink" title="4.2.6 IP 层转发分组的流程"></a>4.2.6 IP 层转发分组的流程</h2><ul>
<li>若路由表指出到每一台主机应怎样转发，则所得出的路由表就会过于庞大，即<strong>每一行对应于一台主机</strong>；但若路由表指出到某个网络应如何转发，则每个路由器中的路由表就只包含 4 个项目，即<strong>每一行对应于一个网络</strong>。</li>
<li>在互联网上转发分组时，是<strong>从一个路由器转发到下一个路由器</strong>。</li>
<li>在路由表中，对每一条路由最主要的是以下两个信息：<strong>目的网络地址，下一跳地址</strong>。</li>
<li>根据目的网络地址来确定下一跳路由器，可得出以下的结果：<ol>
<li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li>
<li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li>
</ol>
</li>
<li>互联网所有的分组转发都是<strong>基于目的主机所在的网络</strong>。</li>
<li>采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，也可在需要考虑某种安全问题时采用这种特定主机路由。</li>
<li>路由器还可采用<strong>默认路由</strong>以减小路由表所占用的空间和搜索路由表所用的时间。</li>
<li><strong>分组转发算法</strong>如下：<ol>
<li>从数据报的首部提取目的主机的 IP 地址 <em>D</em>，得出目的网络地址为 <em>N</em>。</li>
<li>若 <em>N</em> 是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 <em>D</em> 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行 3。</li>
<li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。</li>
<li>若路由表中有到达网络 <em>N</em> 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 5。</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。</li>
<li>报告转发分组出错。</li>
</ol>
</li>
</ul>
<h1 id="4-3-划分子网和构造超网"><a href="#4-3-划分子网和构造超网" class="headerlink" title="4.3 划分子网和构造超网"></a>4.3 划分子网和构造超网</h1><h2 id="4-3-1-划分子网"><a href="#4-3-1-划分子网" class="headerlink" title="4.3.1 划分子网"></a>4.3.1 划分子网</h2><ul>
<li><strong>从两级 IP 地址到三级 IP 地址</strong><ol>
<li>在 ARPANET 的早期，IP 地址的设计不够合理：<ul>
<li>IP <strong>地址空间的利用率有时很低</strong></li>
<li>给每一个物理网络分配一个网络号会<strong>使路由表变得太大</strong>因而使网络性能变坏</li>
<li><strong>两级 IP 地址不够灵活</strong></li>
</ul>
</li>
<li>为解决上述问题，在 IP 地址中增加了一个“<strong>子网号字段</strong>”，使两级 IP 地址变成为三级 IP地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做<strong>划分子网</strong>，或<strong>子网寻址</strong>或<strong>子网路由选择</strong>。划分子网已成为互联网的正式标准协议。</li>
<li>划分子网的基本思路如下：<ul>
<li>一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个<strong>子网</strong>。划分子网是一个单位内部的事情。本单位以外的网络<strong>看不见</strong>这个网络是由多少个子网组成，因为这个单位<strong>对外仍然表现为一个网络</strong>。</li>
<li>划分子网的方法是从网络的主机号借用若干位作为子网号，主机号也就相应减少了同样的位数。于是两级 IP 地址在<strong>本单位内部</strong>就变为<strong>三级</strong> IP 地址：网络号、子网号和主机号。也可以用以下记法来表示：IP 地址 ::&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</li>
<li>凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的子网，把 IP 数据报交付目的主机。</li>
</ul>
</li>
</ol>
</li>
<li><strong>子网掩码</strong><ol>
<li>从 IP 数据报的首部<strong>无法看出</strong>源主机或目的主机所连接的网络是否进行了子网的划分。因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关子网划分的信息。必须使用<strong>子网掩码</strong>。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730151524.png"></li>
</ul>
</li>
<li>使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的“与”运算，就立即得出网络地址来。</li>
<li>为了更便于查找路由表，即使在不划分子网时，还要使用子网掩码。</li>
<li>如果一个网络不划分子网，那么该网络的子网掩码就使用<strong>默认子网掩码</strong>。默认子网掩码中 1 的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相“与”，就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。<ul>
<li>A 类地址的默认子网掩码是 255.0.0.0，或 0xFF000000。</li>
<li>B 类地址的默认子网掩码是 255.255.0.0，或 0xFFFF0000。</li>
<li>C 类地址的默认子网掩码是 255.255.255.0，或 0xFFFFFF00。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730153614.png"></li>
</ul>
</li>
<li><strong>子网掩码是一个网络或一个子网的重要属性</strong>。</li>
<li>采用固定长度子网时，所划分的<strong>所有</strong>子网的子网掩码都是相同的<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230730153818.png"></li>
<li>子网数是根据子网号 subnet-id 计算出来的。若 subnet-id 有 <em>n</em> 位，则共有 2<sup>n</sup> 种可能的排列。除去全 0 和全 1 这两种情况，就得出表中的子网数。</li>
</ul>
</li>
<li>虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，<strong>现在全 1 和全 0 的子网号也可以使用了</strong>。</li>
<li><strong>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数</strong>。</li>
</ol>
</li>
</ul>
<h2 id="4-3-2-使用子网时分组的转发"><a href="#4-3-2-使用子网时分组的转发" class="headerlink" title="4.3.2 使用子网时分组的转发"></a>4.3.2 使用子网时分组的转发</h2><ul>
<li>使用子网划分后，路由表必须包含以下三项内容：<strong>目的网络地址、子网掩码和下一跳地址</strong>。</li>
<li>在划分子网的情况下，路由器转发分组的算法如下：<ol>
<li>从收到的数据报的首部提取目的 IP 地址 <em>D</em>。</li>
<li>先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 <em>D</em> 逐位相“<strong>与</strong>” (AND 操作)，看结果是否和相应的网络地址匹配。若匹配，则把分组进行直接交付)，转发任务结束。否则是间接交付，执行 3。</li>
<li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 4。</li>
<li>对路由表中的每一行 (目的网络地址，子网掩码，下一跳地址)，用其中的子网掩码和 <em>D</em> 逐位相“与” (AND操作)，其结果为 <em>N</em>。若 <em>N</em> 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行 5。</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 6。</li>
<li>报告转发分组出错。</li>
</ol>
</li>
</ul>
<h2 id="4-3-3-无分类编址-CIDR-构造超网"><a href="#4-3-3-无分类编址-CIDR-构造超网" class="headerlink" title="4.3.3 无分类编址 CIDR (构造超网)"></a>4.3.3 无分类编址 CIDR (构造超网)</h2><ul>
<li><strong>网络前缀</strong><ol>
<li>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：<ul>
<li>B 类地址在 1992 年已分配了近一半，很快将分配完毕。</li>
<li>互联网主干网上的路由表中的项目数急剧增长。</li>
<li>整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽。</li>
</ul>
</li>
<li>早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。使用<strong>变长子网掩码</strong> VLSM 可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出<strong>无分类编址</strong>方法，它的正式名字是<strong>无分类域间路由选择</strong> CIDR。</li>
<li>CIDR 主要的特点有两个：<ul>
<li>CIDR <strong>消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念</strong>，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是“<strong>网络前缀</strong>” (简称“<strong>前缀</strong>”)，用来指明网络，后面部分则用来指明主机。因此 CIDR 使 IP 地址从三级编址 (使用子网掩码) 又回到了两级编址，但这已是<strong>无分类的两级编址</strong>。其记法是：IP 地址 ::&#x3D;{&lt;网络前缀&gt;,&lt;主机号&gt;}；CIDR 还使用“<strong>斜线记法</strong>”，或称为 <strong>CIDR 记法</strong> ，即在 IP 地址后面加上斜线“&#x2F;”，然后写上网络前缀所占的位数。</li>
<li>CIDR 把<strong>网络前缀都相同</strong>的连续的 IP 地址组成一个“CIDR <strong>地址块</strong>”。只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址 (即最小地址) 和最大地址，以及地址块中的地址数。</li>
</ul>
</li>
<li>为了更方便地进行路由选择，CIDR 使用 32 位的<strong>地址掩码</strong>。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为<strong>子网掩码</strong>。<strong>斜线记法中，斜线后面的数字就是地址掩码中 1 的个数</strong>。</li>
<li>由于一个 CIDR 地址块中有很多地址，所以在路由表中就利用 CIDR 地址块来查找目的网络。这种地址的聚合常称为<strong>路由聚合</strong> (构成超网)，它使得路由表中的一个项目可以表示原来传统分类地址的很多个 (例如上千个) 路由。</li>
<li>路由聚合有利于减少路由器之间的路由选择信息的交换，提高了整个互联网的性能。</li>
<li>使用 CIDR 的一个好处就是可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。</li>
<li><strong>网络前缀越短，其地址块所包含的地址数就越多</strong>。</li>
</ol>
</li>
<li><strong>最长前缀匹配</strong><ol>
<li>在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要有相应的改变。每个项目由“<strong>网络前缀</strong>”和“<strong>下一跳地址</strong>”组成。在查找路由表时<strong>可能会得到不止一个匹配结果</strong>。</li>
<li><strong>最长前缀匹配</strong>是<strong>从匹配结果中选择具有最长网络前缀的路由</strong>，最长前缀匹配又称为<strong>最长匹配</strong>或<strong>最佳匹配</strong>。</li>
<li>网络前缀越长，地址块越小，路由越具体。</li>
</ol>
</li>
<li><strong>使用二叉线索查找路由表</strong><ol>
<li>使用 CIDR 后，由于要寻找最长前缀匹配，路由表的查找过程变得更加复杂了。</li>
<li>对无分类编址的路由表的最简单的查找算法是对所有可能的前缀进行循环查找，这种简单算法的缺点是查找的次数太多。最坏的情况是路由表中没有这个路由。</li>
<li>为了进行更加有效的查找，通常把无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。最常用的就是<strong>二叉线索</strong>，它是一种特殊结构的树。IP 地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。</li>
<li>为了提高二叉线索的查找速度，使用了各种<strong>压缩技术</strong>。</li>
</ol>
</li>
</ul>
<h1 id="4-4-网际控制报文协议-ICMP"><a href="#4-4-网际控制报文协议-ICMP" class="headerlink" title="4.4 网际控制报文协议 ICMP"></a>4.4 网际控制报文协议 ICMP</h1><ul>
<li>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了<strong>网际控制报文协议 ICMP</strong>。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议，但不是高层协议，而是 IP 层的协议。ICMP 报文作为 IP 层数据报的数据部分，加上数据报的首部，组成 IP 数据报发送出去。ICMP 报文格式如图 4-27 所示。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230731164920.png"></li>
</ol>
</li>
</ul>
<h2 id="4-4-1-ICMP-报文的种类"><a href="#4-4-1-ICMP-报文的种类" class="headerlink" title="4.4.1 ICMP 报文的种类"></a>4.4.1 ICMP 报文的种类</h2><ul>
<li>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</li>
<li>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段，其长度取决于 ICMP 的类型。表 4-8 给出了几种常用的 ICMP 报文类型。</li>
<li>ICMP 报文的代码字段能进一步区分某种类型中的几种不同情况。检验和字段用来检验整个 ICMP 报文。IP 数据报首部的检验和并不检验 IP 数据报的内容 (检验首部)，因此不能保证经过传输的 ICMP 报文不产生差错。</li>
<li>表 4-8 给出的 ICMP 差错报告报文共有四种：<ol>
<li><strong>终点不可达</strong> 　当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li>
<li><strong>时间超过</strong> 　当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li>
<li><strong>参数问题</strong> 　当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li>
<li><strong>改变路由 (重定向)</strong> 　路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器 (可通过更好的路由)。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230802183434.png"></li>
</ol>
</li>
<li>对改变路由报文进行解释。在互联网的主机中要有一个路由表，当主机要发送数据报时，首先查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由 (通过和其他路由器交换路由信息)。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器 R (而不是默认路由器)。</li>
<li>所有的 ICMP 差错报告报文中的数据字段都具有同样的格式 (图 4-28)。把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段。再加上相应的 ICMP 差错报告报文的前 8 个字节，就构成了 ICMP 差错报告报文。提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号 (对于 TCP 和 UDP) 以及运输层报文的发送序号 (对于 TCP)。这些信息对源点通知高层协议是有用的。整个 ICMP报文作为 IP 数据报的数据字段发送给源点。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230802184415.png"></li>
</ol>
</li>
<li>下面是不应发送 ICMP 差错报告报文的几种情况：<ol>
<li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。</li>
<li>对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。</li>
<li>对具有多播地址的数据报，都不发送 ICMP 差错报告报文。</li>
<li>对具有特殊地址 (如 127.0.0.0 或 0.0.0.0) 的数据报，不发送 ICMP 差错报告报文。</li>
</ol>
</li>
<li>常用的 ICMP 询问报文有两种，即：<ol>
<li><strong>回送请求和回答</strong> 　ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。</li>
<li><strong>时间戳请求和回答</strong> 　ICMP 时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。****</li>
</ol>
</li>
</ul>
<h2 id="4-4-2-ICMP的应用举例"><a href="#4-4-2-ICMP的应用举例" class="headerlink" title="4.4.2 ICMP的应用举例"></a>4.4.2 ICMP的应用举例</h2><ul>
<li>ICMP 的一个重要应用是分组网间探测 <strong>PING</strong>，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的一个例子，没有通过运输层的 TCP 或 UDP。</li>
<li>另一个非常有用的应用是 traceroute (这是 UNIX 操作系统中名字)，它用来跟踪一个分组从源点到终点的路径。在 Windows 操作系统中这个命令是 tracert。</li>
</ul>
<h1 id="4-5-互联网的路由选择协议"><a href="#4-5-互联网的路由选择协议" class="headerlink" title="4.5 互联网的路由选择协议"></a>4.5 互联网的路由选择协议</h1><h2 id="4-5-1-有关路由选择协议的几个基本概念"><a href="#4-5-1-有关路由选择协议的几个基本概念" class="headerlink" title="4.5.1 有关路由选择协议的几个基本概念"></a>4.5.1 有关路由选择协议的几个基本概念</h2><ul>
<li><strong>理想的路由算法</strong><ol>
<li>路由选择协议的核心是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点：<ul>
<li><strong>算法必须是正确的和完整的</strong>。“正确”是：沿着各路由表所指引的路由，分组一定能够最终到达目的网络和目的主机。</li>
<li><strong>算法在计算上应简单</strong>。路由选择的计算不应使网络通信量增加太多的额外开销。</li>
<li><strong>算法应能适应通信量和网络拓扑的变化</strong>，要有<strong>自适应性</strong>。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些结点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为“<strong>稳健性</strong>“。</li>
<li><strong>算法应具有稳定性</strong>。在网络通信量和网络拓扑相对稳定的情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。</li>
<li><strong>算法应是公平的</strong>。路由选择算法应对所有用户 (除对少数优先级高的用户) 都是平等的。</li>
<li><strong>算法应是最佳的</strong>。路由选择算法应当能找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。</li>
</ul>
</li>
<li>路由选择是个复杂的问题，因为它是网络中的所有结点共同协调工作的结果。其次，路由选择的环境是不断变化的，这种变化无法事先知道，此外，当网络发生拥塞时，需要有能缓解拥塞的路由选择策略。</li>
<li>从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，有两大类：<ul>
<li><strong>静态路由选择策略</strong>，也称<strong>非自适应路由选择</strong><ol>
<li>特点：简单、开销小，但不能及时适应网络状态的变化。对于很简单的小网络，采用静态路由选择，用人工配置每一条路由。</li>
</ol>
</li>
<li><strong>动态路由选择策略</strong>，也称<strong>自适应路由选择</strong><ol>
<li>特点：能较好地适应网络状态的变化，实现起来较复杂，开销也较大。因此，动态路由选择适用于较复杂的大网络。</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>分层次的路由选择协议</strong><ol>
<li>互联网采用的路由选择协议主要是自适应的 (即动态的)、分布式路由选择协议。由于以下两个原因，互联网采用分层次的路由选择协议：<ul>
<li>互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。</li>
<li>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议，但同时还希望连接到互联网上。</li>
</ul>
</li>
<li>可以把整个互联网划分为许多较小的<strong>自治系统</strong>，一般记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是<strong>一个单一的和一致的路由选择策略</strong>。</li>
<li>在目前的互联网中，一个 ISP 就是一个自治系统。互联网就把路由选择协议划分为两大类：<ul>
<li><strong>内部网关协议</strong> IGP　在一个自治系统内部使用的路由选择协议，与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。</li>
<li><strong>外部网关协议</strong> EGP　若源主机和目的主机处在不同的自治系统中 (这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，需要使用协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4 (BGP-4)。</li>
</ul>
</li>
<li>自治系统之间的路由选择叫做<strong>域间路由选择</strong>，自治系统内部的路由选择叫做<strong>域内路由选择</strong>。</li>
<li>图 4-31 是两个自治系统互连在一起的示意图。每个自治系统自己决定在本自治系统内部运行哪一个内部路由选择协议 (例如，可以是 RIP，也可以是 OSPF)，但每个自治系统都有一个或多个路由器 (图中的路由器 R<sub>1</sub> 和 R<sub>2</sub>) ,除运行本系统的内部路由选择协议外，还要运行自治系统间的路由选择协议 (BGP-4)。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230803100909.png"></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4-5-2-内部网关协议-RIP"><a href="#4-5-2-内部网关协议-RIP" class="headerlink" title="4.5.2 内部网关协议 RIP"></a>4.5.2 内部网关协议 RIP</h2><ul>
<li><strong>工作原理</strong><ol>
<li>RIP 是内部网关协议 IGP 中最先广泛使用的协议，是一种分布式的<strong>基于距离向量的路由选择协议</strong>，是互联网的标准协议，最大优点是简单。</li>
<li>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录 (因此，这是<strong>一组距离</strong>，即“<strong>距离向量</strong>”)。</li>
<li>RIP 认为好的路由通过的路由器的数目少，即“距离短”。它允许一条路径最多只能包含 15 个路由器。因此“距离”等于 16 时即相当于不可达。<strong>RIP 只适用于小型互联网</strong>。</li>
<li>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由 (即最短路由)，哪怕还存在另一条高速 (低时延) 但路由器较多的路由。</li>
<li>RIP协议的特点是：<ul>
<li><strong>仅和相邻路由器交换信息</strong>。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。</li>
<li>路由器交换的信息是<strong>当前本路由器所知道的全部信息，即自己现在的路由表</strong>。即：“我到本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器”。</li>
<li><strong>按固定的时间间隔</strong>交换路由信息，然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</li>
</ul>
</li>
<li>路由器在<strong>刚刚开始工作时</strong>，它的路由表是空的。然后路由器就得出直接相连的几个网络的距离 (这些距离定义为 1)。接着，每一个路由器只和<strong>数目非常有限的</strong>相邻路由器交换并更新路由信息。经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。 </li>
<li>在一般情况下，RIP 协议可以<strong>收敛</strong>，且过程较快。“收敛”是在自治系统中所有的结点都得到正确的路由选择信息的过程。</li>
<li>路由表中主要的信息是：到某个网络的距离 (即最短距离)，以及应经过的下一跳地址。路由表更新的原则是找出到每个目的网络的<strong>最短距离</strong>。这种更新算法又称为<strong>距离向量算法</strong>。</li>
</ol>
</li>
<li><strong>距离向量算法</strong><ol>
<li>对<strong>每一个相邻路由器</strong>发送过来的 RIP 报文，进行以下步骤：<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的<strong>所有项目</strong> ：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。每一个项目都有三个关键数据，即：到目的网络 N，距离是 d，下一跳路由器是 X。</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：若原来的路由表中没有目的网络 N，则把该项目添加到路由表中。否则（即在路由表中有目的网络 N，这时就再查看下一跳路由器地址）若下一跳路由器地址是 X，则把收到的项目替换原路由表中的项目。否则（即这个项目是：到目的网络 N，但下一跳路由器不是 X）若收到的项目中的距离 d 小于路由表中的距离，则进行更新，否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为 16（距离为 16 表示不可达）。</li>
<li>返回。</li>
</ul>
</li>
<li>RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从<strong>每一个路由器到每一个目的网络的路由都是最短的</strong>。</li>
<li>所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表也应当是不同的。</li>
</ol>
</li>
<li><strong>RIP 协议的报文格式</strong><ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230803131532.png"></li>
<li>RIP 协议使用运输层的用户数据报 UDP 进行传送。</li>
<li>RIP 报文由首部和路由部分组成。</li>
<li>RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1 表示请求路由信息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的“必为 0”是为了 4 字节字的对齐。</li>
<li>RIP 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。<strong>地址族标识符</strong> (地址类别) 字段用来标志所使用的地址协议。如采用 IP 地址就令这个字段的值为 2。<strong>路由标记</strong>填入<strong>自治系统号</strong> ASN，因为 RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个<strong>网络地址</strong>、该网络的<strong>子网掩码</strong>、<strong>下一跳路由器地址</strong>以及<strong>到此网络的距离</strong>。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4＋20×25＝504 字节。如超过，必须再用一个 RIP 报文来传送。</li>
<li>RIP 具有简单的鉴别功能。若使用鉴别功能，则将原来写入第一个路由信息 (20 字节) 的位置用作鉴别。这时应将地址族标识符置为全 1 (即 0xFFFF)，而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，这时最多只能再放入 24 个路由信息。</li>
<li>RIP 的问题是<strong>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器</strong>。网络出故障的传播时间往往需要较长的时间。这是 RIP 的主要缺点。</li>
<li>RIP 协议的优点是<strong>实现简单，开销小</strong>。</li>
<li>RIP 有很多缺点：RIP 限制了网络的规模，它能使用的最大距离为 15 (16 表示不可达)。其次，路由器之间交换的路由信息是路由器中的完整路由表，随着网络规模的扩大，开销也增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用 OSPF 协议。在规模较小的网络中，使用 RIP 协议。</li>
</ol>
</li>
</ul>
<h2 id="4-5-3-内部网关协议-OSPF"><a href="#4-5-3-内部网关协议-OSPF" class="headerlink" title="4.5.3 内部网关协议 OSPF"></a>4.5.3 内部网关协议 OSPF</h2><ul>
<li><strong>OSPF 协议的基本特点</strong><ol>
<li>协议的名字是<strong>开放最短路径优先</strong> OSPF，是为克服 RIP 的缺点开发出来的。</li>
<li>OSPF 只是一个协议的名字，<strong>并不表示其他的路由选择协议不是“最短路径优先”</strong>。所有的在自治系统内部使用的路由选择协议 (包括 RIP 协议) 都要寻找一条最短的路径。</li>
<li>OSPF 主要的特征是使用分布式的<strong>链路状态协议</strong>，不像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样：<ul>
<li>向本自治系统中<strong>所有路由器</strong>发送信息。使用的方法是<strong>洪泛法</strong>，就是路由器通过所有输出端口向所有相邻的路由器发送信息。每一个相邻路由器又再将此信息发往其所有的相邻路由器 (但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。RIP 协议仅仅向自己相邻的几个路由器发送信息。</li>
<li>发送的信息是与本路由器<strong>相邻的所有路由器的链路状态</strong>，但这只是路由器知道的<strong>部分信息</strong>。所谓“链路状态”就是说明本路由器和哪些路由器相邻，以及该链路的“<strong>度量</strong>”。度量用来表示费用、距离、时延、带宽等等。这些由网络管理人员决定，较灵活。有时为了方便就称度量为“<strong>代价</strong>”。对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。</li>
<li>只有当链路状态<strong>发生变化时</strong>，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。</li>
</ul>
</li>
<li>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库</strong>，这个数据库实际上是全网的拓扑结构图。</li>
<li>RIP 协议的每一个路由器虽然知道到所有的网络的距离以及下一跳路由器，但却<strong>不知道全网的拓扑结构</strong>。</li>
<li>OSPF 的<strong>更新过程收敛得快</strong>是其重要优点。</li>
<li>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统划分为若干个更小的范围，叫做<strong>区域</strong>。图 4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符 (用点分十进制表示)。一个区域不能太大，在一个区域内的路由器最好不超过 200 个。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804152244.png"></li>
</ul>
</li>
<li>划分区域的好处是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用<strong>层次结构的区域划分</strong>。在上层的区域叫做<strong>主干区域</strong>。主干区域的标识符规定为 0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息由<strong>区域边界路由器</strong>进行概括。在图 4-34 中，路由器 R<sub>3</sub>，R<sub>4</sub> 和 R<sub>7</sub> 都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫做<strong>主干路由器</strong>，如 R<sub>3</sub>，R<sub>4</sub>，R<sub>5</sub>，R<sub>6</sub> 和 R<sub>7</sub>。一个主干路由器可以同时是区域边界路由器，如 R<sub>3</sub>，R<sub>4</sub> 和 R<sub>7</sub>。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做<strong>自治系统边界路由器</strong> (如图中的 R<sub>6</sub>)。</li>
<li>采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复杂。但这样做却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议能够用于规模很大的自治系统中。</li>
<li>OSPF 不用 UDP 而是<strong>直接用 IP 数据报传送</strong> (其 IP 数据报首部的协议字段值为 89)。OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li>
<li>OSPF 分组使用 24 字节的固定长度首部 (见图 4-35)，分组的数据部分可以是五种类型分组中的一种：<ul>
<li><strong>版本</strong> 　当前的版本号是 2。</li>
<li><strong>类型</strong> 　可以是五种类型分组中的一种。</li>
<li><strong>分组长度</strong> 　包括 OSPF 首部在内的分组长度，以字节为单位。</li>
<li><strong>路由器标识符</strong> 　标志发送该分组的路由器的接口的 IP 地址。</li>
<li><strong>区域标识符</strong> 　分组属于的区域的标识符。</li>
<li><strong>检验和</strong> 　用来检测分组中的差错。</li>
<li><strong>鉴别类型</strong> 　只有两种，0 (不用) 和1 (口令)。</li>
<li><strong>鉴别</strong> 　鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字符的口令。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804152901.png"></li>
</ul>
</li>
<li>除了以上的几个基本特点外，OSPF 还具有下列的一些特点：<ul>
<li>OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF <strong>对于不同类型的业务可计算出不同的路由</strong>。链路的代价可以是 1 至 65535 中的任何一个无量纲的数，因此十分灵活。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。</li>
<li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的<strong>负载平衡</strong>。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。</li>
<li>所有在 OSPF 路由器之间交换的分组 (例如，链路状态更新分组) 都具有鉴别的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。</li>
<li>OSPF 支持可变长度的子网划分和无分类的编址 CIDR。</li>
<li>由于网络中的链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过每 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复号。</li>
</ul>
</li>
</ol>
</li>
<li><strong>OSPF 的五种分组类型</strong><ol>
<li>OSPF 有五种分组类型：<ul>
<li><strong>类型 1，问候</strong>分组，用来发现和维持邻站的可达性。</li>
<li><strong>类型 2，数据库描述</strong>分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。</li>
<li><strong>类型 3，链路状态请求</strong>分组，向对方请求发送某些链路状态项目的详细信息。</li>
<li><strong>类型 4，链路状态更新</strong>分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是 OSPF 协议的核心部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有五种不同的链路状态。</li>
<li><strong>类型 5，链路状态确认</strong>分组，对链路更新分组的确认。</li>
</ul>
</li>
<li>OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要是指出有哪些路由器的链路状态信息 (以及其序号) 已经写入了数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。图 4-36 给出了 OSPF 的基本操作，说明了两个路由器需要交换各种类型的分组。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804153513.png"></li>
</ul>
</li>
<li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，与整个互联网的规模无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</li>
<li>OSPF 协议对多点接入的局域网采用了<strong>指定的路由器</strong>的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</li>
</ol>
</li>
</ul>
<h2 id="4-5-4-外部网关协议-BGP"><a href="#4-5-4-外部网关协议-BGP" class="headerlink" title="4.5.4 外部网关协议 BGP"></a>4.5.4 外部网关协议 BGP</h2><ul>
<li>内部网关协议主要是设法使数据报在一个 AS 中尽可能有效地从源站传送到目的站。</li>
<li>BGP 使用的环境不同，主要是因为以下原因：<ol>
<li><strong>互联网的规模太大，使得自治系统 AS 之间路由选择非常困难</strong>。</li>
<li><strong>自治系统 AS 之间的路由选择必须考虑有关策略</strong>。</li>
</ol>
</li>
<li>边界网关协议 BGP 力求寻找一条能够到达目的网络且比较好的路由，<strong>并非要寻找一条最佳路由</strong>。BGP 采用了<strong>路径向量路由选择协议</strong> ，它与距离向量协议 (如 RIP) 和链路状态协议 (如 OSPF) 都有很大的区别。</li>
<li>BGP 协议交换路由信息的结点数量级是<strong>自治系统个数</strong>的量级，比自治系统中的<strong>网络数</strong>少。</li>
<li>在 RFC 4271 中规定了 BGP-4 的四种报文：<ol>
<li>OPEN (打开) 报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。</li>
<li>UPDATE (更新) 报文，用来通告某一路由的信息，以及列出要撤销的多条路由。</li>
<li>KEEPALIVE (保活) 报文，用来周期性地证实邻站的连通性。</li>
<li>NOTIFICATION (通知) 报文，用来发送检测到的差错。</li>
</ol>
</li>
<li>图 4-41 给出了 BGP 报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度为 19 字节。通用首部为三个字段。<strong>标记</strong>字段为 16 字节长，用来鉴别收到的 BGP 报文。当不使用鉴别时，标记字段要置为全 1。<strong>长度</strong>字段指出包括通用首部在内的整个 BGP 报文以字节为单位的长度，最小值是 19，最大值是 4096。<strong>类型</strong>字段的值为 1 到 4，分别对应于上述四种 BGP 报文中的一种。<ol>
<li>OPEN <strong>报文</strong>共有 6 个字段，即<strong>版本</strong> (1 字节，现在的值是 4)、<strong>本自治系统号</strong> (2 字节，使用全球唯一的 16 位自治系统号，由 ICANN 地区登记机构分配)、<strong>保持时间</strong> (2 字节，以秒计算的保持为邻站关系的时间)、<strong>BGP 标识符</strong> (4 字节，通常就是该路由器的 IP 地址)、<strong>可选参数长</strong>(1 字节) 和<strong>可选参数</strong>。</li>
<li>UPDATE <strong>报文</strong>共有 5 个字段，即<strong>不可行路由长度</strong> (2 字节，指明下一个字段的长度)、<strong>撤销的路由</strong> (列出所有要撤销的路由)、<strong>路径属性总长度</strong> (2 字节，指明下一个字段的长度)、<strong>路径属性</strong> (定义在这个报文中增加的路径的属性) 和<strong>网络层可达性信息 NLRI</strong>。最后这个字段定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀。</li>
<li>KEEPALIVE <strong>报文</strong>只有 BGP 的 19 字节长的通用首部。</li>
<li>NOTIFICATION <strong>报文</strong>有 3 个字段，即差错代码 (1 字节)、差错子代码 (1 字节) 和差错数据 (给出有关差错的诊断信息)。</li>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804161110.png"></li>
</ol>
</li>
</ul>
<h2 id="4-5-5-路由器的构成"><a href="#4-5-5-路由器的构成" class="headerlink" title="4.5.5 路由器的构成"></a>4.5.5 路由器的构成</h2><ul>
<li><strong>路由器的结构</strong><ol>
<li>路由器是一种具有多个输入端口和多个输出端口的专用计算机，任务是转发分组。</li>
<li>典型的路由器的结构<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170016.png"></li>
<li>从图 4-42 可以看出，路由器结构可划分为两部分：<strong>路由选择</strong>部分和<strong>分组转发部分</strong>。</li>
<li>路由选择部分也叫<strong>控制部分</strong>，其核心构件是路由选择处理机。</li>
<li>分组转发由三部分组成：<strong>交换结构</strong>、一组<strong>输入端口</strong>和一组<strong>输出端口</strong>。</li>
<li>交换结构又称为<strong>交换组织</strong>，作用是根据<strong>转发表</strong>对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是“在路由器中的网络”。</li>
<li>在图 4-42 中，路由器的输入和输出端口里面都各有三个方框，用方框中的 1，2 和 3 分别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。若接收到的分组是路由器之间交换路由信息的分组 (如 RIP 或 OSPF 分组等)，则把这种分组送交路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得出的结果，分组经过交换结构到达合适的输出端口。一个路由器的输入端口和输出端口安装在路由器的<strong>线路接口卡上</strong>。</li>
<li>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中 (如图 4-42 中的虚线箭头所示)。路由选择处理机负责对各转发表的副本进行更新。这些副本常称为“<strong>影子副本</strong>”。分散化交换可以避免在路由器中的某一点上出现瓶颈。</li>
</ul>
</li>
<li>输入端口对线路上收到的分组的处理<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170325.png"></li>
<li>当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个后到的分组必须在队列中排队等待，产生了一定的时延。图 4-43 给出了在输入端口的队列中排队的分组的示意图。</li>
</ul>
</li>
<li>输出端口把交换结构传送过来的分组发送到线路上<ul>
<li><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_networkSnipaste_2023-12-04_11-02-43.png"></li>
<li>观察在输出端口上的情况 (图 4-44 )。输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上是一个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</li>
</ul>
</li>
<li>分组在路由器的输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</li>
</ol>
</li>
<li><strong>交换结构</strong><ol>
<li>三种常用的交换方法<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804170614.png"></li>
<li>最早的路由器：当路由器的某个输入端口收到一个分组时，用中断方式通知路由选择处理机。然后分组从输入端口复制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。</li>
<li>图 4-45 (a) 的示意图表示分组通过存储器进行交换。与早期的路由器的区别是，目的地址的查找和分组在存储器中的缓存是在输入端口中进行的。</li>
<li>图 4-45 (b) 是通过总线进行交换的示意图。数据报从输入端口通过共享的总线直接传送到合适的输出端口，不需要路由选择处理机的干预。由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线忙，则被阻塞不能通过交换结构，并在输入端口排队等待。因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品都采用这种通过总线的交换方式。</li>
<li>图4-45 (c) 是通过纵横交换结构进行交换。这种交换机构称为<strong>互连网络</strong>，它有 2<em>N</em> 条总线，可以使 <em>N</em> 个输入端口和 <em>N</em> 个输出端口相连接，这取决于相应的交叉结点是使水平总线和垂直总线接通还是断开。当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。但若该垂直总线已被占用 (有另一个分组正在转发到同一个输出端口)，则后到达的分组就被阻塞，必须在输入端口排队。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="4-6-IPv6"><a href="#4-6-IPv6" class="headerlink" title="4.6 IPv6"></a>4.6 IPv6</h1><h2 id="4-6-1-IPv6-的基本首部"><a href="#4-6-1-IPv6-的基本首部" class="headerlink" title="4.6.1 IPv6 的基本首部"></a>4.6.1 IPv6 的基本首部</h2><ul>
<li>IPv6 支持无连接的传送，但将协议数据单元 PDU 称为<strong>分组</strong>，而不是 IPv4 的数据报。</li>
<li>IPv6 所引进的主要变化如下：<ol>
<li><strong>更大的地址空间</strong>。IPv6 把地址从 IPv4 的 32 位增大 4 倍，即增大到 128 位，使地址空间增大了2<sup>96</sup> 倍。这样大的地址空间在可预见的将来是不会用完的。</li>
<li><strong>扩展的地址层次结构</strong>。IPv6 由于地址空间很大，因此可以划分为更多的层次。</li>
<li><strong>灵活的首部格式</strong>。IPv6 数据报的首部和 IPv4 的并不兼容。IPv6 定义了许多可选的扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路由器对扩展首部不进行处理 (除逐跳扩展首部外)。</li>
<li><strong>改进的选项</strong>。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选项。但 IPv6 的<strong>首部长度是固定的</strong>，其选项放在有效载荷中。IPv4 所规定的选项是固定不变的，其选项放在首部的可变部分。</li>
<li><strong>允许协议继续扩充</strong>。因为技术总是在不断地发展而新的应用也还会出现。</li>
<li>支持即插即用 (即自动配置)。因此 IPv6 不需要使用 DHCP。</li>
<li><strong>支持资源的预分配</strong>。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。</li>
<li>IPv6 首部改为 8 <strong>字节对齐</strong> (即首部长度必须是 8 字节的整数倍)。原来的 IPv4 首部是 4 字节对齐。</li>
</ol>
</li>
<li>IPv6 数据报由两大部分组成，即<strong>基本首部和后面的有效载荷</strong>。有效载荷也称为净负荷。有效载荷允许有零个或多个<strong>扩展首部</strong>，再后面是数据部分 (图 4-46)。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804173631.png"></li>
<li>与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：<ul>
<li>取消了首部长度字段，因为它的首部长度是固定的 (40 字节)。</li>
<li>取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。</li>
<li>取消了总长度字段，改用有效载荷长度字段。</li>
<li>取消了标识、标志和片偏移字段，因为这些功能已包含在分片扩展首部中。</li>
<li>把 TTL 字段改称为跳数限制字段，但作用是一样的。</li>
<li>取消了协议字段，改用下一个首部字段。</li>
<li>取消了检验和字段，加快了路由器处理数据报的速度。在数据链路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确传送到目的进程为止。因此在网络层的差错检测可以精简掉。</li>
<li>取消了选项字段，而用扩展首部来实现选项功能。</li>
</ul>
</li>
</ol>
</li>
<li>解释 IPv6 基本首部中各字段的作用 (参见图 4-47)。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230804173739.png"></li>
</ul>
<ol>
<li><strong>版本</strong>　占 4 位。它指明了协议的版本，IPv6 字段是 6。</li>
<li><strong>通信量类</strong>　占 8 位。这是为了区分不同的 IPv6 数据报的类别或优先级。</li>
<li><strong>流标号</strong>　占 20 位。IPv6 的一个新的机制是支持资源预分配，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出流的抽象概念。所谓“流“<strong>是互联网络上从特定源点到特定终点 (单播或多播) 的一系列数据报 (如实时音频或视频传输)，“流”所经过的路径上的路由器都保证指明的服务质量</strong>。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频&#x2F;视频数据的传送有用。对于传统的电子邮件或非实时数据，流标号则没用，把它置为 0 即可。</li>
<li><strong>有效载荷长度</strong>　占 16 位。它指明 IPv6 数据报除基本首部以外的字节数 (所有扩展首部都算在有效载荷之内)。这个字段的最大值是 64KB (65535字节)。</li>
<li><strong>下一个首部</strong>　占 8 位。相当于 IPv4 的协议字段或可选字段。<ul>
<li>当 IPv6 数据报没有扩展首部时，下一个首部字段的作用和 IPv4 的协议字段一样，它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议 (例如：6 或17 分别表示应交付运输层 TCP 或 UDP)。</li>
<li>当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。</li>
</ul>
</li>
<li><strong>跳数限制</strong>　占 8 位。用来防止数据报在网络中无限期地存在。源点在每个数据报发出时即设定某个跳数限制 (最大为 255 跳)。每个路由器在转发数据报时，要先把跳数限制字段中的值减 1。当跳数限制的值为零时，就要把这个数据报丢弃。</li>
<li><strong>源地址</strong> 　占 128 位。是数据报的发送端的 IP 地址。</li>
<li><strong>目的地址</strong> 　占 128 位。是数据报的接收端的 IP 地址。</li>
</ol>
</li>
<li>IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，降低了路由器处理数据报的速度。然而实际上很多的选项在途中的路由器上是不需要检查的 (因为不需要使用这些选项的信息)。IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理，数据报途中经过的<strong>路由器都不处理这些扩展首部</strong> (只有一个首部例外，即逐跳选项扩展首部)，<strong>大大提高了路由器的处理效率</strong>。</li>
<li>在 RFC 2460 中定义了以下六种扩展首部：<ol>
<li>逐跳选项</li>
<li>路由选择</li>
<li>分片</li>
<li>鉴别</li>
<li>封装安全有效载荷</li>
<li>目的站选项</li>
</ol>
</li>
</ul>
<h2 id="4-6-2-IPv6-的地址"><a href="#4-6-2-IPv6-的地址" class="headerlink" title="4.6.2 IPv6 的地址"></a>4.6.2 IPv6 的地址</h2><ul>
<li>一个 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：<ol>
<li><strong>单播</strong>　单播是传统的点对点通信。</li>
<li><strong>多播</strong>　多播是一对多的通信，数据报发送到一组计算机中的每一个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。</li>
<li><strong>任播</strong>　IPv6 增加的一种类型。任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。</li>
</ol>
</li>
<li>IPv6 把实现 IPv6 的主机和路由器均称为<strong>结点</strong>。由于一个结点可能会使用多条链路与其他的一些结点相连，因此一个结点可能有多个与链路相连的接口。IPv6 给结点的每一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当作到达该结点的目的地址。</li>
<li>为了使地址再稍简洁些，IPv6 使用<strong>冒号十六进制记法</strong>，它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。</li>
<li>IPv6 的地址分类见表 4-10 所示。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805093424.png"></li>
</ol>
</li>
<li>对表 4-10 所列举的几种地址简单解释如下。<ol>
<li><strong>未指明地址</strong> 　这是 16 字节的全 0 地址，可缩写为两个冒号“::”。这个地址不能用作目的地址，而只能为某台主机当作源地址使用，条件是这台主机还没有配置到一个标准的 IP 地址。这类地址仅此一个。</li>
<li><strong>环回地址</strong> 　IPv6 的环回地址是 0:0:0:0:0:0:0:1，可缩写为 ::1。它的作用和 IPv4 的环回地址一样。这类地址也是仅此一个。</li>
<li><strong>多播地址</strong> 　功能和 IPv4 的一样。这类地址占 IPv6 地址总数的 1&#x2F;256。</li>
<li><strong>本地链路单播地址</strong>　有些单位的网络使用 TCP&#x2F;IP 协议，但<strong>并没有连接到互联网上</strong> 。连接在这样的网络上的主机都可以使用这种本地地址进行通信，但不能和互联网上的其他主机通信。这类地址占 IPv6 地址总数的 1&#x2F;1024。</li>
<li><strong>全球单播地址</strong> 　使用得最多的一类。IPv6 单播地址的划分方法非常灵活，可以如图 4-48 所示的任何一种。可把整个的 128 比特都作为一个结点的地址。也可用 <em>n</em> 比特作为子网前缀，用剩下的 (128–<em>n</em>) 比特作为接口标识符 (相当于 IPv4 的主机号)。当然也可以划分为三级，用 <em>n</em> 比特作为全球路由选择前缀，用 <em>m</em> 比特作为子网前缀，而用剩下的 (128–<em>n</em>–<em>m</em>) 比特作为接口标识符。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805093530.png"></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4-6-3-从-IPv4-向-IPv6-过渡"><a href="#4-6-3-从-IPv4-向-IPv6-过渡" class="headerlink" title="4.6.3 从 IPv4 向 IPv6 过渡"></a>4.6.3 从 IPv4 向 IPv6 过渡</h2><ul>
<li><strong>双协议栈</strong><ol>
<li><strong>双协议栈</strong>是指在完全过渡到 IPv6 之前，使一部分主机 (或路由器) 装有双协议栈：一个 IPv4 和一个 IPv6。因此双协议栈主机 (或路由器) 既能够和 IPv6 的系统通信，又能够和 IPv4 的系统通信。双协议栈的主机 (或路由器) 记为 IPv6&#x2F;IPv4，表明它同时具有两种 IP 地址：一个 IPv6 地址和一个 IPv4 地址。</li>
</ol>
</li>
<li><strong>隧道技术</strong><ol>
<li>向 IPv6 过渡的另一种方法是<strong>隧道技术</strong>， 这种方法的要点是在 IPv6 数据报要进入 IPv4 网络时，把 IPv6 数据报封装成为 IPv4 数据报。</li>
<li>要使双协议栈的主机知道 IPv4 数据报里面封装的数据是一个 IPv6 数据报，就必须把 IPv4 首部的协议字段的值设置为 41 (41 表示数据报的数据部分是 IPv6 数据报)。</li>
</ol>
</li>
</ul>
<h2 id="4-6-4-ICMPv6"><a href="#4-6-4-ICMPv6" class="headerlink" title="4.6.4 ICMPv6"></a>4.6.4 ICMPv6</h2><ul>
<li>和 IPv4 一样，IPv6 也不保证数据报的可靠交付，因为互联网中的路由器可能会丢弃数据报。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。</li>
<li>ICMPv6 是面向报文的协议，它利用报文来报告差错，获取信息，探测邻站或管理多播通信。ICMPv6 还增加了几个定义报文功能及含义的其他协议。在对 ICMPv6 报文进行归类时，不同的文献和 RFC 文档使用了不同的策略，有的把其中的一些报文定义为 ICMPv6 报文，而把另一些报文定义为<strong>邻站发现</strong> ND 报文或<strong>多播听众交付</strong> MLD 报文。其实所有这些报文都是 ICMPv6 报文，只是功能和作用不同而已。</li>
</ul>
<h1 id="4-7-IP-多播"><a href="#4-7-IP-多播" class="headerlink" title="4.7 IP 多播"></a>4.7 IP 多播</h1><h2 id="4-7-1-IP-多播的基本概念"><a href="#4-7-1-IP-多播的基本概念" class="headerlink" title="4.7.1 IP 多播的基本概念"></a>4.7.1 IP 多播的基本概念</h2><ul>
<li>与单播相比，在一对多的通信中，多播可大大节约网络资源。图 4-53(a) 是视频服务器用单播方式向 90 台主机传送同样的视频节目。为此，需要发送 90 个单播，即同一个视频分组要发送 90 个副本。图 4-53(b) 是视频服务器用多播方式向属于同一个多播组的 90 个成员传送节目。这时，视频服务器只需把视频分组当作多播数据报来发送，并且<strong>只需发送一次</strong>。路由器 R<sub>1</sub> 在转发分组时，需要把收到的分组<strong>复制</strong>成 3 个副本，分别向 R<sub>2</sub>、R<sub>3</sub> 和 R<sub>4</sub> 各转发 1个副本。当分组到达目的局域网时，由于局域网具有硬件多播功能，因此<strong>不需要复制分组</strong>，在局域网上的多播组成员都能收到这个视频分组。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230805150914.png"></li>
</ol>
</li>
<li>当多播组的主机数很大时 (如成千上万个)，多播明显地减轻网络中各种资源的消耗。在互联网范围的多播要靠路由器来实现，这些路由器必须增加一些能够识别多播数据报的软件。能够运行多播协议的路由器称为<strong>多播路由器</strong>。多播路由器当然也可以转发普通的单播 IP 数据报。</li>
<li>在互联网上进行多播叫做 <strong>IP 多播</strong>。IP 多播所传送的分组需要使用多播 IP 地址。</li>
<li>多播数据报的目的地址不能写入主机的 IP 地址。因为在同一时间可能有成千上万台主机加入到同一个多播组。多播数据报不可能在其首部写入如此多的主机 IP 地址。目的地址写入的是多播组的标识符，然后设法让加入到这个多播组的主机 IP 地址与多播组的标识符关联起来。</li>
<li><strong>多播地址只能用于目的地址，不能用于源地址</strong>。此外，对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，永远不会收到响应。</li>
<li>IP 多播可以分为两种。一种是在本地局域网上进行硬件多播，另一种是在互联网上进行多播。前一种虽然比较简单，但很重要，因为现在大部分主机都是通过局域网接入到互联网的。在互联网上进行多播的最后阶段，还是要把多播数据报在局域网上用硬件多播交付多播组的所有成员。</li>
</ul>
<h2 id="4-7-2-在局域网上进行硬件多播"><a href="#4-7-2-在局域网上进行硬件多播" class="headerlink" title="4.7.2 在局域网上进行硬件多播"></a>4.7.2 在局域网上进行硬件多播</h2><h2 id="4-7-3-网际组管理协议-IGMP-和多播路由选择协议"><a href="#4-7-3-网际组管理协议-IGMP-和多播路由选择协议" class="headerlink" title="4.7.3 网际组管理协议 IGMP 和多播路由选择协议"></a>4.7.3 网际组管理协议 IGMP 和多播路由选择协议</h2><ul>
<li><strong>IP 多播需要两种协议</strong><ol>
<li>图 4-55 是在互联网上传送多播数据报的例子。图中标有 IP 地址的四台主机都参加了一个多播组，其组地址是 226.15.37.123。显然，多播数据报应传送到路由器 R<sub>1</sub>，R<sub>2</sub> 和 R<sub>3</sub>，而不应传送到路由器 R<sub>4</sub>，因为与 R<sub>4</sub> 连接的局域网上现在没有这个多播组的成员。路由器需要用<strong>网际组管理协议</strong> IGMP 来识别多播组的成员信息。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806153909.png"></li>
<li>图 4-55 强调了 IGMP 的<strong>本地使用范围</strong> 。IGMP 并非在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上等等。IGMP 协议是让<strong>连接在本地局域网</strong>上的多播路由器知道<strong>本局域网上</strong>是否有主机 (严格讲，是主机上的某个进程) 参加或退出了某个多播组。</li>
</ul>
</li>
<li>仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员，需要使用<strong>多播路由选择协议</strong>。</li>
<li>**多播转发必须动态地适应多播组成员的变化 (这时网络拓扑并未发生变化)**。</li>
<li><strong>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址</strong>。</li>
<li><strong>多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络</strong>。</li>
</ol>
</li>
<li><strong>网际组管理协议 IGMP</strong><ol>
<li>和网际控制报文协议 ICMP 相似，IGMP 使用 IP 数据报传递其报文 (即 IGMP 报文加上 IP 首部构成 IP 数据报)，但它也向 IP 提供服务。因此，IGMP 不是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。</li>
<li>从概念上讲，IGMP 的工作可分为两个阶段：<ul>
<li>第一阶段：当某台主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器。</li>
<li>第二阶段：组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续当组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍没有一台主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。</li>
</ul>
</li>
<li>IGMP 设计得很仔细，避免了多播控制信息给网络增加大量的开销。IGMP 采用的一些具体措施如下：<ul>
<li>在主机和多播路由器之间的所有通信都是使用 IP 多播。只要有可能，携带 IGMP 报文的数据报都用硬件多播来传送。因此在支持硬件多播的网络上，没有参加 IP 多播的主机不会收到 IGMP 报文。</li>
<li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，不需要对每一个组都发送询问报文。</li>
<li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。因此，网络上多个多播路由器并不会引起 IGMP 通信量的增大。</li>
<li>在 IGMP 的询问报文中有一个数值 <em>N</em>，它指明一个最长响应时间。当收到询问时，主机在 0 到 <em>N</em> 之间随机选择发送响应所需经过的时延。因此，若一台主机同时参加了几个多播组，则主机对每一个多播组选择不同的随机数。对应于最小时延的响应最先发送。</li>
<li>同一个组内的每一台主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。这样就抑制了不必要的通信量。</li>
</ul>
</li>
<li>多播路由器并不需要保留组成员关系的准确记录，因为向局域网上的组成员转发数据报使用硬件多播。多播路由器只需要知道网络上是否至少还有一台主机是本组成员即可。实际上，对询问报文每一个组只需有一台主机发送响应。</li>
<li>如果一台主机上有多个进程都加入了某个多播组，那么这台主机对发给这个多播组的每个多播数据报只接收一个副本，然后给主机中的每一个进程发送一个本地复制的副本。</li>
</ol>
</li>
<li><strong>多播路由选择协议</strong><ol>
<li>多播路由选择实际上就是要找出以源主机为根节点的<strong>多播转发树</strong>。在多播转发树上，每一个多播路由器向树的叶节点方向转发收到的多播数据报，但在多播转发树上的路由器不会收到重复的多播数据报。</li>
<li>已有了多种实用的多播路由选择协议，它们在转发多播数据报时使用了以下的三种方法：<ul>
<li><strong>洪泛与剪除</strong>。这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。一开始，路由器转发多播数据报使用洪泛的方法 (广播)。为了避免兜圈子，采用了叫做<strong>反向路径广播 RPB</strong> 的策略。RPB 的要点是：每一个路由器在收到一个多播数据报时，先检查数据报是否是从源点经最短路径传送来的。进行这种检查很容易，只要从本路由器寻找到源点的最短路径上 (之所以叫做反向路径，因为在计算最短路径时把源点当作终点) 的第一个路由器是否是刚才把多播数据报送来的路由器。若是，就向所有其他方向转发刚才收到的多播数据报 (进入的方向除外)，否则就丢弃而不转发。如果本路由器有好几个相邻路由器都处在到源点的最短路径上 (也就是说，存在几条同样长度的最短路径)，那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。图 4-57 的例子说明了这一概念。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806161532.png"></li>
</ol>
</li>
<li><strong>隧道技术</strong>。隧道技术适用于多播组的位置在地理上很分散的情况。例如在图 4-58中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R<sub>1</sub> 和 R<sub>2</sub> 之间的网络并不支持多播，因而 R<sub>1</sub> 和 R<sub>2</sub> 不能按多播地址转发数据报。为此，路由器 R<sub>1</sub> 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的<strong>单播</strong>数据报，然后通过“<strong>隧道</strong>”从 R<sub>1</sub> 发送到 R<sub>2</sub> 。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806161545.png"></li>
</ol>
</li>
<li><strong>基于核心的发现技术</strong>。这种方法对于多播组的大小在较大范围内变化时都适合。对每一个多播组 G 指定一个<strong>核心路由器</strong>，给出它的 IP 单播地址。核心路由器创建出对应于多播组 G 的转发树。如果有一个路由器 R<sub>1</sub> 向这个核心路由器发送数据报，在途中经过的每一个路由器都要检查其内容。当数据报到达参加了多播组 G 的路由器 R<sub>2</sub> 时，R<sub>2</sub> 就处理这个数据报。如果 R<sub>1</sub> 发出的是一个多播数据报，其目的地址是 G 的组地址，R<sub>2</sub> 就向多播组 G 的成员转发这个多播数据报。如果 R<sub>1</sub> 发出的数据报是一个请求加入多播组 G 的数据报，R<sub>2</sub> 就把这个信息加到它的路由中，并用隧道技术向 R<sub>1</sub> 转发每一个多播数据报的一个副本。这样，参加到多播组 G 的路由器就从核心向外增多了，扩大了多播转发树的覆盖范围。</li>
</ul>
</li>
<li>使用的多播路由选择协议：<ul>
<li><strong>距离向量多播路由选择协议</strong> DVMRP 是在互联网上使用的第一个多播路由选择协议。它使用 DVMRP 在路由器之间传播路由信息。</li>
<li><strong>基于核心的转发树 CBT</strong>。这个协议使用核心路由器作为转发树的根节点。一个大的自治系统 AS 可划分为几个区域，每一个区域选择一个核心路由器。</li>
<li><strong>开放最短通路优先的多播扩展 MOSPF</strong>。这个协议是单播路由选择协议 OSPF 的扩充，使用于一个机构内。MOSPF 使用多播链路状态路由选择创建出基于源点的多播转发树。</li>
<li><strong>协议无关多播-稀疏方式 PIM-SM</strong>。这个协议使用和 CBT 同样的方法构成多播转发树。“协议无关”强调：虽然在建立多播转发树时是使用单播数据报来和远程路由器联系的，但这并不要求使用特定的单播路由选择协议。这个协议适用于组成员的分布非常分散的情况。</li>
<li><strong>协议无关多播-密集方式 PIM-DM</strong>。这个协议适用于组成员的分布非常集中的情况，例如组成员都在一个机构之内。PIM-DM 不使用核心路由器，而是使用洪泛方式转发数据报。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="4-8-虚拟专用网-VPN-和网络地址转换-NAT"><a href="#4-8-虚拟专用网-VPN-和网络地址转换-NAT" class="headerlink" title="4.8 虚拟专用网 VPN 和网络地址转换 NAT"></a>4.8 虚拟专用网 VPN 和网络地址转换 NAT</h1><h2 id="4-8-1-虚拟专用网-VPN"><a href="#4-8-1-虚拟专用网-VPN" class="headerlink" title="4.8.1 虚拟专用网 VPN"></a>4.8.1 虚拟专用网 VPN</h2><ul>
<li><strong>在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</strong>。RFC 6890 全面地给出了所有特殊用途的 IPv4 地址，但三个专用地址块的指派并无变化，即：<ol>
<li>10.0.0.0 到 10.255.255.255 (或记为 10.0.0.0&#x2F;8，它又称为 24 位块)</li>
<li>172.16.0.0 到 172.31.255.255 (或记为 172.16.0.0&#x2F;12，它又称为 20 位块)</li>
<li>192.168.0.0 到 192.168.255.255 (或记为 192.168.0.0&#x2F;16，它又称为 16 位块)</li>
</ol>
</li>
<li>有时一个机构的许多部门分布的范围很广，这些部门要互相交换信息，有两种方法：<ol>
<li>租用电信公司的通信线路为本机构专用。这种方法简单方便，但线租金高，一般难于承受。</li>
<li>利用公用的互联网作为本机构各专用网之间的通信载体，这样的专用网又称为<strong>虚拟专用网</strong> VPN。</li>
</ol>
</li>
<li>“专用网”是指为本机构的主机用于机构内部的通信，而不是用于和网络外非本机构的主机通信的网络。如果专用网不同网点之间的通信必须经过公用的互联网，但又有保密的要求，那么<strong>所有通过互联网传送的数据都必须加密</strong>。</li>
<li>VPN 只是<strong>在效果上</strong>和专用网一样。一个机构要构建自己的 VPN 就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的 VPN 系统都知道其他场所的地址。</li>
<li>由场所 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为<strong>内联网</strong>，表示场所 A 和 B 都属于同一个机构。</li>
<li>有时一个机构的 VPN 需要有某些<strong>外部机构</strong> (通常就是合作伙伴) 参加进来。这样的 VPN 就称为<strong>外联网</strong>。</li>
<li>还有一种类型的 VPN，是<strong>远程接入</strong> VPN。</li>
</ul>
<h2 id="4-8-2-网络地址转换-NAT"><a href="#4-8-2-网络地址转换-NAT" class="headerlink" title="4.8.2 网络地址转换 NAT"></a>4.8.2 网络地址转换 NAT</h2><ul>
<li>装有 NAT 软件的路由器叫做 NAT 路由器，它至少有一个有效的外部全球 IP 地址。</li>
<li>图 4-60 给出了 NAT 路由器的工作原理。在图中，专用网 192.168.0.0 内所有主机的 IP 地址都是本地 IP 地址 192.168.x.x。NAT 路由器至少要有一个全球 IP 地址，才能和互联网相连。图 4-60 表示出 NAT 路由器有一个全球 IP 地址 172.38.1.5。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806174735.png"></li>
</ol>
</li>
<li>为了更加有效地利用 NAT 路由器上的全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也利用上。这样可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和互联网上的不同主机进行通信。</li>
<li>使用端口号的 NAT 也叫做<strong>网络地址与端口号转换</strong> NAPT，而不使用端口号的 NAT 就叫做传统的 NAT。</li>
</ul>
<h1 id="4-9-多协议标记交换-MPLS"><a href="#4-9-多协议标记交换-MPLS" class="headerlink" title="4.9 多协议标记交换 MPLS"></a>4.9 多协议标记交换 MPLS</h1><ul>
<li>MPLS 利用面向连接技术，使每个分组携带一个叫做<strong>标记</strong>的小整数。当分组到达交换机 (即标记交换路由器) 时，交换机读取分组的标记，并用标记值来检索分组转发表，比查找路由表来转发分组要快得多。</li>
<li>MPLS 常与<strong>异步传递方式</strong> ATM 联系起来，因为它们都采用了面向连接的工作方式。</li>
<li>MPLS 具有以下三个方面的特点：<ol>
<li>支持面向连接的服务质量。</li>
<li>支持流量工程，平衡网络负载。</li>
<li>有效地支持虚拟专用网 VPN。</li>
</ol>
</li>
</ul>
<h2 id="4-9-1-MPLS-的工作原理"><a href="#4-9-1-MPLS-的工作原理" class="headerlink" title="4.9.1 MPLS 的工作原理"></a>4.9.1 MPLS 的工作原理</h2><ul>
<li><strong>基本工作过程</strong><ol>
<li>在传统的 IP 网络中，分组每到达一个路由器，都必须查找路由表，并按照“最长前缀匹配”的原则找到下一跳的 IP 地址。当网络很大时，查找含有大量项目的路由表要花费很多的时间。在出现突发性的通信量时，往往还会使缓存溢出，引起分组丢失、传输时延增大和服务质量下降。</li>
<li>MPLS 的一个重要特点是在 MPLS 域的入口处，给每一个 IP 数据报打上固定长度“标记”，<strong>然后对打上标记的 IP 数据报用硬件进行转发</strong>，使 IP 数据报转发的过程大大加快。采用硬件技术对打上标记的 IP 数据报进行转发就称为<strong>标记交换</strong> 。“交换”也表示在转发时不再上升到第三层查找转发表，而是<strong>根据标记在第二层 (链路层) 用硬件进行转发</strong>。MPLS 可使用多种链路层协议，如 PPP、以太网、ATM 以及帧中继等。图 4-61是 MPLS 协议的基本原理的示意图。<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175138.png"></li>
</ul>
</li>
<li>MPLS 域是指该域中有许多彼此相邻的路由器，并且所有的路由器都是支持 MPLS 技术的<strong>标记交换路由器</strong> LSR。LSR 同时具有标记交换和路由选择这两种功能，标记交换功能是为了快速转发，但在这之前 LSR 需要使用路由选择功能构造转发表。</li>
<li>MPLS 的基本工作过程如下：<ul>
<li>MPLS 域中的各 LSR 使用专门的<strong>标记分配协议 LDP</strong> 交换报文，并找出和特定标记相对应的路径，即<strong>标记交换路径</strong> LSP。例如在图中的路径 A→B→C→D。各 LSR 根据这些路径构造出转发表。这个过程和路由器构造自己的路由表相似。MPLS 是面向连接的，因为在标记交换路径 LSP上 的第一个 LSR 就根据 IP 数据报的初始标记确定了整个的标记交换路径，就像一条虚连接一样。</li>
<li>当一个 IP 数据报进入到 MPLS 域时，MPLS <strong>入口结点</strong>就给它打上标记，并按照转发表把它转发给下一个 LSR。以后的所有 LSR 都按照标记进行转发；给 IP 数据报打标记的过程叫做<strong>分类</strong>。严格的<strong>第三层 (网络层) 分类</strong>只使用了 IP 首部中的字段，如源 IP 地址和目的 IP 地址等。大多数运营商实现了<strong>第四层 (运输层) 分类</strong>，而有些运营商则实现了<strong>第五层 (应用层) 分类</strong>。</li>
<li>在全网内统一分配全局标记数值是非常困难的，因此<strong>一个标记仅仅在两个标记交换路由器 LSR 之间才有意义</strong>。分组每经过一个 LSR，LSR 做两件事：一是转发，二是更换新的标记，即把<strong>入标记</strong>更换成为<strong>出标记</strong>。这就叫做<strong>标记对换</strong>。做这两件事所需的数据需要写在转发表中。例如，图 4-61 中的标记交换路由器 B 从入接口 0 收到一个入标记为 3 的 IP 数据报，查找了如下的转发表：<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175430.png"></li>
</ol>
</li>
<li>当 IP 数据报离开 MPLS 域时，MPLS <strong>出口结点</strong>就把 MPLS 的标记去除，把 IP 数据报交付非 MPLS 的主机或路由器，以后就按照普通的转发方法进行转发。</li>
</ul>
</li>
</ol>
</li>
<li><strong>转发等价类 FEC</strong><ol>
<li>MPLS 有个很重要的概念是<strong>转发等价类</strong> FEC。所谓“转发等价类”就是路由器<strong>按照同样方式对待</strong>的 IP 数据报的集合。这里“按照同样方式对待”表示从同样接口转发到同样的下一跳地址，并且具有同样服务类别和同样丢弃优先级等。FEC 的例子是：<ul>
<li>目的 IP 地址与某一个特定 IP 地址的前缀匹配的 IP 数据报；</li>
<li>所有源地址与目的地址都相同的 IP 数据报；</li>
<li>具有某种服务质量需求的 IP 数据报。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4-9-2-MPLS-首部的位置与格式"><a href="#4-9-2-MPLS-首部的位置与格式" class="headerlink" title="4.9.2 MPLS 首部的位置与格式"></a>4.9.2 MPLS 首部的位置与格式</h2><ul>
<li>MPLS 不要求下层的网络都使用面向连接的技术。因此一对 MPLS 路由器之间的物理连接，既可以由一个专用电路组成，如 OC-48 线路，也可以使用像以太网这样的网络。但是这些网络并不提供打标记的手段，而 IPv4 数据报首部也没有多余的位置存放 MPLS 标记。需要使用一种封装技术：在把 IP 数据报封装成以太网帧之前，先要插入一个 MPLS 首部。从层次的角度看，MPLS 首部就处在第二层和第三层之间 (图 4-63)。在把加上 MPLS 首部的 IP 数据报封装成以太网帧时，以太网的类型字段在单播的情况下设置为 8847 16 ，在多播的情况下为 8848 16 。这样，接收方可以用帧的类型来判决这个帧是携带了 MPLS 标记还是一个常规的 IP 数据报。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175802.png"></li>
</ol>
</li>
<li>图 4-64 给出了 MPLS 首部的格式。给 IP 数据报打上标记其实就是在以太网的帧首部和 IP 数据报的首部之间插入一个 4 字节的 MPLS 首部。具体的标记在“标记值”这个字段中。<ol>
<li><img src="https://cdn.jsdelivr.net/gh/chipfron/Image_/test_Pasted%20image%2020230806175822.png"></li>
<li>MPLS 首部共包括以下四个字段：<ul>
<li><strong>标记值</strong> 　占 20 位。由于一个 MPLS 标记占 20 位，因此从理论上讲，在设置 MPLS 时可以使用标记的所有 20 位，因而可以同时容纳高达 2<sup>20</sup> 个流 (即 1048576 个流)。但是，实际上几乎没有哪个 MPLS 实例会使用很大数目的流，因为通常需要管理员人工管理和设置每条交换路径。</li>
<li><strong>试验</strong> 　占 3 位，目前保留用于试验。</li>
<li><strong>栈</strong> S　占 1 位，在有“标记栈”时使用。</li>
<li><strong>生存时间</strong> TTL　占 8 位，用来防止 MPLS 分组在 MPLS 域中兜圈子。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="本章重要概念"><a href="#本章重要概念" class="headerlink" title="本章重要概念"></a>本章重要概念</h1><ul>
<li><p>TCP&#x2F;IP 体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限，所传送的分组可能出错、丢失、重复和失序。进程之间通信的可靠性由运输层负责。</p>
</li>
<li><p>IP 网是虚拟的，因为从网络层上看，IP 网是一个统一的、抽象的网络。IP 层抽象的互联网屏蔽了下层网络很复杂的细节，使我们能够使用统一的、抽象的 IP 地址处理主机之间的通信问题。</p>
</li>
<li><p>在互联网上的交付有两种：</p>
<ol>
<li>在本网络上的直接交付 (不经过路由器) </li>
<li>到其他网络的间接交付 (经过至少一个路由器，但最后一次一定是直接交付)。</li>
</ol>
</li>
<li><p>一个 IP 地址在整个互联网范围内是唯一的。分类的 IP 地址包括 A 类、B 类和 C 类地址 (单播地址)，以及 D 类地址 (多播地址)。E 类地址未使用。</p>
</li>
<li><p>分类的 IP 地址由网络号字段 (指明网络) 和主机号字段 (指明主机) 组成。网络号字段最前面的类别位指明 IP 地址的类别。</p>
</li>
<li><p>IP 地址是一种分等级的地址结构。IP 地址管理机构在分配 IP 地址时只分配网络号，而主机号则由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。</p>
</li>
<li><p>IP 地址标志一台主机 (或路由器) 和一条链路的接口。多归属主机同时连接到两个或更多的网络上。这样的主机同时具有两个或更多的 IP 地址，其网络号必须是不同的。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。</p>
</li>
<li><p>用转发器或网桥连接起来的若干个局域网仍为一个网络。所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网) 都是平等的。</p>
</li>
<li><p>物理地址 (硬件地址) 是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址，在数据链路层看不见数据报的 IP 地址。</p>
</li>
<li><p>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。一些长度可变的可选字段放在固定首部的后面。</p>
</li>
<li><p>IP 首部中的生存时间字段给出了 IP 数据报在互联网中所能经过的最大路由器数，可防止 IP 数据报在互联网中兜圈子。</p>
</li>
<li><p>地址解析协议 ARP 把 IP 地址解析为硬件地址，它解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。ARP 的高速缓存大大减少网络上的通信量。</p>
</li>
<li><p>在互联网中，我们无法仅根据硬件地址寻找到在某个网络上的某台主机。因此，从 IP 地址到硬件地址的解析是非常必要的。</p>
</li>
<li><p>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好方法。CIDR 记法把 IP 地址后面加上斜线“&#x2F;”，然后写上前缀所占的位数。前缀 (或网络前缀) 用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的IP地址组成一个“CIDR 地址块”。IP 地址的分配都以 CIDR 地址块为单位。</p>
</li>
<li><p>CIDR 的 32 位地址掩码 (或子网掩码) 由一串 1 和一串 0 组成，而 1 的个数就是前缀的长度。只要把 IP 地址和地址掩码逐位进行“逻辑与 (AND) ”运算，就很容易得出网络地址。A 类地址的默认地址掩码是 255.0.0.0。B 类地址的默认地址掩码是 255.255.0.0。C 类地址的默认地址掩码是 255.255.255.0。</p>
</li>
<li><p>路由聚合 (把许多前缀相同的地址用一个来代替) 有利于减少路由表中的项目，减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。</p>
</li>
<li><p>“转发”和“路由选择”不同。“转发”是单个路由器的动作。“路由选择”是许多路由器共同协作的过程，这些路由器相互交换信息，目的是生成路由表，再从路由表导出转发表。若采用自适应路由选择算法，则当网络拓扑变化时，路由表和转发表都能够自动更新。在许多情况下，可以不考虑转发表和路由表的区别，而都使用路由表这一名词。</p>
</li>
<li><p>自治系统 (AS) 是在单一的技术管理下的一组路由器。一个自治系统对其他自治系统表现出的是一个单一的和一致的路由选择策略。</p>
</li>
<li><p>路由选择协议有两大类：</p>
<ol>
<li>内部网关协议 (或自治系统内部的路由选择协议)，如 RIP 和 OSPF；</li>
<li>外部网关协议 (或自治系统之间的路由选择协议)，如 BGP-4。</li>
</ol>
</li>
<li><p>RIP 是分布式的基于距离向量的路由选择协议，适用于小型互联网，按固定的时间间隔与相邻路由器交换信息。交换的信息是自己当前的路由表，即到达本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器。</p>
</li>
<li><p>OSPF 是分布式的链路状态协议，适用于大型互联网，只在链路状态发生变化时，才向本自治系统中的所有路由器，用洪泛法发送与本路由器相邻的所有路由器的链路状态信息。“链路状态”指明本路由器都和哪些路由器相邻，以及该链路的“度量”。“度量”可表示费用、距离、时延、带宽等，统称为“代价”。所有的路由器最终都能建立一个全网的拓扑结构图。</p>
</li>
<li><p>BGP-4 是不同 AS 的路由器之间交换路由信息的协议，是一种路径向量路由选择协议。BGP力求寻找一条能够到达目的网络 (可达) 且比较好的路由 (不兜圈子)，而并非要寻找一条最佳路由。</p>
</li>
<li><p>网际控制报文协议 ICMP 是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 并非为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p>
</li>
<li><p>ICMP 的一个重要应用就是分组网间探测 PING，用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。</p>
</li>
<li><p>要解决 IP 地址耗尽的问题，根本的办法是采用有更大地址空间的新版本 IP 协议，即 IPv6。</p>
</li>
<li><p>IPv6 所带来的主要变化是：</p>
<ol>
<li>更大的地址空间 (采用 128 位的地址)；</li>
<li>灵活的首部格式；</li>
<li>改进的选项；</li>
<li>支持即插即用；</li>
<li>支持资源的预分配；</li>
<li>IPv6 首部改为 8 字节对齐。</li>
</ol>
</li>
<li><p>IPv6 数据报在基本首部的后面允许有零个或多个扩展首部，再后面是数据。所有的扩展首部和数据合起来叫做数据报的有效载荷或净负荷。</p>
</li>
<li><p>IPv6 数据报的目的地址可以是以下三种基本类型地址之一：单播、多播和任播。</p>
</li>
<li><p>IPv6 的地址使用冒号十六进制记法。</p>
</li>
<li><p>向 IPv6 过渡只能采用逐步演进的办法，必须使新安装的 IPv6 系统能够向后兼容。向 IPv6 过渡可以使用双协议栈或使用隧道技术。</p>
</li>
<li><p>与单播相比，在一对多的通信中，IP 多播可大大节约网络资源。IP 多播使用 D 类 IP 地址。IP 多播需要使用网际组管理协议 IGMP 和多播路由选择协议。</p>
</li>
<li><p>虚拟专用网 VPN 利用公用的互联网作为本机构各专用网之间的通信载体。VPN 内部使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都必须加密。</p>
</li>
<li><p>使用网络地址转换 NAT 技术，可以在专用网络内部使用专用 IP 地址，而仅在连接到互联网的路由器使用全球 IP 地址。这样就大大节约了宝贵的 IP 地址。</p>
</li>
<li><p>MPLS 的特点：</p>
<ol>
<li>支持面向连接的服务质量；</li>
<li>支持流量工程，平衡网络负载；</li>
<li>有效地支持虚拟专用网 VPN。</li>
</ol>
</li>
<li><p>MPLS 在入口结点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层 (链路层) 用硬件进行转发 (在标记交换路由器中进行标记对换)，因而转发速率大大加快。</p>
</li>
<li><p>子网划分为什么全0全1子网号不能使用？</p>
<blockquote>
<p>看看 RFC950 提到的原因：<br>假设我们有一个网络：192.168.0.0&#x2F;24，我们现在需要两个子网，那么按照 RFC950，应该使用使用两位子网号，即 &#x2F;26，得到两个可以使用的子网 192.168.0.64&#x2F;26 和 192.168.0.128&#x2F;26<br>对于主网络 192.168.0.0&#x2F;24，网络地址是192.168.0.0，广播地址是 192.168.0.255<br>对于子网 192.168.0.0&#x2F;26 (子网号全 0)，网络地址是 192.168.0.0，广播地址是 192.168.0.63<br>对于子网 192.168.0.64&#x2F;26，网络地址是 192.168.0.64，广播地址是 192.168.0.127<br>对于子网 192.168.0.128&#x2F;26，网络地址是 192.168.0.128，广播地址是 192.168.0.191<br>对于子网 192.168.0.192&#x2F;26 (子网号全1)，网络地址是 192.168.0.192，广播地址是 192.168.0.255</p>
<p>可以看出，对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。这样的重叠将导致极大的混乱。比如，一个发往192.168.0.255 的广播是发给主网络的还是子网的？这就是为什么在当时不建议使用全 0 和全 1 子网。</p>
</blockquote>
</li>
<li><p>IP, ARP, RARP, ICMP 协议的作用：</p>
<blockquote>
<p>网际协议 IP: 使用 IP 协议就可以把互连以后的计算机网络看成是一个虚拟互连网络。所谓虚拟互连网络也就是逻辑互连网络，或称为互联网。我们知道，各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用 IP 协议的虚拟互连网络可简称为 IP 网。使用 IP 网的好处是: 当 IP 网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节 (如具体的编址方案、路由选择协议，等等)。<br>地址解析协议 ARP: 用来把一个机器 (主机或路由器) 的 IP 地址转换为相应的物理地址或硬件地址)。<br>逆地址解析协议 RARP: 和 ARP 相反，用来把一个机器 (主机或路由器)的物理地址 (或硬件地址) 转换为相应的 IP 地址。<br>网际控制报文协议 ICMP: 用来使主机或路由器报告差错情况和提供有关异常情况的报告，这样就可以更有效地转发 IP 数据报和提高交付成功的机会。</p>
</blockquote>
</li>
<li><p>IP 地址分为几类？各如何表示？IP 地址的主要特点是什么？</p>
<blockquote>
<p>在 IPv4 的地址中，所有的地址都是 32 位，并且可记为: IP 地址 ::&#x3D;&lt;网络号&gt;,主机号&gt;<br>IP 地址共分为五类:<br>A 类地址: 网络号字段为 1 字节，最前面的 1 位是 0<br>B 类地址: 网络号字段为 2 字节，最前面的 2 位是 10。<br>C 类地址: 网络号字段为 3 字节，最前面的 3 位是 110<br>D 类地址: 用于多播，最前面的 4 位是 1110。<br>E 类地址: 保留今后使用，最前面的 4 位是 1111。<br>IP 地址具有以下一些重要特点:<br>(1) 每一个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种分等级的地址结构。<br>(2) 实际上 IP 地址是标志一个主机(或路由器)和一条链路的接口。换言之，IP 地址并不仅仅指明一个主机，同时还指明了主机所连接到的网络。<br>(3) 按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，用转发器或网桥连接起来的若干个局域网仍为一个网络，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连<br>(4) 在 IP 地址中，所有分配到网络号的网络 (不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网) 都是平等的。</p>
</blockquote>
</li>
<li><p>IP 地址与硬件地址的区别，为什么使用两种不同的地址？</p>
<blockquote>
<p>从层次的角度看，物理地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址 (称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的)。<br>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此由用户或用户主机来完成这项工作几乎是不可能的事。但统一的 IP 地址把这个复杂问题解决了。连接到互联网的主机只需拥有统一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便。当需要把 IP 地址转换为物理地址时，调用 ARP 的复杂过程都由计算机软件自动进行，而用户是看不见这种调用过程的。因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来很大的方便。</p>
</blockquote>
</li>
<li><p>IGP 和 EGP 这两类协议的主要区别？</p>
<blockquote>
<p>IGP 是内部网关协议，即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。EGP 是外部网关协议。若源主机和目的主机处在不同的自治系统中 (这两个自治系统可能使用不同的内部网关协议)，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4 (BGP-4)。</p>
</blockquote>
</li>
<li><p>试简述 RIP, OSPF 和 BGP 路由选择协议的主要特点。</p>
<blockquote>
<p>RIP 是一种分布式的基于距离向量的路由选择协议，是互联网的标准协议，其最大优点就是简单。RIP 协议的特点是:<br>(1) 仅和相邻路由器交换信息。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。<br>(2) 路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。也就是说，交换的信息是:“我到本自治系统中所有网络的 (最短) 距离，以及到每个网络应经过的下一跳路由器”。<br>(3) 按固定的时间间隔交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。<br>OSPF 最主要的特征就是使用分布式的链路状态协议。OSPF 协议的特点是:<br>(1) 向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法，这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器(但不再发送给刚刚发来信息的那个路由器)。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。<br>(2) 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”。OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定，因此较为灵活。有时为了方便就称这个度量为“代价”。<br>(3) 只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。<br>BGP 是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议。BGP 协议的主要特点是:<br>(1) BGP 在自治系统之问交换“可达性”信息 (即“可到达”或“不可到达”)。例如，告诉相邻路由器:“到达目的网络 N 可经过 AS<sub>x</sub>”<br>(2) 自治系统之间的路由选择必须考虑有关策略。<br>(3) BGP 只能是力求寻找一条能够到达目的网络且比较好的路由 (不能兜圈子)，而并非要寻找一条最佳路由。</p>
</blockquote>
</li>
<li><p>IGMP 协议的要点是什么？隧道技术在多播中是怎样使用的？</p>
<blockquote>
<p>IGMP 是网际组管理协议，它不是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。IGMP 并非是在互联网范围内对所有多播组成员进行管理的协议。IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上，等等。IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机 (严格讲，是主机上的某个进程) 参加或退出了某个多播组。显然，仅有 IGMP 协议是不能完成多播任务的。连接在局域网上的多播路由器还必须和互联网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用多播路由选择协议。<br>从概念上讲，IGMP的工作可分为两个阶段。<br>第一阶段: 当某个主机加入新的多播组时，该主机应向多播组的多播地址发送一个 IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，还要利用多播路由选择协议把这种组成员关系转发给互联网上的其他多播路由器<br>第二阶段: 组成员关系是动态的。本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要有一个主机对某个组响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，多播路由器就认为本网络上的主机已经都离开了这个组，因此也就不再把这个组的成员关系转发给其他的多播路由器。隧道技术适用于多播组的位置在地理上很分散的情况。例如在图 T-4-43 中，网 1 和网 2 都支持多播。现在网 1 中的主机向网 2 中的一些主机进行多播。但路由器 R<sub>1</sub> 和 R<sub>2</sub> 之间的网络并不支持多播，因而 R<sub>1</sub> 和 R<sub>2</sub>不能按多播地址转发数据报。为此，路由器 R<sub>1</sub> 就对多播数据报进行再次封装，即再加上普通数据报首部，使之成为向单一目的站发送的单播数据报，然后通过“隧道”从 R<sub>1</sub> 发送到 R<sub>2</sub>。<br><img src="https://raw.githubusercontent.com/chipfron/Image_/main/computer_network20231217162537.png"><br>单播数据报到达路由器 R 后，再由路由器 R 剥去其首部，使它又恢复成原来的多播数据报，继续向多个目的站转发。</p>
</blockquote>
</li>
<li><p>VPN 的优缺点：</p>
<blockquote>
<p>优点是比专用网造价便宜，缺点是技术复杂，并且当进行加密通信时，需要更加安全的加密措施。</p>
</blockquote>
</li>
<li><p>什么是 NAT ？NAPT 有哪些特点？NAT 的优缺点有哪些？</p>
<blockquote>
<p>NAT 是网络地址转换。NAPT 是网络地址与端口号转换，是使用端口号的 NAT。<br>NAP 的优点是可以通过使用 NAT 路由器使专用网用户与互联网用户连接。缺点是通过 NAT 路由器的通信必须由专用网内的主机发起，另一个缺点是当 NAT 路由器只有一个全球 IP 地址时，专用网内部只能有一个主机接入互联网。</p>
</blockquote>
</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Chipfron</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://chipfron.github.io/2023/12/09/wang-luo-ceng/">https://chipfron.github.io/2023/12/09/wang-luo-ceng/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Chipfron</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E8%B0%A2%E5%B8%8C%E4%BB%81%EF%BC%89/">
                                    <span class="chip bg-color">计算机网络（谢希仁）</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/12/11/ying-yong-ceng/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="应用层">
                        
                        <span class="card-title">应用层</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-12-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Chipfron
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E8%B0%A2%E5%B8%8C%E4%BB%81%EF%BC%89/">
                        <span class="chip bg-color">计算机网络（谢希仁）</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/12/09/shu-ju-lian-lu-ceng/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="数据链路层">
                        
                        <span class="card-title">数据链路层</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            Chipfron
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E8%B0%A2%E5%B8%8C%E4%BB%81%EF%BC%89/">
                        <span class="chip bg-color">计算机网络（谢希仁）</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2024</span>
            
            <a href="/about" target="_blank">Chipfron</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">114.3k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/chipfron" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1325964828@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1325964828" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1325964828" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>');
            }
        </script>
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
